{"pages":[],"posts":[{"title":"제주코딩베이스캠프 후기1: 캠프소개 + HTML","text":"드디어 첫 교육! 얼마나 기다려왔던가!여러 직업들에 대해서 들었는데 나는 front-end나 정보보완쪽으로 가고싶다.내가 생할코딩을 들었더니 다행히 html과 css는 따라잡을 수 있었다. 오전 강의 정리 : 개요설명 하는 일 우선순위 언어,해야할 것들, 할 수 있는 직업 Front-end HTML, CSS, JS back-end Linux, JS, Jaca, Python 네트워크관리사 네트워크관리사 2급, CCN 정보보안 통합보안관제실, 정보보안 R&amp;D, 보안 운영, 정보보안기사(자격증취득시 바로 취업가능) 정보보안은 깊게 이해하고 있어야한다. 항상 인력이 부족한 영역. 오전 강의 정리 : HTML 꿀팁atom에서 느낌표와 탭을 누르면 html자동으로 적힌다 글자크기확대는 컨트롤과 마우스의 힐로 조정. 쉬프트 누르고 행을 클릭하면 해당 행 삭제됨. div는 디비전으로 특정 영역을 나눠 주는 것. 그 특정 영역만 css다르게 적용할 때 주로 사용(ex)특정부분 색깔 변경 등등 web brower란 서버에서 가져온 태크(내가 쓴 태크)를 해석해주는 것. 웹브라우저(크롬,익스플로어등등)마다 지원해주는 태크가 다르다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104h1누르고 tab을 클릭하면 자동으로 h1 /h1 꺽쇠세트가 자동완성됨.&lt;h1&gt;&lt;/h1&gt;h1{hello world}*n 누르고 tab 치면 n번 적힘 예를들어 h1{hello world}*5 누르고 tab을 누르면 5번 적힌다 &lt;h1&gt;hello world&lt;/h1&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;h1&gt;hello world&lt;/h1&gt;h$*6 누르고 tab을 치면 h1부터 h6까지 꺽쇠포함해서 작성됨 개이득.&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h4&gt;&lt;/h4&gt;&lt;h5&gt;&lt;/h5&gt;&lt;h6&gt;&lt;/h6&gt;.one하고 tab치면 div class=\"one\" /div 이렇게 클래스가 됨&lt;div class=\"one\"&gt; &lt;/div&gt; .one#two하고 tab치면 div class=\"one\" id=\"two\"/div 이렇게 클래스는 원이고 아이디는 투가 됨&lt;div class=\"one\" id=\"two\"&gt; &lt;/div&gt; .one two three#four하고 tab치면 div class=\"one two three\" id=\"four\" /div 이렇게 클래스는 원투쓰리고 아이디는 포가 됨.&lt;div class=\"one two three\" id=\"four\"&gt; &lt;/div&gt;table&gt;(tr&gt;td*4)*5하고 tab치면 테이블이 완성 되며,tr이 행(5개)이고 td가 열(4개)임. &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;.one_$*5하고 tab하면 클래스 1부터 5까지 만드는 거임&lt;div class=\"one1\"&gt;&lt;/div&gt;&lt;div class=\"one2\"&gt;&lt;/div&gt;&lt;div class=\"one3\"&gt;&lt;/div&gt;&lt;div class=\"one4\"&gt;&lt;/div&gt;&lt;div class=\"one5\"&gt;&lt;/div&gt; h1+h2 하고 tab치면 h1꺽쇠세트와 h2꺽쇠세트가 자동완성됨.&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;의미없는 문자열 만드는 것은 lorem하고 tab치면 됨. 홈페이지만들때 글자골격을 위해 자주 사용함.Lorem ipsum dolor sit, amet consectetur adipisicing elit. Culpa perferendis libero nemo inventore enim aspernatur asperiores consectetur voluptatibus quasi accusamus quas nobis earum, animi, ab, itaque sequi ipsa voluptas cumque?b태크와 strong태크는 HTML5에서 같이 굵게를 만들어주지만 차이점이 있다면, 시각장애인을 위해 음성을 읽을때 b태그는 음성강조가 안되지만 strong태크는 음성강조가 됨 =&gt; strong 태크를 쓸 것!&lt;strong&gt;야망&lt;/strong&gt;i태크와 em태크도 기울게로 동일하지만 음성인식에 있어 em태그가 음성강조가 들어감.=&gt; em태크 쓸 것!&lt;em&gt;야망&lt;/em&gt;mark태크는 노란색으로 셀색칠해줌&lt;mark&gt;야망&lt;/mark&gt;ol과 ul차이점은 ol은 순서가 있는 리스트 만들어주고 ul은 순서가 없는 리스트임. 활용팁 : ul태크는 앞의 점을 없애고 가로로 나열되는 걸 세로로 나열해서 홈페이지의 메뉴로 많이 사용함&lt;ol&gt;&lt;/ol&gt;&lt;ul&gt;&lt;/ul&gt; 오후 강의 정리 : HTML123456HTML 주석달기 : 컨트롤 + / =&gt; 주석처리모양 &lt;!-- --&gt;CSS 주석달기 : 컨트롤 + / =&gt; 주석처리모양 /* */","link":"/2019/08/04/190805/"},{"title":"제주코딩베이스캠프 후기2: 카카오특강 + 부트스트랩","text":"두번째이야기, 제주코딩베이스캠프 후기2:카카오특강+부트스트랩 드디어 자바스크립트!오늘을 제일 기다렸다!이거랑 내일 파이썬이 제일 기대된다.그리고 오늘은 카카오 특강이 있는데 도대체 무슨 이야기를 하려나 싶어 참 궁금했다 오전 강의 정리 : CSS &amp; JS오늘내내 CSS에 대해 DEEP하게 배웠다어제 배웠던 내용을 실습해볼수 있어서 큰 도움이 되었다.그리고 내가 기대했던 자바스트립트는 1시간안에 축약적으로 설명을 들었다.자바스크립트의 기본중의 기본, 데이터타입, 변수, 함수까지만 설명해주었다.깊게 들어가지 않아서 실망스러웠다 쳇- 오후 강의 정리 : 카카오특강강의내용은 들여쓰기로 저장해내봤다. 카카오는 크게 제주와 판교.카카오는 서류전형에 학력입력란이 없음. 오로지 코딩테스트를 통해서 선발됨.현직자로서 느끼는 카카오 복지는 매력적칼퇴 후 가족과 제주바닷가에서 보내는 그 시간이 참 좋다전직원에게 법인카드 제공하는데 승인시스템은 없음. 다만 사용내역 전부 내역이 공개되기에 자신이 판단해서 사용한다3년근속하면 안식휴가(한달유급휴가+휴가비까지 지원) 냐하… 개좋다 진짜 On-demand 경제 : 생산자가 아닌 고객 결정 중심으로 서비스가 제공되는 체제의 총칭.2017년부터 중요할 거라고 대두되는 중요한 개념으로 온라인 장터등을 통해수요자가 원하는 형태로 즉각 제공되는 경제 시스템이다on-demand경제 = o2o + 공유경제카카오택시 기획자분은 해당 서비스를 런칭하기 위해서 택시업체에 1년간 상주하면서 나오게 된 서비스이다. 서비스런칭은 생각보다 고된 직업이구나. 쉬울거라 생각해본적없지만 역시 쉬운 일은 없다 제주데이터허브 = 민간데이터(카카오) + 관공서데이터(제주도청) 으로 최초의 민관데이터허브데이터사이언티스티 라는 직업군이 생길 것. : 빅데이터를 분석하는 직업카카오 API : 유용하게 이용할 수 있음개발시 자주 사용하는 언어 : 스칼라, 자바, 파이선(머신러닝시 주로 이용)컴퓨팅사고(Unplugged coding) : 문제해결 능력을 키워주는 사고 ex) 땅콩잼 샌드위치 만들기 신입은 총 7단계를 거쳐 정직원으로 선발 됨 서류 &gt; 코딩테스트 &gt; 화상테스트 &gt; 1차면접 &gt; 임원면접 &gt; 신입의경우 3개월의 인턴과정 후 현업평가 &gt; 개발직군평가 저녁 강의 정리 : 부트스트랩부트스트랩은 처음 배우는데 css와 되게 비슷하다.좀더 공부하면 다른 점을 확실히 느끼겠지.그래도 CSS공부하다가 부트스트랩 들으니까 뭔가 친숙한 느낌적인 느낌느낌!부트스트랩은 CSS보다 덜 자유도를 가지고 사용하는 디자인 프로그램 같은 거다.CSS를 잘 못 다루더라고 이렇게 예쁜 버튼을 만들수있다.어떻게?그냥 복붙해서 ㅋㅋㅋㅋ먼저 아래 Bootstrap CSS 태크를 head태그 사이에 입력한다 12&lt;!-- Bootstrap CSS --&gt;&lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"&gt; 그리고 원하는 링크를 가져와서 body태그 사이에 복붙한다그럼 끝!추가로 바디태그 닫기 바로 직전에 아래 js태크를 입력해주면 된다 12345&lt;!-- Optional JavaScript --&gt;&lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;&lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\" integrity=\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\" integrity=\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 신기하다! 부트스트랩을 쓰다가 너무 못생겼는데 싶으면 Semantic UI추천부트스트랩의 생태계가 더 큼. 유료 템플릿을 이용하고자하면 부트스트랩을, 무료로 이용하고자하면 시맨틱유아이를 추천시맨틱유아이를 추천하는 이유는 기본적으로 예쁘고 제공하는 것들팁: 템플릿이 많다보니 구글링할때 best를 붙이면 편하다 ㅋㅋㅋ 제이쿼리란? 자바스트립트에서 사용할 함수들을 미리 만들어놔서 거기서 바로 사용할 수 있는 라이브러리 라이브러리란? 함수들을 미리 만들어 놓은 곳 시간이 촉박하여 실습위주로 빠르게 진행하였다부트스트랩은 활용도 높을 듯 하다!","link":"/2019/08/05/190806/"},{"title":"장염과 배열에 두 번 무너지다","text":"비전공자가 IT개발자로, 커리어전환기2장염과 배열에 두번 무너지다.이번주는 급 장염이 목요일 Live session에 참가를 못했다.하나라도 더 배우고싶어 죽겠는데…진짜 죽다가 살았다 화장실과 한발짝도 떨어질. 수. 가. 없었다. 다행히 live session은 런코에 동영상이 올라와서 보면서 공부중이다.근데 배열 너무 어려운거 아님?아래는 spilce인데 내가 도저히 이해가 안되서 집중적으로 공부해보았다.w3school의 spilce 예제 splice를 공부해 보자면 아래와 같다 12var arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\", \"Kiwi\"];arr.splice(2, 2); 12var arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\", \"Kiwi\"];arr.splice(2); 아래 2가지가 이해가 되지 않는다. 두 식의 값은 같은데 왜 나는 변환하며 이해가 안가는건지… 1234567function new1(array, n) { let newArr = []; for (let i = n + 1; i &lt; array.length; i++) { newArr.push(array[i]); } return newArr;} 123function new2(array, n) { return array.splice(n+1);} TWIL array.push 쓸 때, return 쓰면 안됨. push의 return 값이 항상 array의 length값을 가져다 줌. 띠용.EX ) 12345function ans(array, value){ array.push(valus);}let test = [1,2] ; ans[test, 3] // ans = [1,2,3] 위의 식은 ok이지만 여기서 아래처럼 return을 쓰면 12345function ans(array, value){ return array.push(valus);}let test = [1,2] ; ans[test, 3] // ans = 3 (원래는 1,2,3을 기대했지만 return은 length인 3의 값을 가져왔음) 중요한 문법 순서 : for반복문 &gt; filter, map, reduce, foreach는 필수","link":"/2019/08/01/190802/"},{"title":"비전공자, 드디어 깃허브 블로그 개설","text":"비전공자가 IT개발자로, 커리어전환기1비전공자, 드디어 깃허브 블로그를 개설하다. 나는 경영학도다.IT개발자로 커리어를 전환하기 위한 엄청난 노력과 그 과정, 아니,그 험.난.한. 과정을 이 블로그에 적을 예정이다. 왜 험난하냐고? 나는 프로그래밍 지식이 1도 없기 때문이다.그럼에도 불구하고 내가 개발자가 되려는 이유는내가 현업에서 겪은 문제들을 해결할 수 있는 프로그램을 스스로 개발하고 싶어서이다야망찬 꿈! 한 선배가 나한테 한 말이 생각난다.“직장생활 힘들지?” “네” “야 그럴땐 눈 감아봐” “왜요? (당시 순진했던 나는 순순히 눈을 감았다.)” “깜깜해서 아무것도 안보이지? ““네” “그게 니 미래야” 명언이었다.깜깜한 나의 미래 경 깃허브블로그개설 축고생고생고생해서 드디어 깃허브 블로그를 개설했다!CSS 적용 방법을 찾아 해맨다고 삽질했다! 심지어 포스팅작성시에도 HTML을 알아야한다. 띠용포스팅쓰다가 어떤 부분을 강조를 하고 싶을 때 굵게라는 버튼이 없다!그동안 에디터에 친숙한 채 너무나 편하게 살았던 것이다.포스팅 작성시 마크다운사용법을 숙지해야한다줄바꿈을 하고 싶으면 ‘바’를 넣어야한다이거예요근데 이거 어떻게 적용안시키고 넣는지를 모르겠네?ㅋㅋㅋㅋㅋㅋㅋㅋㅋ색깔은 또 우째넣지….ㅋㅋㅋㅋㅋㅋㅋㅋㅋ대환장파티ㅋㅋㅋㅋㅋㅋㅋㅋ 그래도 나아가보려고한다.힘차게 힘차게 한 걸음 한 걸음씩내 기록이 다른 누군가에게 큰 힘이 되었으면 좋겠다 비전공자도 할 수 있다아아아아아! 비전공자가 IT개발자가 되는 방법을 검색하면 다양한 방법과 후기가 나온다.그 중 고심끝에 내가 택한 것은 코드스테이츠의 pre course코스다해당 코스는 10주짜리 코스이다.이제 막 블로그를 개설하고 프로그래밍기초 수업을 듣고 있다. 그렇다. 나는 이제 고작 한 걸음 내딛었을 뿐이다. 고작 한 걸음이지만, 그리고 앞으로 갈 길이 엄청 멀겠지만그래도 나아가보자 혼자 가는 길, 막막할 땐?내 블로그와 [코드스테이츠][codestates]를 추천한다원하는 목적지까지 손잡아 이끌어 줄 것이다.물론 다리를 움직여 걷는 것은 스스로의 몫 [codestates]: https://www.codestates.com This Week I learn가장 중요한 건 크롬의 개발자 도구!F12를 누르면 해당페이지의 엘리먼트들을 볼 수 있고콘솔을 눌러서 간단한 체크를 해볼수있다에러에 대한 코멘트도 나오기때문에 내가 뭘 잘못적어서 틀렸는 지 알 수 있어 매우 유용하다 첫주차에 JavaScript 기본 문법을 공부했다진도가 겁나 빡셈근데 새로운 걸 배울땐 초기에 빡시게 공부하는 것이 맞다.초기가 가장 동기부여가 잘 되어있는 시기기 때문!변수와 타입, 조건문과 함수, 배열등을 배웠다.아직 내게 제일 어려운 건 문자열의 조건문이다. 코드짜다가 도저히 안 풀리는 점이 있어서 코드스테이츠의 help desk에 문의하니 바로 답변해주셨다이래서 코드스테이츠 하는구나. 혼자였으면 구글링 삼천번하고 빡쳐서 아이스크림 사먹으러 나갔을텐데(응?)이래서 스스로 공부할 때는 선생님이 필요하구나 싶다. 첫 페어프로그래밍을 하면서 느낀 점은 함수적고 return을 굳이 적을 필요가 없다는 점이다나는 리턴을 남발했는데 그냥 funcion끝나기 전에 한번 하면 되는 거였다.페어프로그래밍을 통하여 다른 사람은 코드를 어떻게 효율적으로 짜는 지 보니까 큰 도움이 되었다.물론 내가 페어를 잘 만난 것도 있겠지?내 첫페어분은 C언어를 공부해보셨던 분이라고 하셔서 두뇌회전 속도가 장난아님.천잰줄다음에도 내 페어가 되어주셨으면 좋겠다…나도 빡공해서 페어에게 도움이 되는 페어가 되어야지!","link":"/2019/07/25/190726/"},{"title":"제주코딩베이스캠프 후기3: Python + 홈페이지기획","text":"세번째이야기, 제주코딩베이스캠프 후기3: Python + 홈페이지기획드디어 파이썬교육!얼마나 기다려왔던가!궁금터진다 어떤 언어길래 각광받고 있는 것일까 오전 강의 정리 : 파이썬 파이썬을 왜 배울까?그 답은 쉬워서!하지만 파이썬은 에러를 잡지 못하고 바로 실행해버리곤한다. 그렇다면 디버깅이 어려운 이 언어를 쓰는걸까? 파이썬만의 매력이 있기때문! 콘솔창에서 디렉토리로 가는 법은 shell명령어1shell명령어2를 알아야한다특히 cd 중요. 디렉토리를 움직일때 자주 사용된다.이걸 몰라서 콘솔 사용 못할뻔ㅋㅋㅋㅋㅋㅋ나란 사람, 초보… 콘솔창에 있는 내용을 복사하고 싶으면 컨트롤c는 안 먹힌다. 왜냐면 다른 단축키라서. 예약어란링크예시와 같이 빌트인fuction이라고 해서 이미 사용하고 있는 단어들을 말한다기능이 정혀져있는 단어다예약어를 어떤 값으로 할당은 가능하나 실제로 사용하지 않는다. 헷갈리기때문 형변환형변환 중 숫자를 문자형으로 변환해야한다고 하자 1print(chr(66)) 숫자6을 문자열로 변환하면 뭘까? 1B B이다 왜때문에?바로 아스키문자표 때문! 오후 강의 정리 : 파이썬 + 해커톤 팀빌딩나는 이번에는 해커톤을 참여하지 않기로 했다.본래 참여목적인 여러 언어 맛보기 + 제주디폴트립이기때문에.또한 내가 민폐일까봐라는 소심한 생각과 함께… 잘한 선택인지 고민했으나 지금은 휴식이 필요한 시기라고 판단했다.그 노래가 생각난다. 윤하-someday 나는 나를 더 아낄꺼야나는 나를 사랑해 저녁 강의 정리 : 홈페이지 기획범재님이 강의해주셨다범재님의 부트스트랩강의도 들었는데 강의스타일이 나랑 잘맞다!이번에도 역시 강의를 잘 하신다.홈페이지 기획에 대해 유용한 사이트를 많이 알게되었다기획의도를 받고 주요 질문들을 해야한다 홈페이지기획 기획을 하기 앞서 먼저 해야할 질문들 웹사이트 만드는 이유? 핵심 요소는? 홈페이지 방문 타켓은? 어떤 기능? 화면설계 순서 추천 도구 와이어프레임 목업 스토리보드 oven 프로토타입 프로토파이, 스케치","link":"/2019/08/06/190807/"},{"title":"잘 풀리지 않는 자바스크립트알고리즘 sumDigits 디버깅을 통한 문제해결","text":"비전공자가 IT개발자로, 커리어전환기4 부제 : 잘 풀리지 않는 자바스크립트알고리즘 sumDigits 디버깅을 통한 문제해결하기.아니 알고리즘문제…왜이렇게 안 풀리는거야?한 문제가지고 몇시간동안 씨름하고있다. TIL : a005_sumDigits문제숫자가 주어졌을때, “sumDigits” 함수는 숫자의 각 자리수를 모두 더한 값을 반환합니다. 12345function sumDigits(num) { //코드를 작성해보세요}let output = sumDigits(-316);console.log(output); // --&gt; 4가 나와야합니다. 아하 반복문으로 돌리면서 조건문을 써야하는 문제구나! 일반 접근1234567891011121314function sumDigits(num) { let sum = 0; let stringNumArr = num.toString().split(''); for (let i = 0; i &lt; stringNumArr.length; i++) { if (stringNumArr[0] === '-' &amp;&amp; i === 1) { sum = sum - Number(stringNumArr[1]); } else if (stringNumArr[i] !== '-') { sum = sum + Number(stringNumArr[i]); } } return sum;} 12let output = sumDigits(-316);console.log(output); // --&gt; 4 디버깅을 통한 문제해결예시대로 디버깅해서 풀어 써보자. 1234567891011121314151617181920212223242526272829303132function sumDigits(num) { let sum = 0; let stringNumArr = num.toString().split(''); //=&gt; stringNumArr = ['-', '3', '1', '6'] for (let i = 0; i &lt; 4; i++) { if (stringNumArr[0] === '-' &amp;&amp; 0 === 1) { //=&gt; false sum = 0 - Number(stringNumArr[1]); } else if (stringNumArr[0] !== '-') { //=&gt; false sum = 0 + Number(stringNumArr[0]); } if (stringNumArr[0] === '-' &amp;&amp; 1 === 1) { //=&gt; true sum = 0 - Number(stringNumArr[1]); //=&gt; sum = 0 - 3 =&gt; sum = -3 } else if (stringNumArr[0] !== '-') { //=&gt; false sum = 0 + Number(stringNumArr[1]); } if (stringNumArr[0] === '-' &amp;&amp; 2 === 1) { //=&gt; false sum = -3 - Number(stringNumArr[1]); } else if (stringNumArr[0] !== '-') { //=&gt; true sum = -3 + Number(stringNumArr[2]); //=&gt; sum = -3 + 1 =&gt; sum = -2 } if (stringNumArr[0] === '-' &amp;&amp; 3 === 1) { //=&gt; false sum = -2 - Number(stringNumArr[1]); } else if (stringNumArr[0] !== '-') { //=&gt; true sum = -2 + Number(stringNumArr[3]); //=&gt; sum = -2 + 6 =&gt; sum = 4 } } return sum; //=&gt; 4}","link":"/2019/08/18/190819/"},{"title":"코드스테이츠 프리코스에 관한 질문들과 나의 솔직 답변","text":"비전공자가 IT개발자로, 커리어전환기3 코드스테이츠 프리코스에 관한 질문들과 나의 솔직 답변과 첫 오프라인 모임저번주에 제주코딩베이스캠프를 마치고 돌아왔다.저번주 내내 코드스테이츠 수업에 참석하지 못해서 발등에 불 떨어졌다다행히 live session은 런코에 동영상이 올라와서 보면서 공부중이지만이미 진도는 안드로메다로…내가 코드스테이츠의 pre코스를 수강중이라고 하니 몇가지 질문을 받았는데코드스테이츠 pre 코스에 대해 궁금한 사람들을 위해 말해보자면 Q1 코드스테이츠 pre코스는 HTML과 CSS, JS를 다루나요?A1 아니요. 자바스크립트만 다룹니다. Q2 비전공자가 따라가기 어렵지 않나요?A2 네, 겁나 버겁습니다. 시간 많을 때 수강하세요. Q3 10주동안 뭘 배우나요?A3 10주동안 기본 개념들을 구글링하면서 아래의 과제들을 수행해야합니다. 주차 과제 1주차 코플릿 자바스크립트 베이직 2주차 코플릿 자바스크립트 베이직 3주차 코플릿 자바스크립트 알고리즘 + 자바스크립트 코언즈 4주차 자바스크립트 코언즈 + 자바스크립트 테스트빌더 5주차 자바스크립트 테스트빌더 + 자바스크립트 트위틀러 6주차 자바스크립트 트위틀러 7주차 자바스크립트 트위틀러 + 언더바 8주차 solo week (추석기간임) 9주차 언더바 +Recursion 10주차 Recursion 난 아직도 코플릿 베이직풀고있는데 다른 분들은 코플릿 알고리즘 다 풀고 코언즈 하고 있었다.또르…빨리 알고리즘을 풀고 코언즈로 넘어가고싶지만… 빨리 푸는게 마음대로 안되고한번 푼다고해서 완벽하게 아는게 아니다.다시 풀면 새로운 느낌적인 느낌느낌 오늘은 첫 오프라인 모임에 참석했다.내가 비전공자고 아직도 베이직풀고있어서 코드스테이츠 오프라인 모임에 참석할까말까 고민을 많이했는데그냥 일단 하자!한다! 라는 고리님의 명언이 생각나서 그냥 참석했다참석하고나니 굉장히 유익했다서로 알고있는 개념들을 공유하여 공고히 다지고생각해왔던 것들을 이야기를 나누다보니 동기부여가 많이 되었다만난김에 같이 live session도 들었다 개이득같이 들으니까 집중도 잘되고 더 재미있었다ㅋㅋㅋ오래전 고딩시절 야자했던 기억이 새록새록 ㅋㅋㅋ 젊어진 느낌 TWIL1. 기초가 바로 잡혀있지 않으면 시간이 갈수록 계속 헷갈린다.기본중의 기본 sum += i 의 의미는 sum = sum + i이고아래에서 i++의 의미는 i를 1씩 증가시킨다는 의미이다 123456789var sum = 0;for (i=0; i&lt;5; i++){sum += i}sum = sum + 1; // value = 1sum = sum + 2; // value = 3sum = sum + 3; // value = 6sum = sum + 4; // value = 10sum = sum + 5; // value = 15 그렇다면 sum -= i의 의미는? 1sum = sum - i 2. 자잘한 기본들. for문과 for … in문은 다르다. 고르는 건 필터 filter 새로만드는건 맵 map 누적 리듀스 reduce reduce는 acc과 curr 값을 이용해서 하나의 연산 결과를 만들 때 쓰고, 단순히 배열을 순회하고 싶다면 for문이나 forEach를 쓰는게 더 알맞다 코드를 깔끔하게 하는 것은 나중의 일. 지금은 코드를 작성하는 것에 몰두하는 것이 좋다. 3. 코언즈이용시 기본들. commit은 내가 변경한 내용 저장하는 것. push는 commit한 내용을 원격저장소에 전송하는 것.","link":"/2019/08/15/190816/"},{"title":"콘솔로그 찍는 방법과 디버깅하는 방법","text":"비전공자가 IT개발자로, 커리어전환기5 쌩초보를 위한 콘솔로그 찍는 방법과 디버깅하는 방법코플릿문제를 풀다보면 도대체 어디서 잘못되었는지 궁금할 때가 있다.그때 아주 유용하게 사용할 수 있는 것이 바로 console.log 찍기이다. TWIL 콘솔로그찍는 방법 아래와 같은 예제 console.log를 찍어봤다. 12345678910111213141516171819function sumDigits(num) { let n = num.toString(); let arr = n.split(''); return arr.reduce(function(acc, curr, idx, original){ console.log('-----------------')//=&gt;줄긋기 console.log('넘어온 값', acc) console.log('현재값', curr); if(curr === '-'){ return acc; } if(original[idx-1] === '-'){ return -(Number(curr)) + Number(acc); } else { return Number(curr) + Number(acc); } }, 0); console.log(value)} 1234567891011121314151617sumDigits(-123)/*-----------------넘어온 값 0현재값 ------------------넘어온 값 0현재값 1-----------------넘어온 값 -1현재값 2-----------------넘어온 값 1현재값 3최종 값은 4*/ 위 예시에서 디버깅해서 풀어 써보면 아래와 같다개발자도구에서 함수 아래부분에 그냥 debugger라고 적어주면 된다!완전 쉬움 123456789101112131415161718function sumDigits(num) { debugger; let n = num.toString(); let arr = n.split(''); return arr.reduce(function(acc, curr, idx, original){ if(curr === '-'){ return acc; } if(original[idx-1] === '-'){ return -(Number(curr)) + Number(acc); } else { return Number(curr) + Number(acc); } }, 0);}sumDigits(-123) 콘솔로그는 에러난 코드 또는 알아 보고싶은 코드 바로 윗줄에 찍는 게 좋음","link":"/2019/08/19/190820/"},{"title":"new Array(), Array.join()의 차이","text":"비전공자가 IT개발자로, 커리어전환기6 new Array(), Array.join()의 차이자바스크립트 알고리즘을 눈물로 끝내고 나서…(다시보면 풀지못하는 문제가 너무 많다)드디어 코언즈시작한다.코언즈는 까리한 프로그램을 이용하여 제출해야하는 과제인데, git bash와 Visual Studio Code이다.둘 다 제코베에서 건들여본적이 있어서 어떻게 사용하는 지 대충…정말 대강 조금 알고 있다코언즈가 자바스크립트 알고리즘보다 더 쉽게 느껴진다.왜냐면 콘솔로그 찍으면 바로 답이 나오니까! 이거 빨리 끝내고 후딱 테스트빌더하고 현재 진행중인 트위틀러로 넘어가야지.. 갈..길..이..보이지…않아…아직도…하 멀다 멀어 누군가 그랬었지, 행복은 멀리 있는 것이 아니라고어어어어어어어어어엄청 멀리있다고 내게 남은 과제도…머어어어얼리 TWIL Array 길이 확인하기겁나 베이직한 개념인데 내가 이해를 못해서 적어봄.아래 문제에서 ‘답’에 들어갈 답은? 12let tenEmptyElementArray = new Array(10);expect(tenEmptyElementArray.length).toBe('답'); 정답은 아래와 같다. 12let tenEmptyElementArray = new Array(10);expect(tenEmptyElementArray.length).toBe(10); 콘솔로그를 찍어보면 나는 빈배열이니까 배열의 길이는 0이라고 생각했는데왜 10인걸까?일단 new는 class를 만드는 명령어이다. 123456Array(숫자) //=&gt; 이거는 숫자만큼 빈배열이 만들어지는 것.//만약let arr = new Array(3) //위와 같다면 arr는 아래와 같다arr = [ , , ]//=&gt;빈칸이 3개 생기는 것임. empty * 3 따라서 아까는 괄호안에 숫자 10이 있었으므로 빈칸이 10개가 생겨서 length도 10임.더불어서 123let arr2 = new Array(1,2,3) //=&gt;이렇게 하면 arr2는 어떻게 구성되어 있을까?//정답은?arr2 = [1,2,3] 더 나아가 Array.join을 알아보자. 123456let arr3 = new Array(3).join(); //=&gt; 어떻게 될까?arr3 = [ ]//=&gt;빈칸 3개가 합쳐진 것임. 헷갈리므로 숫자를 넣어서 보면 이해하기 편하다. 중요한 점은 join을 하는 순간 배열이 아님! string임!let ans = new Array(1,2,3).join();ans = '123' 만약 join안에 숫자가 있다면? 12let ans2 = new Array(1,2,3).join(0);ans2 = '10203' //=&gt;3뒤에는 0이 붙지 않는다! 숫자들 사이에만 join안의 string이 들어감!","link":"/2019/08/20/190821/"},{"title":"코드스테이츠 이머시브코스의 질문과 솔직한 답변","text":"비전공자가 IT개발자로, 커리어전환기7 코드스테이츠 이머시브코스의 질문과 솔직한 답변하기오늘은 이머시브코스와 관련해서 질의응답시간이 있었다바로 참석해서 이때까지 궁금했던 것들을 물어보았다이머시브코스의 비용이 궁금하다면 클릭다양한 결제방식이 있어서 딱 얼마다라고 말하기가 어렵다.나는 대략적으로 2년에 900만원(월40만원정도)이라고 생각하고 있다. Q. 이머시브코스는 무엇인가?A. Full stack을 지향하는 주니어 개발자를 기르는 것이 목적인 16주짜리 코스이다.주로 자바스크립트, 컴퓨터공학개념, 프론프앤드와 백앤드를 배운다 Q. IAT는 무엇인가?A. Immersive Course를 수강하려면 입학 시험(IAT, Immersive Admission Test)를 통과해야한다.시험수준은 pre course의 과제들을 다양한 방식으로 풀어낼 수 있으면 통과할 수 있다고 한다 Q. 이머시브코스의 결과물은 몇 개인가?A. 2주짜리 결과물 1개와 4주짜리 결과물 1개로 총 2개.완성도가 높은 건 당연히 4주짜리 결과물! Q. 외국에서 수강가능한가?A. 한국시간기준으로 출첵 가능하고 잠을 줄일 수 있다면 충분히 가능하다.출석체크는 시프티라는 어플을 통해 한국시간기준으로 보통 오전9시에 함.팀플이기때문에 다른 팀원들에게 피해를 끼치지 않는 선에서 충분히 수강이 가능하다 Q. 온라인 수강과 오프라인 수강이 어떻게 나누어져있는 것인지?A. 쉽게 말하면, 온라인수강, 오프라인수강, 핫데스크 이렇게 나누어진다고 생각하면 됨Immersive Course의 모든 과정은 기본적으로 온라인으로 진행됨하지만 오프라인 과정 분들은 코드스테이츠가 제공하는 공간(위워크)에 모여서 함께 학습하게 됨온라인과 오프라인 수강생들 모두 주로 zoom을 통해 온라인으로 협업함원한다면, 온라인수강생들도 코드스테이츠의 제휴 공간들(위워크)에서 별도의 비용을 지불하고 함께 모여 수강할 수 있음온라인 : 집에서 수강오프라인 : 출석체크 오전9시 퇴실체크 오후8시. 개인학습공간이 주어짐. 개인짐을 놔두고 다닐 수 있음.핫데스크 : 도서관처럼 위워크에서 제공하는 자리 중 남은 자리를 이용함. (메뚜기) 개인짐을 들고 다녀야하지만 위워크사물함 월3만뭔에 이용가능하다고 한다 Q. CSE란?A. 기수당 2명정도 뽑는다CSE가 되면 이머시브코스에서 수강생에게 도움을 주고 혜택을 받는다어떤 혜택인지 문의해놨음 답변받으면 기재해야지","link":"/2019/08/22/190823/"},{"title":"HTML기초: div와 span의 차이, 새탭에서 링크열기","text":"비전공자가 IT개발자로, 커리어전환기8 HTML기초: div와 span의 차이, 새탭에서 링크열기1. 먼저 div VS span 태그의 차이점12345div 태그는 한 줄을 차지한다&lt;div&gt;division&lt;/div&gt;span태그는 컨텐츠 크기만큼 공간을 차지한다&lt;span&gt;요~~~만큼span&lt;/span&gt; 2. 새탭에서 링크열기1&lt;a href=\"http://naver.com\" target=\"_blank\"&gt; 새탭에서 네이버링크열기&lt;/a&gt; 3. 아이디와 비밀번호 입력칸 만들기아이디칸을 만들때는 인풋타입을 text로 하고비밀번호칸을 만들때는 인풋타입을 password로 지정해주면 됨! 12&lt;input type=\"text\" placeholder=\"아이디\"&gt;&lt;input type=\"password\" placeholder=\"비밀번호\"&gt; 또는 아래와 같이도 그럴듯하게 만들 수 있다! 123456789&lt;div&gt; ID &lt;input type=\"text\" placeholder=\"아이디\"&gt;&lt;/div&gt;&lt;div&gt; PASSWORD &lt;input type=\"password\" placeholder=\"비밀번호\"&gt;&lt;/div&gt;&lt;div&gt; &lt;input type=\"checkbox\"&gt; 항상 ID기억하기&lt;/div&gt; 4. 라디오버튼과 체크박스버튼의 차이점은?라디오버튼은 그룹설정가능, 중복선택불가능체크박스버튼은 그룹설정불가능, 중복선택가능 123456&lt;div&gt; &lt;input type=\"radio\" name=\"choice1\" value=\"a\"&gt; 출근이 힘들까? &lt;input type=\"radio\" name=\"choice1\" value=\"b\"&gt; 퇴근이 힘들까?&lt;/div&gt;만약 name이 없다면 중복선택이 가능하다.근데 한 번클릭하면 해제가 안됨.name의 값은 똑같은 이름이 되어야 같은 그룹으로 지정이 되어 둘중하나 선택이 가능해진다 1234&lt;div&gt; &lt;input type=\"checkbox\" checked&gt; 월급은 내가 받을게 &lt;input type=\"checkbox\"&gt; 출근은 누가 할래&lt;/div&gt; 5. textarea는 줄바꿈이 가능하다!123&lt;div&gt;&lt;textarea&gt;&lt;/textarea&gt;&lt;/div&gt; 6. 버튼만들기123&lt;div&gt; &lt;button&gt; 제출하기 &lt;/button&gt;&lt;/div&gt; 지금까지의 내용들을 html로 보면 아래와 같다","link":"/2019/08/26/190827/"},{"title":"CSS기초: block과 inline, inline-block의 차이,  border-box, postion","text":"비전공자가 IT개발자로, 커리어전환기9 CSS기초: block과 inline, inline-block의 차이, border-box, postion1. block과 inline, inline-block의 차이 block은 &lt;div&gt;태그처럼 한 줄을 다 차지하는 요소 inline과 inline-block은 &lt;span&gt;태그처럼 딱 콘텐츠 공간만을 차지하는 요소 그 중 inline은 높이height를 가질 수 없다. inline-block은 높이height를 가질 수 있다. 그림이 이해가 쉬우니까 구글링해보았다 2. CSS box-sizing : border-box로 꼭!CSS 시작 전에 box-sizing : border-box로 지정해두면 편하다.지정하는 방법은 2가지 1234567891011121314151. 지정하고픈 id나 class에 각각 지정#id, .class { box-sizing : border-box;}2. style sheet 시작시에 바로 기재*{ box-sizing : border-box;}#id { //write your code} 3. 어렵고도 어려운 postion항상 어려운 게 포지셔닝이다.대학시절 마케팅때고 포지셔닝이 어려웠는데 여기서 또 만날 줄이야?!(물론 다른 학문으로) static 기본값 relative 기본값+상대적인위치 fixed 브라우저 화면의 좌상단을 기준으로 절대적인 위치 absolute 부모 중 기준점이 있는 경우, 그 기준으로 절대적인 위치 sticky 기본적으로 relative처럼 작동하나, 스크롤 영역을 벗어나면 fixed처럼 작동. ex)스크롤내리면 따라다니는 팝업광고창","link":"/2019/08/28/190829/"},{"title":"DOM : JS에서 자식태그만들기, .append와 .appendChild의 차이점, innerHTML","text":"비전공자가 IT개발자로, 커리어전환기10 DOM : JS에서 자식태그만들기, .append와 .appendChild의 차이점, innerHTML우연한 기회에 친한 언니에게 내가 만든 블로그를 소개해주려고 모바일로 접속했다(자랑할라고ㅋㅋㅋ)이거 봐라~하면서 의기양양하게 클릭했는데아니?! 코드의 왼쪽 부분이 다 짤려서 보이지 않았다. 그래서 집에 오자마자 배운 CSS로 바로 margine 넣어서 간단하게나마 반응형 웹을 만들었다(여기서라도 자랑중) 1. 자식태그만들기123&lt;div&gt;태그만들기 &lt;button&gt;버튼&lt;/button&gt;&lt;/div&gt; 을 js에서 만들려면 방법2가지가 있다. 123456789방법 1 : append 쓰기var div태그 = document.createElement('div'); div태그.textContent = '태그만들기'; document.body.append(div태그);var 버튼태그 = document.createElement('button'); 버튼태그.textContent = '등록'; div태그.append(버튼태그); //div태그(부모태그)안에 자식태그로 넣는 것. 123456789방법 2 : appendChild 쓰기var div태그 = document.createElement('div'); div태그.textContent = '태그만들기'; document.body.append(div태그);var 버튼태그 = document.createElement('button'); 버튼태그.textContent = '등록'; div태그.appendChild(버튼태그); //div태그(부모태그)안에 자식태그로 넣는 것. 둘 다 잘 작동한다그렇다면 둘의 차이점은 무엇일까? 2. .append와 .appendChild의 차이점123&lt;div&gt;태그만들기 &lt;button id='비교해보자'&gt;등록&lt;/button&gt;&lt;/div&gt; 기존 js 12345678var div태그 = document.createElement('div'); div태그.textContent = '태그만들기'; document.body.append(div태그);var 버튼태그 = document.createElement('button'); 버튼태그.textContent = '등록'; 버튼태그.id = '비교해보자'div태그.append(버튼태그); //div태그(부모태그)안에 자식태그로 넣는 것. 위와 같이 이미 만들어져있는 HTML에서 ‘버튼’뒤에 string을 추가하고 싶다.이때 2가지 비교해보자. 1234방법 1 : append 쓰기기존 js의 아래부분에 추가한다document.getElementById('비교해보자').append(\" 이건 어팬드\"); 버튼안에 ‘버튼 이건 어팬드’라고 출력되며 잘 작동한다두번째 appendChild쓰면 어떨까? 12345방법 2 : appendChild 쓰기기존 js의 아래부분에 추가한다document.getElementById('비교해보자').appendChild(\" 이건 어팬드차일드\");//TypeError: Failed to execute 'appendChild' on 'Node': parameter 1 is not of type 'Node'. 타입에러가 난다.왜일까?appendChild는 element가 필요하기 때문.따라서 아래와 같이 적어야한다. 12345678방법 2-1 : appendChild 쓰기기존 js의 아래부분에 추가한다var 어팬드차일드 = document.createElement('text');또는var 어팬드차일드 = document.createElement('span');어팬드차일드.textContent = ' 이건 어팬드차일드'document.getElementById('비교해보자').appendChild(어팬드차일드); 버튼안에 ‘버튼 이건 어팬드차일드’라고 출력되며 잘 작동한다만약 버튼 안의 text를 아예 바꾸고 싶다면 appendChild와 innerHTML를 세트로 사용하면 된다! 1234567방법 2-2 : appendChild + innerHTML 세트로 쓰기//이 방법은 기존js에서 수정이 필요하다//div태그.append(버튼태그);에서 appendChild로 수정이 필요하다 div태그.appendChild(버튼태그); document.getElementById('비교해보자').innerHTML =' 이건 어팬드차일드'; 딱 2줄 바꿨다.근데 이건 버튼태그안의 내용에 추가하는 게 아니라 내용 자체를 변경하는 것이다 따라서 버튼태그안의 text인 ‘등록’은 없어지고 ‘ 이건 어팬드차일드’만 남는다. 결론 appendChild사용할 수 있는 모든 경우는 append 사용이 가능하지만, 그 반대는 아니다. appendChild는 DOM method고 append는 jQuery method 이다. appendChild + innerHTML 세트로 사용하면 내용 변경에 유용하다 참고 https://rpubs.com/raulUbiqum/append https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append","link":"/2019/09/04/190905/"},{"title":"끝말잇기: 괄호의종류,객체벤다이어그램,배열기본,콜백함수,이벤트리스너","text":"웹 게임을 만들며 배우는 JS : 끝말잇기괄호의종류,객체벤다이어그램,배열기본,콜백함수,이벤트리스너 1. 대괄호 [] 중괄호 {} 소괄호 ()2. 객체 벤다이어그램함수는 객체지만, 객체는 함수가 아님. 배열은 객체지만, 객체는 배열이 아님. 3. 객체 = { 속성(프로퍼티) : 값(value), 속성(메서드) : 함수, } 3-1. 객체에서 값을 가져올 때, 2가지 방법123456789101112131415161718let 가랑카페 = {커피 : '아메리카노',가격 : 1500}//첫번째 방법 : 닷 노테이션가랑카페.커피//두번째 방법 : 브라켓 노테이션가랑카페['커피'] 방법이 두가지인 이유는? 닷노테이션은 변수를 가져오지 못한다 1234567var 값 : '커피'가랑카페.값 //=&gt; undefined가랑카페['값'] //=&gt; '아메리카노' 3-2 객체에서만 쓸 수 있는 것 닷 노테이션 ex) ‘안녕하세요’.length 또는 ‘*’.repeat(5) 브라켓 노테이션 ex) ‘안녕하세요’[1] 여기서 잠깐!‘안녕하세요’는 문자인데 어떻게 both 노테이션을 쓸 수 있을까? 브라우저가 자동으로 문자객체로 바꾸기 때문에 가능. 직장생활 꿀팁1. 객체 속성 값을 지우고 싶을 때는 undefined 가 아닌 null로 값을 덮어씌움으로써 내가 직접 지웠는지 아닌지 구분할 수 있다 직장생활 꿀팁2. 객체에서 값을 작성한 후 마지막 속성에도 꼭 반점(,) 을 찍어준다. 그게 실전에서 편함. 4. 배열 = [ ‘사과’, ‘오렌지’, ‘포도’, ] 12345let 과일 = [ '사과', '복숭아', '배']console.log(과일[1]) // =&gt; 복숭아 여기서 잠깐!과일은 배열인데 어떻게 브라켓 노테이션을 쓸 수 있을까? 배열은 객체이기때문! 하지만 객체는 배열이 아님! 직장생활 꿀팁3. 그룹화하고싶지만 속성이름을 따로 주고 싶지 않을 때 배열을 사용한다. 직장생활 꿀팁4. 배열에서 값을 작성한 후 마지막 속성에도 꼭 반점(,) 을 찍어준다. 그게 실전에서 편함. 5. 무한 반복문을 끄고 싶으면 shift + esc -&gt; 크롬관리자창에서 현재탭 종료6. JS에서 HTML 태크 만들기1234567891011var 바디 = document.body;var 단어 = document.createElement('div');단어.textContent = '단어';document.body.append(단어);var 폼 = document.createElement('form');document.body.append(폼);var 입력창 = document.createElement('input');폼.append(입력창);var 등록버튼 = document.createElement('button');등록버튼.textContent = '등록';폼.append(등록버튼); 위와 JS와 아래의 HTML은 동일하다 12345&lt;div&gt;단어&lt;/div&gt;&lt;form&gt; &lt;input type=\"text\" &gt; &lt;button&gt;등록&lt;/button&gt;&lt;/form&gt; 7. 콜백함수매개변수 이름은 마음대로! but 다른 사람이 봐도 알 수 있게 명확히 이름짓는 것이 포인트! 12345678function 콜백함수 (이벤트) {}예를 들어 function 더하기 (숫자1, 숫자2) { console.log(숫자1 + 숫자2);}더하기(3, 5) //=&gt;8 8. 이벤트리스너 = 반복문 역할 (아닐 때도 있음)1234567891011121314151617181920212223242526폼.addEventListener('submit', function (이벤트) { //sunmit은 enter를 치면 기본적으로 새로고침이 되고 기존 기억이 리셋된다.//그걸 방지하고 계속 진행하기 위해 아래와 같이 preventDefault를 넣어줌 이벤트.preventDefault(); if (단어.textContent[단어.textContent.length -1] === 입력창.value[0]){ 결과창.textContent = '딩동댕'; 단어.textContent = 입력창.value; 입력창.value = ''; //입력창을 비워주는 것 입력창.focus(); //커서가 자동으로 입력창에 있음 }else{ 결과창.textContent = '땡!'; }});===반복문// while(true){// var answer = prompt(word);// if (word[word.length -1] === answer[0]){// alert('딩동댕');// word = answer;// } else {// alert('땡');// }// }","link":"/2019/09/03/190904/"},{"title":"동기와 비동기, split, join, indexOf, i++과 i+&#x3D;1","text":"웹 게임을 만들며 배우는 JS : 숫자야구동기와 비동기, split, join, indexOf, i++과 i+=11. 동기와 비동기동기 : 위에서 아래로 순차적으로 코드가 실행 됨. 비동기 : 순차적X, 언제 코드가 실행될 지 모름. ex) .addEventListener 2. split와 join1234문자.split(구분자) -&gt; 배열배열.join(구분자) -&gt; 문자구분자 ex : ' ' 또는 ' : ' 또는 ',' 등등 다양하게 가능. 3. 배열. indexoOf1234배열.indexOf(값)값의 위치를 알 수 있다.배열속의 0번째인지 2번째인지 등등배열속에 없으면 -1 출력. 활용방안 123456789101112let 숫자배열 = [1,3,4,5];숫자배열.indexOf(1) //=&gt; 0숫자배열.indexOf(4) //=&gt; 2숫자배열.indexOf(8) //=&gt; -1어떤 배열에 내가 궁금한 숫자가 있는 지 확인하고 싶을때 for (let i =0; i&lt;숫자배열.length; i+=1){ if (숫자배열.indexof(내가궁금한숫자) &gt; -1){ 있다 ++ }} 4. i++ 과 i+=1123456i = i + 1을 두가지 방식으로 짧게 표현할 수 있다첫번째 : i+=1원래 순서대로라면 i=+1이 되어야할텐데 왜 +=순서냐면, 연산자에 순서가 있는데 그중에 = 이 제일마지막에 와야하기 때문! 두번째 : i++ 첫번째가 더욱 직관적이기때문에 첫번째 방식으로 공부하기를 추천함.","link":"/2019/09/05/190906/"},{"title":"제주코딩베이스캠프 후기4: Python + Django","text":"마지막이야기, 제주코딩베이스캠프 후기4: Python + Django날씨가 이렇게 좋기 있기없기?벌써 마지막이라니 일주일이 빠르게 지나갔다. 오전 강의 정리 : 파이썬 + Djang cd = change director꿀팁 : so치고 탭치면 source라고 자동완성되고 ac치고 탭치면 activate로 나온다장고는 해커톤의 치트키라는 별명을 가지고 있다. 한 10개정도 만들면 숙련이 될 것이고 그 후 원하는 앱을 만들 수 있다. 구름IDE컨테이너에서 항상 가상환경안에서 작업을 해야한다. 컨테이너 다시 실행해도 명령어 3종 세트. 이건 그냥 세트다 세트가상환경만들고 들어가는 방법은 아래와 같다 123cd mysitesource myvenv/bin/activatepython manage.py runserver 0:80 아래와 같이 콘솔 맨 앞에 (my venv)로 꼭 들어가 있는지 확인하고 코딩 작업할 것! 필수! 아래처럼 allow host의미는 화이트리스트기반 여기안에들어온 친구만 접속하게하고 나머지 차단하겠다는 의미.보안이 좋다. 오후 강의 정리 : 파이썬 + Django MVC모델MTV 모델(Django용) : ORM기법(Object Relationship Management) 파이선 문법을 가지고 DB를 조작할 수 있음SQL언어 : 데이터베이스 다룰때 가장 좋은 툴이지만 어려움 그래서 python + django로 대신 DB다룰 수 있음파이선+장고를가지고 DB를 다룰 수 있다. make migrations 하고 .py파일을 만지고 mighrate할것임. 추가 장고문법 공부 링크","link":"/2019/08/07/190808/"},{"title":"[한국코드페어python특강후기] 데이터의 관점으로 생각하기","text":"데이터의 관점으로 생각하기 by 이숙번강사 2019년 한국코드페어 - SW 빌더스 챌린지 오프라인 특강「데이터의 관점으로 생각하기」 강사: 이숙번 blackdew7@gmail.com 강의 내용 여러 관점으로 데이터 이해하기 데이터와 모델 마법의 공식 Y = WX + b마법의 공식에서 w는 가중치이다 딥러닝은 W과 b값을 스스로 찾는 것 이숙번 강사 소개파인코드에서 주 4회근무 &amp; 한달에 1번 강연반 로섬이 파이썬을 만든 이유 : 로컬에서 FILE들을 편리하게 처리하고 싶어서 만든 언어파이썬은 script, web, data science, machine learning등 다양한 분야에서 강력한 개발 환경을 갖추게 됨 구글드라이브 colaboratory.python을 다운 받지 않아도 바로 사용할 수 있는 걸 구글이 구글드라이브에 만들어놨음 프로그램이란?진행 계획이나 순서. 또는 그 목록.코드(=명령어)를 순서대로 실행시키는 것. 컴퓨터의 구성요소land gate를 쌓아서 computer가 만들어짐 land gate = universial gate land gate를 중첩해서 쌓으면 computer같은 효과가 나타남 머신러닝이란?사람이 패턴을 학습하는 방법을 알아냈고 그걸 컴퓨터에게 알려준 것패턴에서 가장 중요한 것은 바로 데이터 데이터를 잘 준비하려면, 데이터에 대해 잘 알기 데이터 잘 다루기 데이터 찾고 수집하고 만들기 데이터 제대로 해석하기 데이터 관점에서 생각하기 Python을 추천하는 이유는 2~4번까지가 잘 되게 때문임 데이터에 대해 잘 알기변수 (특징, feature)다리라는 특징으로 동물이라는 데이터를 표현하도록 만든 것변수의 타입은 2가지임 : 범주형, 숫자형ex) 숫자라고 해서 숫자형데이터가 아니다. 예를 들어 month라는 변수가 있을때 1월 2월~12월이라고 해서12월이 1월의 12배인게 아니니까 -&gt; 이건 범주형데이터고 이걸 정확히 비교해야 데이터를 올바로 이해하는 것임또 다른 예로 hour가 있다1시가 6시에 비해 6배가 더 많은 게 아니다 또 다른 예로 rank가 있다1등급과 3등급이 3배차이가 나는 것이 아니다 차원과 데이터 포인트 2교시 : colab을 통해 딥러닝모델 만들기내가 준 a와 내가 정해준 b를 loss 줄이게끔 스스로 딥러닝하는 모델을 만드는 거임그니까 f(x)를 컴퓨터 스스로가 찾는 거임처음에는 loss가 10,000이었는데 천번째 돌리면 loss가 7300이고 삼천번째 돌리면 loss가 300으로 낮아짐 숫자형 데이터(y = Wx+b) : linear regression리니어 리그레이션 (직선) , 위아래(b)와 기울기(W)를 통해 오차값을 줄인다범주형 데이터(sigmoid(y = Wx+b)) : logistic regression로지스틱 리그레이션 (곡선) , sigmoid함수안에 오차값이 들어있음(y = Wx+b) , 위아래(b)와 기울기(W)를 통해 오차값을 줄인다 3교시 : 인공신경망 인공신경망은 리니어 리그레이션과 로지스틱 리그레이션을 깊게 쌓아서 개와 고양이를 구분해낼 수 있다. 머신러닝 = 리니어 리그레이션 : y=M(X) 이 수식은 행렬수식이다. 칼럼이 한개 : y = W1X1 + W0 칼럼이 두개 : y = W2X2 + W1X1 + W0 행렬연산은 데이터를 펼쳐놓은 것 칼럼이 늘수록 W렬의 갯수가 늘어난다. 인공신경망을 위해 공부해야할 것 : linear regression리니어 리그레이션 + logistic regression로지스틱 리그레이션 + 행렬 + 미분 우리 뇌에는 cpu가 없다 오직 Neuron으로만 이루어져있다.뉴런의 촉수들이 연결되어있다. input이 중요하다하면(가중치가 높다면) 스스로 다음 촉수로 보내고 가중치가 낮으면 input을 무시한다. relu함수를 통해서 학습이 진행된다. 기존 sigmoid를 통해 앞에서 보낸 신호가 학습이 안되었는데 relu를 이용하여 앞에서 보낸 신호를 학습가능하게 된다.","link":"/2019/08/30/190831/"},{"title":"콜백함수실행, Blocking VS non-blocking, 배열.indexOf(value), Number.toFixed(숫자), 탬플릿태그","text":"비전공자가 IT개발자로, 커리어전환기11 콜백함수실행, Blocking VS non-blocking, 배열.indexOf(value), Number.toFixed(숫자), 탬플릿태그 1. 콜백함수실행 handleClick()은 실행이고 실행의 결과는 return값이 없으므로 undifiend이다 2. 동기와 비동기 개념설명 : Blocking VS non-blocking 비동기는 요청에 대한 결과가 동시에 일어나지 않는다.요청을 다 받긴 한다. 그럼 결과가 언제 일어나느냐? callback이 일어날때 결과가 발생함! 3. 배열.indexOf(value)값의 위치를 알 수 있다. [0]번째인지 [2]번째인지 등등값이 없으면 -1이 출력. 123456789//예제let 과일 = ['딸기', '포도', '바나나', '사과']console.log(과일.indexOf('바나나'))// expected output: 2console.log(과일.indexOf('리치'))// expected output: -1 4. Number.toFixed(숫자)Number.toFixed(2) = 소수점 둘째자리까지 반올림하여 표시 1234//예제1console.log(((1.2345).toFixed(1))// expected output: \"1.2\" 1234//예제2console.log((1.256).toFixed(2))// expected output: \"1.26\" 1234567//예제3function financial(x) { return Number.parseFloat(x).toFixed(2);}console.log(financial(123.456));// expected output: \"123.46\" 5. 템플릿태그 HTML에 템플릿 태그부분은 JS의 세번째 줄이 없으면 아예 브라우저가 읽지 않는다.따라서 이벤트리스너를 달때는 템플릿아이디를 가지고 와서 다는 게 아니라 템플릿안의 다른 클래스나 아이디를 가지고와야한다","link":"/2019/09/23/190924/"},{"title":"isNaN(), parseInt(), 연속된 숫자생성3종세트Array().fill().map(), 뽑은 숫자들을 랜덤도splice(Math.floor(Math.random()*arr.length, n)","text":"웹 게임을 만들며 배우는 JS : 지뢰찾기isNaN(), parseInt(), 연속된 숫자생성3종세트Array().fill().map(), 뽑은 숫자들을 랜덤도splice(Math.floor(Math.random()*arr.length, n)1.isNaN()isNaN()는 value가 Not-A-Number인 경우 true를 return한다. return type은 boolean이다. 즉 숫자가 아닌 것을 찾는 함수다. 12345678console.log(isNaN(2));// expected output: false 숫자아님? 놉! 숫자임console.log(isNaN('me'));// expected output: true 숫자아님? 얍! 숫자아님console.log(isNaN('2'));// expected output: false 숫자아님? 놉! 숫자임 참고로Number.isNaN(https://www.w3schools.com/jsref/jsref_isnan_number.asp) 와 isNaN()(https://www.w3schools.com/jsref/jsref_isnan.asp)은 완전히 다르다. 2. parseInt()parseInt()는 문자열을 구분하고 정수로 변환한다. 1234567891011function roughScale(x, base) { var parsed = parseInt(x, base); if (isNaN(parsed)) { return 0 } return parsed * 100;}console.log(roughScale(' 0xF', 16));// expected output: 1500console.log(roughScale('321', 2));// expected output: 0 코딩공부하면서 수학공부를 다시 하게 된다ㅋㅋㅋㅋㅋ하… 대환장파티 정수가 뭐였더라? 3. 연속된 숫자생성 3종세트지뢰 위치를 뽑기 위해 0부터 99까지의 숫자를 생성해야한다. 이때 암기해두면 좋은 함수 3가지가 있다. Array().fill().map()꼭 암기할것 연속된 숫자생성에 필요한 3종세트라고 생각하면된다 Array(n)로 =&gt; n개의 빈 배열을 만들고 fill()로 =&gt; 빈 배열을 undefined로 채워고 map()으로 =&gt; n개의 빈 배열과 n개의 undefined를 1대1매칭 시켜준다 예를들어 for문 안쓰고 3~50까지 숫자만들고 싶을때 유용하다. 12345//step3. 지뢰 위치 뽑기 var 후보군 = Array(hor*ver).fill().map(function(요소, 인덱스){ return 인덱스 //0부터 99까지 인덱스를 리턴. 1~100까지하고싶으면 인덱스+1 하면 됨 }); // 100개의 숫자를 만들고 칸에 fill채워주고 map으로 숫자와 칸을 1대1매칭시켜준다 4. 뽑은 숫자들을 랜덤하게 나타내기후보군으로 뽑은 숫자들을 랜덤하게 나타나게 하고 싶을 때 아래와 같이 코딩한다 12345var 셔플 = [];while (후보군.length &gt; 80){ //지뢰는 20개만 필요하므로 100개중애 80개는 안쓴다 var 이동값 = 후보군.splice(Math.floor(Math.random()*후보군.length), 1)[0]; 셔플.push(이동값); //랜덤하게 순서를 섞어서 셔플배열에 넣어준다}","link":"/2019/09/30/191001/"},{"title":"Git bash 명령어(깃허브로 클론하고 커밋남기고 푸쉬하기)","text":"비전공자가 IT개발자로, 커리어전환기12 1. git 순서 : 처음시작시 원하는 폴더안으로 들어가기 : cd Documents 꿀팁) cd do까지 입력한 뒤 tab치면 fullname폴더 찾아줌! 개이득! 폴더안에 어떤 폴더가 있는 지 확인 : ls 폴더만들기 : mkdir 폴더이름 만든 폴더 안으로 이동 : cd 폴더이름 주소에 맨 끝에 (master)로 지정되어있는지 꼭 확인! 복붙원하는 깃허브 fork -&gt; 내 repo생성 -&gt; code 탭에서 clone or download클릭 -&gt; 주소복사 복붙하기 : git clone 마우스우클릭paste 복붙한 내용 열기 : ls 방금복붙한주소의파일 –주소 맨 끝 (master)확인–&gt; code . 열코 : 코딩하기 수정한 코드 확인하기 : git status 추가하기 : git add 스테이터스에나온이름 커밋하기 : git commit -m '커밋메세지' 깃 스테이터스에 더이상 수정한 내용이 없을 때까지 반복 9~10번 반복 푸쉬하기 : git push origin master 나의 깃허브 repo로 가서 상단 메뉴의 pull requests 클릭 -&gt; new pull request 클릭 -&gt; Create pull request 클릭 후 제목과 내용작성 -&gt; Create pull request -&gt; 끝! 2. git remote가 바로 원격 저장소를 관리git push와 git pull을 할 때, remote 저장소와 push 또는 pull할 branch를 함께 설정할 수 있다. 12$ git push [리모트저장소이름] [branch name]$ git pull [리모트저장소이름] [branch name] 2-1. remote 저장소 현재 remote 저장소 확인 1$ git remote -v remote 저장소 설정새로운 저장소 주소를 추가 12345//기본$ git remote add [리모트저장소이름] [깃헙저장소주소명]//예시$ git remote add [remote name] https://github.com/[깃헙프로젝트유저명]/git remote 저장소 수정추가된 저장소 주소를 변경 1$ git remote set-url upstream/origin https://github.com/[깃헙프로젝트유저명]/git remote 저장소 삭제만약 origin지우고싶다면 아래 코드를 입력하면 된다 1234$ git remote remove [리모트저장소이름]//예시$ git remote remove origin 참고링크 : git push와 git pull에 대해서 3. git 순서 : 기존의 repo에서 데이터 가져와서 시작 터미널창에서 git init를 해놓은 경로로 들어가기 git pull origin master 열코! 수정한 코드 확인하기 : git status 추가하기 : git add 스테이터스에나온이름 커밋하기 : git commit -m '커밋메세지' 푸쉬하기 : git push origin master 4. 꿀팁 잘못 들어왔을 때 상위폴더로 나가는 명령어 : cd .. Git bash로 editor여는 명령어 : code","link":"/2019/10/05/191006/"},{"title":"Image sprite, Dictionary자료구조, setInterval(fuction(){},100), find VS findindex VS indexOf, Object.entries(객체), or연산자를 [].includes()로","text":"웹 게임을 만들며 배우는 JS : 가위바위보Image sprite, Dictionary자료구조, setInterval(fuction(){},100), find VS findindex VS indexOf, Object.entries(객체), or연산자를 [].includes()로 1. 이미지스프라이트(Image sprite)가위바위보게임을 만들기 위해 가위,바위,보 손가락 모양의 이미지가 필요하다. 흔히 이미지를 가위 하나, 바위 하나, 보 하나 총 3장이 있어야 된다고 생각하기 쉬운데~ 땡!!! 가위바위보가 다 그려져있는 한 장의 이미지를 가지고 표현할 수 있다. 이것을 이미지스프라이트라고 한다 12345678910111213141516&lt;head&gt; &lt;style&gt; #computer { width : 273px; height: 350px; background :url(\"가위바위보.jpeg\") no-repeat; background-position: -273px 0; //각각 왼쪽부터 x축과 y축의 좌표. x축의 좌표를 변경하여 한장으로 가위,바위,보를 각각 나타낼 수 있다 } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"computer\"&gt; &lt;img src=\"\" alt=\"\"&gt; &lt;/div&gt;&lt;/body&gt; 추천링크1 : https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Images/Implementing_image_sprites_in_CSS 추천링크2 : http://tcpschool.com/css/css_basic_imageSprites 2. Dictionary 딕셔너리자료구조123456789//딕션너리자료구조var dictionary = { //딕셔너리자료구조 바위 : ['0', '바위', 'rock'] //1대 多 구조 가능 보 : { 한국어 : '보', 영어 : 'paper', 값 : '0' } //배열,객체 구조도 가능. 다국어 지원시 용이}; 3. setInterval(fuction(){},100)1234567891011setInterval(function(){ if(컴퓨터의선택 === dictionary.바위){ 컴퓨터의선택 = dictionary.가위; }else if(컴퓨터의선택 === dictionary.가위){ 컴퓨터의선택 = dictionary.보; }else { 컴퓨터의선택 = dictionary.바위; } document.querySelector('#computer').style.background = \"url('가위바위보.jpeg') \"+ 컴퓨터의선택 + ' 0';}, 100) //0.1초마다 반복 실행 setInterval과 setTimeout 차이점 setInterval n초마다 반복실행(인터벌은 간격을 뜻하니까) setTimeout n초에 한번실행 후 종료 4. find VS findindex VS indexOf차이점은 indexOf는 1차원배열에 쓰고, find또는findindex는 2차원배열에 쓴다 find반복문이지만 지정된 값을 찾으면 반복문 자동 종료 findindex는 2차원배열의 인덱스값(몇번째인지)을 알려준다 5. Object.entries(객체)Object.entries(객체)는 객체를 배열로 바꾸어준다. 1234567891011121314var dictionary = { //딕셔너리자료구조 가위 : '-255px', 바위 : '0', 보 : '-535px'};console.log(dictionary);// {가위: \"-255px\", 바위: \"0\", 보: \"-535px\"}console.log(Object.entries(dictionary));// (3) [Array(2), Array(2), Array(2)]// 0: (2) [\"가위\", \"-255px\"]// 1: (2) [\"바위\", \"0\"]// 2: (2) [\"보\", \"-535px\"] 2차원 배열인 [key, 값(value)] 로 만들어진다 6. or연산자를 [].includes()로 나타내기123if (결과 === -1 || 결과 === 2 ){ console.log('이겼습니다!!')} 위의 or연산자를 [].includes() 간단하게 나타낼 수 있다. 123if([-1,2].includes(결과)){ console.log('이겼습니다!!')}","link":"/2019/09/21/190922/"},{"title":"WCC1기 OFF-SESSION 후기","text":"유이경연사님의 프레시코드 창업기, 이은지연사님의 데이터 분석 교육 프로그램 기획자의 커리어 이야기오늘은 코드스테이츠의 OFF SESSION이 있는 날이다.WCC장학프로그램을 수료완료한 장학생을 대상으로 연사님들의 특강을 듣는 날이다.이 날을 얼마나 기다리고 기다렸던지…! 네 분의 연사님 중에서 두 분의 강연을 골라 들을 수 있었다몸을 쪼개어 강의를 전부 다 듣고 싶었다 ㅋㅋㅋㅋㅋ&lt;진심. 궁서체. 유이경 연사님의 프레시코드 창업기유이경 연사님은 프레시코드의 창업자이다.프레시코드란 건강편의식 거점 배송 물류 유통망 온라인 플랫폼이다.일반 배송원가는 3~4000원인데 반해 늘어나고 있는 1인가구엔 너무 비효율적이라고 늘 생각했던 터에실리콘밸리에서 인턴을 하며 샐러드를 밥으로 먹는 사람들을 보며 큰 시장이 될 것을 확신했다고 한다. 연사님이 좋아하는 것 사회적 가치, SIFE(현, ENACTUS) 활동 아이디어 내기 새로운 활동 [걸스인텍(https://www.facebook.com/GITSeoul/)] 활동 자신이 좋아하는 것을 어떻게 풀어낼까 하다가 창업을 선택하게 되었다고 한다.연사님의 강연 중 가장 와닿았던 부분은 초기 창업자에게 필요한 것에 대한 조언이었다. 초기장업자에게 필요한 것 세가지창업자는 마케터이다Connecting the dots 내 주변에 알리기도 필요하다.내 주변도 설득 못 하면서 하물며 알지도 못하는 고객을 어떻게 설득시키겠는가 실행력초반의 프레시코드를 구상할 당시에는 몰랐지만 지나고보니 Lean startup cycle를 비슷하게 사이클했다고 한다.갓 창업을 구상할 때 추천하는 사이클이라고 했다. 아이디어 -&gt; 베타제품제작 -&gt; 마켓테스팅-&gt; 2-1. 페이스북홍보+구글폼 -&gt; 2-2. 애플리케이션에서 웹사이트로 제작변경(becaz 초기 단계에선 접근성에 유리)-&gt; 2-3. 개발자들이 웹사이트 제작하는 동안 창업자들은 임시 웹사이트를 열어 한 달간 샐러드어택이벤트를 진행함-&gt; 2-4. 72개사에 110개판매로 성공적으로 베타서비스 완료 분석 -&gt;3-1. 거점 배송지 증설3-2. 산학협력으로 신메뉴개발 아이디어검증 기억에 남는 두 문장 처음부터 완벽한 전략은 없다. 그 대신 찾아오는 기회를 빠르게 잡을 수 있어야 한다. 한 명의 안티를 붙잡는 것보다 10명의 충성고객을 유지하는 것이 중요하다 딱딱하지 않고 친근한 연사님이었다. 대단하다는 생각과 동시에 나도 할수있다는 동기부여를 얻었다. 이은지 연사님의 데이터 분석 교육 프로그램 기획자의 커리어 이야기시작부터 화끈한 이은지 연사님은 그야말로 카리스마 대장이었다강연시작하자마자 SI업체에 가지말라고ㅋㅋㅋㅋㅋ국비지원학원을 다나면 취업연계로 경력 뻥튀기해서 SI업체로 종종 연결해준다고 한다SI란 시스템 통합을 뜻하며 추가로 더 구글링해봤는데 읽어도 무슨 말인지 잘 모르겠었다.그 중에 발견한 티스토리블로그가 있다. 실제 SI업체에서 업무중인 신입개발자의 솔직담백한 이야기를 들을 수 있었다. 티스토리 : 부산 신입 개발자 SI업체 취업기 1년 한국의 대표적인 3대 SI업체로는 삼성SDS, LG CNS, SK C&amp;C가 있고 절대 가지말라고 하셨다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ개발자의 무덤이라고 ㅋㅋㅋㅋㅋ 그리고 시작된 재미있는 데이터사이언스강연에 나는 퐁당 빠져버리고 말았다. 데이터사이언스란데이터에 기반한 방법으로 현실 세계의 문제를 해결 하는 것.문제 해결을 위한 적정 기술. 비교: 인공지능 VS 머신러닝 VS 딥러닝 VS 데이터과학 머신러닝 : 데이터와 결과를 주고 예측 모델 만드는 것 딥러닝 : 데이터를 주면 데이터간의 연결관계를 찾고 컴퓨터 스스로 결과와 예측모델을 만드는 것 데이터과학자가 되고 싶으면?SQL과 python + R 이 기본이다 단계별로 배워가면 된다파란 계단으로 올라섰으면 데이터사이언스주황 계단으로 올라가면 머신러닝노랑 계단으로 올라가면 빅데이터에 특화되었다고 볼 수 있다. 신입이 맡게되는 직무는 크게 2가지이다 데이터분석가 퍼포먼스마케터 기억에 남는 두 문장 절대 혼자 공부하지 마세요. 무료인강과 커뮤니티를 적극 활용하세요. 고과의 교육 과정으로 시작해야만 좋은 데이터 분석가가 되는 것은 아닙니다 기술적으로 완성되지 않아도 취업할 수 있습니다. 모든 것을 다 배워야 한다는 압박감 때문에 너무 긴 시간을 공부에만 투자하지 마세요. 공부한다고 모든 것을 알 수 없어요. 입사하면 어차피 새로운 것을 배우게 되어있습니다.","link":"/2019/09/27/190928/"},{"title":"func(...arguments) 의미, 화살표함수 &#x3D;&gt; 의미","text":"비전공자가 IT개발자로, 커리어전환기13 func(…arguments) 의미자바스크립트에서 (…arguments)의 의미는 매개변수가 몇 개가 들어올 지 모르니 유동적으로 받겠다는 의미이다.아래 예시를 보자.이때 Add는 편의상 숫자를 더하는 함수이다. 12345678//함수선언function A(func, ...args){ func(...args)}//함수사용A(Add,1,2,3,4)A(Add,1,2) A함수는 그 내부에서 Add(1,2,3,4)와 Add(1,2)를 실행시켜주는역할을 하는 함수가 된다.이때 매개변수의 갯수는 정해지지않았기때문에 매개변수의 갯수가 달라져도 상관이 없이 함수가 정상 실행된다. 화살표함수 =&gt; 의미화살표함수는 익명함수를 만드는 명령어로 적기 귀찮아서 줄여서 쓰는 것이다.이름 필요없이 한 번 쓰고 버릴 함수 만들 때 유용하다. 1234567//기본 함수let sum = function(a, b) { return a + b;};//화살표함수: 인수가 2개인 경우let sum = (a, b) =&gt; a + b; 만약 인수가 하나라면 괄호를 생략하여 나타낼 수 있다.인수가 아예 없는 경우에는 괄호안을 비워두면 된다. 다만 이 때 괄호는 생략할 수 없다. 12345//인수가 하나인 경우let double = n =&gt; n * 2;//인수가 없는 경우let sayHi = () =&gt; alert(\"안녕하세요!\"); 참고 https://ko.javascript.info/arrow-functions-basics","link":"/2019/10/07/191008/"},{"title":"웹 게임을 만들며 배우는 JS 완강 후기","text":"웹 게임을 만들며 배우는 JS 완강 후기온라인 인강을 혼자 수강한 경험이 있는 사람들은 많이 공감할 것이다.강의를 100% 수강하기가 굉장히 어렵다는 사실을.그 어려운 걸, 제가 해냅니다!!!이 강의는 코드스테이츠 pre 코스를 수강하면서 부족한 나의 JS 실력을 쌓고자 들었던 무료강의이다. 이 강의의 장점은 무수히 많지만 그 중 몇가지를 꼽자면, 무료 실습위주라서 재미보장 10분단위의 강의로 집중도를 높임 제로초 유튜브계정에서도 무료로 강의를 볼 수 있지만 나는 구름에듀에서 인강을 보았다. 그 이유는 수강률을 보면서 동기부여를 스스로 받고 싶어서였고… 그 결과!!... 2019년 9월에 시작해서 2020년 3월에 완강에 성공했다.6개월내내 공부한 건 아니고….사실 중간에 손을 놓은 적도 몇 번있었다.&lt;원래 사람이 그렇잖아요? 허허 먼산…… 그래도 다시 마음잡고 끝까지 완강해서 뿌듯하고 참으로 많이 배웠다. 구름에듀에서는 100%완료한 강의에 대해서 수료증도 발급해준다.별거아니지만 받고 보면 참 뿌듯하다 ㅋㅋㅋㅋㅋ 나처럼 비전공자이면서도 JS 비기너에게 꼭 추천하고 싶은 강의이다!게임이 직접 실행되기때문에 재미있어 쉽게 따라갈 수 있고코드를 보고 떠오른 내 머리속 궁금증을 어떻게 알았는지 속시원하게 알려준다. why를 알려주니 이해가 쏙쏙!이렇게 적다보니 홍보같지만… 홍보아니고 개인적인 경험에 의한 강력추천무료강의니까 바로 시작해보시길!","link":"/2020/03/30/200331/"},{"title":"우클릭이벤트실행, target VS currentTarget, arr.filter(function(v){}), arr1.concat(arr2), 스코프(scope)와 스코프체 렉시컬 스코프, 재귀함수, arr.filter((v)&#x3D;&gt;!!v)","text":"웹 게임을 만들며 배우는 JS : 지뢰찾기 1. 우클릭이벤트 실행 addEventListener(‘contextmenu’, function(){})우클릭시 이벤트실행은 contextmenu사용 123456789101112131415161718//step5. 우클릭하면 깃발모양만들기td.addEventListener('contextmenu', function(e){ e.preventDefault(); console.log('우클릭');//우클릭한 곳이 몇번째줄 몇번째칸인지 알아야하니까 currentTarget 사용 var 부모tr = e.currentTarget.parentNode; var 부모tbody = e.currentTarget.parentNode.parentNode;//var 칸 = 부모tbody.children.indexOf(tr) 부모tr이 배열이 아니라서 indexOf적용안됨. 부모tbody는 유사배열임//indexOf를 쓰고 싶은데 배열이 아닌 애들한테 강제로 쓰는 법은 아래와 같이 Array.prototype.indexOf.call()를 사용 var 칸 = Array.prototype.indexOf.call(부모tr.children, e.currentTarget); var 줄 = Array.prototype.indexOf.call(부모tbody.children, 부모tr); console.log( 칸, ':', 줄); e.currentTarget.textContent = '!'; dataset[줄][칸] = '!'; //데이터와 화면일치를 위해 꼭 필요. 이게 불편해서 react를 많이 씀 }); 2. event.target VS event.currentTarget언뜻보면 이벤트가 일어난 곳을 둘 다 알 수 있는 것 같지만, 차이가 있다. target은 이벤트리스너가 발생하는 대상(내가 클릭한 td) currentTarget은 이벤트리스너를 단 대상(내가 클릭한 td가 속해있는 테이블 전체) 1234tbody.addEventListener('contextmenu', function(e){ console.log('타켓', e.target); console.log('커렌트타켓', e.currentTarget);}); 3. arr.filter(function(v){})배열에서 v인것을 필터링해주는 함수이다 123456789//step6. 클릭했을때 주변 지뢰 개수 세기e.currentTarget.textContent = [ dataset[줄-1][칸-1], dataset[줄-1][칸], dataset[줄-1][칸+1], dataset[줄][칸-1], dataset[줄][칸+1], dataset[줄+1][칸-1], dataset[줄+1][칸], dataset[줄+1][칸+1] ].filter(function(v){ return v === 'X' //=&gt; v가 'X'인 배열을 필터링함 }).length; 가장자리는 배열이 마이너스가 나기때문에 오류가 난다. 해결하는 방법은 아래 4번의 concat을 이용해서 배열을 다시 만들어주면 된다. 1234567891011121314151617181920td.addEventListener('click', function(e){ var 부모tr = e.currentTarget.parentNode; var 부모tbody = e.currentTarget.parentNode.parentNode; var 칸 = Array.prototype.indexOf.call(부모tr.children, e.currentTarget); var 줄 = Array.prototype.indexOf.call(부모tbody.children, 부모tr); if(dataset[줄][칸] === 'X'){ e.currentTarget.textContent = '펑!'; }else{ var 주변 = [dataset[줄][칸-1], dataset[줄][칸+1] ]; if(dataset[줄-1]){ 주변 = 주변.concat(dataset[줄-1][칸-1], dataset[줄-1][칸], dataset[줄-1][칸+1]); } if(dataset[줄+1]){ 주변 = 주변.concat(dataset[줄+1][칸-1], dataset[줄+1][칸], dataset[줄+1][칸+1]); } e.currentTarget.textContent = 주변.filter(function(v){ //배열에서 필터링하는 함수 return v === 'X' }).length; }}) 4. arr1.concat(arr2)배열과 배열을 합칠때 push말고 concat이 유용하다 MDN : concat 123456var 주변 = [ dataset[줄][칸-1], dataset[줄][칸+1] ];if(dataset[줄-1]){ 주변.push(dataset[줄-1][칸-1]); 주변.push(dataset[줄-1][칸]); 주변.push(dataset[줄-1][칸+1]);} 동일하게 concat으로 나타내면 1234var 주변 = [ dataset[줄][칸-1], dataset[줄][칸+1] ];if(dataset[줄-1]){ 주변 = 주변.concat(dataset[줄-1][칸-1], dataset[줄-1][칸], dataset[줄-1][칸+1]);} 5. Scope와 Scope Chain과 Lexical Scope변수는 자신을 감싸고 있는 함수의 바깥으로 빠져나갈 수 없다. var은 선언한 함수 내부에서만 유효하다 (= function scope) 참조 : 제로초 블로그 - 함수의 범위(scope) 6. 재귀함수재귀함수란 자신을 불러오는 함수로 반복문 역할로 사용 가능하다 1234function 재귀함수(숫자){ console.log(숫자); 재귀함수(숫자+1);}; 재귀함수(1)을 실행하면 12345function 재귀함수(숫자){ //=&gt; 1 &gt; 2 &gt; 3 &gt; 4 ...무한반복 console.log(숫자); //=&gt; 1 &gt; 2 &gt; 3 재귀함수(숫자+1); //=&gt; 2 &gt; 3 &gt; 4};재귀함수(1) 무한반복문이 된다. 그걸 방지하기 위해서 if로 숫자 제한을 둔다 123456function 재귀함수(숫자){ console.log(숫자); if(숫자&lt;3){ 재귀함수(숫자+1) }}; 재귀함수(1)을 실행하면 12345678function 재귀함수(숫자){ //=&gt; 1 &gt; 2 &gt; 3 console.log(숫자); //=&gt; 1 &gt; 2 &gt; 3 if(숫자&lt;3){ //=&gt; 1 &gt; 2 &gt; false 재귀함수(숫자+1) //=&gt; 2 &gt; 3 } //=&gt; end};재귀함수(1); 7. arr.filter((v)=&gt;!!v)배열에서 undefined, 0, null, 빈문자열 제거하는 코드로 암기필수이다. 123arr.filter(function(v){ return !!v;}); 최신문법으로 나타내면 1arr.filter((v)=&gt;!!v); 지난번 포스팅에서도 언급했듯이 화살표함수(=&gt;)는 익명함수를 만드는 명령어로 적기귀찮아서 줄여서 쓰는 것이다.","link":"/2019/10/14/191015/"},{"title":"HTML5와 CSS : background 기본속성 7종세트","text":"CSS background 기본속성 7종세트 12345678910body{ width: 500px; height: 200px; background-image: url(\"../img/이미지이름\"); background-repeat: no-repeat; background-size: cover; background-position: center; background-attachment: fixed;} div에 이미지 삽입했을 때 기본속성1234567div{ background-color: white; width: 100px; padding: 410px; margin: 30px auto; border: 10px solid coral;} 위의 코드에 추가로 1234567891011121314151617 /* div든 뭐든 센터로 위치 시킬때(상-좌우-하 순서) */ margin: 30px auto;/* div든 뭐든 센터로 위치 시킬때(상-좌우-하 순서) */ margin: 30px auto 50px; /* div든 뭐든 센터로 위치 시킬때(상-우-하-좌 순서: ) */ margin: 10px 20px 30px 10px; /* div든 뭐든 테두리주고 싶을때 */ border-width: 10px; border-style: solid; border-color: coral; /* 위의 border 속성을 한 줄로 줄여쓸 수 있다(단축속성) */ border: 10px solid coral; div는 기본적으로 block속성이다 가장 중요한 박스모델가장 중요한 박스모델을 정리하자면 12345678Box modelwidth : 너비, 미설정시 모부크기만큼 꽉참height : 미설정시 자식높이만큼 자동 조절margin : 바깥여백padding : 안쪽여백, 설정시 자신의 width와 height에 padding만큼 증가함border : 테두리, 설정시 자신의 width만큼 증가함","link":"/2019/10/20/191021/"},{"title":"초기화버튼, Number와 String의 사칙연산","text":"ES2020 초급 웹게임 강좌 : 계산기 1. 값을 초기화를 하려면 보통 null이나 undefined 사용.초보자는 null추천 123456clearbtn.addEventListener('click', ()=&gt;{ //clearbtn클릭시 초기화 numberInput.value = null; temp = null ; operator = null; resultInput.value = null;}) 2. Number 와 String의 사칙연산숫자와 문자열을 더하면(+) 숫자가 문자열로 바뀌어서 계산됨ex) 10 + ‘5’ = ‘105’ (결과값이 문자열) 숫자와 문자열을 곱하기,빼기,나누기는 문자열이 숫자로 바뀌어서 계산됨ex) 10 / ‘5’ = 2 , ‘10’ * 5 = 50 , ‘10’ - ‘5’ = 5 (결과값이 숫자) 3. Falsy 값을 가지는 6가지 (암기필수)There are only six falsey values in JavaScript:undefined , null , NaN , 0 , “” (empty string), and false.","link":"/2020/04/29/200430/"},{"title":"Hi, How are you?","text":"200505은 역사적인 날!어린이 날이면서도 깃헙블로그를 새로 단장한 날이다!기존에 Jekyll이었는데 hexo로 싹 바꿨다.고생많았지만 차근차근 많은 것을 배웠다.앞으로도 더 배워나가야지.스스로 테마도 만들어 볼 수 있는 수준까지 가자!!","link":"/2020/05/05/200505start/"},{"title":"변수 기초(정확한 데이터타입)","text":"생활코딩JAVA1 : 변수 기초(정확한 데이터타입)자바는 변수를 설정할때 꼭 정확한 데이터타입을 적어줘야한다.숫자 1의 경우에는 Number지만 정확히 말하면 정수(Integer 인티저)에 속한다따라서 아래 변수a와 같이 int 를 적은 뒤 변수를 적는다. 숫자 1.1의 경우에는 실수(real number)이다.이를 아래 변수b처럼double로 나타내면 된다 문자열은 그래도 String을 쓰면 된다! 1234567891011121314public class Main { public static void main(String[] args) { // Number -&gt; integer ... -2, -1 , 0, 1, 2 ... int a = 1; System.out.println(a); // real number -&gt; double ... -2.0, -1.0, 0, 1.0, 2.0 ... double b = 1.1; System.out.println(b); String c = \"Hello World\"; System.out.println(c); }}","link":"/2020/05/16/200517javae/"},{"title":"JAVA 동작 원리","text":"생활코딩JAVA1 : JAVA 동작 원리모든 공부는 그 원리가 중요하다원리 즉 기초를 튼튼히 쌓아 올려야 무너지지 않는 건물이 되고 건물주가 될 수 있다&lt;응? 그렇다면 자바는 어떻게 작동할까? 우리는 자바라는 언어를 이용하여 컴퓨터에 우리가 원하는 것을 시킬 수 있다. 이때 컴퓨터는 우리의 언어를 이해하지 못한다. 이러한 우리의 언어를 컴퓨터가 이해할 수 있도록 컴파일(compile)을 한다. 컴파일링 후 .class가 생성되고 쉽게 말해 컴퓨터가 이해할 수 있는 언어로 번역된 것이다. 그리고 실행(Run)을 시키면 우리가 java를 설치하면서 다운로드했던 Java Virtual Machine을 거쳐서 computer는 결과를 도출한다.","link":"/2020/05/18/200519javae/"},{"title":"코드스테이츠 Pre 35기 수료 후기","text":"코드스테이츠 Pre 35기 수료 후기코드스테이츠는 부트캠프 형식의 코딩 교육으로 알고리즘은 물론 JS, HTML, CSS를 페어프로그래밍을 통해서 공부할 수가 있다. 나는 코드스테이츠를 2019년 10월에 수료를 했다.Latte is horse, 코스가 총 2가지로 pre코스(기초과정)와 immersive코스(심화과정)으로 나뉘었었는데이번에 다시 홈페이지를 방문하니 기존 코스를 하나로 통합하여 몰입과정만 운영하고 있었다.멈춰있지않고 항상 나아가려고 노력하는 기업인 것 같다. 나는 코드스테이츠 pre과정에 엄청 만족했다.정말 다양한 이유가 있다. 할 수 있는 언어가 +1 증가했습니다한국어, 영어만 할 수 있는 나에게 JS까지 3개국어를 할 수 있게 되었다ㅋㅋㅋㅋㅋㅋfront-end의 기본중의 기본인 바닐라 JS, HTML, CSS를 배웠다.비전공자인 나에게 그것조차 꽤 버거웠지만 수료하기위해서 많은 시간을 들여 공부했다.JS기반 알고리즘문제해결부터 single page application개발(간단한 트위터 구현)까지 진행하였고 과제를 수행할때마다 꽤 재미있었다. 협업스킬이(가) +1 향상되었습니다코드스테이츠 덕분에 나는 전혀 몰랐던 Zoom과 Slack 그리고 Github를 주구장창 사용할 수 있게 되었다.모두 페어프로그래밍으로 진행하여 협업능력이 향상되었다.또 좋았던 부분은 질문과 답변시간인데, 내가 공부하다 막히는 부분이 있으면 언제든지 Github를 통해 질문했고, 질문들을 텍스트로 설명해줄뿐만아니라 매주2회 온라인강의에서 실시간으로 알려주었다.강사가 해결하는 방법을 보면서 ‘아 개발자는 저렇게 해결하는구나’라는 것을 느끼고 배울수있었다. 평생친구를(을) 만났습니다.같은 목표를 보고 함께 만난 사람들중에 놀랍게도 나와 찰떡인 평생친구를 만났다.공통점이 많은 우리는 절친이 되서 같이 놀러도 다니고 지금까지 끈끈한 우정을 이어오고 있다. 별 건 아니지만 수료증도 주니 참 뿌듯뿌듯하다.덕분에 나의 경험치는 향상되었고 나는 정말 만족한다.내가 조금더 기초가 있었더라면 더 많은 경험치를 올릴 수 있었을텐데 하는 아쉬움과 함께 코드스테이츠를 수료했다.","link":"/2020/05/18/200519pre/"},{"title":"이클립스 설치시 오류 해결 : Unable to connect the database server at this time(eclipse)","text":"자바 설치 및 이클립시 설치시 오류 해결 Java를 공부하기 위해선 다양한 방식이 있지만전통적인 JAVA와 Eclipse를 설치하는 것이 좋다 1단계, Java development kit 다운로드하기java development kit를 검색하여 최신버전을 다운로드 하면 된다JDK 다운로드를 클릭하면 된다. 2단계, Eclipse 다운로드하기Eclipse download를 검색하여 최신버전을 다운로드하면 된다 척척 잘 진행되는 것 같았으나… 문제가 생겼다. Eclipse의 다운로드 버튼을 누릴때마다 아래 사진처럼 Error창이 뜨는 것이다 Unable to connect the database server at this time(eclipse)짜Unable to connect the database server at this time(eclipse)증Unable to connect the database server at this time(eclipse)나죽겠네! 해결하고자 네이버링도하고 영어로 구글링도 했지만 뚜렷한 방법은 보이지 않는 듯 했다. 자바를 공부하고 있는 친구에게 상황을 설명하니 혹시 컴퓨터 user name이 한글이냐고 물어봤다 오브콜스! 그러자 친구가 말하길 user name이 한글이라서 안될수도 있다면서 자기도 그런 케이스라서 결국 노트북을 포맷했다고 한다. 포맷은 절대 하기 싫어서 온갖 방법을 써봤다 제어판 &gt; 계정 &gt; 사용자정보에서 내 Microsoft 계정관리에서 영어로 이름 변경한 뒤 노트북 재부팅 후 크롬브라우저에서 다운로드 시도 =&gt; 동일 현상으로 실패 집안의 다른 컴터에서 exe파일은 usb메모리에 받은 뒤 옮기기 =&gt; 동일현상으로 실패 크롬브라우저가 아니라 익스브라우저로 다운로드 시도 =&gt; 성공 정말 Java 공부 시작도 전에 짜증이 화르륵ㅋㅋㅋㅋㅋㅋㅋㅋ성공했을 때의 그 기쁨의 맛이란?! 참 뿌듯했다. [잘 다운로드 되고 있는 어여쁜 이클립스의 모습. 초록바가 차오를수록 나의 흥도 차오른다 아싸리~] 3번을 통해 나는 문제를 해결했고 이 점이 나와 같은 빡침을 겪은 사람에게 조금이라도 도움이 되었으면 좋겠다. 1번해결방법에서 컴퓨터 계정이름을 영어로 변경한 뒤 바로 컴퓨터에 반영되지 않았다. 그래서 좌절하고 있었는데 노트북 재부팅하고 5시간정도 지난 후에 변경한 계정이름이 반영되었다. 그 후로 크롬브라우저로 들어가 이클립스 다운로드를 누르니 다운이 잘 된다! 즉 이클립스 다운로드 오류는 내 노트북 계정 이름이 한글이었기때문에 발생했다고 할 수 있다. 결론혹시나 인터넷 익스플로러에서도 이클립스 다운로드 오류가 난다면, 노트북 계정이름을 영어로 변경 후 5시간 정도 기다린 뒤, 노트북의 계정이름이 영어로 반영된 것을 확인 후에 이클립스 다운로드하자!","link":"/2020/05/14/200515javae/"},{"title":"Character VS String, 줄바꿈, 문자열안의 큰따옴표넣기","text":"생활코딩JAVA1 : 자바기초, Character VS String, 줄바꿈, 문자열안의 큰따옴표넣기1. 자바 기초아래를 항상 기초로 적어야한다 12345public class name { //name은 항상 파일명과 일치해야한다 public static void main(String[] args) { System.out.println(); }} 매번 코딩해야하기에 여간 귀찮은 게 아니다그래서 한가지 tip이 있다 sout 을 누르고 ctrl + space 를 누르면 짜잔! System.out.println()가 자동완성된다 2. Character VS String몇몇 언어와 다르게 JAVA에서는 큰따옴표&quot; &quot;와 작은따옴표' ' 명백한 차이가 있다. 12System.out.println(\"Hello World\");//String는 문자열으로 캐릭터들이 모여있는 것을 뜻한다 123System.out.println('H'); //Character는 문자 한 글자만 나타낼 수 있다//따라서, System.out.println(\"H\")와 위의 작은따음표('H')는 결과는 같아보일 수 있지만 사실 문자 한글자와 문자열로 나눠지기때문에 근본적으로 다르다. 3. 줄바꿈new line의 약자로 \\n을 해주면 된다 1System.out.println(\"Hello \\nWorld\"); 4. 문자열안의 큰따옴표 (escape)문자열 안에 큰따옴표를 사용하고 싶을 때는 \\&quot;\\&quot; 를 사용해주면 된다 1System.out.println(\"Hello \\\"World\\\"\");// Hello \"World\"","link":"/2020/05/15/200516javae/"},{"title":"ID와 PASSWORD 일치여부 앱의 코드 리팩토링","text":"ID와 PASSWORD일치여부 앱의 코드 리팩토링 생활코딩 JAVA를 수강중에 나오는 실습들만 따라하는 게 아니라 더 나아가 응용을 스스로 하고 있다.그만큼 JAVA의 매력에 푹 빠졌달까… 실습에선 ID와 PASSWORD가 일치하면 로그인되는 결과만 도출하는 APP이었다면 나는 더 나아가 ID만 일치하고 PASSWORD가 다른 경우 PASSWORD를 다시 입력하라는 메세지를 전달하는 APP을 만들고 싶었다. 그래서 내가 처음 짠 코드는 아래와 같다. 초기 코드조건문을 어떻게 해야하는 지 고민스러웠다.일단 가장 쉬운 if로만 이루어진 코드를 짰다.원하는대로 작동하니 정말 뿌듯했다. 1234567891011121314151617181920212223242526272829303132333435public class authapp { public static void main(String[] args) { String[][] users = { {\"민지\", \"111\"}, {\"하지\", \"222\"}, {\"뽀니\", \"333\"}, {\"라미\", \"444\"} }; String inputId = args[0]; String inputPass = args[1]; Boolean isRightId = false; Boolean isRightPass = false; for(int i=0; i&lt;users.length; i++) { String[] current = users[i]; if(current[0].equals(inputId)){ isRightId = true; if(current[1].equals(inputPass)){ isRightPass = true; break; } } } System.out.println(\"Hi,\"); if(isRightId &amp;&amp; isRightPass) { System.out.println(args[0] + \" Long time No see!\"); }else if (isRightId &amp;&amp; (!isRightPass)) { System.out.println(args[0] + \" Please check password again\"); }else{ System.out.println(args[0] + \"Please sign up\"); } }} 작동해서 뿌듯했지만 프로그래머들 사이에서 들여쓰기가 3번이상된다면 코드를 한번 더 봐라라는 격언이 있다고 들었다. 리팩토링 두번째코드주석없이도 다른 사람이 알아볼 수 있는 코드를 만들고 싶었다.위의 코드와 1줄차이이고 두번째코드가 오히려 1줄 더 길다.하지만 나는 두번째코드가 직관적이라서 더 좋은 느낌이다. 12345678910111213141516171819202122Boolean isRightId = false;Boolean isRightPass = false;for(int i=0; i&lt;users.length; i++) { String[] current = users[i]; if(current[0].equals(inputId) &amp;&amp; current[1].equals(inputPass)) { isRightId = true; isRightPass = true; break; }else if(current[0].equals(inputId)) { isRightId = true; break; }}System.out.println(\"Hi,\");if(isRightId &amp;&amp; isRightPass) { System.out.println(args[0] + \" Long time No see!\");}else if (isRightId &amp;&amp; (!isRightPass)) { System.out.println(args[0] + \" Please check password again\");}else{ System.out.println(args[0] + \"Please sign up\");} 좋은 코드란 무엇일까? 아직까지 잘 모르겠다.JAVA를 더 배우고나면 좋은 코드가 무엇인지 감이 확실히 올거라 믿는다.","link":"/2020/05/22/200523javae/"},{"title":"[패스트캠퍼스python] 괄호종류, .format(), 기본단축키, 가상환경명령어, 데이터타입","text":"괄호종류, .format(), 기본단축키, 가상환경명령어, 데이터타입1. 괄호종류 : 대괄호[] - 중괄호{} - 소괄호()2. format사용Python에서 중요한 format함수의 활용에 대해 공부했다.각 약어들의 의미는 아래와 같다 $s : 문자 $d : 정수 (ex: -1,0,1등) $f : 실수 (유리수 + 무리수이므로 ex: 1.8, 3/4, √4, π 등) 12345678print('{} and {}'.format('You', 'I'))print('{0} and {1} and {1}'.format('You', 'I'))print(\"%s likes to go %d St. %s\" %('Kim', 7, 'library'), '도서관')# run하면 아래와 같이 터미널에 나타난다. # You and I# Me and I and I# Kim likes to go 7 St. library 도서관 3. 기본 단축키 ctrl + shift + B =&gt; 터미널에 코드실행 (터미널에 적힌 코드들의 실행값을 볼 수 있음) ctrl + / =&gt; 파이썬에서 주석을 나타낼 수 있다. 언어마다 주석이 다른데 파이썬은 앞에 #이 붙으면 주석처리가 된다. 4. 가상환경 명령어여러 프로젝트를 진행하다보면 다양한 프로그램들을 다운로드하게 되고 python버전끼리 또는 프로그램끼리 서로 충돌할 수 있다.에러를 해결하기위해 고군분투하다가 심한 경우 포맷을 해야하는 끔찍한 상황에 처할 수 있다. 이를 방지하기 위해 프로젝트를 가상환경안에서 진행하면 좋다.프로그램끼리 충돌이 생겨 에러가 난 경우, 가상환경안의 include폴더, Lib폴더 그리고 Scripts폴더만 삭제해주면 끝!굳이 눈물의 포맷을 할 필요가 없다! 가상환경설정을 윈도우기준으로 설명하자면, cmd를 검색하여 명령 프롬프트를 연다 cd 원하는파일위치복붙: 원하는 파일위치를 연다 dir: 현재 파일 위치안에 있는 파일들을 확인한다 cd Scripts: Scripts파일로 들어간다 activate.bat : 명령어를 입력하면 경로 제일 앞에 괄호가 생기고 그 안에 (지정했던 가상환경파일)이 적힌다. 이렇게 되면 가상환경안에 들어와 있는 것이 된다! code: 가상환경안에 있음을 확인 후 code를 쳐서 에디터를 연다.꼭 가상환경안에서 에디터를 열어야 추후 일어날 수 있는 문제를 예방할 수 있다. deactivate.bat: 가상환경 밖으로 나갈 수 있는 코드이다. 5. 가상환경설정시 warning 해결명령 프롬프트를 열고 열심히 강의를 따라하고 있는데 아래 이미지와 같이 warning이 나타났다. 옛날이었으면 엄청 당황했겠지만 공부하는 동안 꽤 많이 봐왔다.당황하지않고 찬찬히 읽어보았다. 현재 pip버전이 옛날 버전이므로 이를 업그레이드하라는 말이었다.뭐야~ 쉽잖아!휴~ 난 또,, 놀래라! 그래서 적혀저있는 그대로~ 하라는대로~ python -m pip install --upgrade pip를 복붙했다.짜잔- 위의 사진에서 위와 아래, 두 개의 빨간 동그라미를 통해 버전업그레이드가 잘 된것을 확인할 수 있다. 6. 파이썬의 데이터타입 종류 파이썬의 데이터타입에는 Boolean Numbers String Bytes List Tuples Sets Dictionaries사실 모든 테이터 타입들이 다 중요하다.이 중 중요한 타입들로는 Lists, Sets, Dictionaries라고 한다.","link":"/2020/05/24/200525python/"},{"title":"[패스트캠퍼스python] 데이터타입(리스트, 튜플, 딕셔너리, 셋)","text":"데이터타입(리스트, 튜플, 딕셔너리, 셋)다른 데이터들은 익숙한데 위의 데이터타입들은 생소해서 꼼꼼하게 인강을 들었다.이러한 데이터들만 잘 활용해도 파이썬을 제대로 사용할 수 있을 것만 같다신기한게 다음 인강이 test인강이었다. 답을 어디 제출하는 것은 아니지만 숙제개념으로 먼저 풀어본 뒤 인강을 들으면 진짜 학원다니는 느낌(?)을 낼 수 있다 ㅋㅋㅋㅋㅋ 1. 리스트리스트는 아래 4가지가 다 가능한 매우 유연한 데이터타입이다. 순서O 중복O 수정O 삭제O 1-1 리스트의 선언선언은 쉽다 12345678a = [1,2,3,4,5]b = list('a') c = [1,2,'Apple', ['Pink', 'Red']]d = list(1)print(a)print(b)print(d) 출력값으로는 123[1, 2, 3, 4, 5]['a']#에러발생, int값은 출력이 안됨. d = list(‘a’)는 출력이 가능하나 list(1)은 출력이 불가능했다. 1-2 리스트의 인덱싱위의 선언을 그대로 아래코드를 입력했다 12345print(c[0])print(c[-1]) print(c[1]) print(c[-1][-2]) print(c[3][1]) 그 출력값은 아래와 같다.특히 -인덱스에서 출력되는 값들이 조금 헷갈린다실습을 많이해서 실수하지 않도록 해야겠다. 123451['Pink', 'Red']2PinkRed 1-3 리스트의 슬라이싱선언한 c에서 1부터 사과까지의 값만 가지고 오고싶다면 슬라이싱을 하면 된다. 12c = [1,2,'Apple', ['Pink', 'Red']]print(c[0:3]) 출력값 1[1, 2, 'Apple'] 1-4 리스트의 연산곱하기 연산이 신기했다 12a = [1,2]print(a * 3) 출력값은 1[1,2,1,2,1,2] 1-5 리스트의 수정 및 삭제리스트는 수정 및 삭제가 간편했다. 1234567891011c[0] = 77print(c)a[1:3] = [100, 200, 300]print(a)c[1] = aprint(c)del c[1]print(c) 출력값 1234[77, 2, 'Apple', ['Pink', 'Red']][1, 100, 200, 300, 4, 5][77, [1, 100, 200, 300, 4, 5], 'Apple', ['Pink', 'Red']][77, 'Apple', ['Pink', 'Red']] 1-6 리스트 함수함수는 재미있는 내용이 꽤 많았다 append(a)와 insert(a,b), extend(c)의 차이점 append(a)는 배열 맨 뒤에 a값을 넣음 insert(a,b)는 a번째 인덱스에 b값을 넣음 list.extend(a)는 a가 배열인 경우 배열 통채로 list에 삽입되지만 list.extend(a)는 a의 원소들이 list에 삽입됨 차이점은 아래 코드를 보면 명확히 나타난다 123456789101112131415y = [5,2,3,1,4]print(y)y.append(6)print(y)list = [10,20,30]list.append(y)print(list)list.extend(y)print(list)y.insert(2,7) #2번째 인덱스에 7을 넣음print(y) 출력값은 12345[5, 2, 3, 1, 4][5, 2, 3, 1, 4, 6][10, 20, 30, [5, 2, 3, 1, 4, 6]][10, 20, 30, 5, 2, 3, 1, 4, 6][1, 2, 7, 3, 4, 5, 6] append는 배열 통채로 추가되는 것을 확인할 수 있다. sort()와 reverse()는 서로 반대! sort()는 순서대로정렬, 오름차순정렬 reverse()는 역순정렬, 내림차순정렬 del, remove(), pop()은 셋 다 삭제하는 기능이다! del는 인덱스로 삭제 가능 remove(a)는 인덱스의 값이 지워지는게 아니라 a라는 값을 찾아서 삭제해줌 pop() 맨 마지막 값을 꺼냄, 참고로 pop()과 push())를 LIFO(Last in first out)구조를 가진 스택(Stack)이라고 부른다 12345y.remove(7)print(y)y.pop()print(y) 출력값은 12[1, 2, 3, 4, 5, 6][1, 2, 3, 4, 5] 2. 튜플언뜻보면 리스트와 다름없는 튜플은 왜 있는걸까?수정이나 삭제되면 안되는 중요 데이터를 다룰때 튜플에 저장사용하면 좋기 때문이다리스트와 중복되는 부분이 많아 내게 필요한 부분만 정리해보았다 순서O 중복O 수정x 삭제x 1234d = (10, 20, 30, ('a', 'b', 'c'))print(d[2:])print(d[3][0:1]) 출력값은 12(30, ('a', 'b', 'c'))('a',) 마지막 출력값에 ,가 찍히는 건 튜플의 특성이다. 튜플은 수정과 삭제가 안되기 때문에 위의 이미지처럼 del로 삭제를 시도한 경우 터미널에 TypeError코드가 생기며 deletion을 support하지 않는다고 알려준다. 3. 딕셔너리dictionary 는 key, value, items를 구분할 줄 알아아한다.딕셔너리를 배우면서 이렇게 데이터를 효율적으로 다룰 수 있단 말이야? 하며 크게 놀랐다.왜 파이썬이 데이터베이스에 많이 사용되는 언어인지 이해가 갔다. 순서x 중복x 수정o 삭제o 3-1 딕셔너리의 선언12a = {'name' : 'kim', 'Mobile':'02-3196-777'}b = {'arr' : [1,2,3,4,5]} 3-2 딕셔너리의 출력딕셔너리 출력시 그냥 출력하는 것보다 get()을 이용하는 걸 추천한다.get()을 이용해서 key를 찾으면, None을 통해 key유무를 확실히 확인할 수 있어 유용하다 12print(a['name'])print(a.get('name')) 둘 다 동일한 출력값을 가진다. 12kimkim 3-3 딕셔너리의 추가123456a['address'] = 'Seoul'print(a)``` 출력값```python{'name': 'kim', 'Mobile': '02-3196-777', 'address': 'Seoul'} 3-4 keys, values, items(keys와 values 합친거)형변환 필수! 1234567print(a.keys())print(list(a.keys()))# 정말 자주 사용함. 중요해! for반복문할때 temp에 넣어서 자주 사용temp = list(a.keys())print(temp[1:3])print(a.values()) # 대량의 데이터처리가 매우 쉬움print(a.items()) 출력값은 12345dict_keys(['name', 'Mobile', 'address'])['name', 'Mobile', 'address']['Mobile', 'address']dict_values(['kim', '02-3196-777', 'Seoul'])dict_items([('name', 'kim'), ('Mobile', '02-3196-777'), ('address', 'Seoul')]) 3-5 ( in )은 keys 유무확인만 가능할뿐 value유무확인은 안됨12print('name' in a) print('kim' in a) 출력값은 12TrueFalse 4.집합(Sets)셋의 특징은 아래와 같다.셋을 통해 파이썬이 빅데이터처리에 유용하다는 것을 느꼈다. 순서x 중복x 1234z = set([1,2,7])y = set([1,2,3,4,4,5,6])print(y) 출력값은 1{1, 2, 3, 4, 5, 6} sets은 중복을 허용하지않기때문에 알아서 중복제거해준다. 4-1 교집합12print(z.intersection(y))print(z &amp; y) 동일한 출력값을 가진다 12{1, 2}{1, 2} 4-2 합집합12print(z | y)print(z.union(y)) 동일한 출력값을 가진다 12{1, 2, 3, 4, 5, 6, 7}{1, 2, 3, 4, 5, 6, 7} 4-3 차집합123print(z - y)print(y - z)print(z.difference(y)) 출력값은 123{7}{3, 4, 5, 6}{7} 위에서 배웠던 데이터타입을 가지고 형변환을 하면 아래 이미지와 같이 출력된다 괄호의 모형도 다르고 type도 다르다. 드디어 자료형에 대해 개략적으로 공부 완료했다실습을 통해 내것으로 빨리 만들어보는 시간을 가졌으면 좋겠다.","link":"/2020/05/25/200526python/"},{"title":"[패스트캠퍼스python] 데이터 타입 관련 퀴즈 풀기","text":"파이썬 인강 : 데이터 타입 관련 퀴즈 풀기내 돈 내고 듣고 있는 패스트캠퍼스의 파이썬 인강! 이때까지 배운 데이터 타입과 관련하여 16문제정도를 풀어보았다.다양한 방법으로 풀어보고 출력값이 일치하는 거 보니 참 뿌듯했다.이런 간단한 사항들을 자유자재로 다룰 수 있어야 나중에 프로젝트를 호율적으로 진행할 수 있을 것임에 틀림없다.간단하다고 약보지말자.16가지 문제 중 기억해야할 것들을 위주로 블로깅을 해보려고 한다 1. 문자열 “30” 을 각각 정수형, 실수형, 복소수형, 문자형으로 변환해보세요.이건 형변환문제이고 아주 쉽지만 중요하다참고로 문자형은 이미 “30” 문자이기때문에 그대로 적어도 되고str()을 사용해서 만들어도 된다. 12345678910print(type(int(\"30\")), int(\"30\"))print(type(float(\"30\")), float(\"30\"))print(type(complex(\"30\")), complex(\"30\"))print(type(\"30\"), \"30\", type(str(30)), str(30))# 출력값은 아래와 같다&lt;class 'int'&gt; 30&lt;class 'float'&gt; 30.0&lt;class 'complex'&gt; (30+0j)&lt;class 'str'&gt; 30 &lt;class 'str'&gt; 30 2. 다음 문자열 “Niceman” 에서 “man” 문자열만 추출해보세요.다양한 방법으로 풀 수 있고 강의에서는 슬라이싱방식과 인덱싱을 이용한 방법으로 풀이해주었다 123456789101112131415# 첫번째 방법: 슬라이스 활용q5 = \"Niceman\"print(q5[4:]) # 슬라이싱으로 간단하게 처리print(q5[4:7]) # 슬라이싱으로 간단하게 처리# 두번째 방법: index활용q5Idx = q5.index(\"m\")print(q5Idx)print(q5[q5Idx:])# 출력값은 순서대로manman4man 만약 Nice를 빼고 문자열을 추출해보세요라고 한다면 어떻게 하면 될까?나는 len()를 이용해서 풀어보았다.위와 동일한 값이 출력되는 것을 볼 수 있다.간단하게 응용도 해보니 파이썬을 향한 재미가 쑥쑥 올라간다. 12345q5len = len(\"Nice\")print(q5[q5len:])# 출력값은man 3. 다음 문자열을 거꾸로 출력해보세요. : “Strawberry”간단한 문제라서 reverse()로 접근했다. 123456q6 = \"Strawberry\"q6.reverse() print(q6)# 출력값은에러 에러가 발생해서 깜짝 놀랬는데 알고보니 reverse()는 리스트일때 사용하는거였다.이제 절대 안 잊어버릴것같다 ㅋㅋㅋㅋ문자형은 reversed()를 사용하면 된다심지어 내 에디터가 알려줬는데도 무시해버렸다ㅋㅋㅋㅋ에디터말 잘 들어야지! 1234print(reversed(q6))# 출력값은&lt;reversed object at 0x0000017E087888E0&gt; 이건 우리가 원하는 데이터가 아니므로 list로 형변환시키면된다 1234print(list(reversed(q6))) # 출력값은['y', 'r', 'r', 'e', 'b', 'w', 'a', 'r', 't', 'S'] 자 이제 원하는 값이 리스트형태로 나왔으니 슬라이싱 이용하면 된다 1234print(q6[::-1])# 출력값은yrrebwartS 손 쉽게 해결! 4. 다음 문자열에서 ‘-‘를 제거 후 출력하세요. : “010-7777-9999”이번 문제는 실무에서 활용도가 높은 문제였다.물론 해결방법은 여러가지가 있지만 제일 쉽게 접근 할 수 있는 방법은 역시 슬라이싱이다.강의에서 슬라이싱뿐만 아니라 아래 이미지처럼 정규표현식을 사용하여 풀이해주었는데 굉장히 재미있었다 4-1 첫번째 방법: 슬라이싱 이용.12345q7 = \"010-7777-9999\"print(q7[0:3]+q7[4:8]+q7[9:])# 출력값은01077779999 4-2 두번째 방법: 정규표현식 이용.이번 문제를 통해 정규표현식을 처음 접했는데 굉장히 재미있었다정규표현식은 언어와 상관없이 표준화가 거의 되어있다.따라서 정규표현식을 공부하면 언어를 초월해서 해당 언어(java,c,c++,js,python등)에 금방 적응할수있다 ^ 의미는 ‘아니다’ 이다. 0-9 는 0부터 9까지라는 의미이다. 즉 [^0-9] 뜻은 숫자제외이다. replace기능 가능 : 예를 들어 010또는 011이면 070으로 바꾸고싶을때 사용가능하다 1234567import reprint(re.sub('[^0-9]','', q7))print(re.sub('010|011','070', q7)) #010또는 011이면 070으로 바꾸고싶다면# 출력값은01077779999070-7777-9999 5. 다음 문자열(URL)에서 “http://“ 부분을 제거 후 출력하세요. : &quot;http://daum.net&quot;이 문제는 위에서 배운 내용들을 토대로 혼자서 네가지 방식으로 풀어보았다다 제대로 값이 출력되니 여간 뿌듯한 게 아니다. 12345678910111213141516171819202122# 첫번째 방식: 슬라이싱q8 = \"http://daum.net\"print(q8[7:])# 두번째 방식: 인덱싱q8index = q8.index(\"/\")print(q8index)print(q8[q8index+2:])# 세번째 방식: len()길이q8len = len(\"http://\")print(q8[q8len:])# 네번째 방식: 정규표현식print(re.sub('http://','', q8))# 출력값은daum.net5daum.netdaum.netdaum.net 6. 다음 문자열을 슬라이싱을 이용해서 “cde”만 출력하세요. : “abcdefghijklmn”해당 문제는 슬라이싱을 이용해서 풀어라고 했기때문에 아래 이미지처럼 풀면 된다 하지만 이렇게 문자열 길이가 긴 문제의 경우 슬라이싱으로 몇 번째 인덱스인지 직접 세는 것보다 인덱싱을 활용하는 게 더 편하다고 생각해서 인덱싱으로 풀어보았다 123456q10 = \"abcdefghijklmn\"q10Index = q10.index(\"cde\")print(q10[q10Index:q10Index+3])# 출력값은cde 7. 다음 리스트에서 “Apple” 항목만 삭제하세요. : [“Banana”, “Apple”, “Orange”]리스트의 remove()를 이용해서 간단하게 풀었다 12345q11 = [\"Banana\", \"Apple\", \"Orange\"]print(q11.remove(\"Apple\")) # 출력값은None 그런데 출력값이 None이 떠서 당황했다.remove()한 내용은 출력할 필요가 없고 삭제완료한 리스트를 print하면 되었던 문제였다 123456q11 = [\"Banana\", \"Apple\", \"Orange\"]q11.remove(\"Apple\")print(q11)# 출력값은['Banana', 'Orange']","link":"/2020/05/26/200527python/"},{"title":"[패스트캠퍼스python] 조건문과 반복문","text":"파이썬의 흐름제어 : 조건문과 반복문 파이썬은 정말 문법에 자유로운 언어인 것 같다.조건문, 반복문에도 ()를 넣지 않아도 된다.점점 내 스타일이다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ 1. 조건문1. 조건문의 Boolean조건문에서 가장 중요한건 boolean이다 1234567if None: print(\"Yes1\")else: print(\"Yes2\")#출력값은Yes2 만약 Yes1을 출력하고 싶다면 if 의 조건을 True 값을 넣어야한다그렇다면 True 와 false 에는 뭐가 있을까? 참 거짓 종류참 : “내용” [내용] (내용) {내용} 1거짓 : “” [] () {} 0 1234567if 1: print(\"Yes1\")else: print(\"Yes2\")#출력값은Yes1 2. 관계연산자다양한 예가 있다.수학에서의 부등호와 비슷하기 때문에 직관적으로 의미를 알수있다.==, !=, &gt;, &gt;=, &lt;, &lt;= 3. 논리연산자 : and or notjs에서 and와 or 연산자만 배웠었는데python에서 not 연산자를 처음 봤다.not이란 연산자는 되게 흥미로워서 조금 더 찾아봤다논리연산자진리표를 보면 쉽게 이해가 간다. 아래 이미지는 논리연산자의 쉬운 예시이다 아래 코드의 의미는 참이 아닌 것을 출력하시오이다. 1234print(not True)# 출력값은False 4. 산술 &gt; 관계 &gt; 논리 순서대로 적용.위에서 배웠던 세 가지의 연산자들이 동시에 쓰이게 되면 우선순위대로 처리가 이루어진다 1234print('ex1 : ', 5+10 &gt; 0 and not 7+3 == 10)# 출력값은ex1 : False 관계연산자와 논리연산자를 함께 쓰면 아래와 같다 123456789score1 = 80score2 = 'A'if score1 &gt;= 90 and score2 =='A': print(\"합격입니다\")else: print(\"불합격입니다\")# 출력값은불합격입니다 5. 다중조건문 : 다중조건문은 위의 점수조건문을 응용해서 만들어볼 수 있다 num이 82이기에 B값이 터미널에 출력되는 것을 확인 할 수 있다. 2. 파이썬 흐름제어(반복문) : while, for 1. while과 for문while문은 아래와 같이 나타낼수있다while문과 for문이 자유자재로 바꿔 생각할 수 있어야 코딩 초짜를 뗄 수있다. 123456789101112131415v1 =1while v1 &lt; 11: print(\"vi is :\", v1) v1 +=1# 출력값은vi is : 1 vi is : 2 vi is : 3 vi is : 4 vi is : 5 vi is : 6 vi is : 7 vi is : 8vi is : 9vi is : 10 이걸 for 문으로 바꾼다면 어떻게 될까? 123456789101112for v2 in range(1, 11): print(\"v2 is : \", v2)v2 is : 1v2 is : 2v2 is : 3v2 is : 4v2 is : 5v2 is : 6v2 is : 7v2 is : 8v2 is : 9v2 is : 10 2. 1부터 100까지의 합을 구하는 두 가지 방법 첫번째 방법 while문사용 12345678910sum1 = 0cnt1 = 1while cnt1 &lt;= 100: sum1 += cnt1 cnt1 += 1print(' 1 ~ 100합은 : ', sum1)# 출력값은 1 ~ 100합은 : 5050 두번째 방법 range()함수사용 1234print(' 1 ~ 100합은 : ', sum(range(1,101)))# 출력값은 1 ~ 100합은 : 5050 위의 range 함수 활용range()함수는 3번째 매개변수까지 받을 수 있다.range(시작값, 끝값, 넘어가는숫자)) 예를 들어 1~100까지의 짝수의 합은? 123456print(' 1 ~ 100까지 짝수의 합은 : ', sum(range(1,101, 2)))print(' 1 ~ 100까지 짝수의 합은 : ', sum(range(1,101, 10))) # 십단위의 합# 출력값은 1 ~ 100까지 짝수의 합은 : 2500 1 ~ 100까지 짝수의 합은 : 460 3. 시퀀스순서가 있는 자료형을 반복 (매우중요)문자열, 리스트, 튜플, 집합, 사전 이 데이터들은 다 시퀀스 가능iterable 리턴함수 : range, reversed, enumerate, filter 예제 1 : 값을 하나씩 가져오시오 12345678names = ['kim', 'park', 'lee']for v in names: print(\"You are : \", v)# 출력값은You are : kimYou are : parkYou are : lee 예제 2 : ‘word’를 한 글자씩 가져오시오 123456789word = 'word'for s in word: print(\"Word : \", s)# 출력값은Word : wWord : oWord : rWord : d 예제 3 12345678910111213141516171819202122232425262728293031323334353637my_info = { 'name' : 'kim', 'city' : 'seoul', 'age' : 77}# 키를 가져오는 두가지 방법 :기본값과 keys()print('기본값은 키가져오기')for key in my_info: print(key)for key in my_info.keys(): print(key)# 값print('값가져오기')for key in my_info.values(): print(key)# 키와 값 둘 다print('키와 값 둘 다 가져오기')for k, v in my_info.items(): print(k, v)# 출력값은기본값은 키namecityagenamecityage기본값은 값kimseoul77기본값은 키와 벨류 둘다name kimcity seoulage 77 예제 4 : 대문자는 소문자로, 소문자는 대문자로 바꾸시오 12345678910111213141516name = 'GoodbYe'for n in name: if n.isupper(): print(n.lower()) else: print(n.upper())# 출력값은gOODByE 4. break정말 중요한 break!사소하지만 효율을 올려준다 1234567891011121314151617numbers = [14,3,4,7,10,33,24,17]for num in numbers: if num == 33: print('찾았다', num) else: print('못찾았다')# 출력값은못찾았다못찾았다못찾았다못찾았다못찾았다찾았다 33못찾았다못찾았다 위의 코드로 하면 원하는 값을 찾은 뒤에 2번 더 실행되는 것을 볼 수 있다.효율이 떨어지므로 break걸어주면 좋다 1234567891011121314for num in numbers: if num == 33: print('찾았다', num) break else: print('못찾았다')# 출력값은못찾았다못찾았다못찾았다못찾았다못찾았다찾았다 33 5. for - else 구문흥미롭게도 python에는 for문에도 else가 있다 (중요)반복문이 정상적으로 수행 된 경우 else 블럭 수행블럭안에 break가 들어간 경우 반복문 전체가 실행되지않기에 for-else문이 출력되지않는다 123456789101112131415161718for num in numbers: if num == 33: print('찾았다', num) else: print('못찾았다')else: print('반복문끄읕') # 출력값은못찾았다못찾았다못찾았다못찾았다못찾았다찾았다 33못찾았다못찾았다반복문끄읕 6. continuebreak의 반대이다아래는 continue를 가장 이해하기 쉬운 예시이다 12345678lt = [\"1\", 2, 5, True, 4.3, complex(4)]for v in lt: if type(v) is float: print('찾았다, float : ', v)# 출력값은찾았다, float : 4.3 만약 찾은 float빼고 나머지를 보고싶다면?이때 continue사용하면 좋다! for v in lt: if type(v) is float: continue print('타입 : ', type(v)) # 출력값은 타입 : &lt;class 'str'&gt; 타입 : &lt;class 'int'&gt; 타입 : &lt;class 'int'&gt; 타입 : &lt;class 'bool'&gt; 타입 : &lt;class 'complex'&gt; float만 빼고 출력된 것을 확인할 수있다개이득!","link":"/2020/05/27/200528python/"},{"title":"[패스트캠퍼스python] 파이썬 인강 자기계발 챌린지 시작","text":"[패스트캠퍼스 수강 후기]파이썬인강 자기계발 챌린지 시작기회는 준비된 자에게 온다고 했던가?이번에 패스트캠퍼스 5주 자기계발 챌린지 라는 좋은 기회가 있어 바로 기회를 잡았다. 앞으로 35일간 매일 TIL을 작성할 예정이다이번 인강을 통해 Python을 실무에서 쓸 수 있었으면 좋겠다. 참고링크 파이썬 웹 개발 올인원 패키지 Online : https://bit.ly/2WG0IXN","link":"/2020/05/23/200524python/"},{"title":"[ITWILL : JAVA]컴퓨터와 자바 기초이론","text":"컴퓨터와 자바 기초이론을 아래에 정리해보았다. Bit0 또는 1의 정보를 나타내는 최소 단위쉽게말해 64bit라면 64개의 선들이 한번에 cpu로 들어가는 간다.그리고 신기한 점은 똑같은 0001, 0001이라도 컴퓨터가 알아서 저 비트가 명령어인지 숫자1인지 구분해준다 Q 그렇다면 비트는 모스부호와 같은 건가?궁금해서 검색해보았는데 단순히 이진수의 개념인듯하다. 다음주에 강사님 만나면 물어봐야지 Adapter어탭터는 전압을 맞춰주는 역할을 한다만약 220볼트라면, 어탭터는 0~5볼트처럼 컴퓨터가 쓸 수 있는 낮은 전압으로 바꿔 준다. 프로그래밍 언어의 변천사 기계언어 = 이진수로 나타내는 언어 ex) 0000000010101010, 01010110101110 기계언어로는 너무 복잡해서 사람이 프로그램을 짤 수 가 없다. 그래서 생긴 언어가 어셈블리어 : 니모닉 기호로 이루어짐 ex) add 1, 1 그래도 자료구조 표현 어렵고 복잡함 그래서 만들어진 게 고급언어 Pascal, Algol, visaul Basic, C/C++, C#, Lisp, Fortran ex) a =1+1 개발자가 작성한 고급언어를 기계어로 바꾸어주는 것은 컴파일이라고 함 내가 언어를 만든다고 사용할수있을까? NOPE! 컴파일러가 있어야지만 가능. 자바도 자바컴파일러(javac)도 있고 파이썬도 파이썬컴파일러가 있다 기타 기계언어 + 어셈블리어 = 임베디드와 관련이 있다고 한다. 내 절친 라미가 임베디드 공부했었다던데… 그가 얼마나 어려운 언어를 했는지 조금이 짐작이 간다. 절차지향적언어 VS 객체지향적언어 절차지향언어 흐름도에 따라 일련의 동작들이 순서에 맞게 실행 기능 위주의 언어. 예를 들어 python, c등등 소스 코드 분석시 경비가 높아 기술의 한계가 있음 객체지향적언어 효율적 개발을 위해 등장 소프트웨어의 조립화 스크립트언어스크립트언어란 소스코드를 compile하지 않고도 실행할 수 있는 프로그래밍 언어이다객체지향적언어가 너무 코드가 기니까 짧게 만든게 스크립트언어이고 그 예로 java에서 jsp가 있다.기존에 이미 존재하는 어플리케이션을 제어하기 위한 용도로 쓰이는 언어이고 인터프리터 형식의 언어이다.수정이 빈번하게 일어나는 곳에서 쓰인다 Compile VS Interpreter둘 다 고급언어로 작성된 원시 프로그램(Source Program)을 목적 프로그램(Object Program)으로 번역하는 번역 프로그램이며, 프로그램 번역 방식에 따라 구분된다. 컴파일 목적프로그램을 생성 번역과정과 번역시간이 복잡하고 오래 걸리지만 한번 번역 후에는 다시 번역하지 않아도되므로 실행속도 빠름 대표적 JAVA, C언어 예시: 소스코드(.java) -&gt; 자바 컴파일 -&gt; 바이트코드(.class) -&gt; JVM 의 JIT 컴파일러 -&gt; 머신코드 -&gt; 실행 인터프리터 : 컴파일로 번역된 내용을 메모리에 올려서 실행을 해준다 대표적 JS, PYTHON 목적프로그램을 생성하지않고 위에서 아래로 순차적으로 실행(웹 브라우저에 포함되어있음) 번역속도는 빠르지만 프로그램 실행시 매번 번역해야해서 실행속도가 느리다 대표적 JS, PYTHON 예시1 : 소스코드(스크립트) -&gt; 인터프리터 -&gt; 실행 예시2 : A.class 파일을 메모리에 올리고 cpu가 해석하고 실행 참고링크1: 컴파일러와 인터프리터란 무엇인가참고링크2 : 컴파일언어와 스크립트언어 차이 java의 특징 플랫폼 독립적 컴퓨터는 개발환경(intel CPU, 애플mac / 윈도우,맥,리눅스)를 플랫폼이라고 하는데 c언어는 개발환경이 다른 경우 구현이 불가능함. 하지만 자바는 가능함 이걸 플랫폼 독립적이라고 함. 가능한 이유는 JVM(java virtual machine)이 해줌. 거의 모든 컴터에 기본적으로 다운로드 되어있음 java 프로그램의 단위는 Class이다. Class의 첫문자는 대문자이다 ex) Class XXX {} 위의 예제를 순서대로 Class=예약어, XXX=클래스의이름, {}=실행코드 C#언어와 거의 똑같다. C보다는 처리속도가 느리지만 C만큼 빠르다 자바실행환경소스파일(.java) -&gt; 컴파일 -&gt; 바이트코드(기계어.class) -&gt; JVM이 인터프리터 -&gt; 실행 로딩CPU를 동작시키는 프로그램을 메모리에 올려놓는 작업","link":"/2020/05/27/200528javai/"},{"title":"[패스트캠퍼스python] 파이썬의 조건문과 반복문 중간 점검 퀴즈","text":"파이썬의 조건문과 반복문 중간 점검 퀴즈조건문과 반복문 중간 점검 퀴즈를 하였다데이터타입 중간 점검 퀴즈와는 다르게 조금 어려웠다. 여러 문제를 풀었지만 내가 모르는 문제해결방법 위주로 정리해보았다이번 중간 퀴즈도 역시 유익했다. 1. 아래 딕셔너리에서 ‘가을’에 해당하는 과일을 출력하세요.동일한 접근 방법이지만 keys()를 가져올 지 items()를 가져올 지 선택할수있다 첫번째 방법 : for와 if문 사용 12345q1 = {\"봄\": \"딸기\", \"여름\": \"토마토\", \"가을\": \"사과\"}for k in q1.keys(): if k == '가을': print(q1[k]) 두번째 방법 : keys()말고 items()가져오기 123for k, v in q1.items(): if k == '가을': print(v) 첫번째, 두번째 출력값은 12사과사과 2. 다음 세 개의 숫자 중 가장 큰수를 출력하세요.(if문 사용) : 12, 6, 18나는 아래와 같이 풀었다. 쉽게쉽게~! 1234567891011121314a = 12b = 6 c = 18if a &gt; b: if a &gt; c: print(a) else: print(c)else: print(b) # 출력값은18 위는 내가 푼 코드이고 아래는 강사가 푼 코드이다.변수선언이나 코드길이도 훨씬 효율적여보인다.여러 방법으로 푸는 방법을 익히고 그리고 여러 방법으로 풀어보려는 자세가 중요하다. 12345678a, b, c = 12, 6, 18best = aif b &gt; a: best = bif c &lt; b: best = c print('best : ', best) 두 방법 다 꼭 기억해야겠다. 3. s에서 7자리 숫자를 사용해서 남자, 여자를 판별하세요. (1,3 : 남자, 2,4 : 여자)처음에 어떻게 풀지 막막했다. 결국 겅의를 보게 되었고 결과는 허무했다.이렇게 간단한거였는데 풀지도 못하다니 수학적 사고를 길러야겠다고 생각이 들었다 123456789s = '021022-4473837'if int(s[7]) % 2 == 0: print('여자')else: print('남자')# 출력값은여자 4. 다음 리스트 중에서 ‘아’ 글자를 제외하고 출력하세요.여기서 continue 를 쓸 생각을 하지못했다.슬라이싱 처리하려고 했는데 잘 안되서 막막하던 차에 강의에서 continue쓰고 묵혔던 답답함이 쏴악 해소되었다.이제 컨디뉴 절대 안 잊어버릴것같다 1234567891011q3 = [\"지\", \"컨\", \"아\", \"세\", \"요\"]for v in q3: if v == '아': continue else: print(v, end='')print()# 출력값은지컨세요 5. 아래 리스트 항목 중에서 5글자 이상의 단어만 출력하세요.이건 보자마자 길이함수를 써야겠다는 확신이 들었다js를 할때 길이를 항상 length()로 사용해서 무의식적으로 length()적었다가 에러가 떴다아차차 하고 바로 len()로 바꿨다비슷하지만 조금씩 다른 함수들이 있어서 가끔 혼동스럽다헷갈리지 않도록 더 빡세게 암기해야겠다. 123456789q4 = [\"nice\", \"study\", \"python\", \"anaconda\", \"!\"]for v in q4: if len(v) &gt;= 5: print(v, end=' ')print()# 출력값은study python anaconda 6. 아래 리스트 항목 중에서 소문자만 출력하세요.나는 당연히 islower()함수만 썼는데 강의에서 continue를 써서 깜짝 놀랬다.이런 부분때문에 혼자 공부하는 것보다 강의나 여럿이 공부하는 것이 좋은 것같다어서 실력을 키워 모각코나 스터디그룹을 만들고 싶다 123456q5 = [\"A\", \"b\", \"c\", \"D\", \"e\", \"F\", \"G\", \"h\"]for v in q5: if v.islower(): print(v, end=' ')print() 또는 continue를 써서 풀수도 있다 123456for v in q5: if v.isupper(): continue else: print(v, end=' ')print() 위의 두가기 방식의 출력값은 12b c e hb c e h 7. 아래 리스트 항목 중에서 소문자는 대문자로 대문자는 소문자로 출력하세요.재밌는 문제였다. 위의 방법을 그대로 응용하면 되는 문제라 풀면서도 재미있었다저 출력값들을 한 문장으로 나타내려면 어떻게하면 좋을까?if문 끝난 값들을 temp에 넣고 end()로 한 문장에 넣으면 될 것 같다나중에 실습해봐야지 123456789101112131415161718q6 = [\"A\", \"b\", \"c\", \"D\", \"e\", \"F\", \"G\", \"h\"]for v in q6: if v.isupper(): print(v.lower()) elif v.islower(): print(v.upper())print()# 출력값은aBCdEfgH 그리고 아래 내용들을 학습했다.정의에 관한 내용이라 블로깅할 부분이 없었지만 강의가 구체적으로 들어가면 자세히 블로깅 할 예정이다","link":"/2020/05/28/200529python/"},{"title":"[ITWILL : JSP]프로그래밍기초이론, 하드웨어 vs 소프트웨어 vs 펌웨어, 기억장치, 클라이언트 vs 서버","text":"ITWILL학원 : 1강 프로그래밍이론 BY 정규태강사1. 프로그래밍특정 목적을 위해서 컴퓨터에 명령을 내리는 동작 혹은 동작의 집합 시스템 프로그래밍 : OS제작, 수정 응용 프로그래밍 : 엑셀 제작, 원가 관리 프로그램 등 웹프로그래밍 : 홈페이지 제작 등, 프로그래밍에는 다양한 것들이 있지만 웹 프로그래밍위주로 공부 할 예정(웹 프로그래밍은 망하지 않을 듯) 2. jsp (= java server page)자바 class, 객체 개념 인지 필수! 3. 하드웨어 vs 소프트웨어 vs 펌웨어 하드웨어 : 물리적인 기계 자체 소프트웨어 : 운영체제 : 리눅스, 윈도우, 맥 응용프로그램(application program): excel, power point, 계산기 등등 펌웨어 : 하드웨어+소프트웨어 4. 기억장치(Memory) 주기억장치 : RAM 보조기억장치 : CD-RM, FDD(플로피디스크-&gt;USB), HDD(하드디스크드라이브)-발전-&gt;SDD 모든 프로그램은 주기억장치에서만 실행된다 : 메모리가 크면 한번에 많은 일을 처리할 수 있어서 메모리가 클수록 성능이 좋다 5. 기본용어 적재(load) : 보조기억장치에서 주기억장치로 (HDD-&gt;RAM) 넘어가는 과정 프로그램 : 하드디스크에 들어 있는 상태 프로세스 : 주기억장치에 로드된 상태의 프로그램(실행되고 있는 프로그램) (작업관리자의 백그라운드프로세스가 많을수록 컴터속도가 느려짐) 6. WEB(웹)인터넷 환경에서 여러가지 정보를 html문서 타입을 결과를 나타내는 환경 7. 웹 브라우저웹의 정보를 볼 수 잇는 클라이언트 프로그램ex)익스,크롬,웨일,맥 등 8. 클라이언트 vs 서버 클라이언트 : 정보를 제공 받는 쪽 서버 : 정보를 제공해주는 쪽 9. 클라이언트와 서버는 어떻게 요청을 주고 받을까? 클라이언트가 주소를 검색한다 (https://www.naver.com) http는 통신규약 (보내는 방식, 속도등이 포함되어 있음) http:// https:// 후자가 전자보다 보안이 더 좋음 도메인주소는 인간에게 편하게 만든거고 컴퓨터끼리는 IP주소임 IP주소 : 웹에서 컴퓨터를 구분하는 값 (0 ~ 255숫자조합임) ex)http://192.168.7.200 인간이 기억하기 어렵기때문에 도메인으로 이용 도메인서버 : IP &lt;-변경-&gt; 도메인 서버 주소 시키는 역활을 함 10.IPv4 VS IPv6나누는 이유가 뭘까?원래는 v4(4자리 조합)만 있으면 충분히 사용할 수 있었지만 요즘은 스마트폰, 테블릿, IPTV등 상용화가 많이 이루어지면서 4자리조합힘들어서 v6가 나왔다 IPv4 : IP를 4자리로 구분한 것 ex) 192.168.7.200","link":"/2020/05/27/200528jspi/"},{"title":"[패스트캠퍼스python] 파이썬 함수식","text":"파이썬 인강 : 파이썬 함수식함수식과 람다에 대해 자세히 알아보자.우리가 함수를 사용하는 이유는 반복적이고 중복되는 프로그램을 방지하기위해서다 1. 함수 정의 방법아래처럼 하면 끝! 12def 함수명(parameter): code작성하기 여기서 def는 define의 약자이다. 함수를 호출하는 방법은 함수명() 이고 만약 parameter가 있다면 함수명(parameter)로 호출하면 된다 1234567def hello(world): print(\"Hello, \", world)hello(\"Python!\")# 출력값은Hello, Python! 2. 함수 선언 위치함수를 선언할때는 선언 위치가 매우 중요하다파이썬은 항상 위에서부터 아래로 실행되기 때문이다위의 예제에서 아래 사진처럼 선언 위치를 바꾸면 터미널에 NameError 뜨는 것을 볼 수 있다hello라는 이름이 정의되어 있지 않다는 에러이다. 리턴이라는 예약어를 통해서 함수를 출력할수도있다아래 예제를 보자항상 형변환을 주의하자 123456789def hello_return(world): value = \"Hello, \" + str(world) return valuestr = hello_return(\"천사!\")print(str)# 출력값은Hello, 천사! 3. 다중리턴다중리턴을 사용하면 짜임새있는 함수를 만들 수 있다.java나 기타언어들은 return값이 하나인 게 원칙인데 파이썬은 다르다파이썬은 다중리턴을 허용한다 123456789101112def func_mul1(x): y1 = x * 2 y2 = x * 4 y3 = x * 6 return y1, y2, y3val1, val2, val3 = func_mul1(10)print(val1, val2, val3)# 출력값은20 40 60 파이썬의 매력적인 부분은 return값의 데이터 타입 변환이다.왜냐면 엄청 간단하고 쉽기때문에위의 예제에서 return의 데이터형태는 int(정수)이다.만약 데이터형태를 int가 아닌 다른 형태로 나타내고 싶다면 어떻게 하면 될까? 만약 데이터형태를 리스트로 받고싶다면 return[y1, y2, y3]를 적어주면 끝!만약 튜플로 받고싶다면 return(y1,y2, y3)로 하면 끝!만약 딕셔너리로 return받고싶다면? 12345678910111213def func_mul3(x): y1 = x * 2 y2 = x * 4 y3 = x * 6 return {'ret1': y1, 'ret2': y2, 'ret3': y3}dic = func_mul3(8)print(type(dic), dic, dic.get('ret3'), dic.items(), dic.keys(), dic.values())# 출력값은&lt;class 'dict'&gt; {'ret1': 16, 'ret2': 32, 'ret3': 48} 48 dict_items([('ret1', 16), ('ret2', 32), ('ret3', 48)]) dict_keys(['ret1', 'ret2', 'ret3']) dict_values([16, 32, 48]) 정말 저세상 간단함!정말 매력적인 언어다! 4. *args, **kwargs 이해 *args (아스타)arguments의 약자로 가변인자(인자의 갯수가 변할 수 있음)를 뜻한다다양한 매개변수를 받아서 함수의 흐름이 바뀌게한다매개변수를 하나를 넣든 세개를 넣든 튜플의 형태로 출력해준다기본적으로 *args라고 적지만 이 매개변수명은 자유롭게 변경 가능하다enumerate는 순회라는 의미로 index를 넣어서 나타낼 수 있다. 꼭 알아두자 123456789101112131415def args_func(*args): # 매개변수명 자유롭게 변경 가능 for i, v in enumerate(args): print(v, i)args_func('비')args_func('비', '보')args_func('비', '보', 'TV')# 출력값은비 0비 0보 1비 0보 1TV 2 만약 출력값을 여러줄 나오는게 싫다! 한 줄로 나타내고 싶다면?print(v, i)를 print(‘{}’.format(i), v, end=’ ‘)로 바꿔주면 된다 12# 출력값은0 비 0 비 1 보 0 비 1 보 2 tv 만약 *args와 range()를 같이 사용하면 어떻게 될까? 123456789def args_range(*args): for i, v in enumerate(range(3)): print(i,v)args_range()# 출력값은0 01 12 2 kwargsargs와 똑같은 가변인자이나 딕셔너리로 받는다는 차이점이 있다.별표가 하나일때는 튜플로 받는데 별표가 두개인경우 딕셔너리로 받는다.위의 args와 마찬가지로 매개변수명은 자유롭게 변경 가능하다 1234567def kwargs_func(**kwargs): # 매개변수명 자유롭게 변경 가능 print(kwargs)kwargs_func(name1='가')kwargs_func(name1='가', name2='나')# 출력값은{'name1': '가'}{'name1': '가', 'name2': '나'} 딕셔너리형태말고 한 줄에 주르륵 출력하고 싶으면print(kwargs)를 print(‘{}’.format(v), kwargs[v], end=’ ‘)로 바꿔주면 된다 12# 출력값은name1 가 name1 가 name2 나 *args와 *kwargs의 혼합효율적인 코딩을 위해 필수이며 꼭 이해를 해야하는 부분이다 아래 터미널처럼 가변인자(args와 kwargs)는 없이 int 10과 20만을 넣어도 출력이 되는 것을 알 수 있다.가변인자는 값이 없기때문에 빈 튜플과 빈 딕셔너리가 출력된다. 1234567def example(arg_1, arg_2, *args, **kwargs): print(arg_1, arg_2, args, kwargs)example(10, 20, 'park', 'kim', age1=77, age2=80 )# 출력값은10 20 ('park', 'kim') {'age1': 77, 'age2': 80} 실습을 하면서 궁금했던 점은 어떻게 튜플과 딕셔너리를 나누는 지 궁금했는데 완전 초보적인 생각이었다딕셔너리형태인 address=뭐시기를 넣으면 자동적으로 **kwargs 로 출력된다.만약 딕셔너리 형태를 순서를 섞어 놓으면 1example(10, 20, address=\"Busan\", 30, 'park', age1=77, age2=80 ) 아래 이미지와 같이 SyntaxError가 발행한다. 전체적으로 쉽게 설명한 참고링크1 5. 중첩함수말그래도 함수안에 함수가 있는 것중첩함수를 잘해둬야 클로저를 잘 해결할 수 있다클로저를 나아가서 Python decorator도 중급자에서 필수적인 내용이니 꼭 이해하자 123456789101112def nested_func(num): def func_in_func(num): print('언제실행될까? ', num) print(\"함수 안에서\") func_in_func(num + 100)nested_func(1)# 출력값은함수 안에서언제실행될까? 101 혹시 함수안의 함수 func_in_func()를 실행시킬 수 있을까? 1func_in_func(1) 정답은 실행불가!아래 이미지처럼 Name Error가 발생한다","link":"/2020/05/29/200530python/"},{"title":"DB기초이론, DBMS","text":"DB 기초이론실습환경 운영체제는 Linux!윈도우os에서도 oracle이 잘되지만 Linux위에서 DB운영 리눅스궁금했는데 다루게된다니 신기하다! MySQL도 수업시간에 같이 배울 예정이며다양한 DBMS중 거진 비슷하기때문에 하나만이라도 제대로 해놓으면 다른 프로그램도 쉽게 다룰 수 있다. 가상 PC환경설치현재 OS가 윈도우이기때문에 가상PC환경에서 리눅스를 이용하려고 한다.가상머신을 운영할수있게 도와주는 프로그램이있다 : virtual box, ubuntu 등등 virtual box 다운로드 아래 사진처럼 파일 &gt; 환경설정 &gt; 입력 &gt; 가상머신 &gt; 호스트키조합을 설정해준다.이는 가상PC에 마우스가 들어가면 빠져나올 수 있는 세팅이라 꼭 필요하다!이걸 세팅안하고 가상환경시작하면 가상환경 나올땐 컴터 강제종료밖에……… DBMS : Database Management SystemOracle은 엄연히 말하면 DB가 아니라 DBMS이다. 즉 DBMS의 한 종류가 바로 Oracle이다ex) Oracle, MySQL, Tibero(티베로)시중에 나와있는 DBMS는 대부분 관계형 DBMS이다 줄여서 RDBMS.관계형DMBS란 클라이언트가 원하는 것을 요청할때 요청사항에 위치가 포함되는게 아니라 그냥 what을 요청한다 그 후 RDMBS는 어느 위치에 있는지 스스로 찾아 데이터를 가져온다 Q. 그렇다면 DBMS와 RDBMS 차이점이 무엇일까?DBMS안에 RDBMS가 속해있음DBMS와 달리 RDBMS는 정규화를 수행할 수 있어 데이터중복을 최소화한다참고링크1, 참고링크2 SQL : Structured Query LanguageDBMS와 소통하려면 어떻게 해야할까? 소통할 수 있는 언어를 사용해야한다.그러한 언어가 바로 SQL이다. 참고링크 제약조건크게 5개정도가 있다. Primary key 제약조건 : 테이플의 각 행(row)을 고유하게 식별하는 열(column) 또는 열 집합 Foreign key 제약조건 : 다른 테이블의 기본 키를 참조하는 열 Not null 제약조건 : 주로 이름컬럼에 걸어놓으면 레지스터가 이루어지지않는다 즉 필수입력사항을 이 제약조건으로 걸수있다.","link":"/2020/05/28/200529dbi/"},{"title":"[ITWILL : WEB]&#96;&lt;pre&gt;&#96;태그, html특수문자입력, &#96;&lt;b&gt;태그&#96; 와 &#96;&lt;strong&gt;태그&#96;의 차이점","text":"ITWILL학원 : 1강 WEB(HTML, CSS) BY 김영희1강 HTML 기초WEB(HTML, CSS)을 담당하며 일주일에 1번 4시간 수업 HTML은 웹페이지를 만들어 주는 프로그래밍 언어이며 웹페이지의 구조를 담당한다enter나 space bar(2칸 이상)는 명령으로 해결한다. 1. tag는 원칙상 대소문자의 구별이 없으나 소문자로 입력한다2. !DOCTYPE html의 의미는 html5 문서임을 선언3. &lt;pre&gt;태그&lt;pre&gt;태그는 html문서안에서 &lt;p&gt;나 &lt;br&gt;를 쓰지않아도 html상의 Enter나 Tab, Space를 다 표현할 수 있기때문에 긴 문장등을 표현할때 굉장히 효율적으로 사용할 수 있다.더불어서 자동적으로 모든 문자의 width 간격을 일치시켜준다ex) i와 w의 크기가 같다 1234567만날 수 없어만나고 싶은데이런 슬픔처음인걸말할 수 없어말하고 싶은데속마음만 들키는 걸 위 내용을 html상에 적고 브라우저로 열어보면 1만날 수 없어만나고 싶은데이런 슬픔처음인걸말할 수 없어말하고 싶은데속마음만 들키는 걸 우리가 원하는 건 이게 아니다!&lt;p&gt;와&lt;br&gt;태그를 이용할 수 있으나 여간 귀찮은 일이아니다.이때 사용하는 것이 &lt;pre&gt;태그이다 123456789101112131415161718192021&lt;pre&gt;만날 수 없어만나고 싶은데이런 슬픔처음인걸말할 수 없어말하고 싶은데속마음만 들키는 걸&lt;/pre&gt;``` 위의 내용을 출력하면 아래와 같이 편~안하게 우리가 원하는대로 나타낼 수 있다```html만날 수 없어만나고 싶은데이런 슬픔처음인걸말할 수 없어말하고 싶은데속마음만 들키는 걸 4. 특수문자(기호태그)특수문자(기호)표현을 위한 특수문자 태그들. &amp;lt;는 &lt; 를 나타내고 &amp;gt;는 &gt; 를 나타낸다.위의 태그들을 사용하면 html이 자신의 태그로 인식하지않고 특수문자로 인식해서 그대로 표현해준다 12이것은 &lt;br&gt; 태그입니다이것은 &amp;lt;br&amp;gt; 태그입니다 각 두 줄의 코드를 동일한 값이 나오길 기대하며 브라우저 출력물해보자아래와 같이 표시된다 12이것은 태그입니다이것은 &lt;br&gt;태그입니다 띠용~ 그래서 이럴때 특수문자를 사용해준다 자주 사용하는 특수문자는 result 1번부터 5번까지는 기본으로 암기해야한다 1이것은 &amp;lt;br&amp;gt; 태그입니다 // 출력물은 아래와 같다 1이것은 &lt;br&gt;태그입니다 &amp;nbsp;는 space bar를 넣는 태그이고 자주 사용 하지만 css를 사용하면 굳이 사용할 필요없기도 한 모호한 녀석이다. &amp;#9977를 하면 운동하는 사람 아이콘이 나온다. 컬러풀하고 귀여운 symbols를 확인하고 사용할 수 있다 &amp;amp;는 &amp;를 나타낸다 1운동하는 사람 &amp;amp;#9977이 &amp;amp;#9748가 와서 운동을 그만하고 &amp;amp;#9749를 마셨다 출력값은 아래 이미지처럼 짜잔! 5. &lt;b&gt;태그 와 &lt;strong&gt;태그의 차이점 b태그 : 단순히 굵게 표시 strong태그 : 굵게와 중요한 내용이라는 표시가 내포되고있고 더불어 스크린 리더를 사용하는 경우, 음성으로도 강조해서 알려주니까 b태그보단 strong태그 이용할 것. 이와 동일하게 작용하는 것이 기울임태그이다 i태그는 단순히 기울이게 표시 em태그는 기울임과 강조하는 애용이라는 표시가 내포되어있고 더불어 스크린 리더를 이용할 경우, 음성으로 강조해서 알려준다. 참고링크 6. &lt;center&gt;태그는 더이상 사용하지않으며 대신 CSS로 text-align:center를 이용한다7 .&lt;hr&gt;태그는 구분선을 그어준다","link":"/2020/05/28/200529webi/"},{"title":"[패스트캠퍼스python] Hint과 클래스 기초","text":"파이썬 인강 : Hint과 클래스 기초1. Hint데이터타입을 명시적으로 알려주는 역할을 한다 위의 사진에서와 같이 x : int의 의미는 x는 int형만 와야한다는 의미이고-&gt; list: 는 리스트형태로 출력될 것이다라는 의미이다.패키지를 통해 해당 함수를 다른 파일로 빼놓을때 유용하게 사용할 수 있다. 123456789def tot_length1(word: str, num: int) -&gt; int: return len(word) * numprint('hint exam1 : ', tot_length1(\"HeavyTalker\", 10))print(len(\"HeavyTalker\"))# 출력값은hint exam1 : 11011 2. 람다식 예제람다식의 장점은 메모리 절약, 가독성 향상, 코드 간결해진다함수와 람다의 차이점은 함수는 객체 생성 -&gt; 리소스(메모리) 할당 람다는 즉시 실행 함수(Heap 초기화) -&gt; 메모리 초기화즉 함수도 객체이기때문에 메모리에 할당되는 반면에 람다는 즉시실행함수여서 메모리를 효율적으로 사용할 수 있다.람다식을 남발하는 경우에는 가독성이 떨어지므로 실무에서는 주로 익명함수를 사용할때 람다식을 쓴다. 일반적 함수 -&gt; 변수 할당 위의 이미지는 우리가 일반적인 함수를 변수에 할당하는 방법이다var_func이란 변수에 우리가 만든 def를 대입하면 터미널에서 볼수있듯이 메모리에 할당되어있고 type은 function이다. 123456789print()def mul_10(x: int) -&gt; int: return x * 10mul_func = mul_10print(mul_func(77))# 출력값은770 람다 함수 -&gt; 할당위의 일반함수식과 비교하면 123456print()lambda_mul_func = lambda x: x * 10print(lambda_mul_func(77))# 출력값은770 동일한 결과값이 출력되는 것을 확인할수있다.좀 더 나아가 활용할 수 있는 방법이 있다함수를 매개변수로 받는 방법이다위에서 만들었던 lambda_mul_func를 이용한 함수를 만들었다. 12345678print()def func_final(x, y, func): print(x * y * func(7))func_final(10, 10, lambda_mul_func)# 출력값은7000 만들어놓은 람다함수 사용하지않고 즉시 람다식을 넣어서 인자로 함수를 넘길 수 있다None은 더이상 출력할 값이 없어서 출력되는 것임. 12345print(func_final(10,10, lambda x : x * 10))# 출력값은7000None 3. 클래스선언 먼저 클래스를 사용해야 할 이유에 대해 알아보자방대한 어플리케이션이 운영하기 위해서는 클래스방식의 코딩을 해서 구조화를 시키고 결합을 느슨하게 해서 유지보수에 용이하게 한다. 클래스선언시 첫글자는 대문자여야한다.클래스는 속성과 매서드로 구분된다. 클래스(객체), 인스턴스 차이는 매우 중요하디 네임스페이스 : 객체를 인스턴스화 할 때 저장된 공간 클래스 변수 : 직접 사용 가능, 객체보다 먼저 생성 인스턴스 변수 : 객체마다 별도로 존재, 인스턴스 생성 후 사용 아래는 클래스를 인스턴스 변수로 사용한 예이다. 12345678910111213141516171819202122232425262728293031323334class UserInfo: def __init__(self, name): #초기화 self.name = name def print_info(self): print(\"Name: \" + self.name) def __del__(self): print(\"Instance removed!\")# 인스턴스변수 생성하기user1 = UserInfo(\"Kim\") user2 = UserInfo(\"Park\") print(id(user1))print(id(user2))user1.print_info()user2.print_info()# 클래스 네임스페이스 확인print('user1 : ', user1.__dict__) print('user2 : ', user2.__dict__)print(user1.name)# 출력값은26833662374242683366443184Name: KimName: Parkuser1 : {'name': 'Kim'} user2 : {'name': 'Park'}Kim","link":"/2020/05/30/200531python/"},{"title":"ITWILL : JS기초이론, Compile VS Interprete, 변수, js라이브러리,객체타입","text":"ITWILL학원 : 2강 JS기초이론 BY 정규태강사1. 자바스크립트JAVA와 이름은 비슷하지만 어떠한 연관성도 없는 언어이다.JS 특징 객체기반의 스크립트 프로그래밍 언어. C언어 기반의 문법 사용 넷스케이프에서 개발 HTML 문서 내부에 포함되어 있는 기능 웹 브라우저를 통해서 실헹 인터프리터를 사용해서 실행 : 컴파일러가 필요없고 위에서 아래로 순차적 실행 서버의 작업처리부담을 덜어준다(클라이언트에서 처리가 되기 때문에) JS소스코드는 오픈소스로 누구나 코드를 볼 수 있다.(보안측면상 100% 오픈은 아님) 다양한 JS라이브러리를 제공한다 2. 스크립트 프로그래밍 언어란?스크립트 언어 - 어플리케이션에 명령을 전달하기 위한 것. ex) sql, awk, 자바스크립트 등 3. 인터프리터언어와 컴파일러 언어란?Compile VS Interpreter둘 다 고급언어로 작성된 원시 프로그램(Source Program)을 목적 프로그램(Object Program)으로 번역하는 번역 프로그램이며, 프로그램 번역 방식에 따라 구분된다. 컴파일 목적프로그램을 생성 번역과정과 번역시간이 복잡하고 오래 걸리지만 한번 번역 후에는 다시 번역하지 않아도되므로 실행속도 빠름 대표적 JAVA, C언어 예시: 소스코드(.java) -&gt; 자바 컴파일 -&gt; 바이트코드(.class) -&gt; JVM 의 JIT 컴파일러 -&gt; 머신코드 -&gt; 실행 인터프리터 목적프로그램을 생성하지않고 위에서 아래로 순차적으로 실행(웹 브라우저에 포함되어있음) 번역속도는 빠르지만 프로그램 실행시 매번 번역해야해서 실행속도가 느리다 대표적 php, PYTHON 예시 : 소스코드(스크립트) -&gt; 인터프리터 -&gt; 실행 참고링크1 참고링크2 4. JS라이브러리란?라이브러리란 특수한 기능을 모아놓은 것을 말한다ex) jQuery, Ajax, JSON 5. 왜 JS를 쓸까?자바는 서버에서 사용되는 언어이다. 서버에서 처리를 한 후 돌려줘야 한다.반면 JS는 서버가 아닌 클라이언트에서 처리된다. 그래서 서버의 부담이 줄어든다 그렇다면 전부 JS로 하면 안될까?? 하지만 JS에 한계가 있기 때문에 서버의 언어와 클라이언트의 언어를 같이 사용하게 된 것이다. 6. JS 사용시 주의점 항상 대/소문자 구문해서 사용한다.아래 코드는 같은 의미를 가지고 있는 것 같지만 출력값은 다르게 출력된다 12new Date();New DATE(); 실행문을 끝낼때 항상 ;을 사용한다.세미콜론이 없이 실행가능할 수 있지만 실행중에 문제가 발생할 수도 있기에 붙이는 것을 권장한다 사용자(개발자)의 편의성을 위해 한 줄에 하나의 문장을 작성한다. 큰 따옴표와 작은 따음펴 사용에 주의한다 자바의 경우, &quot;&quot;는 String만 가능, ''는 char만 가능 js의 경우, 구분없이 다 사용가능하고 항상 짝으로 사용하면 된다.12// ex)document.write('안녕하세요 |'js|'입니다') 마우스를 사용할 수 없는 환경에 대한 고려를 해야한다.(키보드 접근성 준수) 7. 변수 변수란 무엇일까?하나의 공간에 하나의 데이터만 저장하는 공간(메모리)이다 만약 하나의 공간에 다른 데이터를 추가적으로 넣게되다면?새로운 데이터가 들어올 시 기존 데이터에 덮어쓰여지게 된다. 저번시간에 꼭 기억해야하는 한 문장이 있다고 했다바로 모든 프로그램은 주기억장치에서만 실행된다! 변수의 종류는 크게 아래와 같다 문자형데이터(String) : 문자 또는 숫자를 (“”)(‘’)표현한 데이터. 만약 document.write(‘100’+200+300)이라면 출력값은 어떻게 될까? 100500이라고 답했다면 땡! 정답은 100200300이다. 숫자형(Number) : 변수에 숫자만 저장되는 데이터. 논리형(Boolean) Null : 비워진 데이터 값 변수를 사용하기 위해서는 아래와 같이 세 가지의 동작이 필요하다 변수를 선언 변수를 초기화 변수를 사용 다만 경우에 따라서는 1번 선언과 2번 초기화를 같이 진행할 수도 있다. - 변수 선언만 한 경우 : var 변수명; - 선언과 초기화 같이 하는 경우 : var 변수명 = 값; 8. 변수 선언 후 초기화를 안한다면?아래를 출력하면 언디파인드가 뜨는데 consol창에는 아무메세지도 나타나지않는다즉 에러가 아니다 123456let tmpdocument.write(tmp);//출력값은undefined 왜 이런 현상이 일어날까? 메모리가 할당된 tem안에 값이 없기때문에? 땡!tem안에 값이 있는지 없는지 모르기때문에! 이게 무슨 양자역학같은 소리냐면… 메모리는 유한하다. 8기가나 16기가 등등.컴퓨터는 여러 작업을 하면서 한정된 메모리안에서 데이터를 썼다가 지웠다가를 반복한다.재사용된 메모리위치에 아직 쓰레기값이 들어있을 수도 있다.내가 대입하지 않았더라도 어떤 쓰레기값이 들어가 있을수있기때문에 undefined가 나온 것이다.따라서 변수선언 후에는 항상 초기화를 해줘야된다. 9. 객체타입var타입은 객체타입이라고 한다. 모든 타입을 저장할 수 있다.비교하자면, java의 변수선언은 정수인 경우 int num = 1이라고 하지만 js는 데이터타입을 정의하지않고 변수를 선언할 수 있다.","link":"/2020/05/31/200601jspi/"},{"title":"[패스트캠퍼스python] 클래스의 self의 이해, 클래스, 인스턴스 변수","text":"파이썬 인강 : 클래스의 self의 이해, 클래스, 인스턴스 변수오늘은 꼭 알아야하면서도 엄청 중요한 개념이라고 할 수 있는 클래스의 self, 클래스, 인스턴스 변수에 대해 공부해보자 1. 클래스의 self의 이해self 매개변수의 유무에 따른 차이를 아래 예시를 통해 확인해보자 12345678910print()class SelfTest: #class SelfTest(): 빈괄호가 있어도되고 없어도 된다 def function1(): # self매개변수없음 = 클래스매서드 print(\"function1 called!\") def function2(self): # self매개변수있음 = 인스턴스매서드 print(id(self)) print(\"function2 called!\")self_Test = SelfTest() # 인스턴스 생성 이제 function1을 호출해보자 1234# self_Test.function1()# 출력값은TypeError: unction1() takes 0 positional arguments but 1 was given function1은 클래스매서드이기에 그냥 출력하면 타입에러가 발생한다아래와 같이 출력해야한다 1234SelfTest.function1()# 출력값은function1 called! 잘 출력되는 것을 확인할 수 있다self매개변수를 선언한 함수는 어떨까? 1234567self_Test.function2()SelfTest.function2()# 출력값은function2 called!TypeError: function2() missing 1 required positional argument: 'self'# 두번째 방법의 타입에러를 해결하려면 아래 이미지처럼 하면 된다 터미널을 확인해보면 id값이 일치하는 것을 확인할 수 있다. 2. 변수 , 인스턴스 변수클래스변수는 self가 없고 인스턴스변수는 self가 있어야한다클래스변수는 공용으로 쓸 수 있다 12345678910111213141516print()class Warehouse: # 클래스 변수 stock_num = 0 def __init__(self, name): # 인스턴스 변수 self.name = name Warehouse.stock_num += 1 def __del__(self): Warehouse.stock_num -= 1user1 = Warehouse('Kim')user2 = Warehouse('Park') 그리고 유저1과 유저2 그리고 웨어하우스의 네임스페이를 확인해보자 12345678print(user1.__dict__)print(user2.__dict__)print(Warehouse.__dict__) # 클래스 네임스페이스 , 클래스 변수를 공유한다.# 출력물{'name': 'Kim'}{'name': 'Park'}{'__module__': '__main__', 'stock_num': 2, '__init__': &lt;function Warehouse.__init__ at 0x000001ED3D0C79D0&gt;, '__del__': &lt;function Warehouse.__del__ at 0x000001ED3D0C7A60&gt;, '__dict__': &lt;attribute '__dict__' of 'Warehouse' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Warehouse' objects&gt;, '__doc__': None} 이를 통해 유저1과2에는 이름밖에 없고 웨어하우스에 stock_num이 있다는 것을 알수있다만약 유저안에서 stock_num을 찾는다면 어떻게 될까? 123456print(user1.stock_num) print(user2.stock_num)# 출력물22 만약 유저를 한명 더 추가한다면 아래와 같이 출력된다 네임스페이스안에 이름밖에 없었기때문에 stock_num을 못찾을것같지만 인스턴스는 자신의 네임스페이스에 없으면 클래스의 네임스페이스에서 찾아서 불러온다이러한 점을 이용하여 연봉인상율같은 계산등에 활용할 수 있다.","link":"/2020/05/31/200601python/"},{"title":"ORACLE DB접속순서, DB 명령어","text":"리눅스 터미널에서 DB켜는 순서아래 명령어는 꼭 순서대로 실행해줄 것.DB를 켜고 끄는 중대한 DB관리작업은 SQL Developer에서 할 수 없다. 1234567891011121314151617181920212223//리스너 실행 : 리스너를 작동시키는 명령어SQL&gt; lsnrctl start//SQL PLUS실행 : nolog의 의미는 sqlplus프로그램만 실행 -&gt; SQL단으로 들어감SQL&gt; sqlplus /nolog//DB에 sys로 접속하는 명령어SQL&gt; connect sys/oracle as sysdba//SQL PLUS실행+sys접속 한꺼번에 처리하는 명령어 SQL&gt; sqlplus \"sys/oracle as sysdba\"//DB 켜기SQL&gt; startup//유저바꾸기 : hr로 로그인SQL&gt; conn hr/hr//DB 끄기 SQL&gt; shut abort//터미널종료$&gt; exit 리스너 실행DB를 적상적으로 작동시키려면 운영체제에 존재하는 리스너를 실행 후 DB를 실행한다.순서 중요 : 리스너실행 후 DB실행 필수리스너없이 DB실행 가능하지만 작동오류가 난다.컴퓨터 부팅후에는 항상 리스너를 켜고 DB작업을 하자! SQL PLUS 실행SQL+를 설치 후 실행한 뒤 SQL언어로 DB와 소통할 수 있다운영체제별로 SQL+가 따로 있다. 윈도우용 SQL+ : 시작프로그램에서 클릭을 통해 실행 -&gt; 터미널 열림 리눅스용 SQL+ : 터미널창에서 명령어 입력으로 실행 그렇다면 명령어는? sqlplus입장 명령어 : sqlplus /nolog sqlplus퇴장 명령어 : exit (user도 함께 종료) DB에 sys로 접속후 DB 연결하기connect sys/비번 as sysdba 명령어로 접속하면 현재 DB가 꺼져있는 상태(idle)면 아래 코드처럼 show user -&gt; startup순으로 진행하면된다 1234567891011SQL&gt; connect sys/비번 as sysdbaConnected to an idle instanceSQL&gt; show userUSER is &quot;SYS&quot;SQL&gt; startupORACLE instance started(중략)Database mountedDatabase opened 만약 DB가 켜져있는 상태면 아래와 같이 나온다 12SQL&gt; connect sys/비번 as sysdbaConnected 이제 DB가 켜져있는 상태가 되었고 아래 명령어로 DB에 연결한다conn은 connect의 약자로 동일하게 사용가능한 명령어이다 12SQL&gt; conn sys/비번 as sysdbaConnected sys를 제외한 나머지 유저들은 아래와 같이 연결할 수 있다 12SQL&gt; conn 유저이름/비번Connected sys에서 다른 유저로 접속하면 이전의 유저접속은 자동적으로 끊긴다.어떤 유저로 접속한 지 궁금하면 show user명령어를 사용하면 된다 DB 전환 방법12345$] export ORACLE_SID=resp$] sqlplus /nologSQL&gt; conn sys/oracle as sysdba =&gt; resp로 접속됨(==)$] sqlplus &quot;sys/oracle as sysdba&quot; DB 끄는 명령어리스너가 켜진 후 DB를 켜야하는데 만약 리스너를 깜박하고 DB를 먼저 켠 경우 뒤늦게sys로 접속해서 DB를 끈 후 -&gt; 리스너를 켜고 -&gt; DB를 켜면 된다. 그렇다면 DB를 끄는 명령어는 무엇일까? 터미널창을 그냥 끄면 될까?터미널창끈다고 DB가 꺼지는 건 아니다DB를 끄는 명령어는 크게 두가지이다. shut abort 명령어현재 처리중인 SQL statements를 모두 abort 시키고 rollback 안하고, users들 다 끊고, close &amp; dismount도 안한다.즉, 그냥 꽝 닫는 것!다음번 오라클 시작시에 인스턴스가 자동 복구된다. 12345SQL&gt; shut abortORA-01031: insufficient privileges //이건 권한부족으로 shut은 sys유저에서 진행해야한다SQL&gt; shut abortOracle instance shut down stop 명령어아래 명령어 또한 DB와 리스너를 종료하는 명령어다 12SQL&gt; stopDisconnected from Oracle Database exit 명렁어와 shut abort, stop의 차이점이 명령어는 리스너나 DB를 끄는 명령어가 아니라 유저와 SQL+프로그램종료하는 언어다DB꺼지는거아님위의 명령어와 헷갈리지 말 것. 12SQL&gt; exitDisconnected from Oracle Database 파일 내용 보는 2가지 명령어파일안의 내용을 보고 싶을때는 아래 2가지 명령어를 활용할수있다 cat 열고싶은_파일명 : 터미널내에서 열고싶은_파일의 내용이 출력된다 vi 열고싶은_파일명 : vi편집기 실행 -&gt; vi편집기 빠져나갈때는 :q! 리눅스 터미널에서 복붙은 ctrl+c 와 ctrl+v가 작동하질 않는다.이를 대체해서 ctrl+insert와 Shift+insert를 사용하면된다. 참고링크 : 리눅스 터미널 명렁어참고링크 : 오라클 명령어 리눅스 OS userroot 관리자권한 실행, 최상위유저, 자동으로 계정이 생성됨 회사의 서버관리자가 보통 사용 OS유저 서버관리자가 데이터베이스관리자나 개발자를 위해 만들어주는 계정 보통 아래 두가지 정도의 최소한의 권한을 가짐 home/oracle 디렉토리 권한 u01/app/oracle 디렉토리 권한 계정을 나누지 않으면 개발자나 DB관리자가 서버시스템파일 수정이나 삭제 해버리면 모든 게 먹통된다. 따라서 꼭 계정을 나눠서 사용해야한다. DB userDB를 처음 생성하면 관리자의 권한을 가지고 있는 두 개의 계정이 자동으로 생성됨왜 굳이 두개 계정이 생성될까?차이점을 확실히 알아야한다. 바로 권한에 차이가 있다 sys : sysdba 권한(= dba + DB + DB시작/종료), 가장 높은 권한. system : dba 권한 일반유저 : object 관리 권한(table, view, inex 등 관리) system이 새로운 유저를 만든 경우 dba 권한까지 줄 수 있다sys가 새로운 유저를 만들었을 경우 sysdba권한까지 줄수있을까? 최대권한과 계정만료 주의사항 sys라도 유저에게 줄 수 있는 최대 권한은 dba까지이다. 계정별 비밀번호는 default 값으로 180일간 사용가능하고 만료되기전에 비밀번호 바꿔줘야한다. 바꿔주지 않을 경우 계정만료가 되어버린다. sys한테 얘기해서 임시pw설정해야한다","link":"/2020/06/01/200602dbi/"},{"title":"데이터베이스기초활용","text":"데이터베이스 용어정리 (P63) 개체 = 엔티티(Entity) = 유무형의 객체테이블이라는 개체를 사용해서 DB에 데이터를 분류해서 저장해야한다.=&gt; 데이터베이스관리자의 역할이 아닌 개발자의 역할이다즉 데이터 모델링과정을 잘해야 좋은 개발자이다. 데이터베이스관리자는 DB전체를 관리하는 사람이다 ex)백업 등 속성 = 애트리뷰트(attribute) = 컬럼 DB구조 위의 DB구성에서 추가적으로 아래 2가지가 있다. 데이터베이스 관리자(DBA) 하드웨어 물리적 구조 : 크게 중요하지 않음 논리적 구조 : 물리적구조보다 더 중요하다. 논리적 구졸르 알아야 데이터 저장구조를 알게되고 효율적으로, 그리고 성능좋게 DB를 사용할 수 있다 데이터모델링현실 세계의 정보를 데이터베이스에 표현하는 중간 과정.데이터 모델링 과정:총 3단계로 구성되고 4단계라고 한다면 설계부분이 2가지 모델링(개념과 논리)로 나눠서 표현한 것이다. 1. 요구사항 수집 및 분석 2. 설계 - 개념모델링 - 논리모델링 3. 이터베이스 구현(물리모델링) ERD (ER 다이어그램) VS IE 표기법 둘 다 실무 데이터모델링에서 잘 사용하는 방법이다. IE표기법 쇼핑몰 예제","link":"/2020/06/04/200602dbi2/"},{"title":"ITWILL : JS를 문서에 나타내는 3가지방법, undefined VS null, 백의자리 Math.floor(), 복합대입연산자로table생성, A++과 ++A차이점, &#x3D;&#x3D;과&#x3D;&#x3D;&#x3D;차이점, 논리표","text":"ITWILL학원 : 3강 JS기초 BY 정규태강사1. 문서에 js를 나타내는 3가지 방법 document.write(); console.log(); alert(); 1234567891011121314let a = 100;// 1번 방법document.write(a);// 2번 방법console.log(a);// 3번 방법alert(a)// 출력값은셋 다 동일하게 100이 출력된다.표시되는 곳이 다를 뿐. 2. undefined VS null undefined : 변수에 아무런 값도 등록되어 있지 않은 경우 var value; null : 아무것도 없음을 표현하는 값 따라서 주로 변수를 초기화할때 사용함. var value = null; 객체를 생성하고 사용할 수 있게 하기 위해 null로 초기화한다 3. 변수명 작성 변수명은 영문자로 작성 (첫번째 글자에 $, _ 사용가능) 예약어는 변수명으로 사용할 수없다 ex) False, typeof 변수명은 가능하면 의미를 가지고 생성 대소문자 구분 필수 4. 산술 연산자예제문제를 푸는데 나는 두가지 방법이 떠올라서 두가지방법으로 풀어보았다 예제문제Math.floor를 사용하여 세자리 숫자를 연산하면 100의 단위로만 나타내세요input 456output 400 1234let num3 = 778; console.log('첫번째방법은 ' + (num3 - num3%100)); console.log('두번째방법은 ' + (Math.floor(num3*0.01))*100); 5. 대입 연산자변수에 데이터(값)을 저장하는 연산자ex) A = B ; 연산의 방향이 오른쪽에서 왼쪽이다 복합대입연산자는 산술연산자에 복합연산자를 함께 사용하는 것으로 그 예에는 +=, -=, *=, /=, %=가 있다ex) A += B; &lt;=&gt; A = A + B;ex) A -= B; &lt;=&gt; A = A - B;ex) A *= B; &lt;=&gt; A = A * B; 복합대입연산자를 활용해 테이플을 편하게 만들 수 있다 1234567891011121314let name = \"곽두팔\";let age = 77;let addr = '제주'; let tableTag;tableTag = '&lt;table border=\"1\"&gt;';tableTag += '&lt;tr&gt;';tableTag += '&lt;td&gt;'+name+'&lt;/td&gt;';tableTag += '&lt;td&gt;'+age+'&lt;/td&gt;';tableTag += '&lt;td&gt;'+addr+'&lt;/td&gt;';tableTag += '&lt;/tr&gt;';tableTag += '&lt;/table&gt;'; document.write(tableTag) 물론 HTML로 만드는 것이 훨씬 편하지만…ㅋㅋㅋ 6. 증감 연산자(단항연산자)변수의 앞, 뒤에서 사용하며 값을 1증가 또는 1감소 ++A 또는 –A (전위연산) : 변수의 값을 사용할때 1증가 또는 1감소 실행 A++ 또는 A– (후위연산) : 변수의 값을 먼저 사용하고 나서 1증가 또는 1감소 실행 12345678910111213141516171819202122let A = 100; //1차 비교++A;console.log(A); // 101A++;console.log(A); // 102//2차 비교console.log('++A : ' + (++A) + ' ' + A); // 101console.log(A); //101console.log('A++ : ' + (A++) + ' ' + A); // 101console.log(A); //102//3차 비교let temp = ++A;console.log(temp) // 103console.log(A) //103temp = A++console.log(temp) // 103console.log(A) // 104 세미콜론의 위치때문에 1번과 2번의 값이 차이가 생겼다++A는 A의 값을 변화시키지 않고 콘솔을 찍었고A++은 A의 값을 1씩 더한 뒤(세미콜론찍고) 콘솔을 찍었다.즉 변수의 값을 변하시키는 건 A++후위연산이다. 7. 비교연산자데이터를 비교하는 연산자.연산의 결과는 boolean 으로 나온다.&lt;, &gt;, &lt;=, &gt;=, ==, !=, ===, !== 12345678num1 = 10;num2 = '10';console.log(num1 === num2) // falseconsole.log(num1 == num2) // trueconsole.log(num1 !== num2) // trueconsole.log(num1 != num2) // false 왜 서로 값이 다르게 나올까? == : 데이터의 값만 서용해서 비교 === : 데이터의 값 + 데이터의 타입을 모두 비교 (높은 정확도) 참고로 위의 개념은 js에만 해당됨 8. 논리연산자총 3가지의 연산자가 있다 &amp;&amp; AND 두개 넣어서 AND연산자 || 버티컬바 두개 넣어서 OR연산 ! 느낌표 넣어서 NOT연산 논리연산자진리표를 꼭 기억해야한다.","link":"/2020/06/01/200602jspi/"},{"title":"[패스트캠퍼스python] 모듈과 패키지","text":"파이썬 인강 : 모듈과 패키지우리가 알게 모르게 사용하고 있었던 모듈에 대해 배워보자 가장 중요한 점은 왜 패키지로 개발/배포/사용해야하는지 그 이유를 명확히 알아야 한다는 점이다. 모듈 : 파일 하나하나가 모듈. 독립적인 파일 패키지 : 모듈들을 파일형태로 관리하는 것을 패키지리고 한다 참고로 .. : 부모 디렉토리 이동 . : 현재 디렉토리 이동 아래 두가지 파일을 이용해서 모듈과 패키지에 대해 공부해보자fibonacci.py는 피보나치수열 만드는 파일이다. calculations.py는 아래와같은 세가지의 함수를 가지고 있다 1. 클래스를 가져와서 사용하는 방법클래스를 가져올 수 있다 일반적인 방법 1234567891011from pkg.fibonacci import Fibonacci #클래스명(fibonacci)Fibonacci.fib(10)print(\"ex1 : \", Fibonacci.fib2(20))print(\"ex1 : \", Fibonacci().title) #인스턴스화# 출력값은0 1 1 2 3 5 8 ex1 : [0, 1, 1, 2, 3, 5, 8, 13]ex1 : fibonacci 피보나치수열이 잘 출력되었음을 알수있다. *을 사용한 방법메모리를 많이 사용하기때문에 권장하지 않는 방법이지만 알아둬야한다 *는 모든 리소스를 다 가져오는 것을 뜻한다.터미널을 보면 피보나치 수열이 잘 나타남을 확인할 수 있다 as 사용하는 방법권장하는 방법으로 계속 class fullname을 사용하는 것보다 가독성이 높기때문이다.as는 Alias(엘리아스)의 약자로 별칭이란 뜻이다. 1234567891011from pkg.fibonacci import Fibonacci as fbfb.fib(50)print(\"ex3 : \", fb.fib2(60))print(\"ex3 : \", fb().title)# 출력값0 1 1 2 3 5 8 13 21 34ex3 : [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]ex3 : fibonacci 2. 함수를 가져와서 사용하는 방법 import + as 조합이번에는 클래스말고 함수를 가져와 사용해보자. 클래스를 가져왔던 것과 from + import + as 조합권장하는 방법으로 모듈의 많은 함수들 중에서 필요한 함수만 가져와서 쓸수있다어떠한 언어를 다루던 리소스를 낭비하지 않도록 명확히 코딩하는 것이 좋다 123456from pkg.calculations import div as dprint(\"ex5 : \", int(d(100,10)))# 출력값은ex5 : 10 3. builtins(빌트인)123import builtinsprint(dir(builtins)) 출력값이 너무 길어서 이미지파일로 준비했다 우리가 빌트인인지 모르고 사용했던 list함수, type함수등이 들어가 있는 것을 확인할 수 있다 4. __init__.py의 필요성용도 : 해당 디렉토리가 패키지임을 선언할 때 사용한다.Python 2.x대를 사용하고 있다면 __init__.py가 필수이다Python3.x : 파일이 없어도 패키지 인식하지만 3.x보다 하위 버전 호환 위해서 생성하는 것이 안전 5. 단위테스트독립적으로 만든 파일이 독립적으로 잘 실행되는지는 확인하기 위해서 아래 if name문을 써준다아래 형태로 쓰도록 딱 정해놓았다.만든함수()부분에 만들었던 함수들을 넣어 독립적으로 실행되는지 체크할 수 있다if문이기때문에 import으로 가져온 파일에서는 출력이 안된다 GOOD! 12345# 단위 실행(독립적으로 파일 실행)if __name__ == \"__main__\": print(\"This is\", dir()) 만든함수() 만든함수()","link":"/2020/06/02/200603python/"},{"title":"[패스트캠퍼스python] 상속, 다중상속","text":"파이썬 인강 : 상속, 다중상속 파이썬 클래스 상세 이해 : 상속, 다중상속상속은 부모한테서 물려받는 것을 뜻한다자식이 부모의 속성과 매서드를 사용할 수 있는 것이다 1. 상속 기본슈퍼클래스(Parent Class) 및 서브클래스(자식 Class) -&gt; 모든 속성, 메소드 사용 가능 12345678910111213141516171819class Car: \"\"\"Parent Class\"\"\" def __init__(self, tp, color): self.type = tp self.color = color def show(self): # print('Car Class \"Show\" Method!') return 'Car Class \"Show\" Method!'class BmwCar(Car): # 괄호안에 Parent클래스명을 넣어주면 상속이 됨 \"\"\"Sub Class\"\"\" def __init__(self, car_name, tp, color): super().__init__(tp, color) # super()가 바로 Parent class이다. 상속받아야할 tp와 color를 가져와야한다 self.car_name = car_name def show_model(self) -&gt; None: return 'Your Car Name : %s' % self.car_name 2. 상속의 일반적인 사용아래처럼 인스턴스를 먼저 생성한 후 print해보자 12345678910111213141516model1 = BmwCar('520d', 'sedan', 'red')print(model1.color) # 컬러는 sub클래스에 없고 Super클래스에 있다print(model1.type) # Superprint(model1.car_name) # Subprint(model1.show()) # Super : Super클래스의 매서드도 사용가능print(model1.show_model()) # Subprint(model1.__dict__)# 출력값은redsedan520dCar Class \"Show\" Method!Your Car Name : 520d{'type': 'sedan', 'color': 'red', 'car_name': '520d'} Method Overriding다른 sub클래스를 만들어보자이번에는 sub클래스에 show()라는 매서드를 만들어서 super클래스의 show()매서드와 중복되면 뭐가 실행될지 확인해보자 12345678910111213class BenzCar(Car): \"\"\"Sub Class\"\"\" def __init__(self, car_name, tp, color): super().__init__(tp, color) self.car_name = car_name def show(self): super().show() # super클래스의 매서드도 같이 불러온다 return 'Car Info : %s %s %s' % (self.car_name, self.color,self.type) def show_model(self) -&gt; None: return 'Your Car Name : %s' % self.car_name sub클래스를 만들었으니 인스턴트 생성 후 print해보자 123456print()model2 = BenzCar(\"220d\", 'suv', 'black')print(model2.show())# 출력값은Car Info : 220d black suv 출력값에서도 알수있듯이 super클래스의 모든 것을 사용하는 것이 아니라 sub클래스 입맛에 맞게 기능을 개선하거나 추가 등이 가능하다.이렇게 코드를 재활용이 가능하다 Parent Method Call 12345model3 = BenzCar(\"350s\", 'sedan', 'silver')print(model3.show())# 출력값은Car Info : 350s silver sedan Inheritance Info상속정보를 리스트형태로 나타내주는 매서드이다상속정보 확인할때 자주 사용한다 123456print('Inheritance Info : ', BmwCar.mro())print('Inheritance Info : ', BenzCar.mro())# 출력값은Inheritance Info : [&lt;class '__main__.BmwCar'&gt;, &lt;class '__main__.Car'&gt;, &lt;class 'object'&gt;]Inheritance Info : [&lt;class '__main__.BenzCar'&gt;, &lt;class '__main__.Car'&gt;, &lt;class 'object'&gt;] 3. 다중 상속보통 두 번 정도 상속을 한다. 깊은 상속은 오히려 가독성이 떨어진다. 123456789101112131415161718192021print()class X(): passclass Y(): passclass Z(): passclass A(X, Y): #클래스A는 클래스X,Y를 상속받겠다 passclass B(Y, Z): passclass M(B, A, Z): # 위의 모든 클래스를 상속받음 passprint(M.mro())print(A.mro()) 출력값은 아래 이미지와 같다.M의 경우 모든 클래스에 접근이 가능한 것을 볼 수 있다","link":"/2020/06/01/200602python/"},{"title":"[패스트캠퍼스python] 파일 읽기","text":"파이썬 인강 : 파일 읽기txt파일로 읽거나 쓸 줄 알아야 어플리케이션을 만들었을때 중요한 데이터(결과값)을 저장해놓을 수 있다 읽기 모드 r 쓰기 모드 w : 기존 파일 삭제 추가 모드 a : 파일 생성 또는 추가 상대 경로(‘../‘, ‘./‘) 절대 경로 확인(‘C:...’) 참고 링크 중요한 데이터.txt 파일을을 어떻게 읽을 수 있을까? 1. open()과 close() 방법파일을 열때는 open()을 사용하고 읽어올 것이기때문에 r을 쓰면 된다open()했으면 반드시 close 리소스 반환해줘야한다. 즉 close()로 꼭 문 닫아줘야한다.한 번 사용한 리소스를 꼭 닫아줘야한다. 12345f = open('./resource/중요데이터.txt', 'r')contents = f.read()print(contents)f.close() 2. with open()방법파이썬에서는 open()해놓고 close()는 하지않아도 되는 방법이 있다바로 with문! 12345with open('./resource/중요한데이터.txt', 'r') as f: c = f.read() print(iter(c)) #iterator함수로 변환하여 for문에서 사용가능 print(list(c)) #리스트형변환가능 print(c) read는 전체 내용 읽어준다 ex) read(10) : 10글자 읽기 3. with문과 for문 활용123with open('./resource/중요한데이터.txt', 'r') as f: for c in f: print(c) 출력값을 보면 한 줄씩(line단위) 출력해준다한줄씩 뛰어쓰기되어 나오는 것은 끝에 |n이 들어가있기때문이다제거해주려면 어떻게 하면 될까? 123with open('./resource/중요한데이터.txt', 'r') as f: for c in f: print(c.strip()) |n을 strip()으로 제거해주면 가독성 좋게 출력된다위의 출력이미지와 아래의 출력이미지를 보면 가독성이 좋아진 것을 알 수 있다 4. read VS readline VS readline(문자수) VS readlines read : 처음글자부터 끝까지 전체를 다 읽기. read()가 끝나고 나면 커서가 맨 마지막 글자에 있기때문에 한번 출력 후 read()를 또 출력하면 빈 내용이 출력된다 readline : 한 줄씩 읽기 readline(문자수) : 문자수 읽기 readlines : 전체 읽은 후 라인 단위 리스트 저장 응용한 예시를 함께보자아래 이미지파일과 같은 score.txt파일이 있고 안의 내용의 평균을 for line in으로 구해보자 1234567891011with open('./resource/score.txt', 'r') as f: score = [] for line in f: score.append(int(line)) print(score) print('Average : {:6.3f}'.format(sum(score) / len(score))) #{6자리고 소수셋째자리까지라는 의미}# 출력값[95, 78, 92, 89, 100, 66]Average : 86.7 5. 파일 쓰기 빌트인패키지인 random을 이용해서 파일을 써보자로또번호와 비슷하게 6개 랜덤번호를 출력하는 예제이다. 1234567from random import randint#랜덤파일로부터 randint함수를 가져와라는 뜻with open('test2.txt', 'w') as f: for cnt in range(6): # range(6)은 0~5까지임. f.write(str(randint(1, 50))) # 1부터50까지 f.write('\\n') writelines : 리스트 -&gt; 파일로 저장 123with open('test3.txt', 'w') as f: list = ['Kim\\n', 'Park\\n', 'Lee\\n'] f.writelines(list) print로 바로 저장하는 예제이다 123with open('./resource/test3.txt', 'w') as f: print('Test Contents!', file=f) print('Test Contents!!', file=f)","link":"/2020/06/03/200604python/"},{"title":"[ITWILL : JAVA]자바접근자 public과 private, 자바 데이터 형태, 모든 연산자들, A++과 ++A의 차이, (조건)? TRUE:FALSE","text":"ITWILL학원 : 2강 JAVA BY 윤미영강사 1. 자바접근자 public와 private public Class A {} private Class A {} 참고링크 : 자바접근자 public과 private차이 private Class는 다른 프로젝트에서 불러오지 못하고 심지어 같은 프로세스안에서도 불러오지 못한다.이런 private를 왜 쓰는걸까? 실생활예를 들자면, 무인경비시스템의 문을 열고 닫는 시스템이 있다고 생각해보자.다른 곳에서 해당 프로그램을 불러와서 수정할 수 있다면 에러가 발생해 무인경비 오작동이 일어날지도 모른다따라서 중요한 파일들을 다른 곳에서 수정할 수 없도록 public이 아닌 private를 쓴다. 2. 자바 데이터 형태기본데이터형과 참조데이터형은 여러 다른점이있지만 메모리에서도 차이점이 있다기본데이터형은 실제값을 가지고 참조데이터형은 실제데이터의 주소값을 가진다. 기본 데이터형 기본데이터형의 메모리는 실제값을 가진다 정수형 int(32비트), long(64비트), short(16비트), byte(8비트 : -128 ~ 127까지 표현가능) 실수형 double(64비트), flote(32비트) : 10.1, 0.0f 12345678910111213141516//소수점을 편하게 나타낼수있다.double d1 = 3.14e-2; System.out.println(d1); //0.0314//10승을 편하게 나타낼 수 있다double d2 = 3.14e2; System.out.println(d1); //314.0//float와 double을 비교해보자float f1 = 0.123456789123456f;double d3 = 0.123456789123456;System.out.println(f1); //0.12345679System.out.println(d3; //0.123456789123456 문자형 char(16비트) : ‘’ char는 문자인데 컴퓨터가 아는건 이진법밖에 없는데 어떻게 이진법으로 나타낼까? 바로 유니코드의 문자를 변환해서 나타낸다. 원래는 아스키문자표 ex)a는 97, A는 65 아스키문자표는 영문만 해당되기때문에 영문이 아닌 다른 전세계 언어는 유니코드로 사용한다 참고링크1 : 아스키코드와 유니코드의 차이 참고링크2 : 한글유니코드1 참고링크3 : 한글유니코드2 1234567// char로 작은따옴표 하나를 나타내고싶다 -&gt; 역슬러시이용char c1 = ''' // 에러 Invalid character constantchar c2 = '\\'' // 'char c3 = '\\\\ // \\ 논리형 boolean형태(각각 8비트) true, false 참조 데이터형 = Class형 = 클래스형기본데이터형이 아닌 나머지 데이터형태를 다 참조데이터형, 또 다른 말로는 클래스형이라고 한다.참도데이터형의 메모리는 실제 데이터의 주소값을 가진다. 예시 문자열 String : “” Scanner 3. 데이터형변환형변환은 크게 두가지로 나눌 수 있다 자동형변환(암시적형변환) 따로 설정하지않아도 컴파일러가 자동으로 형을 변환해준다. 할당된 byte가 작은 데이터타입에서 큰 데이터타입으로 변경된다. 반대는 안될것같지만 되는 것들이 있음. ex) char형 -&gt; int형 (유니코드사용 자동형변환), double형 -&gt; int형(값이 손실되더라도 자동형변환) 명시적형변환 Casting 캐스트연산자를 이용해서 변환 ex) (double)int -&gt; double , (String)int -&gt; String 1234567int count = 128;byte b = (byte)count; System.out.println(b); // -128 count = 130;b = (byte)count; System.out.println(b); // -126 형변환을 했는데 128이 아닌 -128이 나오고 130이 아닌 -126이 출력되었다왜그럴까?명시적형변환의 경우 오류가 발생할 수 있기때문이다 4. 산술연산자 덧셈 뺄셈 나눗셈 곱셈 이 중에서 나눗셈에 주의해야한다. 왜냐하면 예외발생 또는 형변환에 걸릴 수 있기때문에 123456789101112// 1. 예외발생 ( arithmetic exception )System.out.println(3/0);//출력값 : Exception in thread \"main\" java.lang.ArithmeticException: / by zero// 2. 형변환문제int a = 100;int b = 200;int result = a/b System.out.println(result) //출력값 : 0System.out.println((double)result) //출력값 : 0.0 답은 0.5가 나와야하는데 int라는 정수형데이터때문에 0만 출력된다형변환을 한다고해도 이미 result가 0이기때문에 0을 double하니까 0.0이 된다 해결방법은 변수선언을 double로 해주면 끝! 1234567double result = a/(double)bSystem.out.println(result) //출력값 : 0.5double result = (double)a/bSystem.out.println(result) //출력값 : 0.5 5. 대입연산자 = += =+ *= /= 예를들어a+=b 의 의미는 a = a+ba/=b 의 의미는 a = a/b 6. 논리연산자 &amp; : and연산자 | : or연산자 ! : not연산자. 반대의 개념 ex)!false =&gt; true ex)!true =&gt; false ^ : nor연산자. 비트연산자 두개의 값이 같으면 false고 다르면 true. 주로 전자제품할때 사용하고 응용sw에서는 사용할일이 적다 ex) true ^ false =&gt; true ex) true ^ true =&gt; false 7. 증감연산자변수의 앞, 뒤에서 사용하며 값을 1증가 또는 1감소 ++A 또는 –A (전위연산) : 변수의 값을 사용할때 1증가 또는 1감소 실행 A++ 또는 A– (후위연산) : 변수의 값을 먼저 사용하고 나서 1증가 또는 1감소 실행 세미콜론의 위치때문에 1번과 2번의 값이 차이가 생겼다++A는 A의 값을 변화시키지 않고 콘솔을 찍었고A++은 A의 값을 1씩 더한 뒤(세미콜론찍고) 콘솔을 찍었다.즉 변수의 값을 변하시키는 건 A++후위연산이다. 8. 삼항연산자실무에선 잘 사용하지 않지만 정말 간단한 조건식이 필요할때 사용한다. 1조건? 값1:값2 풀어서 설명하자면 조건이 true이면 값1이 출력되고 false면 값2가 출력된다 123456789101112int a = 1int b = 2;int c = 4;//첫번째방법int max = a&gt;b? a:b;max = max&gt;c? max:c;System.out.println(max); //4//두번째방법double max2 = (a&gt;b&amp;a&gt;c)? a:(b&gt;c)? b:c ;System.out.println(max2) //4.0 두번째방법을 쓸 수는 있으나 가독성이 떨어지므로 첫번째방법을 쓰는 것을 추천한다","link":"/2020/06/02/200603javai/"},{"title":"[패스트캠퍼스python] 예외처리","text":"파이썬 인강 : 예외처리완벽한 코딩은 없다. 여러 사람이 함께 작업한다한들 예외는 언제든지 나타날수있다만약 미세한 코딩으로인해 수백명이 결제하는 회사 시스템에 예외가 발생해버린다면 그 손해는 막심할 것이다. 1. 예외 종류 SyntaxError TypeError NameError IndexError ValueError KeyError.. 등등 요즘은 문법적으로 에러는 없지만 코드 실행(런타임) 프로세스에서 발생하는 예외 처리가 중요하다에디터에서 linter가 문법적인 에러를 잡아주기때문에 걱정없지만 런타임에서 발생하는 에러에 주의해야한다 항상 예외가 발생하지 않을 것으로 가정하고 먼저 코딩그 후 런타임 예외 발생 시 예외처리 권장(EAFP 코딩 스타일) 1. SyntaxError : 잘못된 문법문법적인 에러는 보통 linter가 잡아준다 12345print('test) # ' 누락if True # : 누락 passx =&gt; y # 작거나 같다는 &gt;=로 해야함 2. NameError : 참조 변수 없음123a = 10b = 15print(c) # 예외 발생 3. ZeroDivisionError : 0 나누기 에러모든 언어에 있는 에러이고 런타임에서 발생하는 에러이기에 중요하다 1print(10 / 0) 4. IndexError : 인덱스 범위 오버자주 발생하는 에러 123456789x = [10, 20, 30]print(x[1])print(x[3]) # 예외 발생print(x.pop())print(x.pop())print(x.pop())print(x.pop()) # 예외 발생print(x.pop(50)) # 예외 발생 5. KeyError주로 딕셔너리에서 나오는 에러이다 123dic = {'name': 'Kim', 'Age': 33, 'City': 'Seoul'}print(dic['hobby']) # 키가 존재하지 않으면 예외 이런 에러를 방지하기 위해 get매서드를 사용하면 좋다 1print(dic.get('hobby')) # 안전 6. AttributeError : 모듈, 클래스에 있는 잘못된 속성 사용시에 예외1234x = [1, 2, 3]print(x.append(4))print(x)print(x.add(10)) 출력값은 list는 add가 없기에 AttributeError발생한다 7. ValueError : 참조 값이 없을 때 예외1234t = (10, 100, 1000)print(t.index(100))print(t.index(7)) # 예외 발생 8. FileNotFoundError외부파일을 불러와서 처리할때 자주 발생 터미널에 보면 디렉토리 내에 찾을 수 없다고 나온다 9. TypeError : 자료형에 맞지 않는 연산을 수행 할 경우123456x = [1, 2]y = (1, 2)z = 'test'print(x + y) # 예외 발생(튜플과 리스트를 결합할수없다 -&gt; 그래서 형변환이 중요)print(sum([1,2,3],10,1)) # 예외 발생(자료형불일치) 2. 예외 처리 기본아래 예외 처리는 기본중의 기본이므로 꼭 알아둬야한다. 123456try 에러가 발생 할 가능성이 있는 코드 실행 except 에러명1: 에러가 발생하면 여기서 처리(여러 개 가능) except 에러명2: except 에러명3: else: try 블록의 에러가 없을 경우 실행 finally: 항상 실행 이를 활용한 예시 12345678try: z = 'Kim' # 'Cho' 예외 발생 x = name.index(z) print('{} Found it! {} in name'.format(z, x + 1))except: # 모든 에러를 처리(Exception) print('Not found it! - Occurred ValueError!')else: print('ok! else!')","link":"/2020/06/04/200605python/"},{"title":"ITWILL : 아이디와 비번입력, 새로고침location.reload(), 주석한번에 단축키, switch문 출력문 한줄리팩토링","text":"ITWILL학원 : 5강 JS기초 BY 정규태강사1.아이디와 비번체크location.reload()는 새로고침의 역할을 한다 아이디와 비번을 존재유무 동시에 체크 12345678910111213141516const id = \"itwill001\"const pw = \"it8030909\"let inputId = prompt(\"아이디를 입력하세요\", \"\")let inputPw = prompt(\"비밀번호를 입력하세요\", \"\")if(id === inputId){ if(pw === inputPw){ alert(inputId+\"님 환영합니다\") }else{ alert(\"비밀번호가 일치하지 않습니다\") location.reload(); }}else{ alert(\"존재하지 않는 회원입니다.\") location.reload();} 아이디 존재유무 먼저 체크후 비번 체크 12345678910111213141516const id = \"itwill001\"const pw = \"it8030909\"let inputId = prompt(\"아이디를 입력하세요\", \"\")if(id === inputId){ if(pw === inputPw){ alert(inputId+\"님 환영합니다\") let inputPw = prompt(\"비밀번호를 입력하세요\", \"\") }else{ alert(\"비밀번호가 일치하지 않습니다\") location.reload(); }}else{ alert(\"존재하지 않는 회원입니다.\") location.reload();} DB를 쓰면 알게되겠지만 2번방법은 아이디한번 비번한번 두번을 가져와야해서 비효율적이다1번을 사용하는 것을 권장한다 html내에서 id로 가져와서 로그인페이지 완성내가 궁금해져서 네이버처럼 로그인페이지를 만들어봤다 1234567891011121314151617181920212223242526272829&lt;img src=\"https://lh3.googleusercontent.com/proxy/kn4y-1fat85W8voylUnkZF1DBTCAwtNwaTwxKJZ-GYiWk83N6rAd2fKqIzdaPSSZKupHKxA-xyZttfXhyO6EQHKxEQ2NTEeByNqAEZaCdJScbyZcUB3nak6TlxWlKv_lRgwfZtY8gWCwjusDnUmRThBUCTYf7ElOwOvnnj772zC02yDGOB5uI-B4rkSeKZjcw0i6FpG3xsATsSvDIw4A28QN\" width=100%, height=100%&gt;&lt;input id=\"id\" type=\"text\" size=\"40px\" placeholder=\"아이디를 입력하세요\"&gt;&lt;p&gt;&lt;input id=\"pw\"type=\"text\" size=\"40px\" placeholder=\"비밀번호를 입력하세요\"&gt;&lt;p&gt;&lt;button id=\"login\"&gt; 로그인 &lt;/button&gt;&lt;p&gt;&lt;input type=\"checkbox\" checked&gt;항상 아이디 기억하기&lt;script type=\"text/javascript\"&gt;let id = document.querySelector('#id');let id = document.querySelector('#id');let loginbtn = document.querySelector('login')loginbtn.addEventListener('click', ()=&gt;{ console.log(id, pw) if( id === \"it\"){ if(pw === \"321\"){ alert(id1 + \"님, 반갑습니다\") }else{ alert(\"비밀번호가 일치하지 않습니다\") location.reload(); } }else{ alert(\"존재하지 않는 회원입니다.\") location.reload(); } }) querySelector로 input태그 ID와 PW를 가져오려고 했으나 “존재하지 않는 회원입니다”라는 에러만 겁나 났다 querySelector가 안되는 이유는 Jquery태그를 추가해야한다고했다 그래서 다른 방법인 getElementById()로 진행해봤다. getElementById(‘id’)만 가지고 왔는데도 전혀 입력값을 가져오지못했고 “존재하지 않는 회원입니다”라는 에러 getElementById(‘id’).value : 그래서 value를 끝에 추가했지만 그래도 가져오지 못했다왜지…. 알고보니 결국 스코프 문제였다 addEventListener안에 넣었더니 정상적으로 실행되었다 뿌듯! 12345678910111213141516171819202122232425262728&lt;img src=\"https://lh3.googleusercontent.com/proxy/kn4y-1fat85W8voylUnkZF1DBTCAwtNwaTwxKJZ-GYiWk83N6rAd2fKqIzdaPSSZKupHKxA-xyZttfXhyO6EQHKxEQ2NTEeByNqAEZaCdJScbyZcUB3nak6TlxWlKv_lRgwfZtY8gWCwjusDnUmRThBUCTYf7ElOwOvnnj772zC02yDGOB5uI-B4rkSeKZjcw0i6FpG3xsATsSvDIw4A28QN\" width=100%, height=100%&gt;&lt;input id=\"id\" type=\"text\" size=\"40px\" placeholder=\"아이디를 입력하세요\"&gt;&lt;p&gt;&lt;input id=\"pw\"type=\"text\" size=\"40px\" placeholder=\"비밀번호를 입력하세요\"&gt;&lt;p&gt;&lt;button id=\"login\"&gt; 로그인 &lt;/button&gt;&lt;p&gt;&lt;input type=\"checkbox\" checked&gt;항상 아이디 기억하기&lt;script type=\"text/javascript\"&gt;let loginbtn = document.getElementById('login')loginbtn.addEventListener('click', ()=&gt;{ let id = document.getElementById('id').value; let pw = document.getElementById('pw').value; console.log(id, pw) if( id === \"it\"){ if(pw === \"321\"){ alert(id1 + \"님, 반갑습니다\") }else{ alert(\"비밀번호가 일치하지 않습니다\") location.reload(); } }else{ alert(\"존재하지 않는 회원입니다.\") location.reload(); } }) 2. JS주석 한번에 단축키 ctrl + shift + / : 한번에 주석설정 ctrl + shift +\\ : 한번에 주석제거 3. switch문 출력문 한줄 리팩토링입력받은 정보를 가지고 학점을 나타내는 switch문을 만들어보자 1234567891011121314151617181920212223242526let score = prompt('점수를 입력하시면 학점이 계산됩니다')switch (Math.floor(score/10)){case 10 :case 9 : document.write(\"A학점\") break;case 8 : document.write(\"B학점\") break;case 7 : document.write(\"C학점\") break;case 6 : document.write(\"D학점\") break;case 5:case 4:case 3:case 2:case 1:case 0: document.write(\"F학점이라니\") break;default : document.write(\"0~100사이의 점수를 입력하세요\")} 자세히보면 반복되는 출력문이 보인다이걸 리팩토링해보자아주 간단하다! 변수만 만들어주면 된다! 123456789101112131415161718192021222324252627282930//switch case 출력문 한번쓰기document.write('&lt;hr&gt;')let score = prompt('점수를 입력하시면 학점이 계산됩니다')let grade = \"\"; //변수만들기switch (Math.floor(score/10)){case 10 :case 9 : grade =\"A\" break;case 8 : grade =\"B\" break;case 7 : grade =\"C\" break;case 6 : grade =\"D\" break;case 5:case 4:case 3:case 2:case 1:case 0: grade =\"F\" break;default : document.write(\"0~100사이의 점수를 입력하세요\")}document.write(grade + \"학점\")","link":"/2020/06/03/200604jspi/"},{"title":"ITWILL : JAVA SE&#x2F;EE&#x2F;ME 차이점, JAVA EE 설정. Tomcat 설치및설정","text":"ITWILL학원 : 4강 JS기초 BY 정규태강사 1. 삼항 조건 연산자기존 if문보다 데이터처리속도가 빠르다 1조건식? 실행문1(참):실행문2(거짓) 2. JAVA 종류 3가지자바 종류 3가지이다 SE 자바 스탠다드 에디션 : 순수 자바만 쓸수있는 목적 EE 엔터프라이즈 에디션 : 자바에 + 서블릿, JSP추가한 것 ME 마이크로 에디션 : 자바를 줄여놓은 형태 주로 스마트폰 OS에서 사용 jsp를 하기 위해서는 EE를 다운받아야한다. 3. JAVA EE 설정 이클립스 패키지 네온3 EE 다운로드 링크 위의 사이트에 접속하여서 아래 그림처럼 버전 확인 후 컴퓨터 비트에 맞게 다운로드하면된다 보통 컴퓨터는 64비트이므로 64비트로 다운로드하면 된다 다운로드 완료하였으면 이클립스를 연 뒤 아래의 이미지처럼 JAVA EE설정해준다. 한글 UTF-8 설정DefauLt(MS949)기본적으로 더 많은 한글을 지원해주기위해 utf-8로 지정해야한다window &gt; preferences 에서 아래 3곳을 찾아서 UTF-8로 설정을 해준다 General &gt; workspace web &gt; css web &gt; html JAVA 컴파일러 버전 확인현재까지 자바 1.13버전이 나왔지만 실무에선 1.8버전이하를 사용한다.무조건 최신버전을 사용하지 않을까 싶지만은 최신버전보다는 안저자바 1.6버전이후부터 다양한 기능들과 함께 안정화되어 있어서 1.6이나 1.8버전을 주로 사용한다.물론 최신버전이 다양한 기능들이 더 많다.예로 기가지니의 자바버전은 1.3버전이 깔려있다 위처럼 1.8버전으로 셋팅이 잘되어있는 지 체크할 것! 4. New project 생성먼저 아래 사진처럼New &gt; New project &gt; Dynamic Web Project 선택 후 next 두번 잠시 멈춰서 아래 사진처럼 Generate web.xml 체크 후에 finish finish후에 아래처럼 여러 파일들이 자동 생성되는데아래 사진처럼 Web conContent안에 파일을 생성하고 테스팅을 해보자 이제 테스트코드를 입력한 뒤 run(단축키 : ctrl+F11)을 해보자 현재 서버가 없어서 작동하지 않는다띠용! 서버이용을 위해 tomcat을 먼저 다운받아야한다tomcat을 다운받으면 현재 컴퓨터를 서버로 사용한다는 의미이다 5. Tomcat 설치 톰캣 여러버전 중 8버전을 쓰는 이유는 학원강사마음…?!?!? 아래의 사진처럼 접속한 뒤 32-bit/64-bit Windows Service installer를 설치한다 설치 완료 후 실행해주면 아래 이미지대로 설정한다 서버셧다운포트 : -1을 그대로 실행하면 에러발생 -&gt; 8003을 입력 HTTP/1.1커넥터포트 : 8080을 지우고 -&gt; 8088로 입력 포트란 입구와 출구가 하나로 된 곳으라고 생각하면 된다. 단어 그대로 항구다.8088포트로 정보요청하면 8088로 정보를 받아야 함 만약 HTTP커넥터포트를 8080으로 진행하면 오라클의 포트와 충돌하여 에러발생할 수 있다.5000이전의 포트에는 프로그램마다 고유한 포트번호가 있었으나 5000이후의 포트는 없어지고 있다하지만 오라클은 8080 포트를 사용한다 톰캣 다큐먼트 드디어 톰캣 다운로드 마지막페이지이다 둘 다 체크해제를 해주고 finish를 눌러준다 톰캣이 잘 설치되었는지 확인하기 위해 아래 사진의 주소에 접속한다 Tomcat8w 실행파일을 누르면 서비스 스테이터스를 stopped가 정상이다start를 누르면 서버가 실행할 수 있다. 보통 컴퓨터는 서버를 1개만 사용할수있다.우리는 톰캣을 이클립스와 연결해서 사용할 예정이다따라서 start해놨던 톰캣을 stop하고 이클립스에서 다시 톰캣을 서버를 연결하면된다. run on server를 설정한다 browse를 눌리고 Tomcat설치한 C드라이브로 가서 연결해주고 확인 눌러준다그리고 미리 다운로드했던 jdk를 아래 사진처럼 연결해준뒤 finish를 클릭한다 만약 jdk를 한가지버전만 다운로드했다면 defalut값을 써도 상관없지만 여러버전을 다운로드했다면 원하는 버전을 선택해 연결해주면 된다 위의 사진처럼 엑세스 허용이 2번뜨는데 둘다 허용누르면 된다 이클립스 내부브라우저에서 테스트 결과값이 출력된다내부브라우저는 한계가 있으므로 크롬과 이클립스를 연결해야한다아래 사진처럼 선택 후 그리고 아래 사진처럼 chrome을 체크해주면 끝! 앞으로 ctrl+F11 누르면 크롬 새창으로 연결되어 출력된다 서버에서 사용하는 localhost는 자신의 IP주소이다localhost 대신 자신의 고유IP주소 또는 로컬호스트(127.0.0.1)를 써도 동일하게 출력된다\\ 내 IP주소는 cmd에서 ipconfig 명령어를 통해 IP주소를 쉽게 확인할 수 있다 6. 제어문프로그램의 흐름을 제어하는 실행문 조건문 : if~else 선택문 : switch~case 반복문 : for, while","link":"/2020/06/02/200603jspi/"},{"title":"[패스트캠퍼스python] 데이터베이스 연동(SQLite)","text":"파이썬 인강 : 데이터베이스 연동(SQLite)1. 커서의 위치데이터베이스는 커서의 위치가 중요하다데이터를 불러오고 난 다음에 커서는 해당 데이터 뒤에 위치하기때문이다 12345678# 1개 로우 선택print('One -&gt; \\n', c.fetchone())# 지정 로우 선택 : size위의 숫자로 로우 갯수를 선택print('Three -&gt; \\n', c.fetchmany(size=3))# 전체 로우 선택print('All -&gt; \\n', c.fetchall()) 위의 명령어를 활용한 예시는 아래 이미지와 같다 터미널에서 볼 수 있듯이 1개 로우 명령어 뒤라서 커서는 1번 로우를 지난 2번로우 앞에 있다그리고 size=3인 로우를 출력하니 2,3,4번 로우가 터미널에 출력되었음을 알 수 있다 위의 상태에서 전체 로우 print(‘All -&gt; \\n’, c.fetchall()) 명령어를 입력하면 어떻게 될까?커서는 지금 4번로우 뒤에 위치해있기때문에 마지막 로우인 5번 데이터만 출력된다 만약 위의 상태에서 print(‘All -&gt; \\n’, c.fetchall())를 한번 더 호출하면 어떻게 될까?커서의 위치는 마지막 로우인 5번 뒤에 있다. 따라서 호출해도 [] 빈리스트만 터미널에 출력된다. 그렇다면 처음 1번 로우를 호출하고 싶을때는 어떻게 할 수 있을까?바로 순회하면 된다 2. 순회순회에는 3가지방법이 있다. 순회 : 변수선언 후 for in 반복문 사용데이터조회 명령어 c.execute(‘SELECT * FROM users’) 뒤에 실행해야 출력된다 123rows = c.fetchall()for row in rows: print('retrieve1 &gt;', row) # 조회 없음 순회 : 변수선언 없이 for in 반복문 바로 사용데이터조회 명령어 c.execute(‘SELECT * FROM users’) 뒤에 실행해야 출력된다간편하기때문에 제일많이 사용된다 12for row in c.fetchall(): print('retrieve2 &gt;', row) # 조회 없음 순회execute(“SELECT * FROM users)는 users에 있는 전체 데이터를 조회하는 명령어이다 따라서 fetchall() 명령어와 동일한 결과값을 가진다.데이터조회 명령어 c.execute(‘SELECT * FROM users’) 까지 포함된 명령어로 데이터조회명령어가 따로 필요없다코드가 길어져서 가독성이 떨어지는 지는 단점이 있다.“ORDER BY id desc” 명령어를 넣어주면 역순출력이 된다 12for row in c.execute(\"SELECT * FROM users ORDER BY id desc\"): print('retrieve3 &gt; ', row) 순회1번과 순회2번은 함께 쓰일수없기때문에순회2번과 순회3번의 출력값을 아래 이미지와 같다 3. WHERE Retrieve6가지 방법이 있고 핵심이므로 꼭 다 알고 있어야한다. WHERE Retrieve1튜플형태로 3번로우인 Lee를 출력fetchone()에서 3번 로우 하나만 불러왔기때문에 그 다음 명령어로 fetchall()로 전체를 불러와도 [] 빈 리스트만 출력된다 1234param1 = (3,) c.execute('SELECT * FROM users WHERE id=?', param1)print('param1', c.fetchone())print('param1', c.fetchall()) WHERE Retrieve2튜플형태로 1번로우인 Kim을 출력%s :문자열형, %d:정수형, %f: 실수형fetchone()에서 1번 로우 하나만 불러왔기때문에 그 다음 명령어로 fetchall()로 전체를 불러와도 [] 빈 리스트만 출력된다 1234param2 = 1c.execute(\"SELECT * FROM users WHERE id='%s'\" % param2) print('param2', c.fetchone())print('param2', c.fetchall()) WHERE Retrieve3이번엔 딕셔너리형태로 1번 로우출력id= 뒤에 :Id를 넣어준뒤 컴마찍고 딕셔너리형태로 {“Id”: 1} 첫번째로우를 호출하면 된다 123c.execute(\"SELECT * FROM users WHERE id= :Id\", {\"Id\": 1})print('param3', c.fetchone())print('param3', c.fetchall()) WHERE Retrieve4리스트형태로 파라미터 2개를 받아서 1번로우와 4번로우 출력파라미터 여러가지를 가져오려면 IN(?,?)로 넣으면 된다이젠 한개가 아니니까 fetchone()은 쓸 수 없고 fetchall()로 출력하면 된다 123param4 = (1, 4)c.execute('SELECT * FROM users WHERE id IN(?,?)', param4)print('param4', c.fetchall()) WHERE Retrieve5위와 똑같은 결과값이지만 다르게 표현할 수 있다 물음표대신 정수값($d)을 넣어주면 된다간단하기때문에 많이 사용한다 12c.execute(\"SELECT * FROM users WHERE id In('%d','%d')\" % (1, 4))print('param5', c.fetchall()) WHERE Retrieve6딕셔너리형태로 1번과 4번로우 출력OR 사용 12c.execute(\"SELECT * FROM users WHERE id= :id1 OR id= :id2\", {\"id1\": 1, \"id2\": 4})print('param6', c.fetchall()) 지금까지 id를 이용했지만 username, date등을 이용해서도 출력할수있다 4. Dump 출력데이터베이스 백업 시 중요하다아래 명령어를 실행하면 새로운 dump.sql이라는 파일이 형성되고 그 안에 작성한 데이터테이블이 백업된다.이를 활용하여 sql에 붙여넣으면 다른 컴퓨터나 환경에서도 데이터사용가능하다실무에서 흔히 ‘덤프떠와’ 라고 말한다. with문을 사용하면 자동으로 close()를 해줘서 편리하다 with open() as f: 를 실행했으므로 f.close()가 자동으로 되었고 with conn: 을 실행했으므로 conn.close()가 자동으로 되었다 12345with conn: with open('본인이 원하는 경로/dump.sql', 'w') as f: for line in conn.iterdump(): f.write('%s\\n' % line) print('Dump Print Complete.') 위의 코드를 실행시키면 출력값은 아래 이미지와 같다.","link":"/2020/06/06/200607python/"},{"title":"DDL vs DML vs DCL","text":"SQL 명령어관계형 데이터베이스 작동을 위해 사용하는 표준언어이고 모든 프로그램 및 유저가 데이터베이스의 데이터를 엑세스학 위해 사용하는 일련의 명령문이다. SQL 대표적인 명령어 sql 쿼리구문에서는 대소문자구분이 없다 DQL 데이터질의어 select DML(Data Mainpulation Language) 데이터조작어 insert, update, delete commit, rollback으로 트랜잭션을 마무리해야함 DDL(Data Definition Language) 데이터정의어 create, alter, drop, truncate autocommit됨 DCL(Data Control Language) 데이터제어어 -grant, revoke -autocommit됨 명령어입력시 오타난 경우 수정하는 순서마지막 쿼리작업은 버퍼에 남아있다이를 이용해 마지막 쿼리작업의 수정이 가능하다. 마지막이 아닌 쿼리는 수정작업 불가 ed(edit의 약자) i 클릭 -&gt; insert모드로 바뀌면서 오타등의 수정이 가능하다 (마우스안됨. 키보드만 가능) 버퍼안에서는 절대 ; (세미콜론) 입력하면 안됨 -&gt; 버터에 세미콜론찍고 나가면 오류 계속 발생함. esc -&gt; 편집모드 insert모드를 빠져나와서 읽기모드로 가면됨 :(콜론) + w + q : 을 찍고 나오면 버퍼에서 빠져나오게 됨 / + enter : 딱 나오게 된다 dept라는 테이블을 만드는 오타수정 예시 create table dept : 그 뒤의 2~5번째줄은 테이블에 들어갈 데이터들이다 describe dept : 만든 테이블을 확인할 수 있는 명령어 ed : 가장 마지막 쿼리작업만 수정가능 버터 안 : 초기값은 읽기모드이므로 i 입력(쓰기모드) -&gt; 테이블 이름을 dept -&gt; dept5252로 변경 버퍼 안 : esc : 쓰기모드에서 읽기모드로 전환 :(콜론) + w + q : 버퍼종료 / + enter : 다시 sql 터미널로 돌아오게된다.","link":"/2020/06/04/200605dbi/"},{"title":"[패스트캠퍼스python] 외부파일 CSV, 엑셀 읽기 및 쓰기","text":"파이썬 인강 : 외부파일 CSV, 엑셀 읽기 및 쓰기1. CSV 읽기, 쓰기 위의 예제를 차근차근 보자with open(작성한 파일을 저장할장소/저장할 파일명, ‘w’(작성한다는는 의미), newline=’’) as f: newline=’’이 의미는 이 부분이 없으면 한 줄씩 띄어쓰기로 for문을 순회하면서 데이터가 자동저장된다하지만 데이터 양이 많을수록 용량도 커지고 쓸데없이 불편할 수 있다.12345678910111,2,34,5,67,8,9,10,11,1213,14,1516,17,18 그래서 ‘’빈칸을 넣어서 띄어쓰기를 없애는 것이다newline=’’을 적용하면 아래와 같이 결과값이 출력된다 writerow()와 writerows()의 차이점 writerow()는 한줄씩 띄어쓰기하여 입력된다 -&gt; for문을 썼기에 순회하면서 전체 내용이 출력되었다. writerows() 한줄씩이 아닌 전체데이터가 입력된다.(for문 반복없이 한번에 입력) 한줄씩 순회하면서 입력 방법(writerow)와 한꺼번에 전체데이터를 입력하는 방법(writerows)은 각각의 장점이 있다예시로 회원가입목록에서 1950년생이하는 빼고 데이터를 출력하고싶을때 if조건문으로 필터링을 걸어줘서 writerow이 유용하게 쓰인다 2. 엑셀 쓰기 읽기엑셀을 처리하는 오픈소스 : openpyxl, xlsxwriter, xlrd, xlwt, xlutils여러가지 방법이 있지만 pandas를 가장 많이 사용한다그 이유는 pandas는 최다사용오픈소스인 openpyxl, 랭킹 1위인 xlrd를 내부적으로 만능으로 사용할 수 있기때문이다 pandas를 이용하기 위해서는 아래 3가지를 다운로드해줘야한다 1. pip install xlrd 2. pip install openpyxl 3. pip install pandas 파이썬 인강 : 데이터베이스 연동(SQLite)SQLite는 기본적으로 설치가 되어있다. 따라서 따로 설치할 필요없이 바로 import하면 된다 1. 테이블 생성 및 삽입import datetimeimport sqlite3 2. 삽입 날짜 생성많이 쓰니까 꼭 알기 12now = datetime.datetime.now()print('now', now) 보기 불편하니까 포맷을 만들면 익숙한 시간형식으로 나타낼수있다 12nowDatetime = now.strftime('%Y-%m-%d %H:%M:%S')print('nowDatetime', nowDatetime) 3. DB생성 &amp; Autocommit 그리고 커밋본인 DB 파일 경로로 설정해주면된다isolation_level=None 을 넣었을 경우 자동으로 커밋 반영(Auto Commit)해준다.설정하지 않았다면 수정 후 conn.commit() 명령어를 입력해야지만 반영된다 1conn = sqlite3.connect('본인DB파일경로/database.db', isolation_level=None) 4. Cursor연결12c = conn.cursor()print('Cursor Type : ', type(c)) 5. 테이블 생성데이블에서 쓰일 수 있는 Datatype에는 총 5가지가 있다 TEXT NUMERIC INTEGER REAL BLOB 123c.execute( \"CREATE TABLE IF NOT EXISTS users(id INTEGER PRIMARY KEY, username text, email text, phone text, website text, regdate text)\") #AUTOINCREMENT 6. 데이터 삽입삽입에는 크게 두가지 방식이 있다 첫번째방법? 를 넣는 이유는 위에서 만들었던 데이터(“nowDatetime,”)를 넣게되면 스트링형식으로 들어가기때문에 ?를 주고 뒤에 매개변수로 튜플형태로 입력한다 1c.execute(\"INSERT INTO users VALUES (1 ,'Kim','Kim@naver.com', '010-0000-0000', 'Kim.com', ?)\", (nowDatetime,)) 두번째 방법?의 갯수와 삽입할데이터의 갯수를 순서대로 일치시켜줘주면된다 1c.execute(\"INSERT INTO users(id, username, email, phone, website, regdate) VALUES (?, ?, ?, ?, ?, ?)\", (2, 'Park', 'Park@naver.com', '010-1111-1111', 'Park.com', nowDatetime)) 7. Many 삽입(튜플, 리스트형태를 삽입가능)가장 중요한 부분이다!Many는 이름 그대로 대용량 데이터를 삽입하는 방법으로 튜플이나 리스트형태를 삽입가능하다 1234567userList = ( (3, 'Lee', 'Lee@naver.com', '010-2222-2222', 'Lee.com', nowDatetime), (4, 'Cho', 'Cho@naver.com', '010-3333-3333', 'Cho.com', nowDatetime), (5, 'Yoo', 'Yoo@naver.com', '010-4444-4444', 'Yoo.com', nowDatetime))c.executemany(\"INSERT INTO users(id, username, email, phone, website, regdate) VALUES (?, ?, ?, ?, ?, ?)\", userList) 웹상에서 입력받은 데이터를 sqlite를 통해서 장고의 경우, orm을 통해서 대용량데이터를 입력할 수 있다 8.테이블 데이터 삭제지우는 명령어는 conn.execute(“delete from users”)지만 몇개의 행을 지웠는지까지 확인할 수 있는 아래 명령어를 쓰는 것이 더 좋다 1print(\"users db deleted : \", conn.execute(\"delete from users\").rowcount, \"rows\") 9. 롤백되돌리기를 뜻하며 커밋한 걸 되돌리는 것이다. 1conn.rollback() 10. 접속 해제DB를 다 사용했을때는 꼭 접속 해제 명령어를 입력해줘야한다. 1conn.close()","link":"/2020/06/05/200606python/"},{"title":"HTML 목록 태그, 정의태그, 글자관련태그","text":"목록 태그HTML 목록 종류 3가지-&lt;ol&gt;태그 : Ordered List 순서 있는 목록-&lt;ul&gt;태그 : Unordered List 순서 없는 목록-&lt;li&gt;태그 : 정의 목록 목록을 &lt;ol&gt;태그로 만들든 &lt;ul&gt;태그만들든간에 &lt;li&gt;태그는 항목을 나타내므로 모든 곳에 필수로 들어가야한다 123456789101112&lt;ol&gt; &lt;li&gt;배&lt;/li&gt; &lt;li&gt;부&lt;/li&gt; &lt;li&gt;르&lt;/li&gt; &lt;li&gt;니&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt; &lt;li&gt;잠&lt;/li&gt; &lt;li&gt;이&lt;/li&gt; &lt;li&gt;온&lt;/li&gt; &lt;li&gt;다&lt;/li&gt;&lt;/ul&gt; 목록태그 앞의 모양 바꾸기 ol태그 : 1/a/A/i/I ul태그 : disc/circle/square/non 정의 태그&lt;dl&gt;태그는 &lt;dt&gt;태그 &lt;dd&gt;태그가 세트이다 &lt;dt&gt;태그 는 정의내리는 대상&lt;dd&gt;태그 는 정의 내용 사실 잘 사용하지 않는 태그지만 기억해두면 필요할때 요긴하게 쓸 수 있다. 1234567891011121314151617181920&lt;h2&gt; 자신을 4가지 관점으로 정의&lt;/h2&gt;&lt;dl&gt; &lt;dt&gt;E&lt;/dt&gt; &lt;dd&gt;외향적 : 에너지가 밖으로 흐르며 사람을 만나는 것을 좋아하고 사람을 만남으로써 에너지를 얻는다.&lt;br&gt; 반대성향으로는 I 내향적이 있다. &lt;/dd&gt; &lt;dt&gt;N&lt;/dt&gt; &lt;dd&gt;직관적 : 숲을 보려는 경향이 있고 아이디어나 육감에 의존하며 주의 초점은 미래와 가능성이다. 따라서 미래지향적으로 새로운 시도를 하는 것을 좋아하며 가능성과 의미를 추구하고 변화와 다양성을 좋아한다&lt;br&gt; 반대성향으로는 S 감각형이 있다. 이는 나무를 보려는 경향으로 실재의 경험, 오감에 주의초점이 있어 현실 수용과 관례를 따르는 결향이 있다. &lt;/dd&gt; &lt;dt&gt;F&lt;/dt&gt; &lt;dd&gt;감정형 : 주관적 판단에 의존하며 주된 관심주제는 사람, 관계이다&lt;br&gt; 반대성향은 T 사고형이있으며 객관적 판단에 의존하고 주된 관심주제는 사실과 진실이다. &lt;/dd&gt; &lt;dt&gt;J&lt;/dt&gt; &lt;dd&gt;판단형 : 정리정돈과 계획성이 있다 뚜렷한 기준과 자기의사가 있으며 신속한 결론을 내리고 분명한 목적의식이 있다.&lt;br&gt; 반대성향으로는 P 인식형이 있고 상황에 맞추는 개방성과 목적과 방향의 변화가 상대적으로 쉽다. &lt;/dd&gt;&lt;/dl&gt;&lt;/dl&gt; 글자 관련 태그12345678small tag : &lt;small&gt;Make font size smaller &lt;/small&gt;sup tag : &lt;sup&gt;supppp 윗첨자&lt;/sup&gt;(ex)300m&lt;sup&gt;2&lt;/sup&gt;의 땅이 있었으면 좋겠다sub tag : &lt;sub&gt;subbbb 아래첨자&lt;/sub&gt;(ex)내가 아는 원소기호는 H&lt;sub&gt;2&lt;/sub&gt;Omark tag : &lt;mark&gt;형광펜효과&lt;/mark&gt;","link":"/2020/06/04/200605webi/"},{"title":"[ITWILL : JAVA]Method, 변수와 상수, 배열 Array, new키워드","text":"ITWILL학원 : 4강 JAVA BY 윤미영강사1. Method괄호가 있으면 다 메서드라고 부른다매서드는 항상 Class라는 주인이 있어야 한다. 다른 사람이 만들어 놓은 매서드를 사용할 수 있다. = 라이브러리라고 부른다 예시 main() : 메인매서드 println() : OutputStream이라는 라이브러리안에 정의되어있는 매서드 Scanner sc = new Scanner(System.in) sc.next(); InputStream 라이브러리에 정의되어 있는 next()매서드 2. 변수와 상수 변수변하는 값.값을 저장할 수 있는 메모리 위치.변수를 사용하기위해서는 항상 변수선언을 데이터타입과 함께 먼저 해줘야한다. 상수변하지 않는 하나의 값앞에 final이 붙는다 예시 PI : 3.141592… 사용법 : final double PI = 3.141592; 3. 배열 Array배열이란 쉽게말해 여러개의 변수를 한꺼번에 선언하는 것이다변수를 선언한다는 것은 메모리에 a변수가 생성이 된다는 의미이다.배열에서는 변수갯수를 선언할 수 있다 -&gt; int [] ar = new int[10]는 메모리에 10개의 정수 변수 생성된다는 의미이다 여기서 주의할 점은 ar1의 데이터타입은 int가 아님을 명심하자!int[]의미는 int를 관리한느 배열타입이지 int타입이 아니다.ar1의 데이터타입은 기본형에 포함되지않는 참조형의 데이터타입이다. 배열객체를 생성하기 위해서는 new키워드와 함께 어떤 데이터를 몇개나 저장할지에 대한 정보가 필요하다.그렇다면 new키워드란 무엇일까?아래 잘 설명한 블로그가 있어서 가져왔다.참고링크 : 자바 변수들의 메모리 구조,new 키워드 배열변수선언에는 두가지 방법이 있다 3-1. 첫번째 배열선언 방법배열생성과 배열갯수만 선언하는 방법이다int [] ar1 = new int[3]로 배열과 배열갯수를 한꺼번에 선언. 초기화는 안됨! 12345678910111213int [] ar1; //배열생성 : 메모리에 a변수 생성ar1 = new int[3]; //배열갯수선언. 메모리에 3개의 정수 변수 생성. 값을 넣어주지않기때문에 초기화는 아니다// 1번과 2번을 합쳐서 한줄로 많이 쓴다int [] ar1 = new int[3]; // 초기화하지 않은 배열은 기본적으로 0의 값을 가진다 ar1[0] = 0; ar1[1] = 0; ar1[2] = 0; for(int i=0; i&lt;ar1.length; i++){ System.out.print(ar1[i]);} //000 데이터형마다 기본값이 다르다기본데이터형이 아닌 참조데이터형인 경우 기본값이 다르다 기본데이터형의 기본값은 데이터형에 따라 다르다 int 는 0 double은 0 char는 ‘’(빈칸) 1234char [] chs = new char[2]; for (int i=0; i&lt;chs.length; i++){ System.out.println(chs[i]); } //00 - 유니코드 -&gt; ''''(빈칸2개) 참조데이터형의 기본값은 null (자바언어의 예약어이고 실제 값이 없다는 의미이다) string은 null String형 1234String [] str = new String[3];for (int i=0; i&lt;str.length; i++){ System.out.print(str[i]);} // nullnullnull 참조형기본적으로 같은 타입을 한 배열에 넣을 수 있다. 12345Person[] p = {new Person, new Person};SpiderMan[] sp = {new SpiderMan, new SpiderMan};AquaMan[] aq = {new AquaMan, new AquaMan}; 타입이 다른 참조형데이터를 하나의 배열에 넣을 순 없을까?다형성을 이용하면 가능하다.상속관계인 경우에만 타입이 다른 참조형데이터를 하나의 배열에 묶을 수 있다. 123456Person[] p = {new Person. new Person}Dobject d = new Dobject[3];d[0] = new Line();d[1] = new Circle();d[2] = new Reat(); 3-2. 두번째 배열선언 방법배열생성과 초기화를 한꺼번에 선언하는 방법이다 int [] ar2 = {10, 20, 30} 여기서는 new int[5]를 하지않아도 된다 왜냐면 위의 코드 자체에 변수갯수선언이 포함되어있다이 방법은 테스트용으로 주로 사용할뿐 실무는 new int[]형태로 사용한다 12345int [] ar2 = {10, 20, 30}; //배열생성과 초기화 한꺼번에!for(int j=0; j&lt;ar2.length; j++){ System.out.println(ar2[j]);} 위의 두 방법의 차이점일반적으로는 new int[]형태를 더 많이 쓰인다왜냐하면 보통 다른 파일이나 데이터베이스의 내용을 가져오기 때문에 변수갯수가 정해져있다.배열을 사용하려면 항상 크기를 미리 알아야한다.만약 배열의 크기를 모른다면 쓸 수 있는 가장 큰 수를 적어주면되지만 대신 메모리를 많이 잡아먹는다.그래서 사용하는 것이 Collection(컬렉션)이다 Collection 컬렉션 : 참조형데이터형태 배열과 같은 역할을 하지만 크기를 모를때 사용 정적 메모리 할당이 아닌 동적 메모리 할당이 되어서 필요한 만큼 공간을 계속 추가할수있다 컬렉션참고링크","link":"/2020/06/07/200608javai/"},{"title":"[패스트캠퍼스python] Web 기초 (클라이언트 VS 서버, 웹프로그래밍, HTTP, 크롬 개발자도구)","text":"파이썬 인강 : Web 기초 (클라이언트 VS 서버, 웹프로그래밍, HTTP, 크롬 개발자도구)15회차까지는 파이썬 기초를 배웠다.이번에는 web기초를 후루룩 배워보자자주 접했지만 아직 암기까진 못한 웹기초!이번엔 기초를 탄탄히 쌓아서 다시 보는 일이 없었으면 좋겠다 ㅋㅋㅋㅋㅋ 1. 클라이언트 (client) VS 서버 (server)클라이언트와 서버, 이 둘은 절대적인 개념이 아니라 상대적인 개념이다.웹 브라우저가 설치된 컴퓨터에서 다른 컴퓨터에 요청을 하는 클라이언트이면서도 또다른 웹 브라우저에 요청을 받는 서버컴퓨터일 수 도 있다. 클라이언트 : 요청을 보내는 주체 크롬, 사파리, 엣지 파이어폭스 등과 같은 웹브라우저 데스크톱 앱 혹은 모바일 앱 다른 서버에 요청을 보내는 서버 개발자가 개발한 별도의 소프트웨어 등등등 서버 : 네트워크를 통해 클라이언트에 정보 혹은 제공하는 프로그램 또는 컴퓨터 웹 페이지, 웹 사이트, 앱 등을 저장한 컴퓨터 웹 서버 애플리케이션을 통해 만들어진 애플리케이션 등등등 이번 강의에서 배울 파이썬기반의 프레임워크인 Flask와 Django로 만들어진 어플리케이션이 서버역할을 수행할 수 도 있다.이처럼 요즘에는 웹 프레임워크를 이용하여 웹 서버를 개발한다. 2. 웹프로그래밍 (Web Programming)웹 프로그래밍이란 HTTP로 통신하는 클라이언트와 서버를 개발하는 것을 말한다. 클라이언트와 서버는 앞에서 배웠는데 HTTP 프로토콜은 무엇일까? 3. HTTP (HyperText Transfer Protocol)HTTP(HyperText Transfer Protocol)란 웹서버와 클라이언트 즉, 브라우저가 인터넷에서 서로 테이터를 주고 받기 위한 약속체계이다. 그럼 실질적으로 HTTP 요청과 HTTP 응답에 대해 자세히 알아보자 HTTP 요청 매서드 Method 실제 서버가 수행해야하는 동작들이다. get : 정보를 가져오기 post : 정보를 올리기 delete : 삭제하기 URL주소 헤더 Header 브라우저 정보 언어 등등 여러정보가 포함된다. 본문 body 있을 수도 있고 없을 수도 있다. 페이스북으로 예를 들자면, 아이디나 패스워드 입력창이나 새글내용등이 본문에 해당된다. HTTP 응답 상태코드 요청의 성공여부가 가장 먼저 표시된다. 예시 200은 성공했다는 의미이다. 404 Not Found …는 실패했다는 의미이다. 헤더 Header 본문 body HTML(Hypertext Markup Language)코드등의 파일 에러가 났다면 생략될 수 있다. 4. 크롬 개발자도구 (chrome developer tools) 위의 이미지에서 볼수있듯이 크롬 개발자도구로 많은 것들을 할 수 있다 Elements엘리먼트탭에서는 각 요소에 대해 알수있으며, 속성값을 다르게 입력하는 등 간단하게 일시수정도 가능하다.일시수정이라서 영영 저장되거나 보존되는 것이 아닌 그냥 임시적으로 수정가능하다. Console콘솔탭에서는 자바스크립트 (javascript)를 다룰 수 있다. Sources소스탭에서는 현재 웹페이지가 가지는 모든 소스코드들중 공개된 코드들을 마음껏 볼 수 있다. Network네트워크탭은 페이지를 로딩하는데 필요한 네트워크작업에 대한 결과를 시간순으로 표시해준다.이를 통해서 웹서버와 주고받는 실제 데이터 모습을 볼 수 있다. 위의 이미지 오른쪽 하단부분에 Method를 확인 할수있다. 위에서 배웠던 get과 post매서드를 확인할 수 있다. 위에서 status를 확인할 수 있다 200으로 성공이 되었음을 의미한다. type에서도 해당 웹사이트가 불러온 데이터의 타입이 gif 이미지파일인지, script파일인지 아니면 text/html파일인지 등등을 확인할 수 있다.","link":"/2020/06/08/200609python/"},{"title":"[JS] 반복문 for 순서 자세히, 개발자 도구로 디버깅, 기본 반복문암기, for문과 if문의 자리바꿈에 따른 변화, 반복문의 전위연산 VS 후위연산, do while문","text":"반복문 : for반복문의 기본식은 아래와 같다 123for(초기식; 조건식; 증감식){ 반복문장} if나 for 문은 중괄호{} 없이도 반복이 된다. 하지만 세미콜론;전까지의 한줄만 반복한다 반복문의 순서 초기식 조건식 반복문장 증감식 조건식 반복문장 증감식 위의 3가지 반복 조건식 (조건이 충족된 경우) 반복문 종료 개발자 도구를 이용하여 간단한 디버깅을 할 수 있다 Sources탭에서 디버깅원하는 소스코드파일을 클릭 후 디버깅원한느 코드의 줄번호 앞부분 클릭 -&gt; 빨간 점으로 표시됨 Block기준으로 변수의 값이 변화 확인 가능 4번에 보이는 회색점을 클릭하면 빨간색점으로 변경됨 -&gt; 점마다 break point가 걸려 순서를 세세하게 볼 수 있음 옅은 파란 블럭이 이동하면서 코드 실행순서를 가시적으롭 보여줌 디버깅이 끝났으면 꼭 줄번호 옆의 빨간색점을 체크해제해줘야 디버깅 모드가 중단된다 기본 반복문암기기본적인 반복문은 암기해서 바로바로 쓰는 것이 좋다 몇씩 증감하는 반복문1~10까지 짝수만 출력하는 반복문을 생각하자마자 나는 if조건이 들어간 for문을 생각했다 12345for(let i=0; i&lt;=10; i++){ if(i%2 !==0){ document.write(' '+i); }} // 1 3 5 7 9 강사님이 보더니만 결과값은 일치하지만 효율을 위해서 간단한건 조건문이 안들어간 반복문으로 나타내는 것이 좋다고했다. 음 그렇군! 오케이 접수! 123for(let i=1; i&lt;=10; i+=2){ document.write(' '+i)} // 1 3 5 7 9 for문안의 증감식을 변경하여 몇씩 증감한다고 하면 주로 위의 코드를 이용하면 된다! 누적합정말 많이봐서 이제 익숙하다 12345let sum = 0for(let i=0; i&lt;=10; i++){ sum+=i} document.write(sum) //55 카운트횟수를 셀 때 자주 사용한다 12345let count = 0;for(let i=1; i&lt;=10; i++){ count+=1;}document.write(count); //10 for문과 if문의 자리바꿈에 따른 변화사용자가 입력하는 숫자의 구구단을 출력하는 예시를 보자 12345678910let num = prompt('구구단 숫자를 입력하세요'); for(let i=1; i&lt;=9; i++){ if(num &gt; 0){ document.write(num + ' * '+ i +' = '+ (num*i)+ '&lt;br&gt;') }else{ alert('잘못입력했습니다 1~9까지 숫자중에 입력하세요') break; }} 위에서 num을 0이하로 입력했다면 alert창 띄우고 다시 숫자를 입력하도록 하게 하고싶었다. 근데 이 로직으로는 감이 잡히지않았다.고민하다가 if와 for문의 자리를 바꿨다.자리만 바꿨을 뿐인데 reload가 가능해서 굳이 새로고침하지않아도 다시 num을 입력할 수 있어 편하다 12345678910let num = prompt('구구단 숫자를 입력하세요'); if(num&gt;0){ for(let i=0; i&lt;=9; i++){ document.write(num + ' * '+ i +' = '+ (num*i)+ '&lt;br&gt;') }}else{ alert('잘못입력했습니다 1~9까지 숫자중에 입력하세요') location.reload();} 반복문 : While반복문 while의 기본식은 아래와 같다 12345초기식;while(조건식){ 반복할문장; 증감식;} 증감식을 꼭 적어줘야 무한실행이 되지 않는다! 전위연산 VS 후위연산전위연산과 후위연산은 잘 비교해야한다 전위연산1234let i=1;while(i++ &lt;=4){ document.write(i+\", \")} // 2, 3, 4, 5 i = 1 -&gt; 조건식 : 참 -&gt; i++ -&gt; write : 2 i = 2 -&gt; 조건식 : 참 -&gt; i++ -&gt; write : 3 i = 3 -&gt; 조건식 : 참 -&gt; i++ -&gt; write : 4 i = 4 -&gt; 조건식 : 참 -&gt; i++ -&gt; write : 5 i = 5 -&gt; 조건식 : 거짓 -&gt; 종료 후위연산1234let i=1;while(++i &lt;=4){ document.write(i+\", \")} // 2, 3, 4, i = 1 -&gt; ++1 라서 2 -&gt; 조건식 : 참 -&gt; write : 2 i = 2 -&gt; ++1 라서 3 -&gt; 조건식 : 참 -&gt; write : 3 i = 3 -&gt; ++1 라서 4 -&gt; 조건식 : 참 -&gt; write : 4 i = 4 -&gt; ++1 라서 5 -&gt; 조건식 : 거짓 -&gt; 종료 do-while()문조건 비교하기 전에 한 번 실행후 조건을 비교한다 기본형태이다 12345초기식;do{ 반복문장; 증감식;}while(조건식) 초기식과 증감식 없더라도 확인가능하다아래는 예시이다 123456let i = 1;do{ document.write(i+\" \"); i++;}while(i&lt;=10);// 1 2 3 4 5 6 7 8 9 10 예시: 구구단 세로로 나타내기구구단을 가로가 아닌 세로로 나타내보자세로로 만들려면 일단 가로로 먼저 만들수있어야한다 구구단 가로출력123456for(let dan=2; dan&lt;=9; dan++){ document.write('&lt;br&gt;') for(let num=1; num&lt;=9; num++){ document.write(dan+'*'+num+'='+(dan*num)+' ') }} 가로출력의 첫번째 반복은 dan이 고정이고 num이 1부터 9까지 변화한다세로출력의 첫번째 반복은 num이 고정이고 dan이 2부터 9까지 변화한다 이 두 사실을 가지고 변수와 숫자를 적절히 바꾸어주면 된다 구구단 세로출력 for문과 이중for문으로 만든 코드이다 12345678910for(let i=2; i&lt;=9; i++){ document.write(' &lt;' + i +'단&gt; ')}for(let dan=1; dan&lt;=9; dan++){ document.write('&lt;br&gt;') for(let num=2; num&lt;=9; num++){ document.write(num+'*'+dan+'= '+(dan*num)+', ') }} 아래 이미지파일을 보면 왼쪽이 출력값이고 오른쪽이 소스코드이다 이중for문 하나로 만들 순 없을까? 당연히 만들수있다! if를 이용하면 된다! 1234567891011for(let num=0; num&lt;=9; num++){ for(let dan=2; dan&lt;=9; dan++){ if(num == 0){ document.write(' &lt;' + dan +'단&gt; ') }else{ document.write(dan+'*'+num+'= '+(dan*num)+', ') } } document.write('&lt;br&gt;') } 반복문으로 테이블만들기테이블만드는 방법도 다양하다 테이블은 행x열(4x3)이고 각 칸안에는 1~12까지의 수를 넣은 테이블을 만들어보자 이중 for문 사용 12345678910111213let tageOpen=\"&lt;table border='1'&gt;\"let tageClose=\"&lt;/table&gt;\"document.write(tageOpen)let count = 0;for(let tr=1; tr&lt;=4; tr++){ document.write('&lt;tr&gt;') for(let td=1; td&lt;=3; td++){ document.write('&lt;td&gt;' + (count+=1) + \"&lt;/td&gt;\") } document.write('&lt;/tr&gt;')}document.write(tageClose) tag로 테이블만들기 12345678910111213let tageOpen=\"&lt;table border='1'&gt;\"let tageClose=\"&lt;/table&gt;\"let trtdtag;let count1 = 0; for (let i=1; i&lt;=4; i++){ trtdtag += \"&lt;tr&gt;\"; trtdtag += \"&lt;td&gt;\" + (count1+=1) + \"&lt;/td&gt;\"; trtdtag += \"&lt;td&gt;\" + (count1+=1) + \"&lt;/td&gt;\"; trtdtag += \"&lt;td&gt;\" + (count1+=1) + \"&lt;/td&gt;\"; trtdtag += \"&lt;/tr&gt;\" }document.write(tageOpen + trtdtag + tageClose ) 아래와 동일 테이블이 만들어진다. 1 2 3 4 5 6 7 8 9 10 11 12","link":"/2020/06/08/200609jspi/"},{"title":"[패스트캠퍼스python] 테이블 데이터의 수정 및 삭제","text":"파이썬 인강 : 테이블 데이터의 수정 및 삭제 데이터베이스 다루기의 기본 명령어 CRUD를 알아야한다 C : Create R : Retrieve 조회 U : Update 수정 D : Delete 1. 데이터베이스 사용 기본 3가지 명령어데이터베이스를 사용할때 기본이 되는 3가지 명령어가 있다 12345678# 1. SQLITE 불러오기import sqlite3# 2. DB생성(파일)conn = sqlite3.connect('C:/Users/ratia/Documents/코딩/Fastcampus Python/Python/db/database.db')# 3. Cursor연결c = conn.cursor() 무엇을 하든지 위의 3가지는 기본으로 깔고 시작해야한다 2. 데이터 수정데이터 수정 명령어에는 크게 3가지가 있다다양한 방법으로 1번로우의 username을 kim에서 seo로 바꾸어보자 1234567891011# 1. 데이터 수정1c.execute(\"UPDATE users SET username = ? WHERE id = ?\", ('seo', 1))conn.commit()# 2. 데이터 수정2 : 딕셔너리형태로 수정c.execute(\"UPDATE users SET username = :name WHERE id = :id\", {\"name\": 'seo', 'id': 1})conn.commit()# 3. 데이터 수정3 : 스트링포맷로 수정c.execute(\"UPDATE users SET username = '%s' WHERE id = '%s'\" % ('seo', 1))conn.commit() 3. DB Browser for SQLite를 이용한 데이터 수정DB Browser for SQLite를 이용해서 손쉽게 데이터를 수정할수도있다아래 이미지에서 1번 로우의 username을 seo에서 so로 바꾸어보자 먼저 데이터보기탭에서 username을 더블클릭한 뒤 오른편 인풋창에 so로 바꿔준 후 적용을 클릭한다 까먹지말고 꼭 SQL실행탭에서 commit을 입력 후 run버튼을 누른다 아래 터미널에 질의가 성공적으로 실행되었다는 안내메세지가 나타나면 끝! 수정이 잘되었는지 확인을 위해 아래 명령어를 출력하면 수정이 잘되었음을 확인할 수 있다 1234567# 1. 수정한 로우만 확인c.execute(\"SELECT * FROM users WHERE id= :Id\", {\"Id\": 1})print('수정 잘 되었는 감?', c.fetchone())# 2. 수정한 로우포함 전체 데이터확인for user in c.execute('SELECT * FROM users'): print(user) 4. 데이터 삭제데이터 삭제에도 다양한 방법이 있다 한 줄 데이터삭제 방법먼저 한줄데이터를 삭제해보자다음 세가지는 2번째 줄 전체를 삭제하는 명령어이다 1234567891011# 1. Row Delete1 #튜플형식c.execute(\"DELETE FROM users WHERE id = ?\", (2,))conn.commit()# 2. Row Delete2 #딕셔너리형식c.execute(\"DELETE FROM users WHERE id = :id\", {'id': 2})conn.commit()# 3. Row Delete3 #스트링포맷c.execute(\"DELETE FROM users WHERE id = '%s'\" % 2)conn.commit() 테이블 전체 데이터 삭제이번에는 테이블 전체를 삭제해보자간단한 명령어지만 위험하니… 신중히 사용하자 ㅋㅋㅋㅋㅋ 1print(\"users db deleted : \", conn.execute(\"delete from users\").rowcount, \"rows\")","link":"/2020/06/07/200608python/"},{"title":"[ITWILL : JAVA]기본 반복문암기, String인지 체크(typeof), N개의 양수를 받아 최대값 출력, char와 String의 차이점 산술연산자","text":"ITWILL학원 : 5강 JAVA BY 윤미영강사1. 기본 반복문암기 1~10까지 나열하기 123for(int i=1; i&lt;=10; i++){ System.out.print(i);} //12345678910 누적합구하기 12345int sum = 0;for(int i=0; i&lt;=10; i++){ sum+=i} System.out.println(sum) //55 카운트세기자주 사용하는 카운트 세기 반복문 12345int count = 0;for(int i=1; i&lt;=10; i++){ count+=1;}System.out.println(count); //10 2. 자바에서의 String인지 체크(typeof)자바에서는 typeof는 없고 각 데이터별로 체크할 수 있는 방법이 있다 12345678910111213141516// 1. 사용자로부터 입력받아오자String [] str = new String[3];Scanner sc = new Scanner(System.in);for(int i=0; i&lt;str.length; i++){ str[i] = sc.next();}// 2. 사용자가 입력한 데이터가 string인지 체크String s = Arrays.toString(str);if( s instanceof String) { System.out.println('참');}else{ System.out.println(\"거짓\");} 3. N개의 양수를 받아 최대값 출력scanner로 사용자로부터 양수 n개를 받아 그 중 최대값을 화면에 출력해보자기본적으로 양수 n개를 받는 코드를 작성하면 아래와 같다 123456789101112131415Scanner sc = new Scanner(System.in);System.out.println(\"양수 5개를 입력하세요\");int [] num = new int[5];for(int i=0; i&lt;num.length; i++){ //1. 숫자 5개 입력받기 num[i] = sc.nextInt();}for(int i=0; i&lt;num.length; i++){ //2. 양수인지 체크(정수전체에서 max를 구하고싶다면 이부분을 없애면된다) if( num[i] &gt; 0){ System.out.print(num[i]+ \" \"); }else{ System.out.print(\"양수아님 \"); } }System.out.println(); 이제 두가지 방법으로 최대값을 구해보자 첫번째 방법 : 삼항연산자 사용 1234567int max = num[0];for( int i = 1; i &lt; num.length; i++) { //최대값구하기 max = num[i] &gt; max ? num[i] : max;} System.out.println(\"최대값은 : \"+ max); 두번재 방법 : if문 사용12345678910int max = num[0];for(int i=1; i&lt;num.length; i++){ if(max &gt; num[i]){ max = max; }else{ max = num[i]; }}System.out.println(\"최대값은 : \"+ max); 위의 코드를 자세히보자. 리팩토링할 부분이 보인다.max가 가장 큰 수 인 경우 굳이 동일값(max = max;)을 대입할 필요가 없다 123456789101112131415161718int max = num[0];for(int i=1; i&lt;num.length; i++){ if(max &lt; num[i]){ max = num[i]; }}System.out.println(\"최대값은 : \"+ max);// 위의 식을 간단하게 {} 중괄호를 생략할 수 있다// 중괄호생략은 블록안의 내용이 한줄일때 생략가능하다for(int i=1; i&lt;num.length; i++){ if(max &lt; num[i]) max = num[i];}System.out.println(\"최대값은 : \"+ max); 중괄호를 생략하니 세상 간단간단해보인다 4. char와 String의 차이점 산술연산자char는 연결연산자가 사용이 안된다.String이 어느 한 변수 이상에 있는 경우에는 연결연산자가 사용이 된다.캐릭터에서 연결연산자를 사용하고싶으면 변수들 사이에 “”를 입력해줘야한다. 123456char c1= 'a', c2= 'b';System.out.println(a + b); //195String c1= 'a', c2= 'b';System.out.println(a + b); //ab 만약 char를 ab로 나타내고 싶다면 변수들 사이에 “”해주면 된다 12char c1= 'a', c2= 'b';System.out.println(a +\"\"+ b); //ab","link":"/2020/06/09/200610javai/"},{"title":"select as from where, order by, 동일유저 동시접속 가능, 트랜잭션 commit과 rollback","text":"SQL select as from where 1234select 컬럼명, 컬럼명, 컬럼명from 컬럼이 있는 테이블명where 좌변 = 우변 (컬럼명) (리터럴값) 예를 들면 아래와 같다employees 테이블의 연봉 3000이하의 사원명을 출력하고싶다 123select last_name, salaryfrom employeeswhere salary &lt;= 3000; 또 as를 사용하면 원하는 컬럼명으로 임시적으로 바꾸어 출력이 가능하다아래 예시는 위의 예시에서 as how_much만 추가해준것이다 123select last_name, salary as how_muchfrom employeeswhere salary &lt;= 3000; 동일유저 동시접속 가능회사마다 다르지만 개발자마다 각각 유저를 쓸수있고 한 유저를 다 같이 사용할 수 있다그 이유는 한 유저아이디를 가지고 동시접속이 가능하기때문이다 그렇다면 동시접속했는데 동일한 데이터를 동시에 commit을 날리면 그 데이터는 어떻게 되는가?같은 행에 대해서는 동시작업이 안된다. 커밋,업데이트, 딜리트를 날려도 아예 실행이 안된다.예시로 두사람이 employee_id =100을 접속했다. 그리고 한 사람이 데이터 수정후 커밋을 날려도 커밋이 아예 실행되지 않는다반면, 한사람은 employee_id =100을 그리고 다른 한사람은 employee_id =101을 접속했으면 각자 수정이 가능하다 아래 이미지처럼 1번이 먼저 데이터를 수정한 터미널창이다.2번은 동일 유저로 접속한 터미널창이다. 2번 터미널창에서는 데이터 중 department_id의 전체 데이터가 ####으로 나타나서 아예 읽기조차 되지않는다 트랜잭션 commit과 rollbackDML 명령어 후에는 임시값으로 보여진다.이를 커밋하거나 롤백을 해서 임시값을 저장할지 안할지 결정해야한다. COMMIT은 임시저장값을 저장한다. COMMIT후에는 낙장불입, 다시 되돌릴수없다 ROLLBACK은 임시저장값을 이전의 원래 값으로 되돌아간다. system 권한 부여 session : 데이터 베이스를 연결할 수 있는 권한 다른 권한을 다 주고 이 권한만 revoke한다면 결국 모든 데이터를 사용하지못하게된다. 시스템권한 링크","link":"/2020/06/09/200610dbi/"},{"title":"[ITWILL : JAVA]리터럴(literal), byte + byte가 왜 에러날까, int VS Integer,  void와 int차이","text":"ITWILL학원 : 6강 JAVA BY 윤미영강사1. 리터럴(literal)실제 값.변수의 값이 변하지 않는 데이터(메모리 위치안의 값)이다. 참고링크 : 상수와 리터럴차이 2. byte + byte가 왜 에러날까b1과 b2는 연산결과는 잘 나오지만 b3의 연산결과는 에러가 난다. 1234567byte b1 = 10;byte b2 = 20;System.out.println(b1+b2); //30byte b3 = b1+b2;System.out.println(b3); //Type mismatch: cannot convert from int to byte 산술연산자는 기본적으로 int형이다. 그래서 type mismatch가 나타난다int형으로 산술하면 잘~출력된다 1234int i1 = 100;int i2 = 200;int i3 = i1+i2;System.out.println(i3); //300 3. int VS Integer아래 데이터형의 차이점이 뭘까? int a; 기본데이터형 Integer i; 참조데이터형 라이브러리 매서드사용가능 123456int a1 = 100;Integer a2 = 100;System.out.println(a2.toString()); //100System.out.println(Integer.MAX_VALUE); //2147483647System.out.println(Integer.MIN_VALUE); //-2147483648 4. void와 int차이void와 int 매서드의 차이를 알아보자public static 뒤에 void가 오기도하고 int등 다른 데이터타입이 올 수 있다. void의 의미 : myPrint가 가지고 있는 값이 없을때, 돌려줄값이 없을때 return이 없을때 사용. int의 의미 : 반대로 가지고있는 값이 있을때, 돌려줄값이 있을때. return과 함께 사용 1234567public static void 매서드이름(매개변수){ //void 매서드 정의하기 System.out.println(\"void 매서드\")}public static int 매서드이름(int 변수명1, int 변수명2){ //int 매서드 정의하기 return 변수명1 + 변수명2;}","link":"/2020/06/10/200611javai/"},{"title":"ITWILL : 무한반복문, 보조제어(break와continue)문, 익명함수, 재귀함수, 지역변수를 전역에서 사용하는 방법, 내장함수","text":"ITWILL학원 : 7강 JS기초 BY 정규태강사1. 무한반복문반복문이 무한으로 실행되는 반복문.문제의 해결이 언제 끝날지 모르는 경우에 주로 사용. 예를 들어,사용자가 정답을 맞출때까지 실행하는 퀴즈프로그램을 만들었다고 생각해보자-&gt; 사용자가 언제 정답을 맞출수있을지 알수있을까?-&gt; 모른다. 따라서 계속해서 실행을 하고 있어야한다-&gt; 이때 무한반복문 사용-&gt; 답을 맞추면 끝나야하기때문에 보조제어문이 필요하다 실제예시 : 스마트폰의 지문인식 1234567891011for(;;){ console.log(\"무한반복\")};for(;true;){};for(let i=1;;i++){};while(true){};do {} while(true); 2. 보조제어문 break문 : 가장 가까운 반복문 하나를 탈출하는 코드다 즉 이중for문이면 둘 다 탈출하는 것이 아니라 가장 가까운 for문만 탈출하는 것이다 break;의 순서에 따라 결과값이 달라지므로 위치가 중요하다 예를 들어 : ~까지만 해라 123456789101112for(let i=1; i&lt;=10; i++){ document.write(i+\" \"); if(i%4 === 0) break;} //1 2 3 4// break문은 순서가 중요하다// 순서에 따라 값이 다르게 나오기 때문이다for(let i=1; i&lt;=10; i++){ if(i%4 === 0) break; document.write(i+\" \");} //1 2 3 아래는 for문의 조건식으 true인 무한반복문이다무한반복문과 함께 쓰이는 경우는 아래와 같다 1234for(let i=1;true;i++){ if(i === 10) break; document.write(i+\" \")} continue문 : 해당 경우를 실행하지않고 다음 경우를 실행하는 동작 continue조건은 빼고 반복문을 실행하는 동작. 예를 들어 : ~를 빼고 진행해라!할때 사용 123456789101112131415let sum=0,i=0while(i&lt;5){ i++ if(i==3) continue; sum=sum+i document.write(\"i값은 \" + i + \" sum값은 \" + sum + \"&lt;br&gt;\") }/* i값은 1 sum값은 1i값은 2 sum값은 3i값은 4 sum값은 7i값은 5 sum값은 12 */document.write(\"while문의 결과값 : \"+sum) // 12 위의 두가지를 활용한 숫자퀴즈를 만들어보자 특정숫자 미리 지정 (1부터 100까지 중에서) 사용자로부터 입력 -&gt; 미리 지정한 숫자와 큰지, 작은지 같은 지를 비교 큰 경우 -&gt; “입력된 값이 큽니다” 출력 같은경우 -&gt; “정답입니다 도전횟수는 땡땡입니다” 출력 작은 경우 -&gt; “입력된 값이 작습니다” 출력 1234567891011121314151617let quiz = Math.floor(Math.random()*100); //랜덤숫자만들기console.log(\"랜덤숫자 정답은? \"+ quiz)let input = prompt('텔레파시를 보냈습니다~ 숫자를 입력하세요');for(let count=1; true; count++){ if(quiz &gt; input){ input = prompt(\"텔레파시숫자보다 작습니다. 숫자를 다시 입력해주세요\"); }else if(quiz &lt; input){ input = prompt(\"텔레파시숫자보다 큽니다. 숫자를 다시 입력해주세요\"); }else if(quiz == input){ alert(\"정답은 \" + quiz + \", \" + count + \"회 시도만에 정답!\") document.write(\"정답은 \" + quiz + \", \" + count + \"회 시도만에 정답!\") break; }else{ input = prompt(\"잘못입력하였습니다. 숫자를 다시 입력해주세요\"); }} 강사님 코드는 아래와 같다굳이 input을 for문 밖에 두는 것이 아니라 안에 두기만 하면 되는 거였다괜히 일일히 input = prompt를 적었다… 띠용 123456789101112131415161718let quiz = Math.floor(Math.random()*100);console.log(\"랜덤숫자 정답은? \"+ quiz)for(let count=1; true; count++){ let input = prompt('텔레파시를 보냈습니다~ 숫자를 입력하세요'); if(quiz &gt; input){ alert(\"텔레파시숫자보다 작습니다. 숫자를 다시 입력해주세요. 시도횟수 \" + count +\"회\"); }else if(quiz &lt; input){ alert(\"텔레파시숫자보다 큽니다. 숫자를 다시 입력해주세요. 시도횟수 \" + count +\"회\"); }else if(quiz == input){ alert(\"정답은 \" + quiz + \", \" + count + \"회 시도만에 정답!\") document.write(\"정답은 \" + quiz + \", \" + count + \"회 시도만에 정답!\") break; }else{ alert(\"잘못입력하였습니다. 숫자를 다시 입력해주세요\"); }} 3. Function 함수 : 일반, 익명함수는 절차지향언어에서 사용되고 매서드는 객체지향언어에서 사용된다.엄밀히 따지면 다른 개념이지만 크게 보면 동일하게 사용되기도 한다.익명함수는 보통 변수에 넣어서 사용한다 변수 : 데이터를 저장해서 사용하는 곳 함수 : 실행문을 저장해서 사용하는 곳 일반함수일반적으로 함수는 아래와 같이 선언과 사용한다. 1234567//1. 일반함수 선언fuction 함수명(매개변수){ 실행코드}//2. 일반함수 호출함수명(); 익명함수익명함수의 선언과 사용은 아래와 같다.익명함수는 함수명이 없기때문에 변수이름으로 호출하면 된다.보통 익명함수는 1회성으로 주로 사용한다 1234567891011121314//1. 익명함수 선언 변수 = fuction (매개변수){ 실행코드}//2. 익명함수 호출변수명();//3.예시let fun1 = function (){ document.write(\"하이\")}fun1() //하이 4. 재귀함수재귀함수란 다시 자기자신을 호출하는 함수이다.재귀함수는 반복문없이 계속 반복된다 따라서 사용범위를 주의해서 사용해야한다재귀함수는 일정크기만큼만 실행되고 자동적으로 멈춘다. return을 이용해 함수를 탈출할수있다 12345678//1. 재귀함수 선언fuction 함수명(매개변수){ 실행코드; 함수명(); //자신의 이름 또 호출}//2. 재귀함수 호출함수명(); 재귀함수를 활용하여 1~10까지 숫자를 나타내는 함수예제를 보자 1234567891011let num=0;function testFun(){ if(num &lt; 10){ num++; document.write(num + \" \") testFun(); }else{ return; }}// 1 2 3 4 5 6 7 8 9 10 강사님은 더 짧은 코드를 썼다나는 왜 이 코드를 못했을까? 뭔가 더 간단해보인다.무슨 코드가 더 좋은 코드일까? 가독성이 좋지만 긴 코드 vs 가독성이 조금 떨어지지만 짧은 코드 아직 잘 모르겠다. 아마 회사 분위기에 따라 다르지 않을까? 12345678910let num1 = 0;function testFun2(){ num1++; document.write(num1 + \" \") if(num1 === 10){ return; } testFun2();}// 1 2 3 4 5 6 7 8 9 10 5. 지역변수를 전역범위에서 쓰는 방법지역변수를 전역변수처럼 쓸 수 있을까?정답은 예스!return을 이용한 예시를 보자 123456789let number = 200;function fun() { var number = 300; return number;}number = fun();document.write(number) //300 number의 값은 200이 아니라 300이 나온다.지역변수를 함수로 만들고 그 값을 전역변수 안에 넣었기 때문이다. 6. 내장함수자바스크립트엔진에는 내장되어있는 함수들이 있다. 예시 String(1) Number(“1”) =&gt; number는 정수와 실수를 합친 것으로 표현됨 Boolean(0) =&gt; alert(“경고창”) prompt(“질문”, “기본값”) confirm() =&gt; yes, no 결정 parseInt() =&gt; 문자데이터를 정수데이터로 변경 parseFloat() =&gt; 문자데이터를 실수데이터로 변경","link":"/2020/06/10/200611jspi/"},{"title":"[패스트캠퍼스python] Web 기초 (프론트엔드 VS 백엔드, Codepen, MDN, devdocs, 크롬검색꿀팁)","text":"파이썬 인강 : Web 기초 (프론트엔드 VS 백엔드, Codepen, MDN, devdocs, 크롬검색꿀팁)1. 프론트엔드 (Front‑end) VS 백엔드 (Back-end)가장 많이 들었던 프론트엔드와 백엔드 그 차이점은 무엇일까? 간단한 도식표로 쉽게 확인할 수 있다. 프론트엔드 (Front‑end)파란색영역으로 HTML, CSS, Javascript를 주로 다룬다.사용자와 웹브라우저사이에서 입력과 출력을 주로 담당하며 가독성이나 사용성을 높여 사용자가 편리하게 이용할 수 있도록 해야한다. 백엔드 (Back-end)주황색영역으로 웹브라우저요청에 웹서버와 데이터베이스를 통해서 응답해준다. OS(operating system 운영체제) : windows, linux, unix, mac, ios, android 등등 DB(DataBase 데이터베이스) : oracle, mysql, mongoDB, mssql 등등 Framework(프레임워크) : spring, flast/Django 등등 프로그래밍 언어 : java, php, python 등등 풀스택 (Full-stack)하지만 요즘은 점점 경계가 모호해지고 있는 추세이다.따라서 프론트엔드와 백엔드를 모두 포함하여 풀스택 (Full-stack)이라고 부르기도 한다. 실습을 하기 앞서 강사님이 여러 좋은 사이트를 알려주었다 2. Codepen 코드펜프론트엔드를 위해 굳이 에디터를 다운로드하지않아도 웹상에서도 쉽게 다룰 수 있다.바로 codepen에서 HTML과 CSS, Javascript가 가능하다.가입하지 않아도 바로 쓸 수 있는 장점이 있다. 원래 알고있던 사이트이다.다른 개발자들이 만들어 놓은 멋진 그리고 화려한 코드를 볼 수만 있는 줄 알았다.그런데 인강에서 코드 수정도 가능하다길래 직접 들어가보니 완전 신세계!!!코드를 수정할 수 있다는 것을 처음 알았다. 좋은 프론트엔드 공부자료가 될 것이다. Codepen Topics 특히 codepen에 topic에는 Vue나 React를 이용해서 만든 멋진 코드들도 볼 수 있다.보는 재미가 쏠쏠해서 시간가는 줄도 몰랐다.특히 슉슉 날아다니는 디자인을 보면 감탄밖에 나오지 않았다.정말 멋있다 사람들……나도 언젠가 그러한 코드를 공유할 수 있는 실력있는 개발자가 되고싶다. 3. MDN(the Mozilla Developer Network)개발자들의 교과서라고 불리는 MDN이다MDN은 FIREFOX를 운영하는 회사에서 만들었다고 한다.사이트에 접속해서 technologies를 클릭하면 다양한 언어들이 있다.이 중에 관심있는 언어를 클릭하고 궁금한 내용을 검색하면 쫘라락- 관련정보들이 엄청난 양으로 쏟아져나온다.차근차근 주워먹기만 하면 끝!물론 주워먹는 일이 힘들지만….. 4. Devdocs데브독스는 위의 MDN을 가독성있게, 즉 보기쉽고 빠르게 찾을 수 있다.UI가 MDN보다 훨씬 깔끔하고 쉬워서 깜짝 놀랬다.이렇게 좋은 사이트가 있었다니!!! 왜 다들 MDN만 추천해줬던 것인가…이젠 MDN보단 DEVDOCS를 더 잘 이용할 것같다. 데드독스의 또 한가지 장점은 원하는 언어만을 설정해서 검색할 수 있다는 점이다.데브독스의 검색창 옆에 점3개아이콘을 클릭하면 Preferences가 나온다여기에 수많은 언어들과 툴들이 있고 이 중 관심있는 것들만 틱해주고 저장해주면 앞으로 검색시에 내가 원하는 정보만 쏙쏙 쉽게 찾을 수 있다. 위의 이미지처럼 체크박스에 체크를 해주면 된다. 완전 꿀팁!!이렇게 수많은 언어들이 있다니 세상 놀람다. 5. Can I use _?Can I use는 사용하고자 하는 기술이 어떤 운영체제나 기반에서 제대로 작동하는 지를 알려주는 사이트이다.이 사이트가 중요한 이유는 프로그램을 만들고 배포하기 전에 상용이 가능한 지를 확인해야하기때문에 꼭 알아야한다.열심히 만든 프로그램이 제대로 작동 안하면 얼마나 속상할지… 절레절레 위의 예시처럼 sticky라는 기술은 구글에서 검색한 모습이다붉은 색이 많을수록 지원 안되는 곳이 많으니 대체가능한 기술이 있는지 체크해야한다. 처음 본 사이트인 줄 알고 즐겨찾기 추가 버튼을 눌렀는데…아니 이미 저장되어 있는 사이트였다.띠용?!?!?!?!?! 그말인 즉슨 좋은 사이트라서 즐겨찾기해놓고 한 번도 안 들어갔나보다…허허;; 6.크롬 검색 꿀팁덤으로 크롬검색꿀팁을 알게되었다 크롬에서 settings에 들어가서 search를 검색하여 Manage search engines을 클릭한다default값으로는 google을 해놓으면 되고 Other search engines에 위의 세 사이트를 추가한다 크롬 검색창에 추가한 키워드를 입력후 tab을 치면 해당사이트내에서 검색결과를 바로 확인할 수 있다. 와… 대박!","link":"/2020/06/09/200610python/"},{"title":"[패스트캠퍼스python] font-size, font-family, font color","text":"파이썬 인강 자기계발 챌린지 19회차 미션1. font-size폰트 사이즈를 지정하는데 크게 가지방식이 있다.직접 수치를 입력하는 방식과 상위요소 기준 상대적수치를 적용하는 방식 그리고 상속값을 적용하는 방식이다. 12345{font-size : 15px; //직접 입력.font-size : 1.5rem; //상위요소 기준 상대적 수치.font-size : inherit; //상속값 위의 태그의 폰트사이즈를 그대로 받는다.} em과 rem의 차이?css다루다보면 em과 rem을 접하게 된다.나는 항상 px이나 %단위로 직접 수치를 입력하여 지정하였는데 em, rem을 사용하면 상대적인 수치가 자동적으로 정해져서 훨씬 디자인이 깔끔하고 통일성있어보이기도 한다.그렇다면 em과 rem의 차이는 무엇일까?둘 다 수치를 직접적으로 입력하는 방식이 아니다. em : 상위요소의 크기에 비례. rem : 최상위 요소의 크기 즉, html 요소 크기에 비례. 참고로 html 요소 크기의 기본값은 웹브라우저 설정에서 정한 크기이며 보통 16px이다. 결국 둘의 차이점은 최상위요소의 크기인지 상위요소의 크기인지의 차이다.언뜻 읽으면 큰 차이가 없을 것 같지만 만약 em의 상위요소가 또 다른 상위요소에 상속을 받았다면 원하는 크기로 지정이 어려울 수 있다. 왜냐면 em은 상속의 영향을 받기 때문이다. 따라서 rem을 쓰는 것을 더 추천한다. 다만 rem을 쓰면 사용자가 커스터마이징해놓은 사이즈를 무시해버려서 사용자의 가독성을 오히려 떨어뜨릴수있다. 따라서 적절한 곳에 em과 rem을 쓰는 것이 좋다 그럼 언제 rem과 em을 써야할까? 참고링크 : 종합 안내: Rem 그리고 Em, 언제 써야 할까 em 단위는 최상위 요소에 지정된 폰트 크기 말고, 다른 특정 요소의 폰트 크기에 따라 그 크기가 변해야 하는 곳에 사용하십시오. rem 단위는 em 단위를 쓸 필요가 없고, 또 브라우저의 폰트 크기 설정에 따라 그 크기가 변해야 하는 곳에 사용하십시오. 폰트 크기 지정을 비롯해서 꼭 em 단위를 써야 하는 곳이 아니라면 rem 단위를 사용하십시오. media queries에도 rem 단위를 쓰세요. 다중 칼럼 레이아웃의 너비에는 em 혹은 rem을 쓰진 마십시오 - 대신 %를 쓰세요. 만약에 크기가 변할 경우 해당 요소의 레이아웃이 깨지는 걸 막을 수 없다면 em과 rem 모두 쓰지 마세요. 2. font-family폰트패밀리는 글꼴집합이다.만약에 폰트를 하나를 지정했다고 생각해보자.이용자가 해당 폰트가 없으면 폰트를 기본값으로 표시되어진다. serif는 바탕체계열 Sans-serif는 고딕체계열 Cursive는 필기체계열 monospace는 가로 폭이 동일한 글꼴 아래는 폰트패밀리예시이다 123{font-family : Arial, Georgia, Times, \"Times New Roman\", serif} 위에서 말했듯이 이용자의 컴퓨터에 지정한 폰트가 설정되어 있지 않으면 기본값으로 표시된다.이러한 경우에는 아예 웹 폰트를 사용하면, 이용자의 컴퓨터에 설치되지 않은 글꼴을 사용할 수 있다. 웹폰트 사용 방법은 html에서 link태그로 삽입하면된다. 12345678910&lt;link href=\"https://fonts.googleapis.com/css?family=Indie+Flower|Londrina+Outline|Open+Sans+Condensed:300\" rel=\"stylesheet\"&gt;&lt;style&gt; #font1{ font-family: 'Open Sans Condensed', sans-serif; } #font2{ font-family: 'Indie Flower', cursive; }&lt;/style&gt; 참고링크 : 웹폰트 생활코딩 3. font 한꺼번에 적용위에서 사용했던 폰트스타일이외에도 다양한 폰트스타일을 한 줄 코드로 작성할 수 있다중요한 점은 아래 순서대로 작성해야 제대로 적용이 된다 1font : 폰트스타일 폰트웨이트 폰트사이즈 폰트패밀리 적용된 예시는 아래와 같다표시를 한 순서대로 1번에는 폰트스타일 2번에는 폰트웨이트 3번에는 폰트사이즈 4번에는 폰트패밀리 4. font color폰트 컬러지정은 그냥 color적어주면 된다 rgba(0,0,0) : 숫자가 작을수록 어두운 색을 띈다 = 검정색 = #000000 rgba(255,255,255) : 숫자가 높을수록 밝은 색을 띈다 = 흰색 = #ffffff 폰트의 투명도도 조절할 수 있다.rgba색상코드에서 마지막에 0에서 1사이의 숫자를 정해주면 된다 0 : 완전투명 0.5 : 절반만 투명 1 : 불투명 12color : rgba(0,0,0, 0.5)// 검정색컬러에 절반만 투명","link":"/2020/06/11/200612python/"},{"title":"[패스트캠퍼스python] HTML 정의태그 dl, dt, dd 태그, code 태그, block VS inline VS inline-block","text":"파이썬 인강 자기계발 챌린지 18회차 미션HTML은 자주 공부했기때문에 약간 지루했지만…. 여전히 내가 몰랐던 내용이 있어서 해당 부분을 정리하고자한다.알고있는 내용들은 이번 기회에 아예 외워버려야겠다. 1. 정의태그 dl, dt, dd 태그어떠한 정의를 내리고 싶을 때 dl, dt, dd 태그를 사용한다.자동으로 들여쓰기가 40px이 되어있다. 이때문에 들여쓰기의 거리를 조절하고 싶으면 text-indent나 margin-left, padding-left 속성값을 변경하면 된다. dl : definition list의 약자이다. 내부에 2개의 태그(dt, dd)를 포함하며 dt는 생략가능하지만 dd는 꼭 포함되어야한다. dt : definition term의 약자이며 정의하고싶은 용어의 제목을 나타낸다 dd : definition description의 약자이며 용어의 내용을 나타내며 dl안에 필수로 들어가야한다. 1234&lt;dl&gt; &lt;dt&gt;정의하고싶은 용어의 제목&lt;/dt&gt; &lt;dd&gt;정의할 내용&lt;/dd&gt;&lt;/dl&gt; 아래 이미지는 왼쪽은 코드, 오른쪽은 그 코드출력값을 나타낸다.1번 부분처럼 dl dt, dd를 단순하게 활용할 수 있다. 실제 포털사이트에서 이용하는 예시도 아래 링크에서 찾을 수 있다.스크린리더이용자를 위해 dl dt dd태그를 남용해서는 안되겠다.모두에게 공정한 정보를 제공할 수 있는 사이트를 만들고싶다. 참고링크 : dl dt dd 태그예시와 dl dt dd 태그를 남용하지마세요 2. code 태그코드태그는 컴퓨터 코드(code)의 일부분을 나타내주는 코드이다. 그래서 컴퓨터나 프로그래밍코드일부를 그대로 표시하고자할때 유용하다. 12&lt;p&gt;다음은 자바 코드의 일부분입니다. &lt;/p&gt;&lt;code&gt;System.out.println(\"헬로자바\"); &lt;/code&gt; 위의 이미지에서 2번부분을 보면 code태그안에서 html태그를 표현하고싶을때, 여전히 꺽쇠는 표현이 되지 않는다. 그래서 왼쪽꺽쇠(&lt;)의 유니코드인 &amp;lt;를 사용했고오른쪽꺽쇠인(&gt;)의 유니코드인 &amp;gt;를 사용했다. 나는 마크다운으로 블로그를 작성하는데 항상 code표현을 백틱으로 이용해왔다. code태그 알아두면 html에서 유용하게 쓸 수 있다. 3. block요소와 inline요소 그리고 inline-block요소의 차이 block 요소 줄바꿈이 이루어진다. 기본적으로 가로폭 전체의 넓이를 가지는 직사각형 형태가 된다. width, height, padding, margin 등을 적용 가능. text-align이 적용 불가능. vertical-align이 적용 불가능. 예시 : article, dd, div, dl, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, noscript, ol, p, pre, section, table, ul 등등 123div {display : inline} inline 요소 줄바꿈이 이루어지지않는다. 기본적으로 콘텐츠가 끝나는 지점까지의 길이를 가진다. width, height, margin, padding-top, padding-bottom 적용 불가능. height 대신 line-height로 높이조절가능. 대신 span태그에서는 불가능. text-align 사용 가능 예시 : a, b, br, button, code, em, i, img, input, kbd, label, map, object, q, samp, small, script, select, span, strong, sub, sup, textarea, tt, var 123div {display : inline} inline-block위의 블럭과 인라인을 합친 것이라고 생각하면 되지만 그 특징이 조금 차이난다 width, height 적용 가능 margin, padding-top, padding-bottom 적용 가능 line-height 적용 가능 inline-block 끼리 공백 생성됨 -&gt; 상위 div에 { font-size: 0; } 를 적용하면 해결가능. inline-block 끼리 높이 불일치될수있음 -&gt; vertical-align 값 적용하면 해결가능.","link":"/2020/06/10/200611python/"},{"title":"[패스트캠퍼스python] float, position, css선택자 우선순위","text":"파이썬 인강 자기계발 챌린지 20회차 미션nomal flow에서 벗어나 복잡한 방식의 레이아웃을 하는 방법에 대해 알아보자.크게 두가지 속성으로 사용할 수 있다. float position 1. floatfloat로는 정교한 레이아웃을 작성할 수 있다.float는 이름그대로 띄우는, 뭔가 떠있는 배치이다. 먼저 비교를 위해 아무것도 적용안된 레이아웃을 보자.일반적인 단락을 나눈 줄글의 형태이다.가로로 나눠진 단락을 세로로 나누고싶을때 float가 유용하다. 이제 float는 left와 right로 줄 수 있는데 아래 이미지는 float : left;로 적용한 모습이다.아래 이미지에서 알 수 있듯이 해당 태그가 왼쪽으로 띄어지고 밑에 배치되었던 줄글이 태그옆으로 옮겨지면서 자연스럽게 흘러내려가는 형태를 취하고 있다 여기서 footer가 조금 아쉽다.column 3개에만 float : 30%;씩 적용해주었는데 10%가 남다보니 footer의 위치가 어색하게 되어버렸다.따라서 column들만 float left로 주고 footer는 하단에 배치하고싶다면 아래와 같이 clear : both; 속성을 넣어주면 된다. clear는 left, right, both 의 값을 선택할 수 있고 해당 사이드에 float정렬을 취소한다.따라서 현재상황에서는 clear : left; 또는 clear : both; 로 같은 결과값을 출력할 수 있다. 짜잔- 세상 깔끔하다! 2. position static postion 속성의 default 값이다.HTML 태그 순서에 따라 화면에 출력된다. relative 원래 위치를 기준으로 상대적인 위치를 지정해줄 수 있다. position : relative;로는 어떠한 값도 바꿀 수 없다.그 밑에 꼭 top, bottom, left, right의 값을 통해 어디를 얼만큼 이동할 것인지 정할 수 있다.여기서 중요한 점은 태그의 원래 위치는 변하지 않는다는 것이다. 없어지지 않고 기억되어져 있다. 하트의 위치에서 top과 left에 100씩 값을 주어서 하트가 글 위로 오게되었다.여기서 쉽게 헷갈릴 수 있는 점이 있다.바로 하트가 top과 left로 100씩 움직이는 것이 아니라, top과 left에 100씩 빈 공간을 준다고 생각하면 된다.빈 공간만큼 원래 태그는 밀려나게된다. absolute relative와 비슷하지만 차이점이 있다면 relative는 원래 태그자리를 빈공간으로 유지하는데 반해, absolute 원래 태그자리를 없애버리고 상대적인 위치에 위치한다.absolute는 상위태그를 기준으로 상대적인 위치를 정한다. fixed absolute와 상대적인 위치를 가진다는 것은 비슷하지만 상위태그기준이 아닌 veiwport(웹페이지가 보이는 화면)을 기준으로 뷰포인트의 특정 위치에 태그를 고정한다. 따라서 스크롤을 내려도 태그는 같은 위치에 고정되어있다. 3. css선택자 우선순위선택자는 총 3종류가 있다. id선택자 &gt; class선택자 &gt; tag선택자 만약 id와 tag에 둘다 css값이 적용되어 있으면 id클래스가 우선이므로 tag값에 덮어씌어져서 id 클래스값이 출력되게 된다.","link":"/2020/06/12/200613python/"},{"title":"[패스트캠퍼스python] Reset보단 normalize, 기본 box-sizing, 홈페이지 기본 레이아웃(hero-section), 가상클래스 (hover, active, focus 등)","text":"파이썬 인강 자기계발 챌린지 21회차 미션1. Reset보단 normalize기본값으로 설정된 css가 레이아웃을 잡을때 불편함을 초래하기도 한다.이에 reset을 시켜주는 코드들이 생겨났다.하지만 reset코드들은 오래된 것들이 많아 요즘 유용하게 쓰이는 기본값까지 초기화시켜버리기떼문에 효율적이지 못하다. 따라서 최근에는 normalize를 더 많이 사용한다. Normalize.css 파일에 들어가서 다운로드를 누르면 css 파일이 나오고 해당 파일 코드를 전체복사하여 내 프로젝트에 normalize.css로 새로운 파일을 만들어 전체붙여넣기해준다.normalize.css안에는 주석으로 해당 코드들이 어떤 역할을 하는지 자세하게 알려주어 필요한 코드만 사용할 수 있고 필요하지 않는 코드들은 삭제하기만 하면 된다. 2. 기본 box-sizing 잡기레이아웃의 에러를 최소화하기 위해서는 box-sizing을 border-box로 하는 것이 좋다.여기서 *는 모든 영역에 적용한다는 뜻이다.*::before와 *::atfer는 숨은 영역을 뜻한다. 123456*, *::before,*::atfer { box-sizing : border-box;} box-sizing을 border-box 3. 레이아웃짜기 hero-section웹페이지를 구성할 레이아웃을 짜본적이 없어서 혼자서 웹페이지를 만들때 수정을 엄청 많이 하게 된다.그래서 다른 사람은 어떻게 짜는 지 궁금했는데 강사가 자신이 왜 이렇게 레이아웃을 짜게 되었는지 설명을 해줘서 좋았다. hero-section을 처음 듣게되었는데 이는 해당 웹페이지가 중요시하는 콘텐츠를 먼저 배치하고 링크를 걸어두는 것이다. 아래 이미지는 강사님이 장고사이트의 레이아웃을 분석한 것이다. 4. Pseudo-class 가상클래스 (hover, active, focus 등 )가상클래스를 사용하여 마우스가 올라가있거나, 활성화되어있거나, 키보드로 선택되었을 때 css요소를 적용할 수 있다.예를 들면 아래 태그는 a태그에 마우스가 올라가있거나, 활성화되어있거나, 키보드로 선택되었을때 배경색상 변경하는 코드이다. hover : 마우스가 올라가 있는 경우 active : 활성화되어 있는 경우 focus : 키보드로 선택되어있는 경우 123456a : hover,a : active, a : focus {/* a 요소에 background-color : orange;} 5. Pseudo Element 가상요소없는 태그를 css로 넣어줄수도 있다.아래는 h2태그에 가상의 태그인 &gt;를 넣는 태그이다.가상태그는 html에서 드래그를 하려고해도 드래그가 되지 않는다.말그대로 가상태그이기 때문이다. 123h2 ::before{ content : \" &gt; \"} 아래 이미지는 h2태그에 가상의 태그인 손가락이모티콘을 표현했다. 6. Cascading 캐스캐이딩캐스캐이딩은 폭포라는 의미를 가지고 있다.웹페이지의 디자인이 아래 3가지 디자인과 결합할 수 있기때문에 그 결과값이 내가 예상한대로 나오지 않을 수 있다. 웹브라우저의 기본 디자인 브라우저 사용자의 디자인 그리고 웹페이지 저자의 디자인 따라서 선택자 구체성 점수를 매겨서 우선순위를 잘 파악하고 있어야한다. 7. 선택자 구체성 점수선택자와 요소에 따라 아래와 같이 다른 값을 매기고 이를 더해주면 어느 것이 더 우선순위인지 확인 할 수 있다. HTML태그의 style속성 사용 : 1000점 ID선택자 : 100점 CLASS선택자와 가상클래스 : 10점 TAG선택자와 가상요소 : 1점 사용한 태그가 위의 4분류중 어디에 속하는 지 잘 모르겠는 경우에는 구체성 계산기에 접속하여 궁금한 태그를 복사 붙여넣기하면 된다.계산기가 자동적으로 사용된 아래 세가지 ID선택자 갯수 CLASS선택자와 가상클래스 갯수 TAG선택자와 가상요소 갯수 를 알려준다 그걸 기준으로 위의 점수표와 함께 계산하면 된다.","link":"/2020/06/13/200614python/"},{"title":"ITWILL : Object객체 전체개념, tv채널객체함수, new를 쓰고 안쓰고의 차이","text":"ITWILL학원 : 8강 JS기초 BY 정규태강사1.객체 Object 정의 자바스크립트는 객체기반의 언어객체는 기능, 속성을 포함하고 있는 것추상화된 객체를 사용할때 속성은 변수를 사용해서 표현하고 기능은 함수(매서드)를 사용해서 표현한다자바스트립트에서는 객체를 직접 만들어쓰지않고 만들어진 객체를 활용한다하지만 자바는 자주 직접 만들어서 사용한다 123let phone = new Object(); //여기서 phone은 참조변수phone.모델명 = \"아이폰\"phone.on(); //전원켜는 기능 실행 위의 phone을 참조변수라고 한다 객체종류 내장객체 자바스크립트엔진에 포함되어있는 객체 String : 문자를 처리하는 객체 Date : 날짜를 처리하는 객체 Array : 배열을 처리하는 객체 Math : 수학을 처리하는 객체 등등 브라우저 객체모델(BOM : Browser Object Model) 브라우저에 계층적으로 내장되어 있는 객체 즉 단계가 있는 객체 window screen location history navigator document 등등 문서 객체 모델(DOM : Document Object Model) HTML 테그의 문서구조 + CSS IE8이하의 버전에서 호환성이 떨어지기에 잘 안쓰게 된다 -&gt; 대신 jQuery문서객체모델을 사용 2. 내장객체1let 참조변수 = new 생성변수(); new : 객체(instance)를 생성하는 연산자이다 -&gt; 메모리에 올려서 사용할 수 있도록 준비 3. tv 채널up/down 함수만들기tv 채널 up과 down이 되는 함수를 만들어보자채널은 1부터 500까지 있다. 1234567891011121314function chUp(){ if(tv.ch &gt;= 1 &amp;&amp; tv.ch &lt; 500){ tv.ch ++; document.write(\"현재 채널 번호는 \" + tv.ch + \"번 입니다 &lt;br&gt;\") }else if(tv.ch == 500){ tv.ch = 1; document.write(\"현재 채널 번호는 \" + tv.ch + \"번 입니다 &lt;br&gt;\") }else{ tv.ch += 1; document.write(\"현재 채널 번호는 \" + tv.ch + \"번 입니다 &lt;br&gt;\") }}} 실행시마다 채널이 다운되는 함수는 아래와 같다 123456789101112function chDown(){ if(tv.ch == 0){ tv.ch = 500; document.write(\"현재 채널 번호는 \" + tv.ch + \"번 입니다 &lt;br&gt;\") }else if(tv.ch == 1){ tv.ch = 500 document.write(\"현재 채널 번호는 \" + tv.ch + \"번 입니다 &lt;br&gt;\") }else{ tv.ch -= 1; document.write(\"현재 채널 번호는 \" + tv.ch + \"번 입니다 &lt;br&gt;\") }} tv.ch가 499일때 두 함수를 호출해보면 1234567chUp() // 499 -up-&gt; 500chUp() //500 -up-&gt;501 -&gt;1chUp() //1 -up-&gt;2chDown() // 2 -down-&gt;1chDown() // 1 -down-&gt;500chDown() // 500 -down-&gt;499chDown() // 500 -down-&gt;499 4. new 를 쓰고 안쓰고의 차이new 연산자는 생성자함수이다.생성자란 객체를 생성할때 초기화하는 것이다. new를 쓰고 안쓰고의 차이가 뭘까? =&gt; 사용법의 차이가 있다(변수에 담아서 사용유무) 객체를 생성할때 new 연산(생성자함수)를 해야하는 객체 날짜객체 : Date() 변수를 생성해서 객체를 담아서 사용123let day = new Date(); //변수에 담아서 사용day.속성 //이렇게 사용해야함 new연산 없이 사용가능한 객체 수학 : Math 객체 =&gt; Math.floor(버림), Math.round(반올림), Math.ceil(올림), Math.max(여러값비교해서 최대값), Math.min(여러값비교해서 최소값), Math.abs(절대값), Math.random(0부터 1사이에 있는 실수를 랜덤하게 출력) 가장 자주 사용하는 것은 random이다 Math.floor(Math.random() *10)로 0부터 10까지의 랜덤양수를 출력한다 숫자 : Number 객체 문자 : String 객체 배열 : Array 객체 바로 사용가능 1Math.floor(); //변수에 담지않아도 바로 사용가능","link":"/2020/06/11/200612jspi/"},{"title":"ITWILL : Date객체 자세히, 디데이구하는 함수","text":"ITWILL학원 : 8강 JS기초 BY 정규태강사1. Date객체Date 객체의 특징 년,월,일 지정해서 객체를 사용 0부터 11까지를 1월부터 12월로 나타낸다. 1234567891011121314151617181920212223242526//참고로 today는 2020년 6월 12일이다.let today = new Date();document.write(today+\"&lt;br&gt;\")let day = new Date(2020,0,1); //month숫자를 0에서부터 세기때문에 1월1일은 0,1이 되어야함 document.write(day+\"&lt;br&gt;\")let day1 = new Date(2020,1,1); //2월1일document.write(day1+\"&lt;br&gt;\")let day2 = new Date(2020,0,1,11,30,5); //년,월,일,시,분,초 지정해서 객체사용가능document.write(day2+\"&lt;br&gt;\")let day3 = new Date(2020,0,1,11,61,5); //분에 61분을 적으면 자동으로 1시간이 올라감document.write(day3+\"&lt;br&gt;\")let day4 = new Date(\"2020/1/1\") //년,월,일만 가능. 시분초불가. 월을 나타낼때 0부터가 아니라 1부터 시작document.write(day4+\"&lt;br&gt;\") // 출력값 순서대로Fri Jun 12 2020 11:14:44 GMT+0900 (대한민국 표준시)Wed Jan 01 2020 00:00:00 GMT+0900 (대한민국 표준시)Sat Feb 01 2020 00:00:00 GMT+0900 (대한민국 표준시)Wed Jan 01 2020 11:30:05 GMT+0900 (대한민국 표준시)Wed Jan 01 2020 12:01:05 GMT+0900 (대한민국 표준시)Wed Jan 01 2020 00:00:00 GMT+0900 (대한민국 표준시) 변수에 저장한 date객체를 가져와서 사용해보자요일출력하는 getDay()의 경우 0(일)부터 6(토)까지를 나타낸다. 123456789101112131415//참고로 today는 2020년 6월 12일이다.let today = new Date();document.write(today.getFullYear() +\"&lt;br&gt;\") //년출력 year말고 fullyear써야함document.write(today.getMonth() +\"&lt;br&gt;\") //월출력 (0부터 11까지)document.write((today.getMonth()+1) +\"&lt;br&gt;\") //알아보기쉽게 1을 추가해서 사용document.write(today.getDate() +\"&lt;br&gt;\") //일출력document.write(today.getDay() +\"&lt;br&gt;\") //요일출력// 출력값 순서대로202056125 숫자로 들어온 요일을 글자로는 어떻게 바꿀수있을까?여러가지 방법이 있다 Array의 index 활용요일이 숫자로만 출력되어 아쉬운 경우에는 변수에 넣어 index를 이용하여 아래처럼 금요일 이렇게 출력되게 할수있다 123let today = new Date();let week = new Array('일', '월', '화', '수', '목', '금', '토')document.write(week[today.getDay()] + \"요일 &lt;br&gt;\") 제어문사용 (if나 switch)if나 switch를 통해 일일히 조건을 걸어 나열할수있다if는 많이 써보았으니 switch를 써보자 123456789101112131415161718192021222324252627function getToDay(day) { switch (day){ case 0 : document.write('일요일') break; case 1 : document.write('월요일') break; case 2 : document.write('화요일') break; case 3 : document.write('수요일') break; case 4 : document.write('목요일') break; case 5 : document.write('금요일') break; case 6 : document.write('토요일') break; }}getToDay(today.getDay()) 2. 디데이 계산하는 함수 구하기Date()객체를 활용하여 디데이를 계산한느 함수를 구해보자Date()객체에서는 사칙연산이 적용되는데 단위가 밀리초로 출력된다 밀리초 = 1/1000초 1초 = 1000msc 1분 = 60 * 1000 1시간 = 60 * 60 * 1000 하루 = 24 * 60 * 60 * 1000 12345678910function calculator(year, month, day){ let today = new Date(); let lastday1 = new Date(year,(month-1),day) //컴터는 0월부터계산하니까 사용자입력값에서 1을 빼줌 console.log(lastday1) let result = (lastday1 - today) / (24 * 60 * 60 * 1000); document.write(Math.ceil(result) + \"일 남았습니다 &lt;br&gt;\")}calculator(2020,12,31); //202일 남았습니다calculator(2020,06,14); //2일 남았습니다","link":"/2020/06/11/200612jspi2/"},{"title":"[ITWILL : WEB]테이블 칸 합치기","text":"ITWILL학원 : 3강 WEB(HTML, CSS) BY 김영희테이블 칸 합치기 colspan = “n” : 세로방향으로 합치는 속성 rowspan = “n” : 가로방향으로 합치는 속성 칸합치는 속성은 항상 th나 td에서 이루어지지 tr에서는 절대 사용하지않는다! rowspan을 생각할때는 빨래줄(tr)에 빨래(td나th)가 걸려있다고 생각하면 편하다기준을 몇번째 tr인지 확인한 뒤 빨래줄에 빨래를 걸면 아래로 내려오듯이 td가 내려와있다고 생각하면 된다. 칸 합치는 속성 가로방향 세로방향 colspan=\"n\" rowspan=\"n\" n개의 칸을 하나로 합치는 속성 12345678910111213141516&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;2&quot;&gt;칸 합치는 속성&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;가로방향&lt;/th&gt; &lt;th&gt;세로방향&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;colspan=&quot;n&quot;&lt;/td&gt; &lt;td&gt;rowspan=&quot;n&quot;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;n개의 칸을 하나로 합치는 속성&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 가로방향 합치기와 세로방향합치기가 동시에 나오는 예시는 아래와 같다rowspan을 위에서 말했던 빨래감예시를 들어 설명해보면, 첫 번째 tr의 빨래줄의 마지막 td에 아래 빨래감이 3개가 걸려야한다.(즉 3칸을 합친다)따라서 첫번째 tr의 두번째 td에 rowspan=”3”를 해준다 12345678910111213141516&lt;table&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;a&lt;/td&gt; &lt;td rowspan=&quot;3&quot;&gt;b&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;c&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;d&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;e&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;f&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","link":"/2020/06/11/200612webi/"},{"title":"ITWILL : Array객체 (for ~ in구문, join(), reverse(), sort())","text":"ITWILL학원 : 8강 JS기초 BY 정규태강사1. 배열객체(Array)내장객체 중에서 가장 활용도가 높은 것은 배열객체이다.연속된 공간에 여러개의 데이터를 저장하는 객체이다.배열에 들어있는 데이터를 요소(Element)라고 부른다.배열의 index는 0부터 시작한다. 그리고 마지막 index는 (배열의 크기 - 1)이다.배열의 요소는 변수처럼 사용가능 -&gt; 주로 반복문에 활용해서 사용한다.JS의 경우 모든 데이터타입을 한 배열안에 넣기 가능하다. 1let arr = [1,2,\"Hello\", true, 3]; 2. for ~ in 구문변수의 값을 0부터 배열 객체의 개수만큼 반복하는 구문.자동적으로 배열 객체의 길이를 계산한다. 1234for(let i in arr){ document.write( arr[i]+ \" \")}//출력값은 1 2 Hello true 2 JS 3. array.join();요소들을 출력할 때 사이에 입력하여 출력하는 방법은 join()을 쓰면 쉽게 해결된다 12document.write(arr.join(\" \"))//출력값은 1 2 Hello true 2 JS 위의 출력값과 아래의 출력값의 차이는 딱 하나이다.마지막 요소에 스페이스의 입력유무이다.join()의 경우 마지막요소에 입력되지 않으니 더욱 유용하다 12document.write(arr.join(\",\"))//출력값은 1,2,Hello,true,2,JS 4. array.reverse();배열안의 요소를 역순으로 출력하고 싶다면 반복문을 먼저 생각해볼수있다.반복문을 이용하면 임시값에 뒷요소부터 넣어서 반복할 수 있다.하지만 array에 좋은 내장함수가 있다.바로 reverse()이다reverse()는 배열의 순서를 반대로 처리한다. 1234arr1 = [1,2,\"hi\", \"a\", \"A\", \"가\", \"나\"];document.write(arr1.reverse())//출력값 나,가,A,a,hi,2,1 기본적으로 콤마(,)가 함께 출력된다.이 콤마를 없애고 싶다면 reverse후에 join을 하면 된다 12document.write(arr1.reverse().join(\" \"))//출력값 나 가 A a hi 2 1 5. array.sort();낮은 순자부터 높은 숫자로 오름차순으로 출력한다. 1234arr2 = [1,2,\"hi\", \"a\", \"A\", \"가\", \"나\"];document.write(arr2.sort())//출력값 1,2,A,a,hi,가,나","link":"/2020/06/14/200615jspi/"},{"title":"[패스트캠퍼스python] Django 홈페이지 실습: max-width와 min-width속성, margin과 padding의 단축속성","text":"파이썬 인강 자기계발 챌린지 22회차 미션이때까지 배운 HTML와 CSS를 가지고 Django 사이트를 만들어보는 실습을 해보자.참고링크 : Django 1. 전체 페이지 레이아웃잡고 마크업하기먼저 홈페이지를 보고 레이아웃을 잡고 미리 스케치하는 것이 좋다.그래야 안 헷갈리고 필요한 태그들만 사용하여 깔끔한 마크업이 가능하기때문이다. 지난 포스팅에서 Django홈페이지 전체를 스케치한 이미지이다. 전체 홈페이지를 가장 큰 세가지부분으로 나눈다 Header main footer 그 뒤로 안에 있는 요소들을 스케치한 뒤 그대로 마크업하면 된다!간단한 작업처럼 보이지만 깔끔하게 잘 만들기 여건 어려운 것이 아니다.나도 강사님처럼 척보면 척하고 짜임새있게 짜고 싶다. 2. Header 전체구상먼저 첫번째 큰 부분인 Header부분이다.안을 보면 logo와 navigator로 나눌 수 있다.logo안은 이미지태크와 링크를 넣어 이미지를 누를때마다 홈으로 돌아가게끔 구현할 것이다.navigator는 ul태그로 만들어서 li태그에 a태그를 넣어 li태그를 누를때 관련 페이지로 이동할 수 있도록 구현할 것이다. logo logo img + link to home navigator list li + link to overview page li + link to download page li + link to documentation page li + link to news page li + link to community page li + link to code page li + link to issues page li + link to about page 스케치를 보고 그대로 html를 작성해주면 좋다.위의 이미지처럼 class 이름까지 지정해서 하면 훨씬 편하고 빠르게 마크업할수있다. li태그와 a태그는 묶어서 총 8번 작성해야한다. 이때 효율적으로 코드를 작성할 수 있는 방법이 있다. 123456789101112 (li&gt;a)*8 // 출력값은&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; li태그 안에 a태그를 만들고 전체를 곱하기 8번해서 총 8개의 태그를 만들게 된다.참~ 쉽죠? 3. max-width 속성과 min-width속성브라우저의 크기를 조절할때, 브라우저가 일정한 크기에 도달할 경우 더이상 콘텐츠의 크기도 같이 줄어들거나 늘어나지 않는다.이러한 속성을 max-width와 min-width라고 한다. 브라우저 전체 넓이가 1060px이 되면 더 이상 줄어들지 않도록 지정하고 1400px이 되면 더 이상 늘어나지않도록 지정해보자. 이를 위해서 먼저 생각해야할 것이 어느 부분에 max-width와 min-width를 적용시킬 것인 가이다. 브라우저 전체 넓이가 일정크기보다 작아지면 모든 요소들이 다 작아지다가 멈춰야하므로 body에 min-width를 주면 된다. 반면 브라우저 전체 넓이가 일정크기보다 커지면 header는 크기와 상관없이 양옆에 컬러가 계속 칠해져있어야하므로 container를 주어 container태그안에 max-width속성을 적용하여 디자인을 유지할 수 있다. 12345678body{ min-width: 1060px;}.container{ max-width: 1400px; margin: 0 auto 0 auto;} 4. margin과 padding의 단축속성margin과 padding값을 주는 데는 총 4가지 단축 방법이 있다. { margin: 0 auto 0 auto}이렇게 4개가 나열되어 있는 경우의 순서는 top right botton left순이다. { margin: 0 auto 10px }이렇게 3개 값이 나열되어 있는 경우에는 순서가 첫번째값은 top, 두번째 값은 left와 right 그리고 마지막 값은 bottom이다 즉 { margin: 0 auto 10px } 는 { margin: 0 auto 10px auto} 와 동일한 값을 가진다. { margin: 0 auto }이렇게 2개가 나열되어 있는 경우의 순서는 첫번째값은 top botton에 적용 두번째 값은 left와 right에 적용된다. 즉 { margin: 0 auto } 는 { margin: 0 auto 0 auto} 와 동일한 값을 가진다. { margin: 10px }이렇게 1개 값만 있는 경우는 어디에 값이 적용될까?정답은 모든 곳에 적용된다.다시말해 10px이 top right botton left에 각각 적용된다. 즉 { margin: 10px } 는 { margin: 10px 10px 10px 10px } 와 동일한 값을 가진다. 5. display: inline-block;display속성에 inline-block을 넣어보자. 1234567.nav{ text-align: right;}.list-items{ display: inline-block;} 아래 이미지를 순서대로 본다면 1번에는 적용되지 않은 순수한 모습에서위의 코드를 적용한 후 3번을 본다면 예쁘게 오른쪽으로 카테고리가 일렬로 배열되어 있는 것을 확인할 수 있다. 6. position: absolute; 와 relative; 적용가장 헷갈리는 position속성을 적용하기 전후를 비교해보자. position : relative;로는 어떠한 값도 바꿀 수 없다.그 밑에 꼭 top, bottom, left, right의 값을 통해 어디를 얼만큼 이동할 것인지 정할 수 있다. 12345678910111213.container{ max-width: 1400px; background-color: red; margin: 0 auto; padding: 0 20px; position: relative; //normal flow의 속성에 변화가 있는 것이 아니기때문에 화면에 출력될때 변화가 없다}.logo{ position: absolute; top: 0; left: 0; } 1번은 위의 태그를 적용하기 전의 모습이고 container클래스에 position: relative;를 적용하고 logo클래스에 position: absolute;를 적용을 하면 아래 이미지의 3번으로 화면에 출력된다.","link":"/2020/06/14/200615python/"},{"title":"ITWILL : 이벤트리스너와 이벤트핸들러, 브라우저객체모델, window객체전체","text":"ITWILL학원 : 8강 JS기초 BY 정규태강사1. 이벤트브라우저에서 사용자가 취하는 모든 행동을 이벤트라고 한다 이벤트 : - 브라우저에서 사용자가 취하는 모든 행동 - ex)button 이벤트리스너 : - 이벤트 발생정보를 체크해서 해당 핸들러로 전달 - ex) onclick 이벤트핸들러 : - 이벤트 발생시 특정 동작을 처리해주는 동작 - 자바스크립트 함수를 실행시켜서 작동한다 즉, js함수실행가능 - 태그의 스타일정보 변경가능 - ex) alert(‘버튼클릭’), open() 등등 보통을 keydown해서 keyup을 해야 즉, 키보드를 눌렀다가 떼면 데이터가 입력된다.따라서 키이벤트를 처리할때는 keyup일때 이벤트를 걸어줘야 keydown일때보다 정확한 처리가 가능하다 1234&lt;input type=\"button\" value=\"버튼\" onclick=\"alert('버튼클릭');\"&gt;&lt;br&gt;&lt;input type=\"button\" value=\"버튼2\" ondblclick=\"alert('버튼더블클릭');\"&gt;&lt;br&gt;&lt;input type=\"button\" value=\"버튼3\" onmouseover=\"alert('마우스오버');\"&gt;&lt;br&gt;&lt;input type=\"text\" name=\"txt\" onkeyup=\"alert('키업!');\"&gt;&lt;br&gt; 참고링크 : onmouseleave와 onmouseout의 차이점 2. 브라우저객체모델(BOM : Browser Object Model)우리가 사용하는 인터넷브라우저안에 내장되어있는/포함되어있는 객체를 말한다.특징 계층적구조 : 단계별로 표시할 수 있다. 최상위레벨 : window객체 그 아래레벨 : document객체, screen객체, location객체, history객체, navigator객체 정확한 구조를 표현한 문장인 window.document.write() 사용해야하지만 최상위 객체는 생략해서 document.write()로 사용한다. 3. window객체브라우저 객체이 최상위 객체.객체이기때문에 당연히 속성과 함수들을 가지고 있다. window.open(“url주소 “, “창이름(title태그와 동일한 기능)”, “옵션”); 새창열기 window.location.href=’url주소’; 현재페이지에서 열기 window.close(); 현재 창 닫기 window.alert(); 알림 팝업창 열기 window.confirm() : 팝업창을 열어서 확인/취소 버튼으로 Boolean 데이터를 받는 함수 window.prompt(); 팝업으로 input창 열기 window.setInterval(“자바스크립트실행문”,밀리초시간); 일정시간동안에 자바스크립트실행문을 실행하는 함수 window는 최상위객체이기때문에 window를 생략하고 사용할 수 있다. 예시1 : window.open(), window.close(), window.location 12&lt;input type=\"button\" value=\"새창열기\" onclick=\"window.open('http://www.naver.com')\"&gt;&lt;input type=\"button\" value=\"현재페이지열기\" onclick=\"location.href='http://www.naver.com'\"&gt; 이렇게 input태그에 많은 내용이 들어가면 보안상의 위험이 있으므로 js에 넣어서 사용한다.참고로 아래 코드에서 점점(..)은 상위폴더로 이동을 의미한다. 12345678function winOpen(){ open(\"http://www.naver.com\") //window생략가능}&lt;input type=\"button\" value=\"새창열기\" onclick=\"winOpen();\"&gt;function pageOpen2(){ open(\"../JS2/Test5.html\") //점점(..)은 상위폴더로 이동을 의미한다.} 예시2 : setInterval(()=&gt;{js실행문}, 밀리초) 3초에 한번씩 숫자를 찍는 함수를 아래코드와 같이 만들수있다.java에서 스래드와 비슷한 개념이다. 123456let i=0;let inter = setInterval(() =&gt; { console.log(i++)}, 3000); //3초에 한번씩 숫자찍기clearInterval(inter); //변수에 담은 interval데이터를 clearInterval()함수로 멈출수있다.","link":"/2020/06/14/200615jspi3/"},{"title":"virtualBox로 가상컴퓨터만들어서 리눅스Linux 설치하기","text":"virtualBox로 가상컴퓨터 만들기 새로만들기클릭 이름명:원하는대로(혹시 오류가 발생한다면 예약어가 있을수있으니 다양한 이름으로 시도해볼 것.), 종류 : Linux 버전:Red hat 64bit 메모리크기 1024MB 하드디스크 : 지금 새 가상 하드 디스크만들기 틱 하드디스크 파일 종류 : VDI 물리적 하드 드라이브에 저장 : 동적할당 파일 위치 및 크기 : 30GB 만들어진 가상컴퓨터 설정하기 Linux 설정 &gt; 시스템 &gt; 마더보드 : 하드웨어 시각을 UTC로 보고하기 틱해제 &gt; 프로세서 : 프로세서 개수 2개 설정 후 저장 Linux 설정 &gt; 시스템 &gt; 저장소 : 컨트롤러 아래 비어있음 클릭 &gt; 광학드라이브 옆 CD아이콘클릭 &gt; 가상 광 디스크파일 클릭 &gt; 받아놓은 .iso 파일 선택 후 열기클릭 Linux 설정 &gt; 시스템 &gt; 저장소 : 컨트롤러 SATA 클릭 &gt; 호스트 I/O캐시 사용하기 틱 &gt; 확인 가상컴퓨터 실행하여 linux 설정하기설치 설정하기 최소설치 : 서버컴퓨터인 경우 최소설치를 활용하여 보안을 높여줌 GNOME(그놈) 데스크탑 : 윈도우 환경과 가장 유사하여 초보자에게 적합한 GUI환경이다. 파티션 : 차후에도 설정가능. KDMUP : 시스템끼리 충돌시 데이터를 모아서 따로 저장을 함 -&gt; 메모리를 잡아먹고 성능저하의 원인이 되기때문에 활성화꺼짐으로 선택하는 것이 좋다 root암호 : 관리자권한으로 실행할때 필요한 암호 사용자생성 : 차후에도 설정가능. 설치 후 재부팅하기재부팅 후 설정하기","link":"/2020/06/15/200616dbi/"},{"title":"정규식을 이용한 전화번호 형식변환","text":"숫자를 전화번호 형식으로 변환숫자를 받은 후 그 숫자를 전화번호형식으로 변화시키고 싶다.if else문을 사용해서 나타낼 수 있겠지만 엄청 길었다.검색해보니 정규식을 이용한 깔끔한 코드를 찾았다 123function phoneformat(num){ return num.replace(/(^02.{0}|^01.{1}|^[0-9]{3})([0-9]*)([0-9]{4})/, \"$1-$2-$3\");} 코드를 설명하자면 뒤에서 설명하는 게 편하다. “$1-$2-$3” 이 부분은 $1과 $2 그리고 $3를 하이픈(-)으로 연결했다.그렇다면 $1과 $2, $3는 뭘까?앞에 괄호와 연결된다 콤마(,)앞에 식을 자세히보면 (/()()()/,”$1-$2-$3”); 이렇게 볼 수 있다.괄호안의 연산된 값이 순서대로 $1, $2, $3에 대입된다고 보면 된다. ([0-9]{4}) 뒤의 괄호부터 차근차근 풀어보자0에서부터 9까지의 숫자중에 4개의 숫자를 가지겠다는 의미이다 ([0-9] * ) 0에서부터 9까지의 숫자중에 모든 남는 숫자를 가지겠다는 의미이다여기서 남는 숫자란, 총 11자리중에 앞에서 3자리, 뒤에서 4자리를 가져간다면 그 나머지숫자은 4개를 가져가겠다는 의미이다. (^02.{0}|^01.{1}|^[0-9]{3})^은 정규식을 시작한다는 의미이다. {0} 는 02로 시작할경우, .{0}는 문자하나를 출력하겠다는 의미이고 뒤에 오는 숫자를 쓰지않고 02만 출력된다|는 or연산자역할이다.^01.{1}는 01로 시작할경우, .{1}는 01 이후로 오는 1자리까지 숫자를 출력하겠다는 의미이고 여기서는 01x가 된다.[0-9]{3}는 0부터 9까지 숫자중에서 입력된 3가지 숫자를 가지겠다는 의미이다.","link":"/2020/06/14/200615me/"},{"title":"ITWILL : String객체, 짤라오는 함수 4종류 .substring(), slice(), substr(), charAt(), .indexOf()와 .lastIndexOf()차이, .concat(), .split(), ID자릿수를 제한하는 이메일 유효성검사","text":"ITWILL학원 : 8강 JS기초 BY 정규태강사1. 문자열객체(String)문자열객체는 배열처럼 데이터를 저장한다. 123let name = new String(\"Hong\") //문자열객체let name2 = \"Kim\" //문자열데이터(문자열상수) 둘 다 문자열객체로 사용할수있다. 문자열객체는 두가지타입의 function을 가지고있다.스타일을 지정하는 타입의 함수와 데이터를 처리하는 타입의 함수이다. 스타일을 지정하는 함수 폰트를 굵게 표시한다.하지만 스타일을 지정하는 함수는 실제론 거의 사용하지않는다.실무에선 스타일은 css로 지정한다그렇지만 굳이 css를 쓰지않더라도 이렇게 스타일을 지정할 수있다는 사실을 알고있어야한다. 참고로 toUpperCase()와 toLowerCase()는 사용할 수 도 있다 123document.write(\"name : \" + name.bold()); //굵게 출력document.write(name.toUpperCase()+\"&lt;br&gt;\"); //모두 대문자로 출력document.write(name.toLowerCase()+\"&lt;br&gt;\"); //모두 소문자로 출력 체이닝기법함수를 연결하여 한번에 사용하는 형태이다. 1document.write(msg.fontcolor(&quot;red&quot;).fontsize(&quot;15&quot;).bold()) 위의 코드를 통해 msg의 글씨색깔은 빨간색이며 폰트사이즈는 15이고 굵게 출력된다. 데이터를 처리하는 함수 아래 함수들(2번부터 ) 모두가 데이터를 처리하는 함수이다. 2. .length길이를 구하는 함수이다 3. 짤라오는 함수 4종류 .substring(), slice(), substr(), charAt()substring(시작인덱스,끝인덱스)는 시작부터 끝 인덱스 앞자리까지 짤라온다.substring(인덱스) 이처럼 인덱스를 하나만 적는 경우에는 시작인덱스로 취급하여 시작인덱스부터 끝까지 다 짤라온다. 123456let name3 = \"이번년도는 복세편살!\"document.write(name3.substring(2,6))document.write(name3.substring(2))//출력값 년도는년도는 복세편살! 이것과 비슷한 함수로는 아래 세 가지가 있다. slice(시작,끝) : 시작인덱스부터 끝인덱스의 앞자리까지 짤라오는 함수 substr(시작인덱스,갯수) : 시작인덱스부터 갯수만큼 짤라오는 함수 .charAt(인덱스) : 해당 인덱스에 있는 문자데이터를 가져온다. 123456let name3 = \"이번년도는 복세편살!\"document.write(name3.charAt(0)) //첫번째글자 가져오기document.write(name3.charAt(name3.length-1)) //제일 끝 글자가져오기// 출력값이! 예시 1. 주민번호로 성별 구분 코드짤라오는 함수를 이용하여 주민번호로 성별을 구분하는 코드를 작성해보자총 4가지 방법의 함수로 짤라올수가 있다! 12345678910111213let num = prompt(\"주민번호를 -와 함께 입력하세요\") let checkNum = num.substring(7,8); //첫번째방법 substring사용let checkNum = num.slice(7,8); //두번째방법 slice사용let checkNum = num.substr(7,1); //세번째방법 substr사용let checkNum = num.charAt(7); //네번째방법 charAt사용if(checkNum === \"2\" || checkNum === \"4\"){ document.write(\"여성입니다\")}else if(checkNum === \"1\" || checkNum === \"3\"){ document.write(\"남성입니다\")} 예시 2. 전화번호 중간자리 가리기위에서 배운 함수로 출력이 가능하나 마지막방법인 charAt는 1자리만 가져오는 것이기때문에 불가능하다.따라서 3가지 방법으로 코드를 작성할 수 있다. 1234let phonenum = prompt(\"전화번호를 -와 함께 입력하세요\")let mobile = \"010-****-\" + phonenum.substring(9) //첫번째방법 substring사용let mobile = \"010-****-\" + phonenum.slioce(9) //두번째방법 slice사용let mobile = \"010-****-\" + phonenum.substr(9) //세번째방법 substr사용 5. .indexOf()String안에 내가 원하는 값이 있는지 찾아보는 방법으로 indexOf()를 사용한다.indexOf()의 괄호안에는 찾고싶은 요소를 입력한다해당 요소가 있는 경우에는 왼쪽에서 시작해서 제일 먼저 만나는 index의 위치를 알려주고해당 요소가 없는 경우에는 -1이 출력된다. 1234567let name3 = \"이번년도는 복세편살이야\"document.write(name3.indexOf(\"이\")+\"&lt;br&gt;\")document.write(name3.indexOf(\"하\")+\"&lt;br&gt;\")//출력값은0-1 현재 name3안에는 “이”가 2개가 있지만 첫번째 “이”의 index위치를 알려주고 있다.중복되는 데이터의 첫번째 index 위치만 알려주기때문에 중복데이터가 있으면 그 위치가 어디인지 찾기가 어렵다.그럴때 사용하는 함수가 아래에 있는 .lastIndexOf()이다. 6. .lastIndexOf()String안에 내가 원하는 값이 있는지 찾아보는 방법으로 lastIndexOf()를 사용한다.lastIndexOf()의 괄호안에는 찾고싶은 요소를 입력한다해당 요소가 있는 경우에는 오른쪽에서 시작해서 제일 먼저 만나는 index의 위치를 알려주고해당 요소가 없는 경우에는 -1이 출력된다. 1234567let name3 = \"이번년도는 복세편살이야\"document.write(name3.indexOf(\"이\")+\"&lt;br&gt;\")document.write(name3.indexOf(\"하\")+\"&lt;br&gt;\")//출력값은11-1 7. .concat()괄호에 추가하고싶은 데이터를 작성하여, 데이터를 추가하는 방법에는 아래처럼 두가지가 있다. 더하기 연산자사용 .concat()사용 1234567let name3 = \"이번년도도는 복세편살이야\"document.write(name3 + \"!!!!\"+\"&lt;br&gt;\")document.write(name3.concat(\"!!!!\")+\"&lt;br&gt;\")//출력값이번년도도는 복세편살이야!!!!이번년도도는 복세편살이야!!!! 8. .split()괄호안의 값을 기준으로 문자를 파싱(나누기)후 배열에 저장한다. 1234567let name3 = &quot;이번년도도는 복세편살이야&quot;document.write(name3.split(&quot; &quot;)+&quot;&lt;br&gt;&quot;)document.write(name3.split(&quot; &quot;)[0]+&quot;&lt;br&gt;&quot;)//출력값 : 괄호가 스페이스이므로 스페이스 기준으로 2개가 나누어진다.이번년도도는,복세편살이야이번년도도는 9. ID자릿수를 제한하는 이메일 유효성검사userEmail.indexOf(“@”) &gt;= 0)에서0대신에 다른 숫자를 넣으면 해당 숫자에 따라 최소 ID의 자리수가 달라지는 로직을 만들수있다.userEmail.indexOf(“@”) &gt;= 8)인경우 8자리이상 ID만 true가 된다. 이런 로직을 잘 짜야지 좋은 개발자가 될 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839function check(userEmail){ let check1 = false; //@유무 체크 let check2 = false; //유효한 이메일주소 체크 let emailArr = [\".co.kr\", \".com\", \".net\", \".or.kr\", \".go.kr\"] if(userEmail.indexOf(\"@\") &gt;= 0){ //숫자에 따라 최소 ID의 자리수가 달라짐 8인경우 8자리이상id필요 check1 = true; } for(let i=0; i&lt;emailArr.length; i++){ //document.write(emailArr[i] + \"&lt;br&gt;\")//출력 if(userEmail.indexOf(emailArr[i]) &gt;= 0){ check2 = true; break; } } if(check1 &amp;&amp; check2){ document.write(\"사용자 이메일 확인완료 : \"+ userEmail +\"&lt;br&gt;\") }else{ document.write(\"이메일주소 오류!&lt;br&gt;\") }}check(\"s.co.kr\")check(\"s.cd\")check(\"s@.co.kr\")check(\"2@.com\")check(\"2@.or.kd\")check(\"2@.cd\")//출력값이메일주소 오류!이메일주소 오류!사용자 이메일 확인완료 : s@.co.kr사용자 이메일 확인완료 : 2@.com이메일주소 오류!이메일주소 오류!","link":"/2020/06/14/200615jspi2/"},{"title":"[ITWILL : JAVA]비트연산자, 이진수와 십진수 변환","text":"ITWILL학원 : 7강 JAVA BY 윤미영강사1. 비트연산자2진수 형태로 연산을 진행한다.따라서 2진수로 표현할 수 있는 정숨나이 피연산자가 될 수 있다.흔히 쓰는 건 아니고 임베디드개발환경이나 안드로이드개발환경에서 종종 사용하는 연산방법이다. a /= b의 의미는 a|b 연산값을 a에 할당한다는 의미이다. 참고링크 : 비트연산자 개념 및 예시 2. 이진수와 십진수 변환비트연산자를 잘 활용하려면 십진수와 이진수의 변환이 머리속에서 빨리 일어나야한다 ㅋㅋㅋㅋㅋㅋㅋㅋ이진수는 중학교때 배웠을 거같지만… 기억나지않으므로 다시 한번 더 보자.","link":"/2020/06/16/200617javai/"},{"title":"ITWILL : 브라우저객체모델안의 Document객체 (bgColor와 fgColor사용,  img태그에 접근하여 속성 사용, 랜덤 img 출력하기)","text":"ITWILL학원 : 9강 JS기초 BY 정규태강사1. Document 객체해당 html문서를 객체로 표시한 것(객체화)이 여기서 말하는 document이다. 2. Document 객체 : bgColor와 fgColor사용 document.bgColor=”” ; 배경색상을 변경함 document.fgColor=”” ; 글자색상을 변경함 위를 활용하여 체크박스를 틱하고 틱을 해제함으로써 배경색과 글자색이 바뀌는 함수를 만들어보자. 1234567891011&lt;input type=\"checkbox\" onclick=\"checkf1(this);\"&gt; 체크박스 온오프로 핑크테마&lt;br&gt;function checkf1(obj){ if(obj.checked){ document.bgColor= '#ffbdbd'; document.fgColor= 'white'; }else{ document.bgColor= 'white'; document.fgColor= 'black'; }} 3. Document 객체 : img태그에 접근하여 속성 사용img태그에 접속하여 속성을 이용해보자 document.images[0].name : 이미지태그 네임을 모를 경우 인덱스활용해서 name불러옥; document.img1.name : 이미지태그 네임을 알경우 name불러오기 document.img1.src : 이미지태그 네임을 알경우 먼저 이미지태그를 만들어보자 12&lt;img src=\"1.jpg\" name=\"img1\"&gt;&lt;input type=\"button\" value=\"이미지속성정보\" onclick=\"fun1()\"&gt;&lt;br&gt; 그리고 이 이미지태그의 속성을 알아보자위에서 만든 버튼태그를 눌릴때마다 속성을 알아보는 방법이다. 1234567891011function fun1(){ alert(\"너의 이름은? \"+document.images[0].name); alert(\"너의 이름은? \"+document.img1.name) alert(\"너의 주소는? \"+document.img1.src) }//출력값은img1img1file:///D:/workspace_jsp7/JavaScript/WebContent/JS3/2.jpg 4. Document 객체 : 랜덤 img 출력하기1부터 6까지 총 6개의 이미지를 랜덤하게 가져와서 이미지태그에 보더, 가로,세로 크기를 변경하는 함수를 만들어 보자 첫번째는 랜덤함수를 이용하는 방법이다 123456789101112131415161718192021&lt;img src=\"1.jpg\" name=\"img1\" onmouseover=\"changeImg()\" onmouseout=\"resetImg()\"&gt;&lt;br&gt;function changeImg(){ let randomNum = Math.floor(Math.random()*6 + 1); //1~6까지 document.img1.src = randomNum+\".jpg\" //1~6까지 console.log(randomNum) document.images[0].border = 2; document.images[0].width = 200; document.images[0].height = 150;}function resetImg(){ document.img1.src = \"1.jpg\" document.images[0].border = 0; document.images[0].width = 80; document.images[0].height = 60;} 두번째 방법은 배열이용하는 방법이다전자보다 더 많이 사용한다 위와의 차이점은 두가지이다. imgArr이라는 배열안에 이미지를 담았다 randomNum만들때 배열은 0부터 시작이고 이미지도 0부터 시작이므로 +1을 할 필요가 없다. 1234567891011121314151617181920212223&lt;img src=\"1.jpg\" name=\"img1\" onmouseover=\"changeImg()\" onmouseout=\"resetImg()\"&gt;&lt;br&gt;let imgArr = [\"1.jpg\", \"2.jpg\", \"3.jpg\", \"4.jpg\", \"5.jpg\", \"6.jpg\"] //0~5번까지밖에없다function changeImg(){ let randomNum = Math.floor(Math.random()*6)//0~5까지 document.img1.src = imgArr[randomNum] //0~5까지 console.log(randomNum) document.images[0].border = 2; document.images[0].width = 200; document.images[0].height = 150;}function resetImg(){ document.img1.src = \"1.jpg\" document.images[0].border = 0; document.images[0].width = 80; document.images[0].height = 60;}","link":"/2020/06/15/200616jspi/"},{"title":"ITWILL : 브라우저객체모델안의 location객체","text":"ITWILL학원 : 9강 JS기초 BY 정규태강사1. location객체브라우저의 url(주소창)에 대한 정보를 가지고 있는 객체 location.href : 페이지이동. 현재브라우저의 주소창의 정보url를 리턴 1location.href=\"Test2.html\" location.protocol : 프로토콜은 통신규약이다 어떤 방식으로 어떤 속도로 해당 통신을 할껀지 약속. 웹통신을 위한 프로토콜 http: http:// 보안이 더 강화됨 location.hostname location.host location.reload(); 페이지새로고침(F5번과 동일한 기능) location.replace(url); 입력한 url로 페이지 이동 123456789101112131415161718&lt;input type=\"button\" value=\"location속성\" onclick=\"fun1()\"&gt;function fun1(){ alert(\"href : \" +window.location.href + \" protocol : \" +window.location.protocol + \" hostname : \"+location.hostname + \" host : \"+location.host + \" port : \"+location.port + \" search : \" + location.search);}//출력값은href : http://localhost:8088/JavaScript/JS3/Test3.htmlprotocol : http: hostname : localhost host : localhost:8088 port : 8088 search :","link":"/2020/06/15/200616jspi2/"},{"title":"[패스트캠퍼스python] Django 홈페이지 실습: web font, a태그 밑줄제거, 마우스오버시 글자색상변경, float적용방법","text":"파이썬 인강 자기계발 챌린지 23회차 미션1. web font사용폰트패밀리로 폰트를 지정해주었을 때, 만약 사용자가 해당 폰트를 다운로드해서 가지고 있지않으면 폰트 적용이 아예 안된다.이를 방지하기위해 웹폰트를 사용하면 사용자가 굳이 다운로드하지않더라고 폰트가 적용된 채로 홈페이지를 볼 수 있다. 웹폰트는 무료도 있고 유료도 있지만 제일 유명한 구글폰트는 무료이다. 구글웹폰트 구글웹폰트깃허브 : 한글 눈누 : 한글폰트로 유로뿐만 아니라 무료상업용웹폰트도 쉽게 찾을 수 있다. 웹폰트 사용법은 간단하다. 웹폰트의 link태그를 복사하여 head태그 사이에 붙여넣기하면 된다. 2. a태그 밑줄제거 text-decoration: none;a태그등을 링크를 나타나내는 태그를 사용하면 자동적으로 밑줄이 나타난다.이를 없애주기 위해서 { text-decoration: none; }을 주면 된다 아래 1번은 a태그의 본래 그대로의 모습이고 이제 { text-decoration: none; }를 적용하면 3번처럼 밑줄이 없이 예쁘게 출력되는 것을 볼 수 있다. 3. 카테고리 기본 레이아웃만들기 display: block; + padding: 10px;list-itmes밑에 있는 8개의 a태그를 한꺼번에 선택하는 방법에는 두가지가 있다.편한 방법으로 선택해주면 된다. 첫번째 방법 : .list-items a {} 12345.list-items a{ color: white; display: block; padding: 10px;} 두번째 방법 : .list-items &gt; a {} 12345.list-items &gt; a{ color: white; display: block; padding: 10px;} 1번은 위의 태그가 적용되기 전의 모습이고 3번은 적용된 후의 모습이다.패딩을 넓게 주어 사용자가 카테고리를 편하게 선택할 수 있도록 했다. 기본적으로 홈페이지 만들때 자주 사용되니 알아두면 좋다. 4. 가상클래스이용해서 마우스오버시 색상변경 구현가상클래스를 이용하여 카테고리에 마우스를 올리면 글자색상을 변경해보자.기존 글자색사은 흰색이고 해당 클래스에 마우스를 올리면 검정색으로 글자색이 변한다. 123list-items &gt; a:hover { color: black;} 이러한 디자인으로 사용자에게 지금 어느 카테고리위에 마우스가 있는지 친절하게 알려주어 사용성이 올라간다. 5. float 적용방법 위의 이미지는 메인콘텐츠와 사이드콘텐츠에 각각 { float : left; }, { float : right; }를 주었다.이로 인해 3가지 문제점이 발견된다. 하늘색은 main태그인데 main영역이 메인콘텐츠와 사이드콘텐츠의 높이를 전혀 인지하지못하고 있어 히어로콘텐츠와 메인콘텐츠, 사이드콘텐츠의 높이를 함께 포함하고 있어야하는데 히어로콘텐츠의 높이만 인식하고있다. 초록색은 footer태그인데 footer영역이메인콘텐츠와 사이드콘텐츠의 영향을 받고 있어 높이가 메인콘텐츠와 사이드콘텐츠만큼 올라와 있다. float된 속성은 normal flow에서 벗어나기때문에 자기자신의 높이를 상위태그가 알지 못하게 된다.normal flow에서 벗어났다는 의미는 해당 부분이 띄어져있다는 의미이다.따라서 이에 영향을 받는 태그들에게 { clear : both; }를 해줘서 자신의 높이를 찾도록 해줘야한다. 1번문제 해결방법 : float한 태그들을 div.container-float로 묶은 뒤 div.container-float에 가상요소를 주고 그 가상요소에 { clear : both; }를해준다. 메인콘텐츠와 사이드콘텐츠를 div.container-float안으로 감싸준다. .container-float에 가상요소를 주어 { clear : both; } 를 적용시킨다. 12345.container-float ::after{ //가상요소after display: block; content: \"\"; clear: both;} 2번문제 해결방법 : footer { clear : both; } footer태그에 아래와 같이 { clear : both; }속성을 적용시킨다.123.footer{ clear: both; }","link":"/2020/06/15/200616python/"},{"title":"[ITWILL : JAVA]자바포맷스트링, Random 숫자 뽑기, 상황별 반복문 추천(for, while, do~while)","text":"ITWILL학원 : 8강 JAVA BY 윤미영강사1. JAVA format string자바 format string은 System.out.printf(“”,)를 이용하여 나타낸다. 주요한 변환코드는 아래와 같다. 포맷스트링으로 자릿수도 표현할 수 있다. 2. Random 숫자 뽑기 Random 라이브러리 : 무작위 숫자를 생성하기 위해 Random 객체를 사용해야하기때문에 import해야한다. null : 아무 값이 없다. 예약어이고 실제 값은 맨 뒤에 위치해있다. 실무에선 null보단 “”로 String을 초기화시켜준다. 왜냐하면 보통 DB에서 데이터를 가져와서 사용하는 경우가 많은데 null로 초기화해버리면 생각하지 못한 에러가 발생할 수 있기때문이다. nextlnt(n); : 매서드로 0 ~ (n-1)사이의 무작위 정수를 생성한다. 아래 코드는 0부터 99중에 랜덤숫자를 뽑아서 50이상이면 큰수로 출력하고 그 이하면 작은수로 출력한다. 12345678910111213141516import java.util.Random;public static void main(String[] args) { String result = null; Random myRandom = new Random(); System.out.println(\"----- 큰수 작은수체크\"); int num1 = myRandom.nextInt(100); //0 &amp;#126; 99사이의 정수 if(num1 &gt;= 50){ result =\"큰 수\"; }else{ result =\"작은 수\"; } System.out.printf(\"%d는 %s이다.%n\", num1, result);} 2. 상황별 반복문 추천반복문은 크게 3가지 종류가 있다.for 문, while 문, do ~ while문! 상화별로 추천하는 반복문이 있다. for 문 : 반복해야하는 횟수가 지정될 경우 유리 ex) 10번 먹으세요 123for(초기화;조건식;증감식){ 조건식이 true일때 실행할 문장} while 문 : 반복횟수보다는 상황에 의한 반복을 정의할 경우 유리 ex) 다 먹으세요 1234while(조건식){ 조건식이 true일 경우 실행할 문장 증감식;} do ~ while문 : while작업 중 최소 한 번은 실행해야 할 작업이 있는 경우 유리 ex) 한 번 먹어보고 맛있으면 다 먹으세요, 홈페이지의 메뉴 (꼭 한번은 실행되어져야하기때문에) 12345초기화;do{ 조건식이 true일때 실행할 문장 증감식;} while(조건식);","link":"/2020/06/17/200618javai/"},{"title":"ITWILL : 브라우저객체모델안의 history객체, screen객체, navigator객체","text":"히스토리 객체사용자가 방문한 기록을 가지고 페이지를 이동.ex) 페이지 앞으로 가기, 페이지 뒤로 가기. history.back(); 뒤로가기 history.forward(); 앞으로가기 history.go(+/-) : 양수는 앞으로 그 숫자만큼이동, 음수는 뒤로 그 숫자만큼이동 ex)history.go(-2) : 뒤로 두번가기. ex)history.go(-1) : history.back()이랗 같은 역할. 뒤로 한번가기. ex)history.go(screenTop) : 탑으로이동 history.length; 몇번 왔다갔다했는지 길이로 알려준다. 등등 1234&lt;input type=\"button\" value=\"뒤로가기\" onclick=\"history.back();\"&gt;&lt;input type=\"button\" value=\"앞으로가기\" onclick=\"history.forward()\"&gt;&lt;input type=\"button\" value=\"탑으로\" onclick=\"history.go(screenTop)\"&gt;&lt;input type=\"button\" value=\"홈으로\" onclick=\"history.go(-1)\"&gt; &lt;!-- history.back();같은역할 --&gt; history.back()차이점아래 세 코드의 차이점은 무엇일까? 123&lt;input type=\"button\" class=\"btn\" value=\"뒤로가기\" onclick=\"javascript:history.back()\"&gt;&lt;input type=\"button\" class=\"btn\" value=\"뒤로가기\" onclick=\"location.href='history.back()'\"&gt;&lt;input type=\"button\" class=\"btn\" value=\"뒤로가기\" onclick=\"history.back()\"&gt; javascript:history.back() : 잘 작동한다. js호출. javascript:를 쓴 이유는 명시를 해서 우선순위를 줄 수 있기때문이다. location.href='history.back() : 문법에 어긋나 404 에러가 발생한다. location객체안에 history객체가 없기때문에 에러가 발생한다. history.back() : 잘 작동한다. js호출. 스크린객체사용자의 모니터 정보/속성을 제공해주는 객체이다. screen.width; : 모니터의 가로길이를 알려준다. 반응형웹에 주로 사용함. 등등 12document.write(\"&lt;hr&gt;\"+screen.width+\"&lt;br&gt;\");//출력값 1920 네비게이터객체현재 방문한 사람의 브라우저 정보, OS정보를 제공해준다. navigator.userAgent : 방문자의 브라우저 및 운영체제 정보를 확인할 수 있다. navigator.appCodeName : 방문자의 브라우저 코드명 정보 등등 1234567891011121314151617181920document.write(navigator.userAgent)document.write(navigator.appCodeName+\"&lt;br&gt;\")document.write(navigator.appName+\"&lt;br&gt;\")document.write(navigator.appVersion+\"&lt;br&gt;\")document.write(navigator.language+\"&lt;br&gt;\")document.write(navigator.product+\"&lt;br&gt;\")document.write(navigator.platform+\"&lt;br&gt;\") //출력값은Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36MozillaNetscape5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36ko-KRGeckoWin32","link":"/2020/06/16/200617jspi/"},{"title":"[패스트캠퍼스python] Django 홈페이지 실습: a태그를 버튼처럼 만들기, 수평선만들기, 다양한 form태그 종류와 사용법(HTTP메서드)","text":"파이썬 인강 자기계발 챌린지 24회차 미션1. a태그 버튼처럼 만들기a태그를 css를 이용하여 버튼처럼 보이게 만들 수 있다.또 가상클래스 hover를 이용하여 마우스를 올렸을때 색상변화를 주어 선택된 것처럼 보이게 만들어 더욱 버튼같은 느낌을 연출할수있다. 참고로 cta란 Call To Action의 약자로서 클릭유도라는 의미를 가진다.hero-section자체가 클릭유도를 하는 곳이기때문에 실무에서도 cta로 사용한다고 한다. 1234567891011121314.cta{ color: white; width: 300px; font-weight: 400; margin: 0 auto 60px; display: block; padding: 20px 50px; border-radius: 8px; background: #44b78b;}.cta:hover{ background: #51be95;} 아래 이미지는 위의 태그를 적용하여 a태그를 버튼처럼 보이게 만든 것이다. 2. 수평선만들기border를 이용해서 원하는 곳에 수평선이든 수직선이든 다 그릴 수 있다. 12345.hero-section{ padding: 50px 0; text-align: center; border-bottom: 1px solid #000000;} 아래 이미지는 위의 태그를 적용하여 수평선을 만든 모습이다 3. 메인콘텐츠마크업Django사이트의 메인콘텐츠를 어떻게 구성되어있는 지 확인하고 큰 스케치를 그려보자. Stay in loop의 경우 중요한 부분이므로 h2로 작업하고 바로 밑의 설명은 여백이 있는 p태그로 진행하면 된다. Using Django 와 Contributing to Django는 메일링 서비스이므로 중요한 영역이고 동일하게 float처리를 한 것으로 보인다.따라서 h3로 작성하고 이름에는 a태그를 주어 관련된 링크로 이동시킬 수 있도록해야한다. 제출하는 곳은 form태그를 사용한다. form태그 밑에는 설명영역을 한번 더 추가하면 끝! 설명영역은 구분될 수 있도록 여백이 있는 p태그를 이용하면 된다 4. 다양한 form태그 종류와 사용법form이란 사용자의 서버에 전송하는 방법이다. 보통 어디에 활용할까? 로그인 : 아이디/비밀번호를 입력시 회원가입 : 개인정보를 입력시 블로그나 게시판 : 글작성이나 파일전송시 그렇다면 form태그는 어떻게 생겼을까? 1234567891011121314151617181920212223&lt;form action=\"/url입력\" method=\"post\"&gt; &lt;div&gt; &lt;label for=\"next\"&gt;텍스트 필드&lt;/label&gt; &lt;input type=\"text\" id=\"text\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"checkbox\"&gt;체크박스&lt;/label&gt; &lt;input type=\"checkbox\" id=\"checkbox\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"radio\"&gt;라디오버튼&lt;/label&gt; &lt;input type=\"radio\" id=\"radio\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"search\"&gt;검색&lt;/label&gt; &lt;input type=\"search\" id=\"search\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"textarea\"&gt;텍스트 영역&lt;/label&gt; &lt;input name=\"textarea\" id=\"textarea\"/&gt; &lt;/div&gt; &lt;button&gt;전송버튼&lt;/button&gt;&lt;/form&gt; form의 action속성 : form태그로 입력받은 전체 내용을 어디에 보낼 것인지를 결정한다. 즉, 사용자가 입력한 데이터를 전송할 서버의 URL를 입력하면 된다. form의 method속성 : form태그로 입력받은 전체 내용을 어떻게 처리한 것인지를 결정한다 즉, 사용자가 입력한 데이터를 전송하는 방법으로 아래와 같은 방식이 있다. method는 기본적으로 get과 post방식을 지원한다. get : action에 입력한 URL에 파라미터의 형태로 전송. post : header의 body에 포함해서 전송.(보통 새로운 글등록할때 post방식사용) delete : 정보를 삭제함. put : 정보 전체를 수정 또는 정보 전체를 대체함. patch : 정보 일부 부분 수정함. 참고링크 : 제로초 HTTP 메서드 form태그 사이에는 텍스트 필드, 라디오 버튼, 체크 박스와 같은 컨트롤을 생성하는 태그들이 들어가줘야한다. label태그는 input태그가 무엇인지 설명해주는 태그로 lable태그를 사용하게 된다면 항상 세트로 lable태그와 input태그를 사용해야한다. 그리고 lable태그의 for속성에는 꼭 input태그의 id값과 동일한 값이 설정되어야한다. 이를 실습페이지에 적용해보자.input과 button태그를 아래 이미지와 같이 생성한다. placholder속성을 이용하면 사용자에게 어떤 걸 적어야하는 지 알려줄수있고 사용자가 입력하는 순간 사라지는 가이드라인이라고 생각하면 된다. 그리고 나면 아래 이미지와 같이 적용된 것을 확인할 수 있다.","link":"/2020/06/16/200617python/"},{"title":"[JS]문서 객체 모델안의 form태그, 페이지이동방식(get과 post), focus() vs blur() vs select()","text":"form 태그폼태그안에 있는 정보를 저장해서 원하는 페이지로 전달하는 방법을 설정할 수 있다.원하는 페이지는 action=”” 여기에 적어준다action페이지로 정보를 전달할때는 주소줄의 ?뒤에 전달할 정보를 담아서 이동한다. 이러한 정보전달방식을 get방식이라고 한다 form action=” 정보를가지고 이동할 url” method=”get” 이동할 url이 없다면 자신의 페이지를 호출 method=”get”는 기본속성이므로 굳이 적지않고 생략가능하다 하지만 post는 기본이 아니므로 꼭 적어줘야한다. 예시태그로 form태그 특징 설명예시태그를 가지고 form태그 특징 세가지를 설명할 수있다 123456&lt;form action=\"ex.html\" method=\"get\"&gt; 텍스트박스 : &lt;input type=\"text\" name=\"txt\"&gt; &lt;lable&gt;텍스트박스 : &lt;/lable&gt; &lt;input type=\"text\" name=\"txt\"&gt; &lt;input type=\"submit\" value=\"전달하기\" onclick=\"fun1()\"&gt; &lt;input type=\"reset\" value=\"원래값으로 초기화\"&gt;&lt;/form&gt; lable태그 기본적으로 &lt;lable&gt;텍스트박스 :&lt;/lable&gt; 는 lable 태그안에 input태그 내용을 적어줘야 css적용이 쉬워진다. 수업편의상 label태그를 생략하고 진행하지만 항상 label태그가 있다고 생각하면 된다 input type=”submit”속성form태그안에서만 input type=”submit”이 가능하다.form태그 없이는 input type=”submit”을 쓸 수 없으므로 input type=”button”으로 대체해줘야한다 onclick보단 onsunmit데이터의 정확한 처리를 위해서 위의 태그 &lt;input type=&quot;submit&quot; value=&quot;전달하기&quot; onclick=&quot;fun1();&quot;&gt; 보다는아래 태그 &lt;form action=&quot;a.jsp&quot; method=&quot;get&quot; name=&quot;myForm&quot; onsubmit=&quot;fun2();&quot;&gt;를 더 많이 사용한다 input태그에 onclick속성보단 form태그에 onsubmit속성을 입력해줘야 정확하게 실행된다고 할수있다.실무에서도 form태그에 onsubmit속성을 더 많이 사용한다. 123456&lt;form action=\"ex.html\" method=\"get\" onsubmit=\"fun1()\"&gt; 텍스트박스 : &lt;input type=\"text\" name=\"txt\"&gt; &lt;lable&gt;텍스트박스 : &lt;/lable&gt; &lt;input type=\"text\" name=\"txt\"&gt; &lt;input type=\"submit\" value=\"전달하기\"&gt; &lt;input type=\"reset\" value=\"원래값으로 초기화\"&gt;&lt;/form&gt; 페이지 이동방식 두가지 : get방식과 post방식get 방식 get() : 겟매서드로도 표현한다. 전송할 데이터(파라미터)를 이동할 주소정보(URL)에 붙여서 같이 전송하는 방식 장점 : 빠른 전송속도, body의 정보가 필요없음 단점 : 전달되는 정보가 모두 주소줄에 오픈됨 =&gt; 보안에 취약. 개인정보를 사용할수없다. 따라서 사용자가 봐도 모르는 정보들에 주로 사용한다. 파라미터길이가 제한됨 (256byte까지) 예시 태그예시 : form action=” 정보를 가지고 이동할 url” method=”get” 주소창 예시 : itwill.com?파라미터이름=값 파라미터 2개이상 가지고 갈때 예시(&amp;로 이어줌):itwill.com?파라미터이름=값&amp;파라미터이름=값 파라미터를 무제한으로 가져갈 수 있느냐? NOPE 한계 : 256byte 길이 이상의 정보를 가져갈 수 없다. 즉, 가져갈 수 있는 파라미터의 개수가 지정되어있다. 제한된 길이 이상의 정보를 가져 갈 경우 데이터 손실이 잃어난다. post 방식 post() : 포스트매서드로도 표현한다 전송할 데이터(파라미터)를 주소줄이 아니라 body에 담은 뒤 이동할 주소정보(URL)에 전송하는 방식 장점 : 외부에서 파라미터를 볼 수 없으므로 상대적으로 보안우수 파라미터길이 제한이 없으므로 많은 양의 파라미터를 전달 가능 단점 : 상대적으로 느린 전송속도 예시 태그예시 : form action=” 정보를 가지고 이동할 url” method=”post” 주소창 예시 : itwill.com focus() vs blur() vs select() focus() : 사용자가 입력 실패시 해당 요소를 선택해서 보여준다. blur() : 포커스를 해제시키는 함수이다. select() : focus와 비슷하지만 select는 focus 후 value값을 드래그해놓는다는 점이 다르다. 1234document.폼태그네임.pw.value = \"123\";document.폼태그네임.pw.focus(); //form태그안의 pw이름을 가진 곳에 \"123\"을 넣고 focus를 줌document.폼태그네임.pw.blur(); //focus해제document.폼태그네임.pw.select(); //focus하고 그 값(\"123\")을 드래그해놓음","link":"/2020/06/16/200617jspi2/"},{"title":"CUI환경 VS GUI환경, 리눅스명령어자세히, vi단축키","text":"CUI환경 VS GUI환경GUI(Graphic User Interface)문자가 아닌 그래픽 위주로 이루어진 방식을 말하며 현재의 우리가 쓰고있는 환경을 말한다.운영체제에서 작업할때 명령어 대신 아이콘을 더블클릭하여 사용하는 등 그래픽으로 데이터를 처리하는 환경이다. CUI(Character User Interface)문자로 이루어진 화면을 말한다. Dos환경일때 그래픽이 아닌 명령어(문자)로 처리하는 환경이다.그렇다면 CUI환경에서 문서를 어떻게 작성하고 저장할까?VI편집기(브이아이에디터)를 사용하면된다. VI 에디터VI편집기는 다른 에디터와 다르게 모드형 편집기이고 총 3가지모드로 구성되어있다. 명령모드 입력모드 ex명령모드 명령모드에서 편집모드로 가기 - i편집모드종료 후 명령모드 esc편집모드에서 저장하기 :w편집모드에서 저장하고 나가기 - :wp편집모드에서 저장하지 않고 나가기 - :p! 리눅스명령어 명령어 잘못 실행시켰을때 : ctrl+z를 누르면 stop이 된다. 폴더복사할때 : 다른 경로로 동일한파일명을 복사하고싶을때는 새로운 파일명을 점(.)을 찍어주면 원본과 동일한 이름으로 복사된다 1$] cp 복사하고싶은파일명.txt 복사할경로/. 이밖에도 리눅스 명령어는 아래 링크에 잘 정리되어있다. 리눅스 명령어","link":"/2020/06/18/200619dbi/"},{"title":"ITWILL : 문서 객체 모델안의 if문에 return;의 역할, radio태그, checkbox태그","text":"ITWILL학원 : 11강 JS기초 BY 정규태강사1. if문에 return;의 역할return : 문제발생시 다른 조건을 실행하지않는다. -&gt; 지금 문제를 먼저 해결예를들어 회원가입페이지의 필수항목인 아이디를 입력하지않았다면 그 다음 항목인 비밀번호는 아예 체크하지않겠다는 의미가 된다. 아래 태그는 if조건문이 연달아 있다.첫번째 if는 아이디를 입력했는지 체크하는 조건이고 두번째 if는 비밀번호를 입력했는지 체크하는 조건문이다. 여기서 return;의 역활에 집중해보자.아이디를 입력하지않았다면 비밀번호를 체크할 필요도 없다.따라서 첫번째 if문에서 아이디가 없을시 return;를 주어 뒤의 비밀번호를 아예 체크하지않고 function이 종료된다. 12345678910111213141516function check(){ if(inputId.length &gt; 0){ alert(\"사용자 ID : \" + inputId + \"\\n\" + userInfo.memo.value); }else{ // 아이디 입력값이 없을때 alert(\"사용자ID를 입력하세요\"); document.userInfo.id.focus(); return; } if(inputPw == \"\"){ //비밀번호 입력값이 없을 때 alert(\"비밀번호를 입력하세요\") document.userInfo.pw.focus(); }}check(); 2. 라디오 Radio 태그라디오버튼은 동일한 name을 써야 한 그룹으로 묶인다.value를 꼭 작성해주어여한다. checked=”checked” 또는 checked라고 속성을 주면 해당 속성에 틱 된 상태로 출력된다.만약 여러 태그를 다 checked한 경우, 제일 마지막 태그의 속성이 틱 된 상태로 출력된다. 아래 코드는 성별체크하는 라디오버튼이다. 12345678&lt;fieldset&gt; //테두리생성되는 태그 &lt;form action=\"#\" name=\"fr\" method=\"get\"&gt; &lt;label&gt; 성별 체크 : &lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" value=\"여\"&gt; 여성 &lt;input type=\"radio\" name=\"gender\" value=\"남\"&gt; 남성 &lt;input type=\"button\" value=\"성별체크유무\" onclick=\"checkRa();\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 여기서 성별을 틱하지않고 성별체크유무 버튼을 클릭하게되면성별을 선택하라는 알림 팝업이 뜨고 난 뒤 focus()를 주는 checkRa() 함수를 만들어보자. 123456789function checkRa(){ let womyn = document.fr.gender[0]; let men = document.fr.gender[1]; if(womyn.checked == false &amp;&amp; men.checked == false){ alert(\"성별을 선택하세요\") womyn.focus(); }} 알림창은 잘 뜨지만 focus()는 티가 나지않는다이럴때 enter를 눌러보면 여성라디오버튼에 굵은 검정테두리를 통해 focus가 됨을 알 수 있다. enter를 안누르고 티나게 하는 방법은 없을까?기존에는 보였으나 브라우저가 업데이트되면서 그런것같다는게 강사님의 의견.w3school에서도 동일한 현상이 나타나는 것을 보니 방법이 없나보다.. 3. 체크박스 checkbox 태그라디오버튼과 다른 점은 중복체크가 가능하다는 점이다.또한 체그해지도 가능하다 내 코드 1234567891011121314151617181920212223242526272829303132333435function checkRa(){ //라디오버튼체크유무 let womyn = document.fr.gender[0]; let men = document.fr.gender[1]; if(womyn.checked == false &amp;&amp; men.checked == false){ alert(\"성별을 선택하세요\")// womyn.focus(); //동일코드// document.forms[\"fr\"].elements[\"gender\"][0].focus(); //동일코드 document.getElementsByName('gender')[0].focus(); }else{ checkRa = true; }}function checkCh(){ //체크박스체크유무 if(document.fr.hobby[0].checked == false &amp;&amp; document.fr.hobby[1].checked == false &amp;&amp; document.fr.hobby[2].checked == false){ alert(\"취미를 한 개이상 선택하세요\") document.getElementsByName('hobby')[0].focus(); }else{ checkCh = true; }}function checkboth(){ //라디오버튼과 체크박스 둘다 체크했는지 확인 console.log(checkRa == true) console.log(checkCh == true) if(checkRa == true &amp;&amp; checkCh == true){ return true; }else{ return false; }} 강사님 코드 =&gt; 다음시간에 다시 123456789101112131415161718192021222324252627282930313233343536function checkRa(){ let womyn = document.fr.gender[0]; let men = document.fr.gender[1]; if(womyn.checked == false &amp;&amp; men.checked == false){ alert(\"성별을 선택하세요\") womyn.focus(); }else{ checkRa = true; }} function checkCh(){ //내코드 if(document.fr.hobby[0].checked == false &amp;&amp; document.fr.hobby[1].checked == false &amp;&amp; document.fr.hobby[2].checked == false){ alert(\"취미를 한 개이상 선택하세요\") document.getElementsByName('hobby')[0].focus(); }else{ checkCh = true; }}function checkCh(){ //강사님코드 if(document.fr.hobby[0].checked == false &amp;&amp; document.fr.hobby[1].checked == false &amp;&amp; document.fr.hobby[2].checked == false){ alert(\"취미를 한 개이상 선택하세요\") document.getElementsByName('hobby')[0].focus(); return; } checkRa(); document.fr.submit();}","link":"/2020/06/17/200618jspi/"},{"title":"[패스트캠퍼스python] git 버전관리","text":"파이썬 인강 자기계발 챌린지 26회차 미션1. git 버전관리버전관리는 필수이다.버전관리를 이용하면 아래 두가지 장점이 있다.표준처럼 사용되고 있는 버전관리 프로그램에는 git이 있다. 어떤 부분이 변경되었는지 변경전후의 소스코드를 비교하여 볼 수 있다. 시간의 순서대로 변경한 내용을 확인할 수 있다. 특정코드를 누가 수정했는지 사용자가 적혀있어서 바로 확인할 수 있다 2. git관리영역 세가지 작업디렉토리 Working directory : 현재 편집중인 파일이 저장되는 영역. 임시구역 Staging area : 저장소에 저장할 변경사항을 임시적으로 보관하는 영역. 저장소 Repository : 지금까지의 모든 변경된 작업내역이 영구히 저장되는 영역. 저장되는 순서는 소스코드를 편집 후 git add ‘경로’ 명령어로 임시구역에 보관한 뒤 git commit 명령어로 repository에 저장한다. 3. vs code로 git commit하는 방법 소스코드를 저장한다. git init 명령어 또는 vs code의 source control에서 저장한 소스코드를 불러와서 git과 소스코드를 연결한다. changes 아래에 변경된 소스코드가 보이지않는 경우 소스코드파일명을 검색해서 연결하면 된다. stage change 혹은 +버튼을 눌러서 임시구역에 보관한다. ctrl+enter로 repository에 저장한다. 즉, 소스코드를 변경한 뒤 commit을 하고 싶다면일단 소스코드를 변경한 뒤 저장을 누른다. -&gt; vs code의 stage change 혹은 +버튼을 누른다. -&gt; 커밋메모를 입력한 뒤 ctrl + enter를 누른다.위의 세단계가 기본중의 기본이다. 여기서 commit이란 두가지의 의미가 있다. 스테이징영역의 변경사항을 레포지토리에 저장하는 행위 변경사항을 묶어주는 단위 : commit을 변경사항이 있을때마다 할 수 있고 또는 모든 변경사항을 다 해준뒤 한번에 commit할수도있다. 4. vs code의 확장프로그램extensions 다운효율적인 git버전관리를 위해서 vs code의 익스텐션에서 아래 두가지익스텐션을 다운로드한다. GitLens : 소스코드옆에 바로 누가 언제 변경했는 지 알려주는 프로그램 Git History : 지금까지 commit된 히스토리를 보여주면서 언제 누가 고쳤는 지 알려주는 프로그램 5. Git History extension 사용방법vs code의 Source Control에서 ctrl + shift + p 를 누른 뒤 git view history를 검색한다. commit의 history가 최신순으로 나타나게된다 확인하고싶은 commit을 누른뒤 Compare against previous version을 클릭하면 commit전의 소스코드와 commit후의 소스코드를 비교하여 보기편하게 알려준다. 6. 위의 사항을 git bash로 하기 먼저 git bash를 열어주고 소스코드가 있는 주소로 이동한다. git status : commit이 되지 않은 변경사항을 확인한다 git add 소스코드파일명 : 변경한 소스코드파일명을 add해준다. 이 명령어로는 잘 진행되었는지 진행사항체크하기가 어렵기때문에 다시 스테이터스를 확인해줘야한다. git status : commit이 완료되었는지 확인한다. git commit -m “메모내용입력” : commit명령어를 통해 스테이징영역에 보관해둔 소스코드를 레포지토리에 저장한다. -m “메모내용입력”은 생략가능하나 앞으로의 history관리를 위해 간단한 변경사항내용을 적어주면 좋다. 7. git 원격 자동저장설정하기 vs code의 Source Control에서 ctrl + shift + p 를 누른 뒤 git add remote를 클릭한다 원격저장할 레포지토리 주소를 붙여넣는다. 이름은 origin입력한다. 점점점(…)을 클릭하여 push를 해준다 참고로, 역으로 웹 레포지토리에서 수정한 내용을 vs code로 받아보고싶을때는 ctrl + shift + p를 누른뒤 git pull을 입력하면 된다","link":"/2020/06/18/200619python/"},{"title":"[ITWILL : WEB]Form태그안의 input와 textarea와 button 태그, input버튼태그와 button태그의 차이점, 드롭다운리스트종류","text":"ITWILL학원 : 4강 WEB(HTML, CSS) BY 김영희1. form태그안의 input태그input type=&quot;&quot; 의 종류는 엄청 많다. 그중에서 아래 코드를 가지고 몇가지 속성과 함께 예시를 알아보자. 123456789&lt;form action=\"test.jsp\" method=\"POST\"&gt; &lt;label for=\"id\"&gt;ID &lt;input type=\"text\" id=\"id\" minlength=\"6\"&gt;&lt;br&gt;&lt;/label&gt; &lt;label for=\"pw\"&gt;Password &lt;input type=\"password\" id=\"pw\"&gt;&lt;br&gt;&lt;/label&gt; &lt;label for=\"idNumber\"&gt;Identification Number(without -)&lt;input type=\"password\" maxlength=\"13\" size=\"20\"&gt;&lt;br&gt;&lt;/label&gt; &lt;textarea name=\"memo\" id=\"\" cols=\"50\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;hr&gt;&lt;input type=\"submit\" value=\"입력한대로 제출\"&gt;&lt;input type=\"reset\"&gt; &lt;/form&gt; label for=””와input id=””는 꼭 일치시켜준다 input type=”password” maxlength=”13” size=”20” type=”password”는 type=”text”랑 동일하나 외부에 암호화되어 보여진다. maxlength=”13”속성으로 전화번호나 주민등록번호등 최대길이가 지정되어있는 정보들을 데이터 입력길이 지정해줄수있다. size=”20” 는 input에 쓰여진 글자의 숫자를 새고 그만큼 size를 늘리는 방식이다. size속성의 경우 한글 및 영문, 폰트크기에 따라서 size가 달라지기 때문에 width값이 정확하지 않기때문에 잘 사용하지않는다. 보통 css로 크기작업을 해준다 input type=”submit” value속성을 적어주지 않으면 브라우저마다 기본 이름이 나온다 기본이름 크롬 : 제출 / 익스엑스 : 퀴리전송 기본이름을 바꾸고싶으면 value=”입력한대로 제출” 이렇게 바꿔주면 버튼안의 글자가 입력한 내용으로 바뀐다 input type=”reset” value속성을 적어주지 않으면 브라우저마다 기본 이름이 나온다 기본이름 크롬 : 초기화 / 익스엣지 : 초기화 기본이름을 바꾸고싶으면 value=”입력한 내용 초기화” 이렇게 바꿔주면 버튼안의 글자가 입력한 내용으로 바뀐다 위의 input type=&quot;submit&quot;와 input type=&quot;submit&quot;은 form태그안에 위치해있을때 사용가능하다! 12345678&lt;h1&gt;파일전송&lt;/h1&gt;&lt;label for=\"ph\"&gt;증명사진&lt;/label&gt; &lt;input type=\"file\" value=\"너의파일\" name=\"\" id=\"ph\"&gt;&lt;h1&gt;검색어 삭제&lt;/h1&gt;&lt;label for=\"\"&gt;&lt;/label&gt;&lt;input type=\"search\" name=\"\" id=\"\" value=\"검색어삭제\"&gt;&lt;h1&gt;히든&lt;/h1&gt; 숨은데이터전송&lt;label for=\"\"&gt;&lt;/label&gt; &lt;input type=\"hidden\" name=\"membership\" id=\"\" value=\"gold\"&gt; input type=”file” 로컬 컴퓨터의 파일을 선택하는 기능을 하는 파일전송버튼을 생성한다. 기본벨류값은 “파일전송”이고 value=”너의파일”이렇게 지정해줘도 보여지는 글이 바뀌지않는다. input type=”search” 검색창을 입력하는 기능은 하지 않고 입력된 검색어를 한꺼번에 삭제해주는 버튼을 만들어주는 기능을 한다. 유저에게 유용한 기능이다 input type=”hidden” hidden타입은 문서상에 출력되지않는다. 그럼 어디다 쓸까? DB를 다룰때 주로 사용된다. 2. form태그안의 textarea태그닫힘태그가 꼭 필요하다.속성들도 꾸미기이기때문에 최근에는 속성을 사용하는대신 css에서 크기를 조작한다. 속성 cols=”” : 가로길이 ex)cols=”10” : 10줄이 들어가는 크기의 길이 rows=”” : 세로길이 ex)rows=”5” : 5열이 들어가는 크기의 길이 1&lt;textarea name=\"textarea\" cols=\"50\" rows=\"10\"&gt;&lt;/textarea&gt; 3. form태그안의 button태그버튼태그의 타입에는 4가지 종류가 있다 type=”submit”type을 적지않아도 기본으로 적용되는 디폴트값이다 12&lt;button type&gt;제출&lt;/button&gt;&lt;button type=\"submit\"&gt;제출&lt;/button&gt; type=”button”그냥 일반 버튼이다. 따라서 onclick=””으로 function이나 url을 연결할수있다. 1&lt;button type=\"button\"&gt;그냥버튼&lt;/button&gt; type=”menu”타입을 메뉴라고 주게되면 minlength=””를 적용하였을때 안내메세지를 띄어주는 신통방통한 기능이다그런데 구글링해보니 많이 사용하지 않는 타입속성이었다.왜지?나는 좋은데… 아무튼 잘 사용하지 않는 속성인 것 같다. 1&lt;button type=\"menu\"&gt;메뉴&lt;/button&gt; type=”reset”입력했던 값을 초기화시키는 버튼이다. 1&lt;button type=\"reset\"&gt;리셋&lt;/button&gt; 4. input=&quot;button&quot;태그와 button태그의 차이점input=&quot;button&quot;태그와 button태그는 submit을 수행하기에 기능적으로 동일하다.그렇다면 왜 나눠져있을까? button태그를 사용하면버튼안에 이미지를 함께 넣거나 버튼글자의 형태(굵기,기울기등)를 바꾸거나 웹아이콘을 넣는 등의 활용도가 높다. 참고링크 : web icon 사용방법 참고링크 : web icon 종류 따라서 요즘에는 input=&quot;button&quot;보다는 button태그를 더 많이 사용한다. 참고링크 : input type=”submit” vs button 비교 5. 드롭다운리스트 Dropdown Listdropdown list는 항목이 많을때 선택할 수 있게끔 아래로 내려오는 목록형식으로 나타내는 태그이다.공간절약형 객관식이다. 드롭다운 리스트를 이미지로 먼저 만나보자. 위의 4가지 형태를 어떻게 html 태그로 만들수있을까? 1. 기본형1234567&lt;select name=\"과목\" id=\"\"&gt; &lt;option value=\"HTML\"&gt;HTML&lt;/option&gt; &lt;option value=\"CSS\"&gt;CSS&lt;/option&gt; &lt;option value=\"JSP\" selected&gt;JSP&lt;/option&gt; &lt;option value=\"JAVA\"&gt;JAVA&lt;/option&gt; &lt;option value=\"직업기초\"&gt;직업기초&lt;/option&gt;&lt;/select&gt; 기본적으로 적은 순서대로 출력된다selected 속성 : checked 속성처럼 selected를 주면 HTML이 아닌 JSP를 먼저 출력할 수 있다. 2. multiple 적용드롭다운리스트는 다중선택이 가능할까?예스예스예스! select태그에 multiple속성을 추가해주면 된다.사용할때는 ctrl를 누르고 다중선택을 하면 표시가 된다.선택된채로 출력되는 selected도 적용가능하다 1234567&lt;select name=\"과목\" multiple&gt; &lt;option value=\"HTML\"&gt;HTML&lt;/option&gt; &lt;option value=\"CSS\"&gt;CSS&lt;/option&gt; &lt;option value=\"JSP\" selected&gt;JSP&lt;/option&gt; &lt;option value=\"JAVA\"&gt;JAVA&lt;/option&gt; &lt;option value=\"직업기초\"&gt;직업기초&lt;/option&gt;&lt;/select&gt; 3. size 적용드롭다운리스트는 다중선택되진않지만 박스리스트형태로 출력하고싶다면?속성 size=&quot;n&quot;을 추가해주면 된다.항목 n개가 보이는 상자형으로 출력된다. 1234567&lt;select name=\"과목\" size=\"10\"&gt; &lt;option value=\"HTML\"&gt;HTML&lt;/option&gt; &lt;option value=\"CSS\"&gt;CSS&lt;/option&gt; &lt;option value=\"JSP\" selected&gt;JSP&lt;/option&gt; &lt;option value=\"JAVA\"&gt;JAVA&lt;/option&gt; &lt;option value=\"직업기초\"&gt;직업기초&lt;/option&gt;&lt;/select&gt; 4. optgroup label=”” 적용만약 optgroup마다 selected를 추가해주면 어떻게 될까? selected가 다 출력되는 것이 아니라 selected속성이 들어간 제일 마지막(순서가 제일 아래인)태그 하나만 선택된채로 출력된다. 1234567891011&lt;select name=\"과목\"&gt; &lt;optgroup label=\"오전수업선택\"&gt; &lt;option value=\"HTML\" selected&gt;HTML&lt;/option&gt; &lt;option value=\"CSS\"&gt;CSS&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"오후수업선택\"&gt; &lt;option value=\"JSP\" selected&gt;JSP&lt;/option&gt; &lt;option value=\"JAVA\"&gt;JAVA&lt;/option&gt; &lt;option value=\"직업기초\"&gt;직업기초&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt;","link":"/2020/06/18/200619webi/"},{"title":"[패스트캠퍼스python] 프로젝트와 앱의 차이, 템플릿생성, 프로젝트에 앱등록하기,Class생성, class Meta","text":"파이썬 인강 자기계발 챌린지 28회차 미션1. 새로운 프로젝트 생성하기 : django-admin startproject 새로운프로젝트명장고 설치가 완료되면 django-admin 명령어를 사용할 수 있다.django-admin startproject fc_community를 통해 fcdjango_venv 아래에 fc_community 프로젝트가 만들어지고 안에 기본적인 내용들이 자동생성된다. 짜라란~ 2. app생성하기 : django-admin startapp 새로운앱명 django-admin startapp board명령어를 통해 fcdjango_venv 아래에 board라는 새로운 앱이 생성되어지고 models과 view게층이 자동적으로 생성된다. 3. project와 app의 차이점그렇다면 startproject명렁어와 startapp명령어의 차이점이 무엇일까? 위의 두가지 명령어로 자동생성된 파일들을 보자. 1번 빨간색은 startproject명렁어를 통해 자동생성된 파일들이다.2번 파란색은 startapp명령어를 통해 자동생성된 파일들이다. 프로젝트는 앱 한개 이상을 담을 수 있고 관련된 configuration도 함께 담아 하나의 웹사이트를 구성한다. 앱은 뷰계층과 모델게층을 묶어서 제공하며 하나의 웹앱기능만 담당한다. 또한 app은 프로젝트 A, B, C, D등등 동시에 여러 프로젝트에 포함될 수 있다. 4. templates생성MTV모델링을 하기 위해서는 템플릿폴더를 생성해줘야한다.템플릿은 어디에나 만들어도되지만 보통 앱안에 만든다.앱폴더명을 우클릭한 뒤 새로운 폴더를 누른 뒤 폴더이름은 templates라고 생성한다.장고에서 사용하는 템플릿엔진이 사용될때 이 폴더가 기본적으로 작동한다.그러니 app을 만든 뒤 항상 templates폴더도 생성할 것!세트로 기억하자 세트! 5. 만든 app을 프로젝트에 등록하기만든 앱들이 자동적으로 프로젝트에 등록되면 정말 좋겠지만 그렇지않다.따라서 프로젝트에 만든 앱을 등록시켜 연결이 되게끔 만들어줘야한다. startproject명령어로 프로젝트를 생성하면 프로젝트폴더안에 동일한 이름의 폴더가 하나 더 생성된다.여기서 만든 앱들을 등록시킬 수 있다.프로젝트명과 동일한 파일명을 클릭하면 여러 파일 중에 settings.py가 있다.클릭후 Application definition를 찾아보면 이미 installed된 앱 목록이 나온다.장고에서 기본적으로 제공해주는 앱으로 아래 코드에서 django.contrib로 시작하는 6개가 바로 그 앱들이다.이 코드 아래에 새로 만든 app을 추가해줘야한다.꼭 등록을 해줘야 모델이라든지 뷰등을 사용할 수 있게 된다.절대 까먹지말자! 나는 board와 fcuser앱 두개를 만들었으므로 두개를 아래 코드처럼 추가해줬다. 123456789101112# Application definitionINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'board', 'fcuser'] 6. Class생성user를 관리할 수 있는 앱을 만들어보자. 1234class Fcuser(models.Model): username = models.CharField(max_length=64, verbose_name=\"사용자명\") password = models.CharField(max_length=64, verbose_name=\"비밀번호\") registered_dttm = models.DateTimeField(auto_now_add=True, verbose_name=\"등록시간\") CharField는 문자열을 담을 수 있는 필드이다. registered_dttm에서 dttm은 실무에서 자주 사용되는 약어로 dateTime의 약자이다 auto_now_add=True 는 fcuser라는 객체가 저장되는 시점에 자동으로 현재시간을 데이터로 넣게된다. 장고는 클래스만 만들면 데이터를 생성하고 삭제하는데에 있어서 별도의 지정이 필요가 없다.클래스 하나로 모델이 완성되버린 것이다! 디폴트값이 적용되어 바로 출력되기때문에 매우 편리하다. 7. class Meta테이블명을 바꿀때는 아래 코드를 사용한다.class Meta:라는 클래스안의 클래스를 통해서 장고프레임워크에게 내가 원하는 것을 전달할 수 있다. 테이블명을 바꾸는 이유는 이해도를 높이기 위함도 있지만 기본적으로 장고에서 제공되는 테이블명과 구분되어야하기 때문에 테이블명을 바꿔주는 것이 좋다. 1234567class Fcuser(models.Model): username = models.CharField(max_length=64, verbose_name=\"사용자명\") password = models.CharField(max_length=64, verbose_name=\"비밀번호\") registered_dttm = models.DateTimeField(auto_now_add=True, verbose_name=\"등록시간\") class Meta: db_table = \"자신이 원하는 테이블명\"","link":"/2020/06/20/200621python/"},{"title":"[패스트캠퍼스python] 프레임워크 VS 라이브러리, Django의 세가지 계층, Django를 위한 패키지 설치, 가상환경실행하는 순서","text":"파이썬 인강 자기계발 챌린지 27회차 미션1. 프레임워크 VS 라이브러리 자주 사용되는 코드를 체계화하여 쉽게 사용할 수 있도록 도와주는 코드 집합이다.라이브러리와 혼동될 수 있지만 규모가 훨씬 크며 프레임워크는 프로젝트의 기반이 된다.건축에 비유를 해본다면 구조를 만드는 골조가 프레임워크고, 그 외 자재들이 라이브러리가 된다고 할 수 있다.웹 개발에 필요한 기본적인 구조와 코드(클래스, 함수등)가 만들어져있다. 기본적인 구조와 코드 예시 : URL파싱, 세션관리, 요청파싱, 응답 생성, 데이터베이스연동, 관리자페이지, 비즈니스로직, 데이터정의 등등 웹프레임워크가 위와 같이 다양한 일을 한다면 개발자는 무엇을 해야할까? 개발자는 비즈니스 로직과 데이터 정의를 중점으로 해야한다.필요한 것들만 중점적으로 하고 나머지는 프레임워크를 이용하면 된다. 2. Django란장고는 3가지의 계층을 이루고 있다. 모델 계층 뷰 계층 템플릿 계층 이는 MVC라고 하는 개발방법론(패턴)에 기반한 코드구조이다. 3. 모델 계층모델 계층은 앞에셔 얘기했던 프레임워크의 다양한 기능(URL파싱, 세션관리, 요청파싱, 응답 생성, 데이터베이스연동, 관리자페이지, 비즈니스로직, 데이터정의)중에 데이터베이스와 연동되는 기능을 담당한다. 기본적으로 데이터베이스를 사용하려면 SQL이라는 별도의 문법을 사용해야한다.하지만 Django에서는 모델 계층의 클래스를 연결만해주면 함수를 사용해서 SQL을 생성할 수 있다.간략하게 클래스를 생성하면 SQL문법으로 자동으로 table을 생성해준다. 세상-편하다! 4. 뷰 계층앞에서 얘기했던 프레임워크의 다양한 기능(URL파싱, 세션관리, 요청파싱, 응답 생성, 데이터베이스연동, 관리자페이지, 비즈니스로직, 데이터정의)중에 비즈니스 로직에 해당된다.이 비즈니스 로직은 개발영역으로 개발자가 역량을 쏟아야하는 부분이다. 뷰 계층에서 개발자가 비즈니스 로직을 작성하면 프레임워크가 URL파싱, 요청파싱, 응답관리등을 해준다. 위의 이미지처럼 한줄코드만 작성해주면, path뒤의 url로 변수등을 이용하여 요청사항을 쉽게 입력할 수 있다. 5. 템플릿 계층디자이너에게 친숙한 문법을 제공한다.HTML을 기반으로 HTML코드안에서 반복문등을 사용할 수 있는 계층이다. 6. Django를 위한 패키지 설치장고를 가상환경에서 설치하고 실행하고자한다. 1. virtualenv 설치하기 : pip3 install virtualenv사용하는 에디터에서 터미널을 열고 pip3 install virtualenv 명령어를 입력해준다.pc 한대에서 여러 프로젝트를 진행할때 버전이 다른 프로그램들을 사용하면 프로젝트왔다갔다할때마다 패키지를 재설치해줘야하는 번거로움이 있다. 따라서 프로젝트별로 패키지를 관리하는 공간이 분리되어야한다.그러한 환경을 제공해주는 것이 가상환경이다. 가상환경을 제공해주는 패키지는 다양하지만 virtualenv로 진행 할 예정이다. 2. 가상환경 폴더만들기 : virtualenv 새로운파일명패키지를 설치하면 새로운 명령어인 virtualenv를 사용할 수 있다.virtualenv 새로운 파일명명령어로 새로운 프로젝트를 생성해준다.vs code의 익스플로러에 자동으로 프로젝트가 생성된 것을 확인할 수 있다. 3. Django설치 : pip3 install django 가상환경안에 들어가기장고를 설치하기전 가상환경안에 들어가야한다.가상환경안에서 설치해야 패키지관리가 가능하다. 터미널에서 cd 가상환경을 설치한파일경로\\Scripts\\activate명령어를 입력한다.내 경우 cd Fastcampus Python\\Django\\fcdjango_venv\\Scripts&gt;activate 로 입력했는데 vs code에서는 activate 명령이 현재 위치에 있지만 이 명령을 찾을 수 없습니다.라는 명령어가 반복적으로 떠서 그냥 명령프롬프트 cmd에서 진행했다. 참고로 cmd키는 방법 : window key + r로 실행창을 띄운 뒤 cmd검색하면 끝! 가상환경에 들어가게되면 line 제일 앞부분에 (fcdjango_venv)가 적히고 그 뒤에 주소가 적힌다. 꼭 (fcdjango_venv)를 확인하고 Django를 설치하자. 장고설치하기가상환경안이란걸 확인 후 pip3 install django명령어를 입력해주면 Django가 Successfully installed asgiref-3.2.9 django-3.0.7 pytz-2020.1 sqlparse-0.3.1 성공적으로 설치된다. 7. 가상환경들어가는 순서 cmd에서 code라고 명령어를 입력하면 vs code가 오픈된다. 그냥 vs code를 더블클릭해서 오픈됨. vs code의 terminal에서 가상환경을 설치한 폴더로 이동한다.","link":"/2020/06/19/200620python/"},{"title":"[ITWILL : JAVA]369게임만들기","text":"ITWILL학원 : 9강 JAVA BY 윤미영강사JAVA 369게임만들기369게임을 만들어보았다.일의 자리와 소수점첫번째자리를 나누어서 처리했다. 변수 input는 사용자가 scanner를 통해 입력하는 숫자이다.변수 remainder는 숫자를 10으로 나눈뒤 소수점첫째짜리를 3,6,9인지확인한다. 함수 divideTen()는 10으로 나눠서 369인지 체크하는 반복되는 코드이므로 밖으로 뺐다.함수를 어디로 빼야하는지몰랐는데 main함수밖이면서 class안으로 빼야하는 것이었다. 123456789101112131415161718192021222324public class game369 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"1~99까지 정수를 입력해주세요\"); int input = sc.nextInt(); int remainder = input%10; //소수점첫번째자리체크 if(remainder == 3){ divideTen(input); }else if(remainder == 6){ divideTen(input); }else if(remainder == 9){ divideTen(input); } } private static void divideTen(int input){ if(input/10 == 3 || input/10 == 6 || input/10 == 9){ //1의자리체크 System.out.println(\"박수짝짝\"); }else{ System.out.println(\"박수짝\"); } }} 강사님 코드는 아래와 같다.박수치는 횟수를 카운드해서 if조건문으로 박수2번이면 박수짝짝을 입력하는 함수이다. 123456789101112131415161718public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"1~99까지 정수를 입력해주세요\"); int num = sc.nextInt(); int digit10 = num/10; //1의자리체크 int digit1 = num%10; //소수점첫째자리체크 int clapCnt = 0;//박수횟수 if(digit1%3 == 0 &amp;&amp; digit1 !=0){ clapCnt++; } //else가 필요없다. 변수가 0일때도 카운트되기때문에 꼭 제거해야한다. if(digit10%3 == 0 &amp;&amp; digit10 !=0){ clapCnt++; } //변수가 0일때도 카운트되기때문에 꼭 빼줘야한다. if(clapCnt == 2){ System.out.println(\"박수짝짝\"); }else if(clapCnt == 1){ System.out.println(\"박수짝\"); }}","link":"/2020/06/21/200622javai/"},{"title":"[패스트캠퍼스python] 설명글 보이지 않게 스타일링, 버튼태그를 input 태그안에 넣기, side content 레이아웃 스케치, 가상요소사용하여 화살표 만들기, nth-chird()","text":"파이썬 인강 자기계발 챌린지 25회차 미션1. 설명글 보이지 않게 스타일링 위의 이미지처럼 설명글을 보이지않게 처리하기위해서는 두가지방법이 있다. display: none; visibility: hidden; 1234.mailing-form &gt; lable{ display: none; visibility: hidden;} 적용시키면 아래 이미지와 같이 설명글은 보이지않게 된다. 이렇게해도 설명글은 보이지 않지만, 스크린리더와 같이 보조기기를 사용하는 사용자들을 위해 웹접근성을 고려한 스타일링을 할 수 있다. 12345678.mailing-form &gt; lable { position: absolute; width: 1px; height: 1px; overflow: hidden; /*크기에 넘치는 내용은 숨겨짐*/ margin: -1px;/*음수마진 가능*/ clip: rect(0,0,0,0);/*상하좌우를 자를 수 있음*/} overflow : hidden;의 경우 안에 있는 데이터가 흘러넘치는 경우 과감하게 넘치는 내용을 숨겨버리는 역할을 한다. margin : -1px; 마진은 음수로도 줄 수 있다. clip : rect(0,0,0,0); 앞으로도 사용될지 안될지 잘 모르는 속성이긴 하지만 현재로선 스크린리더 지원에 가장 적합한 속성이다. 상하좌우를 숫자만큼 남기고 자를수있다. 현재 아예 안보이게 만들고싶으므로 모든 숫자를 0으로 설정했다. 2. 버튼태그를 input 태그안에 넣기위에서 가져 온 이미지를 이번엔 input태그와 button태그에 초점을 맞추어 다시 한번 더 보자. 스타일링을 위해 버튼태그를 어떻게 하면 input태그안에 넣을 수 있을까?position속성으로 가능하다. 12345678910111213141516.input[type=\"email\"]{ width: 100%; border: 1px solid #44b78b; border-radius: 4px; height: 5rem;}.mailing-form-btn{ position: absolute; /*input속성안에 위치해야하기때문에 그렇다면 기준은? mailing-form-&gt;mailing form에서 relative*/ top: 0; right: 0;}.mailing-form{ position: relative;} .input[type=”email”]{}의 의미는 input태그중에 type속성을 email로 가지고 있는 모든 태그들을 선택하는 타입선택자이다. input태그에 width: 100%;를 주게되면 안에 들어오는 btn크기에 맞게 100%가 된다. 버튼태그를 input태그안으로 넣기위해선 position값을 주어야한다. bhn태그는 position : absolute;로 주고 버튼태그의 기준인 form태그로 잡고 form태그의 position : relative;를 준다. 위의 태그를 적용하면 아래 이미지처럼 input태그안에 button이 들어간 것을 확인할 수 있다.하지만 디자인으로서 아쉽다. 123456789.mailing-form-btn{ position: absolute; top: 30%; right: 10px; border: 0; background-color: white; color : #44b78b; cursor: pointer; /*닿으면 커서를 손가락모양 포인터로 변경시킴*/} top과 right를 input의 오른쪽중앙에 오도록 크기를 조절하면 된다 cursor는 button태그에 닿으면 커서가 화살표모양에서 손가락모양으로 변화하게끔 해주는 속성이다. progress; 로딩모양의 커서로 변한다. row-resize : 가로선 크기를 변화시켜주는 모양의 커서로 변한다. 등등 많다. 코드를 적용한 이미지이다.input태그안에 button태그가 조화롭게 잘 배치되어있고 커서모양도 submit위에 위치할때 손가락모양으로 변하는 것을 확인할 수 있다. 3. main의 side content 레이아웃 스케치 div.container-side-cta : 클릭을 유도하는 다운로드 요소가 배치되어있기에 a태그를 이용해서 버튼처럼 표현할 수 있다. 다운로드 밑에 more로 추가설명링크가 있으므로 이것또한 a태그로 마크업해주면 된다. 그리고 &gt; 부분은 가상요소를 이용하여 출력하면된다. 최근 뉴스가 나오는 부분은 그 부분 전체로 완결성을 가지고 있으므로 article태그로 작성하면된다. news의 날짜와 작성자가 출력되는 부분은 meta태그로 span, time 이용하여 작성하면된다. 위의 2번과 마찬가지이므로 class를 이용하여 같이 스타일링하고 다른 부분만 id를 이용하여 적용한다. 정의부분이기때문에 dl태그와 dt태그를 세트로 이용하면 된다. 4. 가상요소사용하여 “&gt;” 만들기아래 코드를 적용하면 바로 &gt; 가 추가됨을 확인할 수 있다. 123.more::after { content : \"&gt;\";} 5. nth-chird()nth-child()는 괄호안에 오는 숫자에 따라 선택되어지는 값이 다르다. nth-child(8) : 8번째 요소를 선택하게 된다. nth-child(n+6) : 6번째 이후의 모든 요소들을 선택하게 된다. 더 궁금한 사항은 아래 링크를 참고하면 비쥬얼적으로 잘 나타나있어 이해하기 쉽다. 참고링크 : nthmaster","link":"/2020/06/17/200618python/"},{"title":"ITWILL : js로 간단한 회원가입페이지 작성하기","text":"ITWILL학원 : 12강 JS기초 BY 정규태강사이때까지 배웠던 내용을 가지고 회원가입페이지를 작성해보자 회원가입페이지에서 구현해볼 기능. 1. 모든정보입력시 회원가입가능 2. 각항목의 입력값이 없을 경우 해당 요소의 알림과 함께 포커싱 3. id는 최소 4자리에서 최대10자리만 허용 4. 비밀번호확인시 두개의 값이 같은 경우 회원가입가능, 다른경우 비밀번호 확인창에 포커싱 후 경고창띄우기 5. 주민번호를 입력받으면 성별자동체크 6. 취미 선택안된경우 1번 옵션 선택 7. 과목 선택안된경우 경고창 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;form action=\"itwill.com\" name=\"fr\" method=\"get\" onsubmit=\"return checkall();\"&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"id\" minlength=\"4\" maxlength=\"10\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"pw\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;비밀번호 확인&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"repw\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;주민번호&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"idnum1\" maxlength=\"6\"&gt; - &lt;input type=\"password\" name=\"idnum2\" maxlength=\"7\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;성별&lt;/td&gt; &lt;td&gt; &lt;input type=\"radio\" name=\"gender\" value=\"여\"&gt;여 &lt;input type=\"radio\" name=\"gender\" value=\"남\"&gt;남 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;취미&lt;/td&gt; &lt;td&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"reading\"&gt;독서 &lt;input type=\"checkbox\" name=\"hobby\" value=\"swmming\"&gt;수영 &lt;input type=\"checkbox\" name=\"hobby\" value=\"breathing\"&gt;침대에서숨쉬기 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;좋아하는 과목&lt;/td&gt; &lt;td&gt; &lt;select name=\"sel\"&gt; &lt;option value=\"\"&gt;선택&lt;/option&gt; &lt;option value=\"자바\"&gt;JAVA&lt;/option&gt; &lt;option value=\"js\"&gt;JavaScript&lt;/option&gt; &lt;option value=\"db\"&gt;DataBase&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;하고싶은 말&lt;/td&gt; &lt;td&gt;&lt;textarea rows=\"5\" cols=\"30\" placeholder =\"자유롭게 입력하세요\" name=\"txt\"&gt;&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt; &lt;input type=\"submit\" value=\"제출\"&gt; &lt;input type=\"reset\" value=\"초기화\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 위는 html태그이고 아래는 js태그이다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;script type=\"text/javascript\"&gt;function checkall(){ //데이터유효성체크 let id = document.fr.id.value let pw = document.fr.pw.value let repw = document.fr.repw.value let name = document.fr.name.value let idnum1 = document.fr.idnum1.value let idnum2 = document.fr.idnum2.value let womyn = document.fr.gender[0] let men = document.fr.gender[1] if(id == \"\"){ alert(\"아이디를 입력하세요\") document.fr.id.focus(); return false; } if(pw == \"\"){ alert(\"비밀번호를 입력하세요\") document.fr.pw.focus(); return false; } if(pw != repw){ alert(\"비밀번호가 일치하지않습니다.\") document.fr.repw.select(); return false; } if(name == \"\"){ alert(\"이름을 입력하세요.\") document.fr.name.select(); return false; } if(idnum1 == \"\"){ alert(\"주민번호를 입력하세요.\") document.fr.idnum1.focus(); return false; } if(idnum2 == \"\"){ alert(\"주민번호를 입력하세요.\") document.fr.idnum2.focus(); return false; } if(womyn.checked == false &amp;&amp; men.checked == false){ if(idnum2.charAt(0) == 2 || idnum2.charAt(0) == 4){ womyn.checked = true; return false; } if(idnum2.charAt(0) == 1 || idnum2.charAt(0) == 3){ men.checked = true; return false; } } if(document.fr.hobby[0].checked == false &amp;&amp; document.fr.hobby[1].checked == false &amp;&amp; document.fr.hobby[2].checked == false){ alert(\"취미를 선택하세요\"); //document.fr.hobby[0].focus(); //사용자의 입력을 기다림 document.fr.hobby[0].checked == true; //사용자입력안할시 자동으로 0번을 선택함 } if(document.fr.sel.selectedIndex == 0){ alert(\"과목을 선택하세요\") document.fr.sel.focus(); return false; } if(document.fr.txt.value == \"\"){ alert(\"메모를 입력하세요\"); document.fr.txt.focus(); return false; }}&lt;/script&gt;","link":"/2020/06/21/200622jspi/"},{"title":"[ITWILL : JSP]JSP 첫 프로젝트 톰캣과 연결","text":"ITWILL학원 : 12강 JSP기초 BY 정규태강사기존 html코드에 java를 추가한 것이 바로 jsp이다. Project Explorer 우클릭 new &gt; dynamic web project &gt; 프로젝트이름을 적어주고 next &gt; next 후 Generate web.xml deployment descriptor를 꼭 틱해주고 Finish클릭 새로만든 프로젝트 우클릭 &gt; new &gt; jsp file 클릭 : 코드가 이미 있는 파일이 만들어졌다 이제 JSP 프로젝트를 톰캣서버와 연결해야한다. 새로 만든 프로젝트 우클릭 &gt; properties 클릭 &gt; java build path &gt; libraries &gt; server runtime 클릭 후 next를 눌러준다 tomcat을 클릭해주고 finish를 눌러준다 jsp파일에 첫번째행에 밑줄이 쳐져있던 것이 깨끗하게 사라진걸 확인할 수 있다 &gt; 서버와 연결 끝! 혹시나 안된다면 이클립스를 껐다 키거나 최상단 project 탭에 clear클릭하여 메모리를 한번 정리해준다","link":"/2020/06/21/200622jspi2/"},{"title":"[패스트캠퍼스python] 은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치 파일이 아닙니다의 윈도우7해결, DB관리","text":"파이썬 인강 자기계발 챌린지 29회차 미션아래는 강사님이 python3 manage.py makemigrations명령어를 입력하고 난 뒤의 터미널 출력모습이다. 그리고 아래 이미지는 내 터미널에서 출력한 모습이다. 내가 뭐 터미널에 치는 코드들이 툭하면 자꾸 은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치 파일이 아닙니다.라는 출력이 떴다. 너무나 빡쳐!!!! 빡치고있는 와중에 구글링해보니 위의 에러는 환경변수에 의해 발생하는 에러라고 한다.내가 컴퓨터가 두대가 있는데 하나는 윈도우 10을 쓰지만 다른 하나는 윈도우 7를 쓴다.그래서 두 OS에 python과 vscode 그리고 가상환경을 사용할 수 있는 환경변수 설정방법을 기록하려고 한다 1. python과 vscode 그리고 가상환경을 사용할 수 있는 환경변수 설정방법1. 윈도우10 환경변수window키를 누르고 검색창에 고급 시스템 설정 보기를 검색한다. 띄어쓰기에 유의하자. 윈도우 10의 경우 환경변수를 추가할 수 있게끔 예쁜 GUI가 나온다.새로만들기를 클릭하고 아래를 추가해준다 변수 값 : C:\\Users\\파이썬저장한경로\\Python\\Python38\\Scripts; 위의 값은 파이썬에서 가상환경을 사용하기 위한 내용이다.이 밖에도 python과 vscode를 추가해주면 되는데 사실 프로그램을 다운로드할때 자동적으로 추가가되어있을 것이다.깔끔하게 해결!! 2. 윈도우7 환경변수 설정하지만 윈도우7의 경우는 거지같이 나온다.일단 환경변수 설정에 들어가보자.window키를 누르고 검색창에 고급 시스템 설정 보기를 똑같이 검색한다. 띄어쓰기에 유의하자. 새로만들기를 클릭하고 아래 값을 그대로 입력했다 변수이름 : path 변수 값 : C:\\Users\\파이썬저장한경로\\Python\\Python38\\Scripts; 왜지? 윈도우10은 리스트에 추가된 행이 바로 나오는데 윈도우7은 전혀 그런게 보이지않았다.내가 잘못했나?다시 path의 값 전체를 삭제하고 파이썬의 가상환경을 사용하기위해서 아래를 입력했다.꼭 자신이 파이썬과 vs code, 가상환경을 다운로드한 경로를 지정해야한다.C:\\Users\\파이썬저장한경로\\Python\\Python38\\Scripts\\;를 붙여넣었다. 3. 설치위치 찾기만약 python과 vs code, 가상환경을 어디 설치했는지 경로를 모르겠다면?걱정 할 필요없다!window에서 모든 프로그램을 클릭한 후 python을 찾은 뒤 우클릭한다.그리고 속성을 클릭하면 대상에 경로가 설정되어있다.그 경로 그대로 복붙하면 된다! 그리고 새로만들기를 눌렀는데 아무런 변화가 없다?!?!그래서 변경을 누르고 기존 path를 아예 삭제하고 다시 등록해보았다.그.런.데.알고보니 path의 기존경로는 절대 지우면 안되고 그 뒤에 세미콜론(;)으로 붙여서 입력해야한다는 것이다.window의 기본 path는 건들면 절대 안된다고 한다!나는 그것도 모르고… 이미 지워버렸다…멘붕왔다가 잠시 진정하고 다시 환경변수 기본값을 찾는 여정부터 이어나갔다. 4. 환경변수 기본값 찾기환경변수의 기본값은 찾는 방법은 아래와 같다.cmd를 열고 regedit명령어를 입력한다.레지스트리편집기가 자동으로 open될텐데 아래 위치로 찾아간다. HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Control\\Session Manager\\Enviroment\\Path 그리고 path를 더블클릭하면 변경되기전이 값이 저장되어있다.복붙해서 환경변수에 한꺼번에 등록했다. 휴- 살았다! 2. Database관리데이터베이스를 관리해보자.데이터를 수정,추가한 경우에 항상 1번부터 2번까지 반복을 해주면 데이터베이스버전이 새로 생성되고 관리된다. python3 manage.py makemigrations명령어를 입력한다내 경우에는 ‘python3’은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는배치 파일이 아닙니다.에러가 사라지지않았다…하지만 python명령어는 위의 환경변수 세팅을 통해 잘되었으므로 3을 뺀 python manage.py makemigrations를 입력했다. 다행히 성공적으로 create model이 되었다. python3 manage.py migrate위와 마찬가지로 3을 뺀 뒤 실행했더니 잘 진행되었다. 1번과 2번을 통해 우리는 명령어 sqlite3 db.sqlite3등을 이용하여 직접 sqlite를 만질 필요가 없다. 왜냐면 장고가 다 알아서 데이터베이스의 테이블을 자동으로 생성해주기때문이다.","link":"/2020/06/21/200622python/"},{"title":"Select 구문을 사용한 데이터 검색, null VS 0 VS 공백, Distinct","text":"Select 구문을 사용한 데이터 검색테이블 구조조회describe 테이블명이지만 실무에선 줄여서 desc 테이블명 명령어를 사용한다. 1SQL&gt; desc 테이블명 테이블로부터 데이터검색 아스타(*)별표(*)라고 아스타 읽는다테이블명에 모든 컬럼을 출력해달라는 의미이다.그때 출력되는 순서는 기본 컬럼이 출력되는 순서이다. 12SQL&gt; select *SQL&gt; from 테이블명 컬럼사이즈조절컬럼사이즈를 조절하고싶다면 아래 명령어를 입력하면된다.사이즈를 줄이는 건 세션단위로만 지속된다. 1234SQL&gt; col 사이즈조절할컬럼명 format a원하는사이즈//예시SQL&gt; col department_name format a20 사이즈를 줄이는 건 쉽게 가능하지만 사이즈를 늘리는건 안된다.따라서 사이즈를 너무 많이 줄여서 #이 엄청 뜬 경우 sql프로그램을 종료 후 재실행해야하면 원래 사이즈로 돌아간다. 아래 exit쿼리는 sql만 종료할 뿐 db를 종료하는 것이 아니다.sql만 종료하고 다시 유저로 로그인하면 간단하게 끝! 123SQL&gt; exitSQL&gt; conn 유저명/비번SQL&gt; col 사이즈조절할컬럼명 format a원하는사이즈 원하는 순서대로 컬럼을 출력하고 싶다면 아래와같이 쿼리구문을 날리면된다.기본 순서가 바뀌는 것이 아니라 내가 display하고싶은 순서대로 화면에 출력만해주는 것이다. 산술식쿼리구문에는 산술식이 가능하다. 산술식은 사칙연산만 가능하다.테이블 employees에서 2가지 컬럼(last_name, salary)과 산술식이 들어간 컬럼 1개(12*(salary+100)))를 출력하는 코드는 아래와 같다. 12SQL&gt; select last_name, salary, 12*(salary+100)SQL&gt; from employees null값null은 사용할 수 없는 값, 알려지지 않은 값, 할당받지 못한 값, 모르는 값, 아직 정의되지 않은 값이다.null은 0과 공백과는 다른 특수한 값으로 모든 데이터타입에 사용가능하다. null VS 0 VS 공백 null은 알려지지 않은 값이고 모든 데이터타입에 사용가능. 숫자 0(zero)는 숫자데이터타입의 한 종류 공백은 캐릭터데이터타입의 한 종류 숫자 0와 null은 구분이 가능하다어떻게?desc 명령어를 통해서! 1SQL&gt; desc 테이블명 위의 명령어로 출력되는 테이블의 TYPE에 NUMBER인 경우 0의 값일것이다. 그렇다면 공백과 NULL은 어떻게 구분할까?desc 명령어를 통해서는 구분할수가없고, 구분할 수 있는 함수가 존재한다. 결국 desc명령어를 통해 null과 숫자데이터타입은 구분이 가능하지만 null과 공백데이터타입은 육안으로 구분하기힘들다. null은 사칙연산을 해도 null이 된다.null때문에 계산이 잘 안되는 경우가 왕왕있다.계산할때만이라도 null값을 0으로 넣어서 계산하는 함수가 존재한다. 제목명을 보기좋게 display하기alias (엘리아스) 별칭칼럼명에 별칭(alias 엘리아스)을 넣어 데이터를 출력할 수 있다. 칼럼명 as alias 칼럼명 alias 칼럼명 (as) “Alias” : 대소문자구분, 공백포함, 특수문자 포함을 원하는 경우 as생략가능! 12SQL&gt; select last_name as name, salary*12 &quot;Annual Salary&quot;SQL&gt; from employees; 엘리아스를 사용하면 엘리아스명으로 format을 새로 지정해줘야한다.위에 별칭을 줬던 두 컬럼의 사이즈를 format해보자. 12SQL&gt; col name format a20SQL&gt; col &quot;Annual Salary&quot; format a20 || 연산자 사용두개의 컬럼을 하나로 합쳐서 출력하면서 직원이름과 job id를 매칭시켜서 출력하고싶다면 ||연산자를 사용하면 된다. 그리고 두 컬럼사이를 구분하기 위해 리터럴 값은 ‘ is a ‘ 를 넣어준다.리터럴값이 뭘까? 아래에 설명글을 보자. 123SQL&gt; select last_name || ' is a ' || job_idSQL&gt; as &quot;Employees Details&quot;SQL&gt; from employees; 리터럴리터럴값 : 명령어, 테이블명, 컬럼명, 엘리아스, 키워드는 아닌데 쿼리구문에 포함된 일반 문자,숫자,날짜 값! 숫자 리터럴값은 그냥적어도 되지만 문자나 날짜 리터럴값은 작은따음표(‘’)로 묶어서 작성해야한다. 실제 문법은 큰따옴표(“”)는 안되고 작은따옴표만 가능하지만 요즘에는 사용 프로그램에 따라 큰따옴표도 자동적으로 작은따옴표료 인식하기도한다. Distinct중복된 값을 자동으로 제거해 주고 한번만 display해주는 키워드 12SQL&gt; select distinct department_idSQL&gt; from employees; 예를들어 employees 테이블에 사원들의 department_id가 총 몇개인지 궁금하다.이럴때 distinct 키워드를 쓰지않고 출력하게된다면 모든 사원의 department_id가 사원수만큼 출력된다. 1번부서 2번부서 1번부서 1번부서 5번부서 5번부서 6번부서 총 7row 이때 distinct 키워드를 사용하면 중복값을 제거하고 출력할수있다 1번부서 2번부서 5번부서 6번부서 총 4row 이를 통해 department_id의 총 갯수파악이 쉬워진다.","link":"/2020/06/22/200623dbi/"},{"title":"[ITWILL : JSP]JSP 주석과 JSP directive, JSP 스크립트 요소","text":"ITWILL학원 : 13강 JSP기초 BY 정규태강사jsp는 html과 java를 합쳐서 사용하는 것이기때문에 주석을 두가지를 사용할 수 있다. 1. JSP주석 <%– – %>%로 시작하는 주석은 jsp주석이다. 이는 엘리먼트요소이다.html 주석문과 <!– –> 과 차이점은 html주석은 개발자도구에서 보이지만 JSP주석은 개발자도구에서 보이지않는다. 12HTML주석 : &lt;!-- &lt;h1&gt;에이치티엠엘yo!&lt;/h1&gt; --!&gt; JSP주석 : &lt;%-- &lt;h1&gt;제이에스피yo!&lt;/h1&gt; --%&gt; 2. JSP가 어떻게 JAVA와 연결되어있을까?연결성을 알기 위해서 아래 경로를 찾아가보자. 경로 : D:\\JAVA저장경로.metadata.plugins\\org.eclipse.wst.server.core\\tmp0\\work\\Catalina\\localhost\\JSP7\\org\\apache\\jsp\\JSP1 해당 폴더에는 내가 생성한 적 없는 아래 파일 두개가 들어가있다. 파일명.java 파일명.class 해당 폴더안에 .java파일을 열어보면 내가 만들었던 .jsp파일이 내부적으로 .java파일을 생성하고 그 뒤 .class파일을 실행시키는 방식으로 연결되어있다.이런 .java파일을 서블릿이라고 부른다. 즉, 내가 .jsp파일을 만들면 컴파일러가 알아서 서블릿이라는 형태인 .java파일을 만들고 그 뒤 .class파일을 실행시킨다. 3. JSP 디렉티브(directive)jsp 디렉티브(directive)는 jsp페이지가 실행될때 필요한 정보를 지정하는 것이다.jsp페이지는 사용자가 페이지를 요청할때 실행된다. <%@ 내용내용블라블라 %> 형태로 사용한다.크게 3가지 지시어가 존재한다. page include taglib 1. JSP 디렉티브(directive)의 page지시어 속성아래는 page예시이다. import 123&lt;%@ page import=\"java.util.*\" %&gt;&lt;%-- import란 외부로부터 다른 파일(클래스/객체)가져와서 추가해서 지정할수있다. --%&gt; contentType 사용자의 요청을 응답할때 응답할 페이지의 MIME타입을 지정하기위한 속성이다.따라서 css나 aac오디오, azw전자책등등 다양한 종류의 페이지타입을 만들수있다. contentType 종류 1&lt;%@ page contentType=\"text/html; %&gt; 5. JSP 스크립트 요소JSP 스크립트요소에는 총 3가지가 있다. 선언문 : 변수, 매서드(함수)를 선언해서 사용한다. 스크립틀릿 : 자바코드를 작성(변수와 매서드 사용가능)해서 사용한다. 표현식 : 화면에 출력할 내용을 작성하여 사용한다. 1. 선언문선언문 형태 : <%! %>변수, 매서드(함수)를 선언해서 사용하기때문에 배열은 생성할수없다. 배열을 생성하고싶으면 스크립틀릿안에 써야한다.멤버변수(전역변수)형태로 사용가능. 123456&lt;%!//자바코드를 사용해서 변수,메서드 사용(전역변수) public void Method(){ System.out.println(\"안녕하세요\"); }%&gt; 2. 스크립틀릿스크립틀릿 형태 : <% %>자바코드를 작성(변수와 매서드 사용가능)해서 사용한다.지역변수형태로만 사용가능. 12345678&lt;% //java System.out.println(name); System.out.println(a); // html 영역의 출력 out.print(\"안녕하세요(html)\");%&gt; 3. 표현식표현식 형태 : <%= 자바의 값 %>화면에 출력할 내용을 작성하여 사용한다.즉 표현식은 값 또는 자바변수의 값을 화면에 출력가능한 코드이다. 1234567&lt;%for (int i=0; i&lt;strArr.length; i++){ %&gt; &lt;%= i%&gt;는 &lt;%= strArr[i]%&gt; &lt;br&gt; &lt;%}%&gt; 표현식으로 테이블만들기 1234567891011121314151617181920212223&lt;%String[] strArr = new String[5];strArr[0] = \"java\";strArr[1] = \"jsp\";strArr[2] = \"web\";strArr[3] = \"DB\";strArr[4] = \"spring\";%&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;인덱스&lt;/td&gt;&lt;td&gt;값&lt;/td&gt; &lt;/tr&gt; &lt;% for(int i=0;i&lt;strArr.length;i++){ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=i %&gt;&lt;/td&gt;&lt;td&gt;&lt;%=strArr[i] %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; 4. 선언문과 스크립틀릿 차이선언문은 전역변수로 사용가능하지만 스크립틀릿은 지역변수로만 사용가능하다.자주 사용할 것은 선언문보다 스크립틀릿이다.","link":"/2020/06/22/200623jspi/"},{"title":"[ITWILL : JSP]내장객체","text":"ITWILL학원 : 13강 JSP기초 BY 정규태강사JSP 내장객체서블릿(JSP -&gt; JAVA로 변환하는 것)을 실행할때 필요한 정보를 저장하고 있는 객체이다.원래 객체는 외부에 있기에 import를 추가해야하지만,내장객체의 경우 기본적으로 포함되어있기때문에 따로 객체를 생성하거나, import로 추가할 필요가 없다. 자주사용하는 객체 6가지는 무조건 암기할 것! 내장객체는 총 9가지이다. java.servlet 패키지 8가지 request : 클라이언트의 Http 요청 정보를 저장하는 객체 response : Http 요청을 처리하는 응답 정보를 저장하는 객체 session : 해당 클라이언트의 세션정보를 저장하는 객체 예시 : 은행웹접속하면 10분지나면 ‘로그인세션이 만료하였습니다’ pageContext : 페이지가 실행할때 필요한 컨텍스트 정보를 저장하는 객체 컨텍스트정보 = 프로젝트정보 out : 응답페이지에 전송하기위한 출력스트림 객체 버퍼링 : 버퍼라는 공간을 채우는 작업이 버퍼링이다. 데이터가 큰 경우 전체 데이터를 작은 단위로 잘라서(버퍼) 먼저 데이터를 보여주는 것이다. 이것이 발전된 형태가 스트림이다. 스트림 : 데이터를 글자단위로 보내는 것이 아니라 스트림단위로 보낸다. 물흐르듯 데이터를 계속 보내는 것을 스트림이라고 한다. 예시 : 음악스트리밍 application : 해당 애플리케이션의 정보를 저장하는 객체 헷갈릴수있는게 스마트폰등의 안드로이드 앱이 아니라 응용프로그램전체라는 의미이다. 개념을 분리하자. jsp에서는 애플리케이션의 정보를 저장한 객체이다. 예시 : 누적페이지방문수를 표시할때 application객체를 이용한다 config : 페이지의 서블릿설정 정보를 저장하는 객체 서블리설정 = 초기화값 page : 페이지의 서블릿 객체 java.lang 패키기 1가지 exception : 예외처리를 다루는 객체 2. 자주 사용하는 내장객체 : request객체클라이언트의 Http 요청 정보를 저장하는 객체이다js에서 객체는 아래와 같이 만들었다. 1let 참조변수a = new 객체(); HttpServeltRequest 클래스를 객체로 구현한 뒤 request 이름(참조변수a)으로 사용한다.웹페이지에서 사용하는 왠만한 데이터들은 다 request객체로 가져 올 수있다. 12345678910111213141516171819서버도메인명 : &lt;%= request.getServerName() %&gt;&lt;br&gt;서버포트번호 : &lt;%= request.getServerPort() %&gt;&lt;br&gt;URL : &lt;%= request.getRequestURL() %&gt;&lt;br&gt;URI : &lt;%= request.getRequestURI() %&gt;&lt;br&gt;클라이언트호스트명 : &lt;%= request.getRemoteHost() %&gt;&lt;br&gt;클라이언트IP주소 : &lt;%= request.getRemoteAddr() %&gt;&lt;br&gt;프로토콜정보 : &lt;%= request.getProtocol() %&gt;&lt;br&gt;요청정보방식(전송방식) : &lt;%= request.getMethod() %&gt;&lt;br&gt;컨텍스트경로(프로젝트경로) : &lt;%= request.getContextPath() %&gt;&lt;br&gt;물리적경로 : &lt;%= request.getRealPath(\"/\") %&gt;&lt;br&gt;- 물리적경로란? 하드디스크의 어디에 저장하는 지가 물리적경로&lt;br&gt;Http헤더(user-agent) : &lt;%= request.getHeader(\"user-agent\") %&gt;&lt;br&gt;- Http헤더(user-agent)란? 이용자가 사용하고있는 웹사이트 정보&lt;br&gt;Http헤더(accept-language) : &lt;%= request.getHeader(\"accept-language\") %&gt;&lt;br&gt;Http헤더(host) : &lt;%= request.getHeader(\"host\") %&gt;&lt;br&gt;Http헤더(connection) : &lt;%= request.getHeader(\"connection\") %&gt;&lt;br&gt; 3. 자주 사용하는 내장객체 : response객체Http 요청을 처리하는 응답 정보를 저장하는 객체이다. 1234567891011&lt;% response.setHeader(\"해더이름\", 값); response.addCookie(\"쿠키값\"); response.setContentType(\"타입\"); response.sendRedirect(\"주소\");//예시 response.sendRedirect(\"httl://www.naver.com\"); //코드를 작성한 html파일에서 실행했지만 자동으로 네이버로 이동됨%&gt; 4. 자주 사용하는 내장객체 : session객체해당 클라이언트의 세션정보를 저장하는 객체세션은 만들어지는 시간, 최종시간등을 확인할 수 있다. 예시 : 은행웹접속하면 10분지나면 ‘로그인세션이 만료하였습니다’ 12345678910세션 ID : &lt;%=session.getId() %&gt;&lt;br&gt;세션 생성 시간 : &lt;%=session.getCreationTime() %&gt;세션 최종 접속시간 : &lt;%=session.getLastAccessedTime() %&gt; &lt;br&gt;세션 유지시간 : &lt;%=session.getMaxInactiveInterval() %&gt; &lt;br&gt;- 세션 유지시간 default값 : 1800초 = 30분&lt;br&gt;&lt;%// 세션 유지시간 변경 :30분 -&gt; 60분session.setMaxInactiveInterval(3600);%&gt;변경된 세션 유지시간 (3600초,60분): &lt;%=session.getMaxInactiveInterval() %&gt; &lt;br&gt; 5. 자주 사용하는 내장객체 : application객체해당 애플리케이션의 정보를 저장하는 객체헷갈릴수있는게 스마트폰등의 안드로이드 앱이 아니라 응용프로그램전체라는 의미이다.개념을 분리하자. jsp에서는 애플리케이션의 정보를 저장한 객체이다.예시 : 누적페이지방문수를 표시할때 application객체를 이용한다 123서버정보 : &lt;%=application.getServerInfo() %&gt;&lt;br&gt;물리적경로 : &lt;%=application.getRealPath(\"/\") %&gt;&lt;br&gt;-슬러시(/)는 root라는 의미로 최상위경로를 의미한다. 6. 자주 사용하는 내장객체 : out객체응답페이지에 전송하기위한 출력스트림 객체 버퍼링 : 버퍼라는 공간을 채우는 작업이 버퍼링이다. 데이터가 큰 경우 전체 데이터를 작은 단위로 잘라서(버퍼) 먼저 데이터를 보여주는 것이다. 이것이 발전된 형태가 스트림이다. 스트림 : 데이터를 글자단위로 보내는 것이 아니라 스트림단위로 보낸다. 물흐르듯 데이터를 계속 보내는 것을 스트림이라고 한다. 예시 : 음악스트리밍 버퍼사이즈를 다 사용하면 출력에 문제가 생길수있다. 입출력작업자체가 자원을 많이 사용하므로 out객체를 사용하고나서 out.close()매서드를 사용해야한다 123456789&lt;% out.print(\"out객체 사용&lt;br&gt;\");%&gt;버퍼 사이즈 : &lt;%=out.getBufferSize() %&gt; BYTE&lt;br&gt;사용후 남은 버퍼사이즈 : &lt;%=out.getRemaining() %&gt; BYTE&lt;br&gt;- out객체를 사용하고나서 out.close()매서드를 사용해야한다&lt;% out.close(); //자원해제 %&gt;","link":"/2020/06/22/200623jspi2/"},{"title":"[패스트캠퍼스python] DB에 만든 app 연결, admin페이지 출력 문자열 한글로 변경","text":"파이썬 인강 자기계발 챌린지 30회차 미션만들어놓은 DB에 내가 만든 앱 연결해보자.이는 admin.py를 이용해서 진행해야한다. 1. admin.py 작성데이터를 추가,수정한 뒤 migrate를 한 상태에서 상위 앱폴더에서 admin.py폴더를 찾는다.그리고 migrate한 models안에 있는 내용을 import해온다.pass는 아무것도 안하겠다는 의미이다.그 뒤 아래와 같이 빈 클래스를 만들어 admin에 두가지(Fcuser, FcuserAdmin) 다 등록(register)한다. 1234567from django.contrib import adminfrom .models import Fcuserclass FcuserAdmin(admin.ModelAdmin): pass admin.site.register(Fcuser, FcuserAdmin) 2. python3 manage.py runserver 명령어입력잘 반영되었는지 runserver명령어롤 틍해 실행해보자.터미널에 아래 코드들이 출력되고 그 중 http://127.0.0.1:8000/를 ctrl를 누른상태에서 click하면 바로 인터넷창이 오픈된다. 123456789(fcdjango_venv) C:\\경로\\fc_community&gt;python manage.py runserverWatching for file changes with StatReloaderPerforming system checks...System check identified no issues (0 silenced).June 21, 2020 - 14:47:46Django version 3.0.7, using settings 'fc_community.settings'Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK. 주소창에 admin/ 추가입력 후 enter.인터넷창이 오픈되면 주소뒤에 admin/을 붙여준다.그러면 장고에서 기본적으로 제공하는 site가 출력되면서 로그인페이지가 나타난다.아직 첫 아이디를 만들지 않았으므로 인터넷창을 닫아주고 터미널창에 ctrl+c 명령어를 입력하여 돌아가던 server를 멈춰준다. 3. python3 manage.py createsuperuser manage.py명령어를 통해 첫 user를 생성한다.자동적으로 아이디와 이메일주소, 비번과 비번확인 총 4단계의 입력과정을 거치면 드디어 생성!! 다시python3 manage.py runserver를 통해 http://127.0.0.1:8000/admin/으로 들어가서 방금 생성한 아이디와 비번으로 로그인을 한다.그러면 아래와 같이 사이트가 뾰로롱 생성된다. 파란색띠가 app을 나타내며 Authentication and Authorization 은 장고에서 제공하는 기본 앱이고 내가 만들었던 fcuser앱이 정상적을 출력되고 그 아래에 만들었던 Fcusers모델이 잘 등록되어있는 것을 확인할 수 있다. add를 누른뒤 사용자명과 비밀번호를 입력하면 아래 이미지처럼 Fcuser object(1)가 생성되고 그 안에 추가로 만든 사용자명과 비밀번호를 확인할 수 있다. 이렇듯 장고는 데이터베이스를 건들이지않아도 웹페이지에서 데이터베이스를 쉽게 다룰 수 있어 정말 편리하다.조금 아쉬운 점이 있다면 유저명이 Fcuser object(1) 이렇게 생성되어서 어떤 유저인지 한눈에 확인하기 어렵다. 이를 바꿔주는 설정을 해보자. 4. DB웹상 유저명 보기 쉽게 변경파이썬에는 기본 문자열을 반환해주는 언더바 두개로 감싼 내장함수( str )를 가지고 있다.이를 이용하여 문자열을 원하는대로 바꿀수있다.fcuser앱 아래의 models.py에서 class 안에 아래 코드를 추가해주면된다. 12def __str__(self): return self().username 5. DB웹상 다양한 유저정보 출력원하는대로 Fcuser object(1)에서 유저명으로 변경되었다.하지만 뭔가 좀 아쉽다.더 많은 정보들이 한눈에 보였으면 좋겠다. 이럴때 해줄 수 있는 방법이 있다.fcuser앱 아래의 admin.py에서 class 안에 아래 코드를 추가해주면된다.password말고도 다양한 내용을 추가입력하면 아래 이미지처럼 한눈에 보기좋게 출력된다. 12class FcuserAdmin(admin.ModelAdmin): list_display = ('username', 'password') #튜플로 만듬 유저명 위의 카테고리설명줄도 FCUSER -&gt; 사용자명, 비밀번호로 변경된 것을 확인할 수 있다.이는 처음 클래스를 만들때 verbose_name=&quot;비밀번호&quot;속성을 추가했기 때문이다. 6. admin페이지 출력 문자열 변경admin page에서 만든 fcuser앱의 하위의 fcusers도 변경해보자.fcuser였는데 s가 붙은 이유는 기본적으로 장고에서는 복수형태로 자동변환해서 출력해주기때문이다. fcusers가 뭘 뜻하는지 알기 쉽게 한글명으로 변경하려면 fcuser앱 아래의 models.py에서 class안의 class Meta:에서 verbose_name을 속성을 주면 된다. 1234class Meta: db_table = \"fastcampus_fcuser\" verbose_name = \"패스트캠퍼스 사용자\" verbose_name_plural = \"패스트캠퍼스 사용자\" 위에서 말했듯이 장고에서 자동적으로 복수형을 기입하기 때문에 verbose_name_plural입력하지 않는 경우 아래 이미지와 같이 패스크캠퍼스 사용자s라는 한국어에서 듣도보도 못한 문법으로 출력된다ㅋㅋㅋㅋㅋ","link":"/2020/06/22/200623python/"},{"title":"[ITWILL : JSP]JAVA DATATYPE, Integer.parseInt(문자열), 동일한 파라미터의 값을 가지는 데이터가 여러개있을 경우 변수로 가져오기","text":"ITWILL학원 : 14강 JSP기초 BY 정규태강사1. JAVA DATA TYPE 자바데이터타입기본형 8가지를 기억하면 나머지는 전부다 참조형이다. 1. 기본형 :8가지 boolean : 1byte char : 2byte byte : 1byte short : 2byte int : 4byte long : 8byte float : 4byte double : 8byte 2. 참조형 : 엄청 많음 String Scanner 등등 2. 형변환1. 묵시적 형변환메모리공간의 크기가 작은 곳에서 큰 곳으로 자동변환. 예시 : int(4바이트) -&gt; double(8바이트) 자동으로 변환되는 것을 말한다 누가 자동으로 형변환을 해줄까?정답은 컴파일러!!문제가 없기때문에 컴파일러가 자동으로 형변환을 해준다. 2. 명시적 형변환메모리공간의 크기가 큰 곳에서 작은 곳으로 변환. 왜 컴파일러가 자동으로 형변환을 해주지않을까?메모리공간의 차이로 데이터손실이 발생하기때문에 자동형변환을 해주지않는다. 예시인티저.파스인트(스트링)Integer.parseInt(문자열)은 문자열을 정수형(int)로 변경해준다. 12345678// 이전페이지에서 정보를 받아오기System.out.println(&quot;입력숫자 : &quot; + request.getParameter(&quot;num&quot;)); //콘솔에서 출력out.println(&quot;입력하신 숫자는 &quot; + request.getParameter(&quot;num&quot;)); //html화면에서출력//form태그에서 get방식으로 정보를 전달할시 모든 데이터는 string타입으로 변경되어 전달되기때문에//숫자데이터 출력을 원하면 형변환Integer.parseInt()해줘야한다int num = Integer.parseInt(request.getParameter(&quot;num&quot;));정수형값 : &lt;%=num %&gt; &lt;br&gt; 3. 파라미터값 한글처리form get방식과 달리 post방식을 사용하면 한글이 깨지는 문제가 발생한다.따라서 body태그 바로 밑에 파라미터 한글처리 코드가 필요하다. 1234&lt;!-- form post방식을 사용하면 한글이 깨지는 문제가 발생하기때문에 파라미터 한글처리 코드가 필요하다 --&gt; &lt;% request.setCharacterEncoding(\"UTF-8\"); %&gt; 4. 동일한 파라미터의 값을 변수로 가져오기사용자가 radio박스를 클릭하면 해당 데이터를 변수로 가져올수있다. request.getParameter(&quot;&quot;) : 큰따옴표안에 name속성을 넣으면된다. 정보를 입력하는 페이지는 아래와 같이 radio버튼을 만들어놓았다. 1234567&lt;form action=\"정보출력페이지.jsp\" method=\"post\" name=\"fr\"&gt;&lt;label&gt;성별 : &lt;/label&gt;&lt;input type=\"radio\" name=\"gender\" value=\"womyn\"&gt; 여성&lt;input type=\"radio\" name=\"gender\" value=\"men\"&gt; 남성&lt;input type=\"submit\" value=\"제출\"&gt;&lt;/form&gt; 정보를 출력하는 페이지는 아래와 같이 코딩하면 된다. 123456789&lt;h1&gt;변수가져오기&lt;/h1&gt;&lt;% String gender = request.getParameter(\"gender\");%&gt;&lt;h1&gt;사용자정보출력&lt;/h1&gt;입력하신 정보를 아래에서 확인해주세요 성별은 &lt;%=gender %&gt;입니다 &lt;br&gt; 5. 동일한 파라미터의 값을 가지는 데이터가 여러개있을 경우일반적으로 4번방법을 이용하면되지만 checkbox처럼 중복데이터가 가능한 경우는 어떻게 해야할까?동일한 파라미터의 값을 가지는 데이터가 여러개있을 경우 배열을 통해서 데이터를 저장해야한다. 사용자가 몇개를 선택할지 모르지만 변수로 가져오고 싶다면 request.getParameterValues(&quot;&quot;)을 이용한다. request.getParameterValues(&quot;&quot;) : 큰따옴표안에 name속성을 넣으면된다. 정보를 입력하는 페이지는 아래와 같이 checkbox버튼을 만들어놓았다. 12345678&lt;form action=\"정보출력페이지.jsp\" method=\"post\" name=\"fr\"&gt;&lt;label&gt;취미 : &lt;/label&gt;&lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt; 게임&lt;input type=\"checkbox\" name=\"hobby\" value=\"movie\"&gt; 영화감상&lt;input type=\"checkbox\" name=\"hobby\" value=\"workout\"&gt; 운동&lt;input type=\"submit\" value=\"제출\"&gt;&lt;/form&gt; 정보를 출력하는 페이지는 아래와 같이 코딩하면 된다. 1234567891011121314151617181920212223&lt;h1&gt;변수가져오기&lt;/h1&gt;&lt;% // String hobby = request.getParameter(\"hobby\"); //중복데이터 변수로 가져오기 불가능. 첫번째꺼데이터만 출력가능 //동일한 파라미터의 값을 가지는 데이터가 여러개있을 경우 배열을 통해서 저장해야한다. String[] hobbyarr = request.getParameterValues(\"hobby\"); //중복데이터 변수로가져오기가능 %&gt;&lt;h1&gt;사용자정보출력&lt;/h1&gt;취미는 &lt;% if(hobbyarr == null){ //취미를 선택 안한경우 처리 out.println(\"선택안함\"); }else{ for(int i=0;i&lt;hobbyarr.length;i++){ %&gt; &lt;%=hobbyarr[i] %&gt; &lt;% } }%&gt;입니다&lt;br&gt;","link":"/2020/06/23/200624jspi/"},{"title":"[ITWILL : JSP]영역객체scope","text":"ITWILL학원 : 14강 JSP기초 BY 정규태강사참고로 교재는 p209부터임. 1. 영역객체(scope)영역 객체(Scope) , 속성(Attribute) 내장객체 (8+1)중에서 해당 유효한 범위안에서 데이터를 서로 공유할수있는 객체이때, 그 공유되는 범위를 ‘영역(Scope)’라고한다. 그때의 공유되는 값 ‘속성(Attribute)’라고한다. 영역 영역처리 객체 page pageContext request request session session application application 왼쪽의 영역을 처리하기 위해서는 오른쪽의 객체를 사용해야한다.내장객체 8가지 중에서 위의 4가지들은 서로 데이터를 공유할 수 있다.page에서 application으로 영역이 내려올수록 영역의 범위/크기가 커진다. 1. page 영역 : 해당 페이지가 클라이언트에 정보를 제공하는 동안해당 페이지가 클라이언트에 정보를 제공하는 동안 페이지 영역이라는 공간에서 데이터를 주고받을 수 있다. pageContext 객체사용가능 : JSP페이지 정보를 저장하는 객체 사용 : 다른 내장객체를 호출하거나, 페이지흐름제어하거나, 에러데이터 처리할 때 주로 사용한다 2. request 영역 : 클라이언트 요청이 처리되는 동안여러개의 페이지를 이동할때 정보를 저장해서 사용page 영역과 request영역 차이request영역은 주소창에 주소를 치는 동안의 영역이다. request 객체사용가능 : 페이지 요청시 정보를 처리하는 객체 사용 : 페이지 이동시 주로 사용한다. 3. session 영역 : 세션이 유지되는 동안 (브라우저당 세션 1개씩 생성이되고 기본값은 30분)예를 들어 크롬창을 키는 순간부터 30분동안 세션에 정보가 저장된다. session 객체사용가능 : 하나의 웹 브라우저가 정보를 유지하기위한 시간동안 사용되는 객체 사용 : 사용자인증처리에서 주로 사용한다. 4. application 영역 : 웹 애플리케이션이 실행되고있는 동안즉 서버가 실행중일때의 영역이다.서버의 설정정보나 자원에 대한 정보, 애플리케이션실행시 발생하는 이벤트정보등이 저장된다.4가지영역중 가장 큰 영역이다 application 객체사용가능 : 웹 애플리케이션의 Context 정보를 처리객체 사용 : 홈페이지 방문자수 카운트 등에 주로 사용한다.","link":"/2020/06/23/200624jspi2/"},{"title":"[패스트캠퍼스python] 부트스트랩을 이용한 회원가입페이지만들기, csrf token","text":"파이썬 인강 자기계발 챌린지 31회차 미션부트스트랩을 이용해 회원가입페이지를 만들어보자 1. 부트스트랩 설정앱 아래에 만들어놓은 templates폴더안에 register.html 파일을 생성한다.그 뒤 부트스트랩 홈페이지로 이동한다. head태그안에 부트스트랩 CSS를 복붙한다. head태그안에 부트스트랩 JS를 복붙한다. head태그안에 아래 기본 meta코드를 복붙한다. 12&lt;meta charset=\"utf-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; 또는 위의 3단계를 생략하고 부트스트랩 Starter template를 복붙해도 된다! 2. Bootstrap’s form styles 적용하기.부트스트랩 컴포넌즈 폼에서 form태그를 복붙해온뒤 센터정렬이라든지 커스터마이징을 할수있다.부트스트랩의 기본 폼스타일은 아래 이미지와 같다.딱 심플 그자체! 기본 폼 스타일에서 커스터마이징을 해보자.input태그를 추가하여 비밀번호 확인을 만들 수 있다.input태그를 추가한 후 python manage.py runserver명령어를 입력한 뒤 주소창에 register/를 추가입력해주면 커스터마이징한 웹페이지가 나타난다. 3. html페이지를 view에 연결하기부트스트랩으로 만든 html페이지를 view에 연결을 해줘야한다.앱 아래의 views.py파일에서 아래 코드를 입력한다. view는 항상 request라는 매개변수를 받기때문에 입력을 해주어야한다. 1234from django.shortcuts import renderdef register(request): return render(request, 'register.html') #따옴표안에 연결하고싶은 파일의 경로입력 4. url설정 앱 하위에 urls.py파일을 생성한 뒤 아래 코드를 입력해준다register는 3번에서 만든 views안의 register함수를 연결해준 것이다. 1234567from django.urls import pathfrom . import viewsurlpatterns = [ path('register/', views.register), #register는 views안의 register함수에 연결하겠다는 의미] 프로젝트폴더의 동일한 이름으로 자동생성된 파일 하위의 urls.py를 클릭한다.urls.py에서 path('앱명/', include('앱명.urls')) 한줄을 추가한다.추가한 뒤 전체코드는 아래와 같다. 1234567from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('앱명/', include('앱명.urls'))] python3 manage.py runserver 실행.잘 연결되었는지 확인을 위해 python3 manage.py runserver를 실행한다. 5. csrf_token장고를 이용하면 꼭 넣어야하는 코드이고 항상 form태그 안에 위치해야한다.form의 겨우 데이터를 서버에 전달하는 역할을 하는데 우리 사이트에서 우리 서버로 데이터를 전송하는 것은 문제될것이 없으나 피싱범죄를 목적으로 자신의 웹사이트에서 전송을 하는 경우가 있다.이를 방지하기 위해, 즉 크로스도메인을 막기위해 암호화된 키를 숨겨놓는다. 참고링크 : CORS 크로스 도메인 이슈와 해결방법 이 코드를 {% csrf_token %}입력을 해놓으면 장고가 알아서 암호화된 키를 생성하고 키검증까지 자동으로 해준다. 123&lt;form method=\"POST\" action=\".\"&gt; {% csrf_token %}&lt;/form&gt; 여기서 action값을 생략하거나 점(.)을 입력하면 현재페이지 action이 진행된다.실제 사용예시는 아래와 같다. form태그 밑에 위치하면 된다!","link":"/2020/06/23/200624python/"},{"title":"[ITWILL : JAVA]배열과 함께쓰는 메서드","text":"ITWILL학원 : 10강 JAVA BY 윤미영강사1. for each문향상된 for문인 for each문은 기존 for문과 비교해서 초기값과 증감식을 사용하지 않으며 배열이 가지고 있는 요소들을 특정 변수로 바로 할당해서 사용할 수 있게한다 123for(데이터타입 변수명 : 반복할 배열명/컬렉션){ //반복할 문장} 이 반복문은 내부적으로 배열의 인덱스 0번부터 배열의 길이만큼을 반복한다. 장점 : 전체적으로 for문을 훨씬 간결히 작성할 수 있다. 단점 인덱스를 사용하지않고 사용불가능. 반복 처리할 범위를 지정불가능. 결론 : 따라서 인덱스를 써야하거나 특정범위를 반복해야하는 경우는 전통적인 for문을 쓰고 아닐 경우 for each를 쓰면 된다 아래 for문과 for each문의 예시를 보자.랜덤한 짝수를 3개를 뽑은 뒤 그 합을 구해보자. 랜덤한 짝수 3개뽑기는 index를 사용해야하기때문에 for each를 쓸 수 없다.뽑은 짝수합을 구하는 경우 index도 필요없고 특정범위반복도 필요없기때문에 for each를 쓰면 한결 간결해진다. 1234567891011121314151617int[] evendatas = new int[3];//랜덤한 짝수 3개 뽑기for(int i=0;i&lt;evendatas.length;i++){ evendatas[i] = rd.nextInt(8)+1; if(evendatas[i]%2 !=0){ evendatas[i] = evendatas[i]+1; } System.out.print(evendatas[i]+\"\\t\");}//뽑은 짝수합구하기evenSum = 0;for(int data : evendatas){ evenSum+=data;}System.out.print(\"랜덤한 짝수의 합 : \"+evenSum); 2. 배열 데이터의 정렬배열과 같은 자료구조에 대해서는 정렬에 대한 요구사항이 빈번하다.정렬을 구현하기 위한 알고리즘은 버블 정렬, 선택 정렬, 삽입 정렬 등 여러가지 방식이 있다. Arrays.sort() 오름차순정렬Arrays클래스 API를 이용하기 위해 import java.util.Arrays;해줘야한다.만약 문자열을 관리하는 배열이 파라미터로 들어온다면 대문자-&gt;소문자의 사전순으로 정렬한다. 12345678910int[] data = {5, 7, 2, 9, 1};Arrays.sort(data);//정렬 후 출력for(int x : data){ System.out.print(x + \"\\t\");}//출력값1 2 5 7 9 3. 배열 데이터의 출력 : Arrays.toString(arr)배열데이터를 출력하기 위해서 for문을 이용해도 되지만 Arrays클래스 API를 이용하여 출력할수있다.Arrays.toString(arr)사용하기 위해서는 import를 먼저 해야한다. 1234567891011121314String [] arr1 = {\"JAVA\", \"is\", \"Not\", \"bad\"};Arrays.sort(arr1);//배열출력1 : for each이용for(String s :arr1){ System.out.print(s + \"\\t\");}//배열출력2 : Arrays클래스 API이용 System.out.println(Arrays.toString(arr1));// 출력값JAVA Not bad is [JAVA, Not, bad, is] 4. Arrays 로또 만들기배열에 무작위 숫자로 구성된 로또를 만들고 정렬 후 출력하는 게임을 만들어보자.로또는 1~45사이의 숫자로 구성되며 6개의 숫자를 랜덤으로 뽑느다.그리고 모든 숫자의 중복 x. 1234567891011121314151617int[] selected = new int[6]; //로또를 저장할 배열int[] fullBall = new int[45]; //모든 공의 정보를 가지고 있는 배열int cnt= 0;Random rd = new Random();while(cnt &lt; 6){ //총 6개의 공을 선택할 조건 int index = rd.nextInt(45); //0~44사이의 정수 int ball = fullBall[index]; if(ball ==0){ //중복체크 selected[cnt] = index +1; fullBall[index] = -1; cnt ++; }}Arrays.sort(selected);System.out.println(Arrays.toString(selected));} random.nextInt(n)이는 0~(n-1)개의 정수를 랜덤하게 생성한다.그렇다면 여기선 random.nextInt(45)이므로 0~44사이의 랜덤한 정수를 생성하게된다.왜그럴까?selected된 공은 index에서 +1해주기때문이다if문을 보자.랜덤으로 index가 0이 걸리면 선택된 공은 1이되고랜덤으로 index가 44가 걸리면 선택된공은 45가된다. ball if문으로 중복체크ball = 0이 참이면 이 fullBall[index]가 한번도 뽑힌적이 없는 숫자라는 의미이다.그리고 선택되어지고 selected[cnt] = index +1을 준다.그리고 이미 뽑힌 수는 -1로 값을 준다.그렇게되면 다음번에 또 뽑혔을때 -1이기때문에 거짓이 되어 selected가 되지않는다. 123예를 들어fullBall[2]가 처음뽑혔으면 if문이 참이므로 selected[1]가 되고 로또숫자는 3이다.그리고 난 뒤 fullBall[2] = -1로 바뀌어서 다음번에 뽑혀도 if문에서 거짓으로 팅겨나간다 5. System.arraycopy()배열은 한 번 생성되면 메모리의 연속성때문에 그 크기를 변경할 수 없다.하지먼 프로그래밍을 하다 보면 처음 예상했던 데이터의 개수보다 더 많은 데이터를 관리해야할 경우가 있다.이를 예방하기위해 처음부터 배열의 크기를 크게 지정해버린다면 불필요한 메모리를 낭비하는 꼴이다. 필요에 따라 배열의 길이를 늘이기 위해서는 기존배열의 길이를 늘일수는 없고배열의 길이 큰 새로운 배열은 만들고 기존 데이터를 복사해 넣은 다음 새로운 데이터를 추가해야한다. 첫번째 방법 : for문과 Arrays.toString()이용123456789int[] source = {1,2,3};int[] newSource = new int[7]; //원하는 배열길이만큼의 숫자입력for(int i=0; i&lt;source.length; i++){ newSource[i] = source[i];}System.out.println(Arrays.toString(newSource));//출력값[1, 2, 3, 0, 0] 두번째 방법 : System.arraycopy()와 Arrays.toString()이용System.arraycopy(기존배열명, 카피할데이터인덱스, 새로운배열명, 데이터붙여넣을시작인덱스, source.length); 아래처럼 데이터붙여넣을시작인덱스에 2를 넣었기때문에 출력값은 인덱스2번부터 [0, 0, 1, 2, 3, 0, 0]부터 붙여넣기가 된다.만약 0을 넣었다면 출력값은 인덱스0번부터 [1, 2, 3, 0, 0, 0, 0]이 된다. 1234567int[] source = {1,2,3};int[] newnewSource2 = new int[7] //원하는 배열길이만큼의 숫자입력System.arraycopy(source, 0, newnewSource2, 2, source.length);System.out.println(Arrays.toString(newnewSource2));//출력값[0, 0, 1, 2, 3, 0, 0] 5. Integer.parseInt(파라미터)GUI환경에서 가장 잘 사용하는 메서드이다.정수의 형태인 파라미터를 int로 변경해 리턴한다.만약 파라미터가 정수형태가 아닐 경우 NumberFormatException 에러가 난다.","link":"/2020/06/23/200624javai/"},{"title":"클래스 : 메서드, 객체생성(객체화 &#x3D; 인스턴스화), 오버로딩(overloading)","text":"메서드 메서드란 어떤 작업을 수행하는 명령문(코드)의 집합을 표현한다.다른 언어에서는 함수라고도 부른다. 메서드를 작성하는 이유 : 반복적으로 사용되는 코드의 중복을 방지. 코드양을 줄여주어 유지 보수성을 향상하기 위함. main메서드 : system소속으로 실행을 담당하는 특별한 메서드이다. 메서드종류 생김새 특징 main메서드 public static voide main(String[] args){ } system소속, 실행을 담당. void형 메서드 void 메서드명(){ } return값 없음. 변수에 담아서 사용X, 호출만 가능. return형 메서드 리턴데이터타입 메서드명(){ } return값이 있기에 리턴데이터타입작성필수, 변수에 담아서 사용가능. 메서드의 형태매개변수는 호출시에만 메모리에 할당받고 메서드실행이 끝나는 순간 매개변수는 사라진다.매서드는 return값이 없으면 void를 붙여준다. 123제한자/리턴_타입 메서드명(타입 변수명, 타입 변수명, ...){ 실행코드} void 메서드 예시void는 return값이 없는 메서드이다return이 없기때문에 system.out,print(person())에서 사용할 수 없고 변수에 담아서 사용할 수 없다.오직 호출만가능하다. 1234567891011public class Person { void eat(String food){ //String food는 매개변수라고 부른다 System.out.println(food + &quot;먹었다&quot;) }}Person p = new Pesron();p.eat(&quot;바나나&quot;); //바나나먹었다p.eat(&quot;딸기&quot;); //딸기먹었다p.eat(1); //타입에러p.eat(&quot;1&quot;); //'먹었다 리턴타입이있는 메서드 예시return값이 있는 메서드는 리턴타입을 적어주면된다 1234567891011public class Person { String name = '민지'; int age = '77'; String infoPrint(){ //String타입을 리턴값으로 가지는 메서드이다. return name +&quot;는 &quot;+ age; }} Person p1 = new Pesron();System.out.println(p1.infoPrint()); // 민지는 77 메서드 오버로딩(Method overloading) 동일한 기능을 수행하는 메서드를 매개변수를 달리하여 추가로 작성하는 것을 의미. 데이터타입이 다른 매개변수에 따라 메서드를 여러개 정의하는 것을 말한다. 메서드오버로딩방법 : 동일한 이름의 메서드에 파라미터의 개수 또는 파라미터의 타입을 다르게 작성하면 된다. 오버로딩 사용하는 이유 : 재사용성을 높이기 위해서. 오버로딩과 오버라이딩은 차이가 있으니 용어에 주의하자 오버로딩(Overloading) : 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술 오버라이딩(Overriding) : 상속관계일때 사용. 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용 메서드뿐만 아니라 생성자도 오버로딩이 가능하다. 생성자 오버로딩 : 파라미터를 다르게 해서 여러 개의 생성자를 정의하는 것 객체(인스턴스)클래스가 붕어빵틀이라면 객체는 붕어빵 그 자체이다.배열과 마찬가지로 객체도 선언 후에 생성을 해야 사용할수있다.객체생성을 하지않으면 메모리에 올가가지않기에 사용할수가없다. 따라서 객체생성을 꼭해야한다. 객체생성 1객체명 변수명 = new 클래스명(); //객채생성 참고링크 : 클래스와 인스턴스","link":"/2020/06/24/200625javai2/"},{"title":"[ITWILL : JSP]영역객체 안에서 사용하는 속성(Attribute), 링크이동 방법별 전달가능한 영역(scope)","text":"ITWILL학원 : 15강 JSP기초 BY 정규태강사1. 영역객체 안에서 사용하는 속성(Attribute)속성(Attribute)을 저장해서 사용. 사용형태 2가지 해당영역객체.setAttribute(&quot;이름&quot;, 값) 해당영역객체.getAttribute(&quot;이름&quot;) 1234567//html페이지&lt;fieldset&gt; &lt;form action=&quot;jsp페이지.jsp&quot; method=&quot;get&quot;&gt; &lt;label&gt;아이디 : &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/fieldset&gt; 페이지객체에서 setAttribute(“이름”, 값)를 통해 생성하고 getAttribute(“이름”)를 통해 출력한다. 123456789101112131415//jsp페이지&lt;h1&gt;내장객체(pageContext, request, session, application)생성&lt;/h1&gt; &lt;%pageContext.setAttribute(&quot;p&quot;, &quot;pageContext 값있음!&quot;);request.setAttribute(&quot;req&quot;, &quot;request 값있음!&quot;);session.setAttribute(&quot;ses&quot;, &quot;session 값있음!&quot;);application.setAttribute(&quot;app&quot;, &quot;application 값있음!&quot;);&lt;h1&gt;내장객체 (pageContext, request, session, application)출력&lt;/h1&gt; pageContext 내장객체의 값 : &lt;%=pageContext.getAttribute(&quot;p&quot;)%&gt;&lt;br&gt;request 내장객체의 값 : &lt;%=request.getAttribute(&quot;req&quot;)%&gt;&lt;br&gt;session 내장객체의 값 : &lt;%=session.getAttribute(&quot;ses&quot;)%&gt;&lt;br&gt;application 내장객체의 값 : &lt;%=application.getAttribute(&quot;app&quot;)%&gt;&lt;br&gt;%&gt; 2. 링크이동 방법별 전달가능한 영역(scope)공통적으로 아래 4가지 방식들은 session,application, 파라미터를 저장/전달가능하다. 자바스크립트, JSP(sendRedirect), 액션태그 방식은 서로 같이 사용불가. 2-1. a태그로 이동시사용가능한 영역은 4가지영역(pageContext,request,session,application) 중에 session, application영역의 값 공유가능하다. 1&lt;a href=\"scopeProPro.jsp\"&gt; scopeProPro.jsp로 페이지이동 ... &lt;/a&gt; 만약 파라미터의 값도 저장하고 전달하고 싶다면 어떻게 하면될까?표현식을 이용하면 된다.파라미터까지 전달이 가능하다. 1&lt;a href=\"scopeProPro.jsp?id=&lt;%=id%&gt;\"&gt; scopeProPro.jsp 페이지로 이동 ... &lt;/a&gt; 즉, a태그(링크) 이동시 session,application 영역의 값을 공유가능.파라미터의 값도 저장/전달 가능하다(get 방식)HTML이기에 파라미터를 가져갈때 표현식을 사용하면된다. 2-2. js에서 location.href사용하여 이동시자바스크립트 이동시 session,application 영역의 값을 공유가능.파라미터의 값도 저장/전달 가능하다(get 방식)HTML이기에 파라미터를 가져갈때 표현식을 사용하면된다. 1234&lt;script type=\"text/javascript\"&gt;alert(\"자바스크립트로 scopeProPro.jsp 페이지로 이동\")location.href=\"scopeProPro.jsp?id=&lt;%=id%&gt;&amp;pw=1234\";&lt;/script&gt; 2-3. 내장객체 response 이동시session,application 영역의 값을 공유가능.파라미터의 값도 저장/전달 가능하다(get 방식).파라미터를 가져갈때 표현식이 아닌 1234567&lt;%//response.sendRedirect(\"이동할 페이지 주소\");response.sendRedirect(\"scopeProPro.jsp\");//파라메터 추가로 같이 공유하는 방법response.sendRedirect(\"scopeProPro.jsp?id=\"+id+\"&amp;pw=1234\");%&gt; 아이디가 한글일때는 왜 물음표가 나타날까요?response.sendRedirect()전까지는 한글이 안깨지다가 response.sendRedirect()명령어부터 한글이 깨진다.데이터를 인코딩해서 보내야한다. 인코딩에는 여러 방식이 있는데 response.sendRedirect()는 한글데이터를 처리하지못하는 인코딩방식이다.response객체안에 전달되는 콘텐츠타입을 바꿔서 해야하는데 그걸 하려면 서블릿을 이용해야해서 서블릿배우면 알수있다. 2-4. 액션태그 forward 이동시(p222)html태그이지만 jsp동작을 할수있게 만들어진 특수한 기능을 가지고 있다.액션태그 : jsp페이지에서 자바, 스크립트코드없이 다른 페이지로 이동하는 기능이 있다.서블릿, 객체(자바빈)에 접근할수있는 방법이 액션태그이다.원래 페이지에 의해 생성된 request객체와 response객체가 그대로 넘어간다. 즉, session,application 그리고 request 영역 더불어 파라미터값까지 공유가능. 1234567&lt;jsp:forward page=\"scopeProPro.jsp\" /&gt; 또는&lt;jsp:forward page=\"scopeProPro.jsp\"&gt; &lt;jsp:param name=\"pw\" value=\"&lt;%=a %&gt;\" /&gt; &lt;!--표현식사용가능 --&gt;&lt;/jsp:forward&gt; 액션태그는 포워딩이 일어난다. forwarding (포워딩)이란 이동하는 페이지의 주소는 변경 X, 페이지의 내용만 변경. 중요 request객체와 response객체를 가지고 이동가능 따라서 액션태그는 이동하는 페이지의 주소는 변경되지않고 페이지의 내용만 변경되는 희안한 태그이면서 request객체와 response객체를 가지고 이동한다. 그런데 주소를 변경안하는 기능이 왜 필요할까?MVC패턴개발방식에서 꼭 필요하다.웹서핑중에 jsp파일명을 주소창에서 본 적이 있는가?아마 없을 것이다. 보안을 위해서 .jsp파일을 절대 공개하지않는다.따라서 가상주소를 사용해야하는데 그 가상주소를 사용할때 액션태그 forward가 필요하다","link":"/2020/06/24/200625jspi/"},{"title":"[ITWILL : JSP]JSP 디렉티브(directive) 중 include VS 액션태그 include, jspf확장자 파일","text":"ITWILL학원 : 15강 JSP기초 BY 정규태강사1. include의 두 종류 @include : 골뱅이방식골뱅이방식은 jsp 지시어이고 jsp문법이다.공통으로 사용되는 변수를 파일에 지정해서 추가한다.해당 페이지가 컴파일되기전에(소스코드파일.java가 클래스파일로.class 변화하는 과정) 소스코드를 include한 후 컴파일한다.컴파일을 한번한다. jsp:include page=”” : 액션태그방식액션태그방식은 html문법이다.공통으로 사용되는 메뉴들을(주로 페이지) 특정 공간에 추가한다.해당 페이지가 java파일(서블릿)으로 컴파일 된 후에 include한다.컴파일을 두번하게된다. 12345 &lt;%@ include ~ %&gt; &lt;!-- JSP 지시어 : 공통으로 사용되는 변수를 파일에 지정해서 추가 --&gt; &lt;jsp:include page=\"\"&gt; ~ &lt;!-- 액션태그 : 공통으로 사용되는 메뉴들을(페이지) 특정 공간에 추가 --&gt; 예시아래 테이블에서 첫 행에 top.jsp라는 파일을 추가하고싶을때 jsp액션태그를 사용하는 방법이다. 123456789 &lt;table border=1 width=\"600\" height=\"600\"&gt; &lt;tr&gt; &lt;td colspan=\"2\" height=\"100\"&gt; &lt;jsp:include page=\"top.jsp\"&gt; &lt;jsp:param value=\"Your name\" name=\"name\"/&gt; &lt;/jsp:include&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 2. @include 와 jsp:include page=”” 차이점둘 다 목적은 include(추가)하는 거지만 include되는 시점이 다르다.골뱅이방식은 jsp파일에 include한 뒤 java가 되고 class파일이 된다.액션태그방식은 jsp가 java파일이 되고 거기에 include를 하고 class파일이 된다. 3. jspf확장자 파일jspf( Jsp Servlet Page Framegment ) : JSP 변수를 저장가능한 확장자파일.","link":"/2020/06/24/200625jspi2/"},{"title":"테이블 전체목록조회, 테이블구조조회, WHERE(조건문)절","text":"테이블 전체 목록조회내가 어떠한 테이블을 가지고 있는 지 모를때 아래 명령어를 날리면 몇개의 테이블을 가지고 있는지 알려준다 12SQL&gt; select *SQL&gt; from tab; 테이블 구조조회위에서 파악된 테이블 전체목록중에 구조 보고싶은 테이블이있다면 아래 명령어를 입력하면된다. describe 테이블명이지만 실무에선 줄여서 desc 테이블명 명령어를 사용한다. 1SQL&gt; desc 테이블명 WHERE(조건문)절 where 컬럼명 = 리터럴값 숫자employees테이블에 salary가 3500인 직원들의 last_name을 출력하는 쿼리. 123SQL&gt; select last_nameSQL&gt; from employeesSQL&gt; where salary = 3500; 문자(대소문자 주의!)employees테이블에 last_name이 Bell인 직원의 last_name과 연봉을 출력하는 쿼리.리터럴값은 대소문자를 구분하기때문에 Bell로 저장된 직원을 bell이나 BELL로 찾으면 no row selected가 뜬다.따라서 대소문자를 주의해야한다!모든 데이터가 소문자인지 대문자인지 intcap형태인지 헷갈리므로 이때 사용하는 대소문자변환함수가 있다. 123SQL&gt; select last_name, salarySQL&gt; from employeesSQL&gt; where last_name = 'Bell'; where between a AND ba는 b보다 항상 작은 값을 주고b는 a보다 항상 큰 값을 입력해야한다. a와b에는 숫자에만 들어갈 수있을까? Nope! 날짜도 순서가 있고 문자에도 순서가있다! 숫자 employees테이블에 연봉 2500에서 3000사이를 받는 직원의 last_name과 salary를 출력하는 쿼리. 123SQL&gt; select last_name, salarySQL&gt; from employeesSQL&gt; where salary between 2500 and 3000; 날짜 : 오래된날짜부터 최신순으로 날짜는 사람마다 국가마다 다르게 쓰기때문에 순서가 정해져있다.날짜는 DAY 두자리-MONTH두자리-YEAR두자리로 사용한다. 날짜순서 : DD-MON-RR employees테이블에서 입사일이 2004년 1월 1일부터 2004년 1월 31일까지인 직원의 last_name과hire_date를 출력하는 쿼리. 123SQL&gt; select last_name, hire_dateSQL&gt; from employeesSQL&gt; where hire_date between '01-JAN-04' and '31-JAN-04'; 문자 : 알파벳순서 기준으로 알파벳순서기준으로 Bell부터 Fay사이에 알파벳이 있는 모든 직원의 employee_id와 last_name을 출력하는 쿼리. 123SQL&gt; select employee_id, last_nameSQL&gt; from employeesSQL&gt; where last_name between 'Bell' and 'Fay'; where 컬럼명 in (a,b,c)a,b,c에는 숫자가능하고 문자도 가능하다.문자쓸때는 꼭 ('a','b','c')를 붙여서 사용하면된다. where 컬럼명 in (a,b,c)는 &&(앤드)연산자처럼생각하면된다.a,b,c를 다 포함하는 걸 출력하는 쿼리이다. where 컬럼명 in (a,b,c) 는 where 컬럼명 = a or 컬럼명 = b or 컬럼명 = c와 동일하다or가 약간 헷갈릴수있지만 a,b,c를 다~ 포함하는 것이란걸 유의하자. employees테이블에서 manager_id가 100이거나 101이거나 201인 직원의 employee_id, last_name, manager_id 를 출력하는 쿼리. 123SQL&gt; select employee_id, last_name, manager_idSQL&gt; from employeesSQL&gt; where manager_id in (100, 101, 201); 이와 동일한 결과가 나오는 쿼리는 아래와 같다.or가 약간 헷갈릴수있지만 매니저ID가 100,101,201인 걸 다 포함하는 것이란걸 유의하자. 123SQL&gt; select employee_id, last_name, manager_idSQL&gt; from employeesSQL&gt; where manager_id = 100 or manager_id = 101, manager_id = 201); where 컬럼명 like ‘’ 비교연산자like비교연산자는 우변에 패턴이 와야한다.대소문자구분되니 대소문자 작성에 유의하자! % : 자리에는 문자가 아예 없거나 또는 여러개여도 된다는 의미._ : 앞자리에 반드시 무언가가 와야한다는 의미. a시작하는 문자열 찾기a로 시작되는 문자열을 찾고싶을때 like 'a%'로 쿼리를 보내면 된다. abc =&gt; 조건일치 (a로 시작해서) a =&gt; 조건일치 (a로 시작해서) baaaa =&gt; 조건불일치 (a로 시작하지않아서) bsc =&gt;조건불일치 a가 포함된 문자열 찾기a가 포함되는 문자열을 찾고싶을때 like '%a%'로 쿼리를 보내면 된다. abc =&gt; 조건일치 a =&gt; 조건일치 baaaa =&gt; 조건일치 bsc =&gt;조건불일치 a로 끝나는 문자열 찾기a로 끝나는 문자열을 찾고싶을때 like '%a'로 쿼리를 보내면 된다. abc =&gt; 조건불일치 a =&gt; 조건일치 baaaa =&gt; 조건일치 bsc =&gt;조건불일치 두번째문자가 a인 문자열 찾기두번째문자가 a인 문자열을 찾고싶을땐 like '_a%'(언더바1개)로 쿼리를 보내면 된다. abc =&gt; 조건불일치 a =&gt; 조건불일치 baaaa =&gt; 조건일치 bsc =&gt;조건불일치 끝에서 세번째문자가 a인 문자열 찾기끝에서 세번째문자가 a인 문자열을 찾고싶을땐 like '%a__'(언더바2개)로 쿼리를 보내면 된다. abc =&gt; 조건일치 a =&gt; 조건불일치 baaaa =&gt; 조건일치 bsc =&gt;조건불일치 employees테이블에서 last_name의 두번째 문자가 소문자 o인 직원의 last_name를 출력하는 쿼리. 123SQL&gt; select last_nameSQL&gt; from employeesSQL&gt; where last_name like '_o%'; 5. where 컬럼명 is null따라서 아래 4가지로 NULL값을 가진 컬럼을 출력할수있을까? where 컬럼명 = null where 컬럼명 = ‘null’ where 컬럼명 = ‘Null’ where 컬럼명 = ‘NULL’ 정답은 NOPE! 싹 다 틀렸다. NULL은 특수한 값이다.따라서 일반 사칙연산자(=등)으로는 비교를 할 수 없다.NULL은 특수한 값이때문에 자체 연산자가 따로 있다.그것이 바로 IS NULL이다. 대소문자 구분은 안해도 된다. employees테이블에서 manager_id가 null인 직원(즉, 대표이사)의 employee_id, last_name를 출력하는 쿼리. 123SQL&gt; select employee_id, last_nameSQL&gt; from employeesSQL&gt; where manager_id is null; 참고링크 : where절 쿼리에 조건주기 WHERE(조건문)절 부정where조건절의 부정은 not을 적어주면 된다.","link":"/2020/06/25/200626dbi/"},{"title":"[패스트캠퍼스python] 회원가입페이지만들기2 비밀번호일치여부확인","text":"파이썬 인강 자기계발 챌린지 32회차 미션 1. 비밀번호와 비밀번호확인값 데이터베이스에 넣기원래 프론트앤드에서 주로 담당하지만 백엔드로도 만들 수 있다.기본 코드는 앱 하위 view.py파일에서 아래 코드를 작성한다. request를 가져오는 방식에느 get과 post가 있다. post일때 회원가입페이지이므로 register.html 파일에서 input태그마다 붙여준 name값을 키로 가지고와서 함수를 실행시킨다. fcuser에 입력값을 생성하기 위해서는 기존의 clas fcuser를 상단에 import해야한다 -&gt; from .models import Fcuser 12345678910111213141516171819202122from django.shortcuts import renderfrom .models import Fcuser #새로운 importdef register(request): if request.method == \"GET\": return render(request, 'register.html') #연결하고싶은 파일의 경로 elif request.method == \"POST\": #회원가입하는 코드작성 -&gt; register.html파일에서 name값을 키로해서 함수진행 username = request.POST['username'] password = request.POST['password'] re_password = request.POST['re-password'] #fcuser생성 -&gt; fcuser를 사용하기 위해서 기존의 clas fcuser를 import해야한다 fcuser = Fcuser( #객체를 생성해서 저장 username=username, password=password ) fcuser.save() return render(request, 'register.html') #연결하고싶은 파일의 경로 회원가입페이지에서 값들을 입력하고 등록버튼을 누르면 빤짝하고 아래 이미지처럼 모든 값들이 리셋되어진다. 어떠한 변화가 생긴걸까?위의 코드의 함수가 실행되었지만 입력값들이 post로 들어왔기때문에 elif문을 실행해주고 마지막에 render가 ‘register.html’를 호출했기때문에 페이지사의 변화는 없어보일뿐 데이터는 데이터베이스에 저장되어있다. 2. 비밀번호와 비밀번호확인입력값이 일치하는 지 확인일치여부는 if문으로 간단하게 나타낼수있다.앱 하위의 views.py에서 아래 코드를 작성하면된다 12345678910111213141516171819202122232425from django.shortcuts import renderfrom .models import Fcuserfrom django.http import HttpResponse #새로운 importdef register(request): if request.method == \"GET\": #기존회원로그인 return render(request, 'register.html') elif request.method == \"POST\": #회원가입 username = request.POST['username'] password = request.POST['password'] re_password = request.POST['re-password'] #비밀번호와 비밀번호확인일치여부 if password != re_password: return HttpResponse('비밀번호가 다릅니다') # HttpResponse를 사용하기위해 파일 상단에 import시켜준다 fcuser = Fcuser( username=username, password=password ) fcuser.save() return render(request, 'register.html') 기존이 회원가입페이지내용이 다 사라져버려서 유저입장에서 불편하다.따라서 기존 코드에서 더 나아가보자. 기존 register()함수에서 res_data = {} 변수를 생성하여 불일치의 경우의 데이터를 변수에 담는다.함수가 끝나가는 마지막라인에서 변수 res_data도 함께 return해준다. 123456789101112131415161718192021222324def register(request): if request.method == \"GET\": return render(request, 'register.html') elif request.method == \"POST\": #회원가입하는 코드작성 -&gt; 앞에서 만든 네임값을 키로해서 진행 username = request.POST['username'] password = request.POST['password'] re_password = request.POST['re-password'] #비밀번호와 비밀번호확인일치여부 res_data = {} #불일치의 경우 데이터를 res_data라는 변수에 담는다. if password != re_password: res_data['error'] = '비밀번호가 다릅니다' fcuser = Fcuser( username=username, password=password ) fcuser.save() return render(request, 'register.html', res_data) 위 코드이 변수res_data가 return할 값이 출력되어야하기때문에 register.html error가 출력된 수 있도록 코드를 추가해야한다.에러코드가 나타나길 원하는 위치에 {{ error }}를 작성해주면 끝! 12345&lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; {{ error }} &lt;/div&gt;&lt;/div&gt;","link":"/2020/06/24/200625python/"},{"title":"Order by 정렬","text":"order by를 입력하는 순서는 쿼리구문의 제일 마지막에 적어줘야한다. 오름차순정렬 : asc = ascending order, default 내림차순정렬(최신이 위쪽) : desc = descending order 컬럼명은 alias를 적어도 적용가능하다 asc : 오름차순 정렬, 디폴트값asc를 적어도되고 생략해도 동일한 결과값이 출력된다. 아래 예시는 employees테이블에서 hire_date로 오름차순 정렬하여 출력하는 퀴리이다. 123select last_name, job_id, department_id, hire_date from employeesorder by hire_date; 아래와 같이 오름차순으로 정렬됨을 알수있다 desc : 내림차순 정렬내림차순을 원하면 꼭 적어줘야한다. 어디서 본적이 없는가?desc는 describe의 약어이기도했다.동명이기능이라고 생각하면된다. hire_date를 alias로 date로 별칭을 정한뒤 order by 컬럼명을 별칭으로 적어도 정상적으로 출력된다.아래 예시는 employees테이블에서 별칭date로 내림차순 정렬하여 출력하는 퀴리이다. 123select last_name, job_id, department_id, hire_date as datefrom employeesorder by date desc; 위치값기준 정렬위치값으로 정렬할수도있다. 아래 예시를 보자.숫자 3을 기준으로 어떻게 정렬될까? select되어진 컬럼들을 차례대로 1번부터 시작하면 된다.3이니 department_id를 기준으로 아무것도 적지않았으니 asc로 정렬하게된다. 아래 예시는 employees테이블에서 department_id로 오름차순 정렬하여 출력하는 퀴리이다. 123select last_name, job_id, department_id, hire_datefrom employeesorder by 3; 다중컬럼기준 정렬다중컬럼 기준으로 정렬도 가능하다이때는 정렬되는 순서가 달라지는데 order by 1번컬럼, 2번컬럼인 경우 1번컬럼 정렬 후!!! 2번컬럼이 정렬되어 출력된다. 아래예시를 보자.employees테이블에서 department_id는 오름차순 정렬한 뒤 salary는 내림차순정렬로 last_name, job_id, department_id, salary를 출력하는 춰리이다. 123select last_name, job_id, department_id, salaryfrom employeesorder by department_id, salary desc;","link":"/2020/06/25/200626dbi2/"},{"title":"radio버튼클릭에 따라 하위태그 사라지게 하기","text":"아래예시를 보자.정보를 제공받으시겠습까 radio버튼 아니요를 클릭하면 아래 소식을 어떻게받으시겠습니까는 아예 사라지게 하고싶다. 아래는 html구조이다 12345678910&lt;p&gt;&lt;label for=\"acceptInfo\"&gt;♣아이티윌부산이 제공하는 정보를 받으시겠습니까?&lt;/label&gt;&lt;/p&gt;&lt;input type=\"radio\" name=\"event\" id=\"event-y\" checked&gt;&lt;label for=\"event-y\"&gt;예, 받겠습니다&lt;/label&gt;&lt;br&gt;&lt;input type=\"radio\" name=\"event\" id=\"event-n\"&gt;&lt;label for=\"event-n\"&gt;아니요, 받지않겠습니다.&lt;/label&gt;&lt;br&gt;&lt;p id=\"event-h\"&gt;&lt;label for=\"howToGetInfo\"&gt;♣정보나 이벤트 소식을 어떻게 받으시겠습니까?&lt;/label&gt;&lt;br&gt;&lt;input type=\"checkbox\" name=\"howToGetInfo\" value=\"email\" checked&gt;이메일&lt;input type=\"checkbox\" name=\"howToGetInfo\" value=\"text\" &gt; 문자&lt;input type=\"checkbox\" name=\"howToGetInfo\" value=\"katalk\" checked&gt; 카카오톡&lt;input type=\"checkbox\" name=\"howToGetInfo\" value=\"mail\" &gt; 우편&lt;/p&gt; 아래는 css코드이다 1234&lt;style&gt; #event-y:checked~#event-h {display: block;} #event-h {display: none;}&lt;/style&gt;","link":"/2020/06/25/200626webi2/"},{"title":"input태그속성 및 input태그type종류","text":"required 속성필수입력요소를 설정할때 required 속성을 지정하면 된다.필수입력요소를 입력하지않고 submit버튼을 누르면 해당칸을 입력하라는 메세지가 출력되고 포커스까지 해준다. 12&lt;h1&gt;필수입력요소로 지정 : required &lt;/h1&gt;&lt;label&gt;연락처 : &lt;/label&gt;&lt;input type=\"text\" required&gt; readonly 속성 vs disabled 속성 readonly : 읽기전용이다. 쓰기가 불가하며 드래그는 가능하다. 태그자체를 가져가서 다른 곳에서 사용가능. 폼태그를 이용해서 submit했을때 데이터가 그대로 넘어가서 다른 곳에서 사용할 수 있다 disabled : 사용불가이다. 쓰기도 불가하고 드래그도 불가능하다. 태그자체를 가져갈수없어서 다른 곳에서 불러 사용할수없다. 폼태그를 이용해서 submit했을때 데이터가 아예 넘어가지않아 다른 곳에서 사용할 수 없다 required속성과 함께 출력해보면 아래 이미지처럼 출력된다. reired속성과 readonly 속성, disabled 속성은 의미상 맞으면 다른 tag에도 사용가능하지만 실무에서는 input타입에 가장 많이 쓰인다!!! type=&quot;number&quot; min, max, step속성입력창을 클릭하면 오른쪽에 화살표버튼이 생긴다. min값을 지정하지않으면 음수도 넣을 수 있다.step에 원하는 숫자n을 넣으면 n단위로 증가/감소 시킬 수 있다.주로 쇼핑몰에서 사용할수있는 속성이다 1234&lt;h1&gt;type=\"숫자\" min, max, step &lt;/h1&gt;&lt;label&gt;type=\"숫자\" min=\"1\" 최소값 : &lt;input type=\"number\" min=\"1\"&gt;개&lt;/label&gt;&lt;br&gt;&lt;label&gt;type=\"숫자\" max=\"10\" 최대값 : &lt;input type=\"number\" max=\"10\"&gt;개&lt;/label&gt;&lt;br&gt;&lt;label&gt; type=\"숫자\" step=\"5\" 5단위로 증가&lt;input type=\"number\" max=\"100\" step=\"5\"&gt;개&lt;/label&gt;&lt;br&gt; 출력값은 아래와 같다. fieldset 필드셋예로 쇼핑몰페이지에서 주문자정보, 배송지정보으로 각각 필드셋으로 묶어서 처리할 수 있다. 12345&lt;fieldset&gt; &lt;legend&gt;배송지정보&lt;/legend&gt; 배송지주소 : &lt;input type=\"text\" placeholder=\"신주소\"&gt;&lt;br&gt; 받는사람 연락처 : &lt;input type=\"text\" size=\"30\" placeholder=\"예) 010-1234-5678\"&gt;&lt;br&gt;&lt;/fieldset&gt; html5에서 추가된 input태그 types 종류input태그의 타입은 굉장히 다양하다 종류참고링크 : W3SCHOOLS input type 특징브라우저마다 지원가능여부도 다르고 디자인도 다르다.지원가능여부를 확인할 수 있는 유용한 사이트인 Can I use가 있다.참고링크 : Can i use에서 검색을 통해 브라우저별로 지원가능한지 확인할 수 있다. 전체 예시1234567891011121314151617181920212223242526&lt;h1&gt;html5에서 추가된 inpu태그 type값&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;input type=\"date\" : &lt;input type=\"date\"&gt;&lt;/li&gt; &lt;!-- 날짜를 포함하는 입력영역(년월일) --&gt; &lt;li&gt;input type=\"datetime-local\" : &lt;input type=\"datetime-local\"&gt;&lt;/li&gt; &lt;!-- 사용자가 위치한 나라를 기준으로 날짜와 시간 입력(년월일시분초) --&gt; &lt;li&gt;input type=\"time\" : &lt;input type=\"time\"&gt;&lt;/li&gt; &lt;!-- 사용자가 위치한 나라를 기준으로 시간 입력 (시분초) --&gt; &lt;li&gt;input type=\"week\" : &lt;input type=\"week\"&gt;&lt;/li&gt; &lt;!-- 사용자가 위치한 나라를 기준으로 날짜 입력 (년주) --&gt; &lt;li&gt;input type=\"month\" : &lt;input type=\"month\"&gt;&lt;/li&gt; &lt;!-- 사용자가 위치한 나라를 기준으로 날짜 입력 (년월) --&gt; &lt;li&gt;모바일 브라우저만 지원 input type=\"tel\" : &lt;input type=\"tel\"&gt;&lt;/li&gt; &lt;!-- 모바일브라우저만 지원. 웹브라우저에서는 아무런 영향이 없음 --&gt; &lt;!-- 가상키패드로 숫자키패드가 디폴트. 전화걸기가능 --&gt; &lt;li&gt;input type=\"email\" : &lt;input type=\"email\"&gt;&lt;/li&gt; &lt;!-- 이메일형식에 맞는지 브라우저에서 자동체크함. @입력필수 --&gt; &lt;li&gt;input type=\"url\" : &lt;input type=\"url\"&gt;&lt;/li&gt; &lt;!-- url형식에 맞는지 브라우저에서 자동체크함. 프로토콜(http, https)입력필수 --&gt; &lt;li&gt;input type=\"number\" : &lt;input type=\"number\"&gt;&lt;/li&gt; &lt;!-- 자동으로 위아래화살표가 생기며 키보드로 제어가능 --&gt; &lt;li&gt;input type=\"range\" : &lt;input type=\"range\"&gt;&lt;/li&gt; &lt;!-- 범위를 바형태로 조절 --&gt; &lt;li&gt;input type=\"color\" : &lt;input type=\"color\"&gt;&lt;/li&gt; &lt;!-- 색상 설정가능 --&gt;&lt;/ul&gt; date, datetime-local, time, week, month 예시위의 타입들을 지정하면 달력아이콘과 날짜 또는 시간형식이 자동생성된다. tel예시하이픈은 뜨지않고 INPUT창을 모바일브라우저에서 눌리면 숫자키패드가 뜬다!아래 MDN사이트들어가면 모바일브라우저를 통해 어떻게 출력되는지 바로 확인가능하다.참고링크 : MDN input type tel email, urlemail, url은 형식에 맞춰쓰지않으면 아래 이미지처럼 느낌표 팝업창이 뜬다. email은 @주소값이 필수로 들어가야한다. url은 프로토콜(http, https)이 필수로 들어가야한다. range예시range는 인스타그램처럼 바형태로 나타난다.구체적인 값이 아닌 대략적인 값을 입력할때 사용한다. color예시color태그를 클릭하면 아래와 같이 컬러파레트가 자동으로 연결된다.","link":"/2020/06/25/200626webi/"},{"title":"[패스트캠퍼스python] 게시판만들기","text":"파이썬 인강 자기계발 챌린지 35회차 미션게시판만들기위해선 순서가 있다. html파일로 화면그리기 board 폴더안에 있는 views.py에서 함수 만들기 board 폴더안에 urls.py 생성하기 프로젝트명과 동일한 폴더하위의 urls.py에 연결하기 board 폴더안에 있는 models.py에서 코드작성하기 1. html파일로 화면그리기기본적으로 board는 테이블형태로 작업을 많이 한다.기본적인 내용은 base.html에서 상속받은 뒤 다른 부분만 작성해주면된다. 상속코드작성 block contents와 endblock 사이에 고유코드작성 부트스트랩의 텍스트유틸리티를 사용해서 색상 밝게 변경 : table table-light, thead-light, text-dark 부트스트랩의 텍스트유틸리티 적용유무의 차이는 가장 아래 첨부된 이미지에서 확인할 수 있다. 아래코드 123456789101112131415161718192021222324252627282930{% extends \"base.html\" %} &lt;!-- 상속 --&gt;{% block contents %} &lt;!-- 다른 부분 시작 --&gt;&lt;table class=\"table table-light\"&gt; &lt;thead class=\"thead-light\"&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;아이디&lt;/th&gt; &lt;th&gt;일시&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class=\"text-dark\"&gt; {% for board in boards %} &lt;tr onclick=\"location.href='/board/detail/{{ board.id }}/'\"&gt; &lt;th&gt;{{ board.id }}&lt;/th&gt; &lt;td&gt;{{ board.title }}&lt;/td&gt; &lt;td&gt;{{ board.writer }}&lt;/td&gt; &lt;td&gt;{{ board.registered_dttm }}&lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt;&lt;/table&gt;&lt;!-- 글쓰기버튼만들기 --&gt;&lt;div class=\"col-12\"&gt; &lt;button class=\"btn btn-primary\" onclick=\"location.href='/board/write/'\"&gt;글쓰기&lt;/button&gt; &lt;/div&gt; {% endblock %} &lt;!-- 다른 부분 끝 --&gt; 2. board 폴더하위에 있는 views.py에서 render함수만들기views.py에서 board_list.html페이지를 render할 수 있는 함수를 만든다 12def board_list(request): return render(request, 'board_list.html') 3. board 폴더하위에 urls.py 생성하기게시판폴더인 board폴더안에는 urls.py파일이 없기때문에 직접생성해줘야한다.board폴더 안에 파일명은 urls.py로 생성한 뒤 아래 코드를 입력하면 위에서 만든 view.board_list가 연결된다. 123456from django.urls import pathfrom . import viewsurlpatterns = [ path('list/', views.board_list)] 4. 프로젝트명과 동일한 폴더하위의 urls.py에 연결하기fc_community하위의 urls.py에서 path를 추가하여 연결해준다 1path('board/', include('board.urls')), 5. 위의 4단계의 결과물위의 4단계를 다 한뒤에 python manage.py runserver명령어로 실행하면 board_list.html파일을 확인할 수 있다. url은 http://127.0.0.1:8000/board/list/로 지정하면 만든 html파일을 볼 수 있다. 부트스트랩의 텍스트유틸리티로 밝기를 지정하기 전에는 위와같은 이미지로 출력되고밝기지정 후에는 아래와 같은 이미지로 출력된다. 한결 가독성이 좋아졌다.따로 색상을 지정할 필요없이 텍스트유틸리티를 이용하면 손쉽게 해결할 수 있다.","link":"/2020/06/27/200628python/"},{"title":"[패스트캠퍼스python] 상속, Django form기능","text":"파이썬 인강 자기계발 챌린지 34회차 미션1. 상속지금까지 회원가입페이지와 로그인페이지를 만들어보았다.html코드를 보면 알겠지만 두 페이지가 body태그빼고 똑같다.이럴땐 하나의 템플릿을 만들고 상속을 이용해야한다. 왜냐고?개발자라면 중복되는 코드는 어떻게든 줄이고싶은 마음이 단전에서부터 부글부글 끓어올라야하기 때문이다!ㅋㅋㅋ 1. base.html만들기중복되는 html코드를 새로운 html파일에 작성한다.그리고 중복되는 부분은 아래코드처럼 처리한다.블럭을 만들고 그 안을 중복되지않은 코드들로 채워넣는 것이다. 12{% block 원하는이름작성 %}{% endblock %} 2. {% extends “이름.html” %}로 상속받기base.html을 상속받아서 사용할 수 있는 코드는 아래와 같다.extends로 먼저 상속받은 뒤 block안에 중복되지않는 html코드들을 입력하면 된다. 12345{% extends \"base.html\" %}{% block 원하는이름작성 %} # 중복되지 않는 HTML코드입력{% endblock %} 위의 이미지에서 2번(오른쪽부분)은 중복되는 코드들을 정리해놓은 HTML태그이고 block를 contents라는 이름으로 지정했다.1번(화면왼쪽)부분은 contents라는 block사이에 중복되지않은 html코드를 작성했다.runserver를 이용하면 정상적으로 실행됨을 알 수 있다. 이렇듯 상속을 이용하면 전체코드를 수정해야할 일이 생길때 일일이 모든 페이지를 수정하지않아도 된다.그냥 base.html페이지만 수정하면 상속받은 모든 코드가 자동으로 수정되기때문이다! 개이득!!! 2. Django form기능이때까지 html태그로 form태그를 만들어 사용하였다. 하지만 Django에서 자체적으로 제공하는 form기능을 이용하면 훨씬 가독성있는 코드를 짤 수 있다. 1. forms.py 파일생성하기fcuser폴더 하위에 forms.py를 생성한 뒤 django에서 forms기능을 import해줘야한다. 아래 코드는 로그인폼을 만드는 코드로 username과 password를 만든다. 12345from django import formsclass LoginForm(forms.Form): username = forms.CharField(max_length=32) password = forms.CharField() 2. view.py 코드 수정django에서 form기능을 import한 뒤 기존 코드는 싹 지우고 아래 코드를 작성하면 끝.단 3줄에 완성할수있다! 신기! 1234# 로그인페이지만들기(django의 form기능이용)def login(request): form = LoginForm() #클래스변수를 만들고 템플릿에 전달 return render(request, 'login.html', {'form':form}) 3. login.html에 {{ form }} 기능 추가기존 form태그안에 로그인과 비밀번호 input태그를 삭제한 후 아래 코드를 입력하면 끝!그 많던 html코드가 python 한줄로 완성된다! 1{{ form }} 위의 코드들을 기존의 html코드들과 비교해보자. 위의 이미지는 왼쪽은 login.html이고 오른쪽은 views.py이다.빨간선을 기준으로 1번부분(위쪽)은 html의 form태그를 이용해서 작성한 코드이다.2번부분(아래)은 django의 form기능을 이용해서 작성한 코드이다.한 눈에 봐도 수많은 코드들이 단 몇줄로 깔끔하게 정리되고 심지어 가독성도 있어보임을 알 수 있다. 그렇다면 출력값도 같을까? 따로 여백을 주지않은채로 진행했기때문에 inline형태로 출력되었지만 특별한 기능이 들어가있다.바로 입력을 하지않으면 알림창이 떠서 모든값을 입력해야지 로그인버튼을 누르고 home페이지로 넘어갈 수 있다.이를 유효성체크라고 하는데 따로 코드를 작성하지않아도 자동으로 들어가있어 엄청 유용한 기능이다.","link":"/2020/06/26/200627python/"},{"title":"[자바JAVA&#x2F;JSP] 세션(Session)","text":"세션 session세션이 없는 http 프로토콜의 요청처리흐름 아래와 같다. 세션을 이해하기 위해서는 http 프로토콜의 특성을 알아둬야한다.http프로토콜의 특성은 연결되면 요청/응답을 한 뒤에 바로 연결이 종료된다.클라이언트와 서버의 연결 정보를 유지하기위해 연결이 끊어지지않도록 유지할 수 있게 하는 것이 세션이다.즉 세션은 클라이언트와 서버 간의 접속을 유지시켜주는 역할을 한다. 세션 : 서버쪽에서 웹컨테이너의 상태를 유지하기 위해서 정보를 저장하는 객체(방법)웹브라우저당 1개의 세션 정보를 생성해서 사용한다.웹 서버는 각각의 브라우저로 부터 요청을 받아서 응답할때 특별한 식별자(seessionID)를 가지고 응답한다. 위와 같은 이미지를 시퀀스 다이어그램이라고 부른다 세션 사용방법 : 세션 객체 생성(JSP내장객체) -&gt; 값을 저장 -&gt; 저장된 값을 확인기본적으로 객체는 객체생성해서 사용해야하지만 세션은 JSP에서 내장함수이다. 세션생성세션영역에 해당 속성을 저장하는 것이 세션 객체이다.세션정보를 생성하는 코드이다 1session.setAttribute(&quot;이름&quot;, 값); 세션정보 가져오기세션 영역에 있는 속성값을 가져오는 코드이다. 1session.getAttribute(&quot;이름&quot;) 세션정보 삭제하기세션정보를 삭제하는 코드이다.해당 코드는 특성 대상값을 삭제한다. 1session.removeAttribute(&quot;이름&quot;) 세션유지시간 설정하고 반환하기세션의 유지 시간을 설정하는데 사용되는 코드이다. 초 단위로 인자 값을 설정할 수 있다. 1session.setMaxInactiveInterval(1000); 아래 코드는 세션의 유지 시간을 반환하는 역할을 한다. 1session.getMaxInactiveInterval(); 세션정보 초기화하기이 코드는 세션의 모든 속성을 제거하는 역할을 한다. 1sesssion.invalidate(); 삭제와 초기화의 차이** invalidate와 removeAttribute의 차이 ** invalidate() 메소드는 세션의 모든 속성 값을 제거하기 떄문에 removeAttribute()메소드를 사용할 때 처럼 각 속성 값들을 하나씩 제거할 필요가 없다.invalidate() 메소드는 모든 속성을 제거하기 때문에 세션 유지 시간이 지났을 때 세션이 초기화되는 것과 같은 효과를 가져온다. 초기화가 되지않는다면 서버입장에서는 세션정보를 계속 가지고있게되어 부담이 되고 또한 보안상의 문제가 있다.따라서 일반적으로 삭제보다는 초기화를 많이 사용한다.주로 로그아웃기능시 사용한다. 세션값 테스트기존 사용하던 브라우저 다 종료한 후 실행해야 정확히 세션테스트를 할 수 있다. 브라우저당 세션 1개이므로 크롬에서 세션을 생성했다고 익스엣지에 똑같은 세션이 생성되어있지않다. 이제 세션값 생성버튼을 누르면 세션을 생성하고 세션값 삭제버튼을 누르면 세션값이 삭제되며 세션값 초기화를 누리면 세션값이 초기화되는 기능을 구현해보자 sessionTest.jsp 페이지생성 12345678910111213&lt;%String value = (String)session.getAttribute(\"value\"); //session.getAttribute()는 object테이터타입이기에 명시적형변환으로 (String)을 해줘야한다.if ( value == null){ value = \"세션값 없음!\"; // 기본 반환타입인 null에서 세션값 없음으로 표현변경}%&gt;&lt;h1&gt;세션 값 : &lt;%= value %&gt;&lt;/h1&gt;&lt;h1&gt;세션 값(이름) : &lt;%= session.getAttribute(\"name\") %&gt;&lt;/h1&gt;&lt;input type=\"button\" value=\"세션값 생성\" onclick=\"location.href='sessionSet.jsp'\"&gt;&lt;input type=\"button\" value=\"세션값 삭제\" onclick=\"location.href='sessionDel.jsp'\"&gt;&lt;input type=\"button\" value=\"세션값 초기화\" onclick=\"location.href='sessionInvalidate.jsp'\"&gt; sessionSet.jsp 페이지생성세션은 여러개 생성가능하다여기서는 value와 name 총 2개의 세션을 만들었다. 123456789&lt;%//세션 값 생성 session.setAttribute(\"value\", \"세션값 있음~\"); session.setAttribute(\"name\", \"홍길동\");%&gt;&lt;script&gt; alert(\"세션값 생성 완료!\") location.href=\"sessionTest.jsp\" 위는 자바스크립트코드를 사용했고 response객체사용를 사용할 수 있다. 123456&lt;%//세션 값 생성 session.setAttribute(\"value\", \"세션값 있음~\"); session.setAttribute(\"name\", \"홍길동\"); response.sendRedirect(\"sessionTest.jsp\");%&gt; sessionDel.jsp 페이지생성sessionSet과 마찬가지로 처리하는 데에 2가지 방법이 있다.자바스크립트를 사용하거나 response를 사용하거나이다. 이 둘의 차이점은 전혀없다.편한거 사용하면 된다. 자바스크립트 코드사용 123456789&lt;%//세션 값 삭제 session.removeAttribute(\"value\");%&gt;&lt;script&gt; alert(\"세션값 삭제 완료!\") location.href=\"sessionTest.jsp\"&lt;/script&gt; response객체사용 1234&lt;%session.removeAttribute(\"value\");response.sendRedirect(\"sessionTest.jsp\");%&gt; sessionInvalidate 페이지생성세션에 있는 모든 정보를 없앨수있다. 처리시 2가지 방법이있다.자바스크립트를 사용하거나 response를 사용하거나이다. 이 둘의 차이점은 전혀없다.편한거 사용하면 된다. 자바스크립트코드사용 123456&lt;%session.invalidate();%&gt;&lt;script&gt; alert(\"세션값 초기화 완료!\") location.href=\"sessionTest.jsp\";&lt;/script&gt; response객체사용 1234&lt;%session.invalidate();response.sendRedirect(\"sessionTest.jsp\");%&gt; 기존 브라우저를 다 종료 후 sessionTest를 열면 세션값은 null인 것을 확인할 수 있다.세션값 생성 버튼을 클릭하면 sessionSet페이지로 이동 후 alert창이 뜨고 다시 sessionTest로 돌아오게된다.그러면 화면에는 세션값 있음~과 홍길동이 출력된다! 이제 세션값 삭제 버튼을 눌러보면 모든 값이 다 사라져야하지만세션값 없음!과 홍길동이 출력된다. 세션값을 삭제했지만 null이 아닌 여전히 홍길동이 계속 출력된다. 이럴때 세션값 초기화 버튼을 사용하면 세션값 없음!과 null이 출력된다초기화버튼을 통해 모든 세션의 정보를 지울 수 있다.","link":"/2020/06/28/200629jspi/"},{"title":"단일행함수 : 숫자함수, 날짜함수","text":"SQL함수에는 두가지 유형이 있다. 단일행함수 : 행당 하나의 결과 반환 여러행함수 : 행 집합당 하나의 결과 반환 이 중 단일행함수에 대해 알아보자. 단일행함수종류단일행함수는 총 5가지이다. 문자함수 숫자함수 날짜함수 변환함수 일반함수 숫자함수실무에서는 반올림, 버림을 자주 사용한다.실무에서 올림은 잘 사용하지않는다.mod함수는 홀수짝수 구분할때 주로 사용한다. dual(듀얼) 테이블select는 출력쿼리이다. 12*123 이라는 간단한 산술결과값을 출력하고 싶다. 123$ select 12*123 as value;//반환값에러 : FROM keyword not found 반환값에러가 나왔다.select와 from은 항상 함께 해야한다.테이블에서 정보를 빼낼 필요가 없지만 from키워드가 있어야하니까 가지고 있는 아무테이블명을 적을 수 있다.단순한 산술결과나 함수결과를 출력할때는 from에 아무테이블명을 적어버리면 테이블의 row갯수만큼 반복 출력된다. 만약 그 아무테이블의 row가 12만개면 출력값이 12만번 반복된다. 따라서 이런 상황에서 쓸 수 있는 행 하나짜리 테이블이 있다. 바로 dual(듀얼)이다. 1234$ select 12*123 as value$ from dual;//반환값 : 1476 0의 자릿수 일의 자리는 0으로 나타내며 생략도 가능하다. 1234$ select round(45.923,2), round(45.923,0), round(45.923), round(45.923,-1)$ from dual;//반환값 : 45.92, 46, 46, 50 날짜함수","link":"/2020/06/29/200630dbi2/"},{"title":"단일행함수 : 문자함수","text":"SQL함수에는 두가지 유형이 있다. 단일행함수 : 행당 하나의 결과 반환 여러행함수 : 행 집합당 하나의 결과 반환 이 중 단일행함수에 대해 알아보자. 단일행함수종류단일행함수는 총 5가지이다. 문자함수 숫자함수 날짜함수 변환함수 일반함수 문자함수문자함수는 크게 변환함수와 문자 조작 함수로 나누어진다. 대소문자 변환함수변환함수는 총 3가지가 있다.대소문자를 변환한다. 기능 결과 LOWER(‘SQL Course’) sql course UPPER(‘SQL Course’) SQL COURSE INITCAP(‘SQL Course’) Sql Course 123$ select_id, last_name$ from employees$ lower(last_name) = 'higgins'; 문자조작함수 concat(expr1, expr2)concat은 인수를 2개밖에 못 받는다.만약 2개초과로 쓰고싶다면 concat을 중첩해서 사용해야한다. 예를 들어 last_name과 first_name을 합쳐서 full_name을 만들고싶다concat이용한 구문과 연결연산자 이용한 구문의 출력값은 같다.차이점은 concatl은 인수2개만 가능하고 연결연산자는 원하는만큼의 인수를 사용할 수 있다 1234567//concat이용한 구문$ select concat(last_name, first_name) as full_name$ from employees;//연결연산자(||) 이용한 구문$ select last_name || first_name as full_name$ from employees; 이때 last_name과 first_name 사이에 공백 한칸을 넣고싶다그래서 처음에는 아래 코드를 작성했다. 1234$ select concat(last_name, ' ', first_name) as full_name$ from employees;//반환값에러 : invalid number of arguments 위 코드처럼 했더니 invalid number of arguments에러가 떴다.즉, concat은 인수를 2개밖에 못 받기때문에 3개를 쓰려면 중첩해야한다. 123//concat 중첩하기$ select concat(concat(last_name, ' '), first_name) as full_name$ from employees; substr(expr1, expr2, expr3)문자열의 일부분을 반환해주는 함수이다. expr1 : 반환할 문자열 expr2 : 시작위치 음수인 경우 뒤에서 시작위치 ex)-1이면 뒤에서 첫번째글자 expr3 : 반환할 문자갯수 방향은 항상 왼쪽에서 오른쪽으로 문자갯수만큼 반환한다 생략가능 : 생략되면 시작위치에서 끝까지 반환 주로 주민번호(770123-2123456)를 반환할때 사용한다. 12345$ select substr(770123-2123456, 1, 6)//반환값 : 770123$ select substr('Kochhar, -3, 2)//반환값 : ha instr(expr1, expr2)문자열(expr1)로 부터 특정 문자(expr2)의 첫번째 위치값을 반환해주는 함수이다. 아래 문자열에는 o가 2개가 있다. 5번째와 7번째에 있는데 어느 값을 반환해줄까?instr는 첫번째 위치값만 반환해준다. 123$ select isnt('HelloWorld', 'o')//반환값 : 5 lpad(expr1, expr2, expr3) 와 rpad(expr1, expr2, expr3)오른쪽 정렬/왼쪽 정렬 해주는 함수 expr1 : 반환할 문자열 expr2 : 전체자리수 expr3 : 남는 공간을 채울 문자 공백을 주면 오른쪽/왼쪽정렬을 표현할 수 있어 유용하다. 1234//lpad 오른쪽정렬$ select lpad(last_name, 20, ' ')//반환값 : 오른쪽정렬 trim(expr1 from expr2)문자열(expr2)로부터 특정 문자(expr1)가 접두어나 접미어에 있다면 삭제(절단)해주는 함수이다. (ex1) trim(‘H’ from ‘HHelloHWHorldHHH’) =&gt; elloHWHorld 한자리 숫자를 출력하려고 할때 01,02,03 등등으로 출력된다.이때 0을 빼고 한자리만 출력할때 주로 사용한다. length(expr1)문자열의 길이를 반환해주는 함수이다. 123$ select length('HelloWorld')//반환값 : 10 replace(expr1, expr2, expr3)문자열(expr1)로 부터 특정 문자(expr2)를 다른 문자(expr3)로 교체해주는 함수이다. DB에 폰번호가 .로 저장되어있을때 우리가 보기 편하게 -로 바꿔줄수있다. 12345//기존데이터 : 010.1234.5678$ select last_name, replace(phone_number, '.', '-') as mobile$ from employees//replace후 반환 : 010-1234-5678","link":"/2020/06/29/200630dbi/"},{"title":"[ITWILL : JSP] &#x3D;&#x3D;과 str.equals(str2) 차이, 객체와 클래스","text":"ITWILL학원 : 16강 JSP기초 BY 정규태강사1. ==과 str.equals(str2) 차이점두가지는 공통적으로 비교연산을 하지만 차이점이 존재한다.String타입을 비교할때는 equals()를 사용해야한다. == : 두개의 문자열 객체가 완전히 같은지 비교(주소비교) 메모리 주소를 비교(동일한 객체인지) stack 메모리에 있는 주소를 비교 기본형데이터타입을 비교할때 사용한다 str.equals(str2) : 두 개의 문자열 객체의 문자 데이터값이 같은지 비교 대상의 내용을 비교 heap 모든 참조형데이터타입에 사용하는 것은 아니고 참조형데이터타입중에 string타입 비교시에만 사용 가능하다. 다른 참조형데이터타입을 비교하는 방법은 상속을 배운뒤 알게된다. 12345678910111213//일치여부확인(==이용)if (id == DBID &amp;&amp; pw == DBPW){ %&gt; &lt;%=id%&gt; 님 환영합니다! &lt;%}else{ %&gt; 잘못입력하셨습니다.&lt;%}//일치여부확인(equals이용)if (id.equals(DBID) &amp;&amp; pw.equals(DBPW)){ %&gt; &lt;%=id%&gt; 님 환영합니다! &lt;%}else{ %&gt; 잘못입력하셨습니다.&lt;%} 참고링크 : java equals 차이점 2. 객체와 클래스 객체 : 모든 대상,기능들이다. -&gt;객체를 프로그램에 포함하기위해서는 내가 필요한 기능만 뽑는 즉, 추상화과정이 필요하다. 클래스 : 추상화된 객체를 코드로 표현한 형태 흔히 이를 붕어빵만들기에 비유하곤 한다. 클래스 - 객체 =&gt; 인스턴스화(객체화)붕어빵틀 - 붕어빵 =&gt; 가열동작 하지만 붕어빵틀과 붕어빵만 있으면 붕어빵을 만들수있을까?가열동작이 없으면 붕어빵은 만들어지지않는다이 가열동작은 인스턴스화(객체화, 메모리에 올린다)라고 생각하면 쉽다.이때 new연산자를 이용한다. -&gt; new를 하면 메모리에 올라간다. 3. 클래스1. 클래스와 객체는 같다?NOPE! 다르다! 2. 클래스의 구성요소 생성자 : 멤버 변수를 초기화 멤버 변수 : 객체의 속성 멤버 메서드 : 객체의 동작(기능) 왼쪽처럼 기본데이터형의 변수를 선언하면 stack메모리에 올라간다.오른쪽처럼 클래스를 선언하면 stack에는 a라는 변수가 생성되고 heap에는 new Test()라는 객체가 생성된다. 3. 클래스예시휴대폰이라는 객체가 있다고 생객해보자 속성 : model, price, color …등등 기능 : on/off(), tell(), sendMSG() …등등 1234567891011121314class Phone { 1. 속성 model price color ...등등 2. 기능 on/off() tell() sendMSG() ...등등}new Phone(); //클래스선언이 되고 이는 heap메모리에 저장된다.","link":"/2020/06/28/200629jspi2/"},{"title":"단일행함수 : 변환함수, 일반함수","text":"SQL함수에는 두가지 유형이 있다. 단일행함수 : 행당 하나의 결과 반환 여러행함수 : 행 집합당 하나의 결과 반환 이 중 단일행함수에 대해 알아보자. 단일행함수종류단일행함수는 총 5가지이다. 문자함수 숫자함수 날짜함수 변환함수 일반함수 변환함수변환함수 종류변환함수는 총 3가지이다. to_char() : 자주사용, 금액 천의 단위로 변환할때 주로 사용 to_number() : 거의 사용안함. to_date() : 가장 많이 사용. 변환함수 출력형식출력형식은 아래와 같다. Y대신 R을 써도 연도표시가능 RRRR : 숫자로 된 전체 연도 ex)2020 RR : 두자리숫자로 된 전체 연도 ex)20 문자열은 큰 따옴표(“”)로 묶어 추가한다. 숫자 접미어는 숫자를 영어 철자로 표기한다.아래 예시는 오늘이 6월 30일인 경우 1234$ select to_char(sysdate, 'fmDdspth \"of\" month YYYY fnHH:MI:SS AM')$ from dual;//반환값 : thirtieth of june 2020 02:41:38PM 주요예시 예시 - 대소문자대문자면 대문자로, 소문자면 소문자로, INITCAP이면 INITCAP형식으로 출력된다. 12345678$ select to_char(sysdate, 'YEAR-MONTH-DD DAY HH24:MI:SS AM') as today$ from dual;//반환값 : TWENTY TWENTY-JUNE-30 TUESDAY 14:32:24 PM$ select to_char(sysdate, '\"Today is\" RRRR-mm-dd DY! \"and time is \" HH:MI') as today$ from dual;//반환값 : Today is 2020-Jun-30 TUE! and time is 02:32 예시 - 천단위로 표시기존 DB값 : 7900, 10000아래 코드 후 : $7,900.00, $10,000.00 12$ to_char(salary, 'fm$999,999.00') salary$ from employees 여기서 fm은 지정해놓은 포맷길이 앞뒤에 있을 수 있는 공백이나 문자들을 삭제한다. 추가링크 : fm 설명자세히 쿼리구문에 큰따옴표(“ “)가 사용되는 경우 컬럼명 [AS] “Alias” : 대소문자, 공백, 특수문자 포함 시 to_char(sysdate, ‘YYYY-MM-DD “Time” HH24:MI’) : 사용자 형식 내 문자열 포함 시 일반함수 종류 의미 NVL(expr1, expr2) expr1이 null이면 expr2 반환 NVL2(expr1, expr2, expr3) expr1이 null이면 expr2 반환 NULLIF(expr1, expr2) expr1 = expr2이면 null반환, 같지않으면 expr1을 반환 COALESCE(expr1, expr2, …, exprn) expr1이 null이 아니면 expr1을 출력하고 종료 후 다음행시작한다. 만약 expr1이 null이면 expr2가 null인지 검사하고 expr2가 null아니면 expr2의 실제값 반환하고 종료한다. 만약 expr2가 null이면 세번째인수 검사하면서 실제값이 나올때까지 n번 한다. NVL 함수 : 가장 많이 사용null값을 실제 값으로 변환한다,사용할 수 있는 데이터 유형은 날짜, 문자, 및 숫자이다.데이터 유형이 일치해야한다. 아래는 직원들의 연봉을 계산하는 쿼리이다. 12345$ select last_name, salary, commission_pct,$ (salary*12) + (salary*12*commission_pct) as annual salary$ from employees;//출력값 : 에러 commission이 없는 직원의 경우 null값이 입력되어있기때문에 산술연산자가 제대로 계산되지 않는다.이때 사용하는 것이 NVL함수이다commission값이 null이면 0으로 변경해서 산술이 잘 이뤄지도록 만든다. 12345$ select last_name, salary, commission_pct,$ (salary*12) + (salary*12*nvl(commission_pct,0)) as annual salary$ from employees;//출력값 : 정상적으로 출력됨 NVL2함수 : 첫번째 표현식을 검사해서 NULL이 아니면 두번째 표현식을 반환하고 NULL이면 세번째 표현식을 반환한다. 약간 내 느낌에 NVL2는 삼항연산자같다.ㅋㅋㅋㅋ(조건 expr1 == null)? 참(expr3반환):거짓(expr2반환) 예시문제employees테이블로부터 사원들의 last_name과 commission_pct를 출력하되 커미션을 받지 않는 직원들은 “No Commission”이라고 출력하는 구문을 작성하시오. 내코드commission_pct의 데이터형태는 number인데 No Commission은 문자열이라서 replace로 숫자0을 문자열No Commission로 대체했다. 123$ SELECT last_name, replace(nvl(commission_pct, '0'), '0', 'No Commission') $ as \"No Commission\"$ FROM employees; 강사님 코드to_char로 null이 나올때마다 문자열No Commission로 대체했다 12$ SELECT last_name, NVL(TO_CHAR(commission_pct), 'No Commission') COMM$ FROM employees;","link":"/2020/06/29/200630dbi3/"},{"title":"[자바JAVA]클래스 : 생성자, new역할, this키워드용법","text":"생성자 생성자란 객체를 생성할 때 호출하는 메서드 비슷한 것을 말함. 주로 일반 멤버변수의 초기화나 객체를 생성할때 실행하는 작업을 정리한다. 생성자 형태 123456class Person{ String name; public Person(){ //생성자명은 class명과 똑같아야함 name = '홍길동'; //생성자의 주요역할은 멤버변수의 초기화 }} 특징 class명과 똑같아야함. 객체생성될때 딱 한번 호출되어짐 생성자도 overloading가능 상속이 안되는 유일한 멤버메서드 생성자 VS void메서드 차이점 형태가 retrun값이 없는 void메서드와 비슷하게 생겼다 차이점 : 이름과 역할 이름 : 생성자는 class명과 똑같아야하고 메서드는 달라야한다. 역할 : 메서드는 다양한 기능을 담당하지만 생성자는 멤버변수의 초기화를 담당한다. 생성자를 왜 쓸까?생성자는 자바창시자가 FM방식으로 설정했기때문이다.자바 창시자는 생성자로 변수초기화시키고 메서드는 기능만 담당하도록 설정하고 싶었던 것이다!자바 창시자가 정식방법으로 자바를 쓰길 원했지만 나는 한번도 쓴 적이 없는데 자바는 잘 돌아갔다.어떻게 된 일일까? 바로 아래 NEW에 답이 있다. new의 역할나는 생성자를 한번도 생성한 적 없이 java를 사용했는데 작동에 전혀 무리가 없었다.왜 그럴까? 바로 new 때문이다. 별도의 생성자를 만들지 않았을 때 컴파일러에 의해 컴파일 타임에 자동으로 생성자가 만들어지기 때문이다. 이를 기본생성자라고 한다. 기본생성자는 파라미터를 전달받지 않기 때문에 빈 객체를 생성한다. 기본생성자의 형태 생성자를 만들지않았지만 new라는 키워드를 통해서 BasicConstructor person = new BasicConstructor()를 통해서 자동으로 public BasicConstructor() {} 기본연산자가 생성된다. 12345678910111213141516171819public class BasicConstructor { String name; int age; boolean isHugry; //public BasicConstructor() {} //생략된 기본 생성자 public static void main(String[] args) { //new연산자가 BasicConstructor()를 호출하면 컴파일러가 자동으로 기본생성자를 만든다 BasicConstructor person = new BasicConstructor(); //기본생성자이므로 외부에서 객체의 멤버 변수를 설정해줘야한다 person.name =\"홍길동\"; person.age =77; person.isHugry = false; }} new 를 쓰고 안쓰고의 차이. this 키워드 용법this에는 두가지 용법이 있다. this. : 현재 객체를 참조하기 위한 용도 this() : 다른 생성자를 호출하는 용도 멤버변수를 참조하는 this.멤버변수명현재 객체를 참조하기 위한 용도로 사용하는 this.먼저 보자. 아래 코드를 보자.멤버변수명과 매개변수명을 동일하게 설정했다.컴파일러가 첫번째 name과 두번째 name을 잘 구분할수있을까? 참고 : 생성자자동생성단축키(Generate Constructor) : Alt + Shift + S → C 매개변수로 만들고싶은 멤버변수의 체크박스를 틱하면 생성자를 생성해준다. 123456789101112public class ThisPerson { String name; int age; boolean isHugry; ThisPerson(String name, int age, boolean isHungry){ name = name; //컴파일러가 첫번째 name은 멤버변수로 두번째 name은 매개변수로 잘 구분할수있을까? age = age; isHungry = isHungry; }} 정답은 NOPE! 구분하지못한다.이때 구분해주기위해 멤버변수명앞에 this를 붙여준다. 123456789101112public class ThisPerson { String name; int age; boolean isHugry; ThisPerson(String name, int age, boolean isHungry){ this.name = name; this.age = age; this.isHungry = isHungry; }} 이제 만든 생성자를 출력해보자.매개변수로 받은 this.name을 출력하는 코드이다. 1234567891011121314151617public class ThisPerson { String name; int age; boolean isHugry; ThisPerson(String name, int age, boolean isHungry){ this.name = name; this.age = age; this.isHugry = isHugry; } public static void main(String[] args) { ThisPerson person = new ThisPerson(\"홍지민\", 20, true); System.out.printf(\"name : %s\", this.name); }} 홍지민이 출력될거라 기대했지만 출력값은 오류가 발생한다. 123//위 코드 출력값Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: Cannot use this in a static context this는 객체에 대한 참조값이다. this는 참조값이기때문에 객체가 생성되기 전에는 사용할 수 없다. 따라서 static영역에서는 this키워드를 사용할 수 없다. 아래 코드를 출력하면 해결된다. 123456789101112131415161718192021public class ThisPerson { String name; int age; boolean isHugry; ThisPerson(String name, int age, boolean isHungry){ this.name = name; this.age = age; this.isHugry = isHugry; } String print(){ return String.format(\"name : %s, age : %d\", this.name, this.age); } public static void main(String[] args) { ThisPerson person = new ThisPerson(\"홍지민\", 20, true); System.out.println(person.print()); }} 다른 생성자를 호출하는 this() 파라미터를 다르게 해서 여러 개의 생성자를 정의하는 것을 생성자 오버로딩이라고 한다. 메서드와 마찬가지로 생성자도 오버로딩이 가능하다. 생성자오버로딩하는 이유 : 다른 생성자를 호출해서 중복코드를 제거.이때 다른 생성자를 호출하는 키워드가 this이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243public class OverloadConstructorPerson { String name = \"한사장\"; int age = 90; boolean isHugry = false; OverloadConstructorPerson(String name, int age, boolean isHungry){ //아래 3줄의 중복코드가 발생함. this.name = name; this.age = age; this.isHugry = false; } OverloadConstructorPerson(String name, int age){ //this()용법사용 this(name, age, false); } OverloadConstructorPerson(String name){ //this()용법사용 this(name, 0, false); } OverloadConstructorPerson(){ //아무 코드도 없으면 기존 멤버변수값이 출력된다. } public static void main(String[] args) { OverloadConstructorPerson p1 = new OverloadConstructorPerson(\"하지\", 77); System.out.printf(\"이름 : %s, 나이 : %d%n\", p1.name, p1.age); OverloadConstructorPerson p2 = new OverloadConstructorPerson(\"뽀니\"); System.out.printf(\"이름 : %s, 나이 : %d%n\", p2.name, p2.age); OverloadConstructorPerson p3 = new OverloadConstructorPerson(); System.out.printf(\"이름 : %s, 나이 : %d%n\", p3.name, p3.age); }}//출력값이름 : 하지, 나이 : 77이름 : 뽀니, 나이 : 0이름 : 한사장, 나이 : 90","link":"/2020/06/30/200701javai/"},{"title":"여러행함수 : 그룹함수","text":"SQL함수에는 두가지 유형이 있다. 단일행함수 : 행당 하나의 결과 반환 여러행함수 : 행 집합당 하나의 결과 반환 그룹함수 Group by절 Having절 이 중 여러행함수에 대해 알아보자.그룹함수는 테이블의 전체 행을 하나 이상의 컬럼을 기준으로 그룹화하여 그룹별로 결과를 출력하는 함수 그룹함수 그룹함수의 특징 null값빼고 연산된다. select절의 컬럼리스트들 중 그룹함수에 포함된 컬럼과 그룹함수에 포함되지 않은 컬럼을 같이 출력하려면 포함되지 않은 컬럼은 반드시 group by절에 적어야한다! 숫자뿐만 아니라 날짜,문자에도 max(),min()가 가능하다날짜에서 min값은 더 과거날짜를 말한다.날짜에서 max값은 더 최신날짜를 말한다.문자열에서 min값은 알파벳순으로 A로 시작하는 값을 말한다.문자열에서 max값은 알파벳역순으로 Z로 시작하는 값을 말한다. avg(), max(), min(), sum()예시employees테이블에 있는 모든 사원의 연봉의 평균값과, 최대값, 최소값, 합계를 구하는 쿼리이다.모든 값들에서 null값 제외된다. 12$ select avg(salary), max(salary), min(salary), sum(salary)$ from employees employees테이블의 모든 사원들의 커미션 평균을 구하는 쿼리구문을 작성해보자두 가지 방법이 있는데 어느 것이 정답일까? 123456789//1. avg()사용select avg(commssion_pct) as \"Avg_comm1\"from employees//출력값 : .222857143//2. sum(), count()사용select sum(commssion_pct)/count(last_name) as \"Avg_comm2\"from employees//출력값 : .072897196 정답은 2번이다.WHY?null값때문에! avg()같은 경우 제외된 null행의 갯수가 분모에 들어갈까?nope! 포함되지 않는다. 따라서 1번과 2번 쿼리구문의 결과값이 다르다.1번 출력값은 커미션을 받는 직원들의 커미션평균값이다.2번 출력값은 전 사원의 커미션평균값이다.avg(), nvl()사용해서도 전 사원의 커미션평균값을 구하는 쿼리를 작성할수있다. 강사님코드 12345//3. avg(), nvl()사용select avg(nvl(commssion_pct, 0)) as \"Avg_comm3\"from employees//출력값 : .072897196 count()예시counts는 null을 포함하여 수를 셀지 여부와 중복값을 포함여부에 따라 달라진다. count(*) : null포함, 중복값포함한 카운트80번 부서에 소속된 사원수를 구하는 쿼리구문이다. 123$ select count(*)$ from employees$ where department_id = 80; count(expr) : null제외, 중복값포함한 카운트.80번 부서에 소속된 직원중 커미션을 받는 사원수를 구하는 쿼리구문이다. 123$ select count(commission_pct)$ from employees$ where department_id = 80; count(distinct expr) : null제외, 중복값제외한 카운트.employees테이블의 department_id갯수를 구하는 쿼리구문이다. 12$ select count(distinct department_id)$ from employees","link":"/2020/06/29/200630dbi4/"},{"title":"[ITWILL : JSP]쿠키(Cookie)","text":"ITWILL학원 : 17강 JSP기초 BY 정규태강사1. 쿠키 Cookie (p279~) 클라이언트쪽에서 저장되어 관리되는 정보. 이름, 값, 유효기간 도메인(주소), 경로 … 등등 포함하고 있다. ㅋ쿠기의 이름은 알파벳, 숫자조합으로 생성됨 공백, 괄호, 등호, 콤마, 세미콜론 등등은 인코딩작업 후 쿠키로 사용할 수 있다. 브라우저가 종료되어도 상관없이 지정된 생존기간까지 사용가능.(클라이언트의 HDD하드디스크에 저장되기때문에 브라우저 종료되어도 계속 데이터를 유지할수있다.) 쿠키생성하면서 값을 입력하였다고 쿠키가 메모리 또는 하드디스크에 저장된 것이 아니다. 쿠키를 생성하였으면 생성한 쿠키를 꼭 클라이언트로 전송해줘야한다. 단점 : 클라이언트에서 관리되기 때문에 보안에 취약(하드디스크에 있는 쿠키파일 수정할수있기때문) 반대개념은 세션(Session) : 서버쪽에서 저장되어 관리되는 정보, 서버종료되면 사용불가 1-1. 왜 쿠키가 필요할까? 서버는 클라이언트의 1건의 요청에 응답 후 연결을 끊는다.WHY?서버가 요청오는 모든 클라이언트와 계속 연결이 되어있으면 서버쪽에 부담이 되기때문에! 이때 요청에 응답하면서 쿠키를 함께 보낸다.WHY?아 옛날에 그 클라이언트구나?! 하면서클라이언트를 구분해서 인지할수있고 빠른 응답이 가능하기때문에! 1-2. 쿠키사용방법 쿠키 생성하기 서버 서버는 쿠키 객체를 생성 서버는 쿠키에 필요한 설정을 지정(유효기간, 설명, 도메인, … 등등) 서버가 생성된 쿠키를 HDD에 저장 후 클라이언트에 쿠키를 전달 1234567891011121314151617&lt;h1&gt;쿠키테스트(서버 역할)&lt;/h1&gt;&lt;% //1.쿠키객체생성 : 기본생성자이면 에러가 뜨니 기본값을 직접 입력해주거나 꼭 파라미터를 작성할 것//아래처럼 직접 입력시 공백있으면 에러남 ex)\"Cookie Val!\" =&gt;에러발생Cookie ck = new Cookie(\"cName\", \"CookieValue!\"); //2.쿠키에 필요한 설정 : 시간설정(사용할 수 있는 시간을 지정)ck.setMaxAge(600); //초단위, 600초 = 10분(60초*10)//3.쿠키정보를 저장해서 응답response.addCookie(ck);%&gt;&lt;script type=\"text/javascript\"&gt; alert(\"쿠키값생성 후 저장됨\"); location.href=\"cookieTest.jsp\";&lt;/script&gt; 쿠키 사용하기 브라우저(클라이언트) 브라우저에서 요청시 쿠키정보를 가져옴 쿠키값은 (이름, 값)쌍으로 만들어진 배열. 쿠키값의 이름을 사용해서 쿠키 객체를 사용. 1234567891011121314151617181920212223&lt;h1&gt;쿠키테스트(클라이언트 역할)&lt;/h1&gt;&lt;%//1. 쿠키정보가져오기Cookie[] cks = request.getCookies();String cName=\"\";String cValue=\"\";if(cks != null){ for(int i=0; i &lt; cks.length; i++){ if(cks[i].getName().equals(\"cName\")){ //2. 저장된 쿠키 이름을 가져온다 cName = cks[i].getName(); //3. 쿠키값을 가져온다 cValue = cks[i].getValue(); } }}%&gt;&lt;h2&gt; 쿠키이름 : &lt;%=cName %&gt; &lt;/h2&gt;&lt;h2&gt; 쿠키값 : &lt;%=cValue %&gt; &lt;/h2&gt;&lt;input type=\"button\" value=\"쿠키값 저장\" onclick=\"location.href='cookieSet.jsp'\"&gt;&lt;input type=\"button\" value=\"쿠키값 삭제\" onclick=\"location.href='cookieDel.jsp'\"&gt; 특정 쿠키 삭제하기 쿠키값이 있을때만 삭제진행 쿠키 배열의 처음부터 끝까지 비교하여 쿠키이름이 “cName”인 대상을 찾아서 삭제 -&gt; 변경된 쿠키 정보를 클라이언트에 전달 12345678910111213141516171819202122&lt;%//1.쿠키 가져오기 : 지울 쿠키가 있는지부터 체크Cookie[] cookies = request.getCookies();String cName=\"\";String cValue=\"\";//2. 쿠키값이 있을때만 삭제동작 진행if(cookies != null){ for(int i=0; i &lt; cookies.length; i++){ // 3. 쿠키이름이 \"name\"인 대상을 찾아서 삭제 = 쿠키의 유효시간을 0으로 설정하여 만료시킨다 if(cookies[i].getName().equals(\"cName\")){ cookies[i].setMaxAge(0); // 4. 변경된 쿠기 정보를 다시 클라이언트에 전달 response.addCookie(cookies[i]); } }} %&gt;&lt;script type=\"text/javascript\"&gt; alert(\"쿠키값 삭제 성공\") location.href=\"cookieTest.jsp\"&lt;/script&gt; 전체 쿠키 삭제 쿠키값이 있을때만 삭제진행 쿠키 배열의 전체를 찾아서 삭제 -&gt; 변경된 쿠키 정보를 클라이언트에 전달 123456789101112131415161718192021&lt;%//1.쿠키 가져오기 : 지울 쿠키가 있는지부터 체크Cookie[] cookies = request.getCookies();String cName=\"\";String cValue=\"\";//2. 쿠키값이 있을때만 삭제동작 진행if(cookies != null){ for(int i=0; i &lt; cookies.length; i++){ // 3. 쿠키 전체의 유효시간을 0으로 설정하여 만료시킨다 cookies[i].setMaxAge(0); // 4. 변경된 쿠기 정보를 다시 클라이언트에 전달 response.addCookie(cookies[i]); } }} %&gt;&lt;script type=\"text/javascript\"&gt; alert(\"쿠키값 삭제 성공\") location.href=\"cookieTest.jsp\"&lt;/script&gt; 1-3. 크롬 개발자도구로 쿠키 확인하기쿠키를 확인하는 방법은 크롬 개발자도구를 오픈 NETWORK 탭에서 NAME카테고리에서 내가 만든 jsp파일클릭 Cookies 탭클릭 세션아이디(jsessionid)위에 쿠기가 생성된 것을 확인할 수 있다. 1-4. 쿠키예시 쿠키폼페이지 생성하기 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;h1&gt;쿠키form&lt;/h1&gt;&lt;!-- 폼태그 언어값에 따라서 달라지는 출력값 구현 --&gt;&lt;%//1.쿠키정보가져오기Cookie[] ck = request.getCookies();String lang = \"\";if(ck != null){ for(int i=0; i&lt;ck.length; i++){ if(ck[i].getName().equals(\"lang\")){ lang = ck[i].getValue(); } }}%&gt;&lt;form action=\"cookiePro.jsp\" method=\"post\" name=\"fr\"&gt; &lt;input type=\"radio\" name=\"language\" value=\"kor\" &lt;% if(lang.equals(\"kor\")){ %&gt; checked &lt;%} %&gt; &gt;한국어 &lt;input type=\"radio\" name=\"language\" value=\"eng\" &lt;% if(lang.equals(\"eng\")){ %&gt; checked &lt;%} %&gt; &gt;영어(미국) &lt;input type=\"submit\" value=\"언어설정\"&gt;&lt;/form&gt;&lt;%if(lang.equals(\"kor\")){ out.print(\"안녕하세요, 쿠키연습!\");}else if(lang.equals(\"eng\")){ out.print(\"Hello, Cookie Test!\");}else{ //설정값없을때 out.print(\"\");}%&gt; 쿠키프로페이지 생성하기 12345678910111213141516171819202122&lt;h1&gt;쿠키pro&lt;/h1&gt;&lt;%System.out.println(\"라디오버튼 결과값 : \"+ request.getParameter(\"language\"));//1.쿠키객체생성 : 기본생성자이면 에러가 뜨니 기본값을 직접 입력해주거나 꼭 파라미터를 작성할 것 , 직접입력시 공백있으면에러남Cookie ck = new Cookie(\"lang\", request.getParameter(\"language\")); //두번째방법 : 첫번째 방법도 쓸수있어야한다(짧은 코드)//String lang = request.getParameter(\"language\");//Cookie ck = new Cookie(\"lang\", lang); //2.쿠키에 필요한 설정 : 시간설정(사용할 수 있는 시간을 지정)ck.setMaxAge(120); //초단위, 600초 = 10분(60초*10)//3.쿠키정보를 저장해서 응답response.addCookie(ck);//response.sendRedirect(\"location href='cookieForm.jsp'\");%&gt;&lt;script type=\"text/javascript\"&gt; alert(\"언어설정완료!\"); location.href=\"cookieForm.jsp\";&lt;/script&gt;","link":"/2020/06/30/200701jspi/"},{"title":"[ITWILL : JAVA]클래스 : 매개변수위치에 따른 차이(생성자 vs 메서드), private멤버변수 getter와 setter로 가져다쓰기","text":"ITWILL학원 : 13강 JAVA BY 윤미영강사1. 매개변수위치에 따른 차이클래스 Book은 책제목과, 저자, 가격을 출력해준다. 123456789101112131415161718public class Book { private String title; private String author; private int price; public Book(String t, String a, int p){ title = t; author = a; price = p; } void showInfo(String title, String author, int price ){ System.out.printf(\"책 제목 : %s, 저자 : %s, 가격 : %,d%n\", title, author, price); } void showInfo(){ System.out.printf(\"책 제목 : %s, 저자 : %s, 가격 : %d%n\", title, author, price); } 클래스 TestBook 이라는 새로운 클래스파일을 만들고 메인메서드를 실행해보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TestBook { public static void main(String[] args) { //생성자파라미터를 통해서 값입력 Book book1 = new Book(\"운동하는여자\", \"양민영\", 25000); Book book2 = new Book(\"채식주의자\", \"한강\", 13500); //파라미터메서드를 통해서 값입력 Book book3 = new Book(); book3.showInfo(\"머니\", \"롭무어\", 28000); //배열생성 Book[] books = new Book[4]; //파라미터가 있는 배열값 넣는 방법2가지 //첫번째방법 : new 이용 books[0] = new Book(\"며느라기\", \"수신지\", 50000); //두번째방법 : 객체대입 books[1] = book1; books[2] = book2; books[3] = book3; //배열의 모든값 출력하는 두가지방법 //for문 사용 for(int i=0; i&lt;books.length; i++){ books[i].showInfo(); } //for each문사용 for(Book b: books){ b.showInfo(); } }}//출력값책 제목 : 머니, 저자 : 롭무어, 가격 : 28,000책 제목 : 며느라기, 저자 : 수신지, 가격 : 50000책 제목 : 운동하는여자, 저자 : 양민영, 가격 : 25000책 제목 : 채식주의자, 저자 : 한강, 가격 : 13500책 제목 : null, 저자 : null, 가격 : 0책 제목 : 며느라기, 저자 : 수신지, 가격 : 50000책 제목 : 운동하는여자, 저자 : 양민영, 가격 : 25000책 제목 : 채식주의자, 저자 : 한강, 가격 : 13500책 제목 : null, 저자 : null, 가격 : 0 1-1 null값이 나오는 이유?보이는 것처럼 생성자파라미터를 통해서 입력한 값들은 제대로 출력되지만 파라미터메서드를 통해서 입력한 값들은 null로 출력된다. WHY?메서드는 파라미터의 값을 받았는데 넣어줄 곳이 없기때문에! 그렇다면 메서드를 어떻게 바꾸면 될까?멤버변수를 파라미터값을 대입할수있게 코드를 추가해주면된다 123456void showInfo(String title, String author, int price ){ this.title = title; this.author = author; this.price = price; System.out.printf(\"책 제목 : %s, 저자 : %s, 가격 : %,d%n\", title, author, price);} 1-2 어떤 방법이 좋은걸까?생성자에 파라미터를 받는 방법과 메서드에 파라미터를 받아서 하는 방법 중 어느것이 더 좋은 것일까? 생성자파라미터 12345678//1-1.생성자파라미터 생성public Book(String t, String a, int p){ title = t; author = a; price = p;}//1-2.생성자파라미터 출력Book book1 = new Book(\"운동하는여자\", \"양민영\", 25000) 파라미터메서드 1234567891011//2-1.파라미터메서드 생성void showInfo(String title, String author, int price ){ this.title = title; this.author = author; this.price = price; System.out.printf(\"책 제목 : %s, 저자 : %s, 가격 : %,d%n\", title, author, price);}//2-2. 메서드 출력Book book1 = new Book();book3.showInfo(\"운동하는여자\", \"양민영\", 25000); 둘 다 기능은 동일하지만 생성자파라미터를 쓰는 것이 더 좋다 WHY?생성자의 기능과 메서드의 기능에 맞게 충실하게 하는 것이 좋기때문이다생성자의 기능은 변수를 초기화하는 것이다.메서드는 이름에서도 알수있듯이 showInfo()이다. 하지만 파라미터메서드를 생성하면 변수도 초기화하고 출력까지하는 두가지 짬뽕기능을 가지게 된다. 따라서 기능에 맞게 나눠서 코딩하는 것이 좋은 개발습관이다. 2. private 멤버변수값을 사용하는 방법 DAO : 주로 jsp model1에서 사용 DTO(Data Transfer Object) : 데이터가 포함된 객체를 한 시스템에서 다른 시스템으로 전달하는 작업을 처리하는 클래스이다. 즉, 객체에서 정보가 중요하다. 즉 멤버변수가 중요한 클래스. 정보전달이 중요한 DTO타입의 클래스들은 값을 생성해주는 getter, setter메서드를 만들어야한다 자바빈으로 불리기도 함. 주로 jsp model2에서 사용 vs 기능이 중요한 클래스, 라이브러리가 중요한 변수 VO(Value Object) DTO와 비슷한 개념 주로 스프링이용할때 사용 멤버변수는 private을 설정하는 것이 데이터보안상 좋다.하지만 private을 쓰게되면 다른 클래스에서 가져가 쓸 수가 없다.이럴때 아래 두가지 메서드를 이용한다(개발자들의 약속이다). 2-1. getter메서드와 setter메서드 멤버변수의 특정한 값을 가져오고 싶을땐 get멤버변수명(). 멤버변수의 특정한 값을 설정하고싶을땐 set멤버변수명(). 이를 getter와 setter라고 부른다. Getters and Setters 단축키 : Alt + Shift + S -&gt; R 또는 source탭 Generate Getters and Setters 클릭 2-2. getter와 setter 사용하는 방법 getter와 setter 사용하는 코드 123456//메인메서드안에서 get메서드쓰는 방법System.out.println(book1.getTitle()); //값가져오기//메인메서드안에서 set메서드쓰는 방법book1.setPrice(20000); //값설정System.out.println(book1.getPrice()); //값가져오기 2-3. getter와 setter 예시Book 클래스파일은 아래와 같다.제목과 저자 가격을 멤버변수로 가지고 있다. 12345678910111213141516171819202122232425262728293031323334public class Book { private String title; private String author; private int price; public Book(String t, String a, int p){ title = t; author = a; price = p; } void showInfo(){ System.out.printf(\"책 제목 : %s, 저자 : %s, 가격 : %d%n\", title, author, price); } String getTitle(){ return title; } String getAuthor(){ return author; } int getPrice(){ return price; } void setTitle(String title){ this.title = title; //매개변수명과 멤버변수명이 같을때 this를 통해 멤버변수를 지정해줄수있다. } void setAuthor(String a){ author = a; //매개변수명과 멤버변수명이 다른경우 그냥 쓰면 된다. } void setPrice(int p){ price = p; }} 매개변수명과 멤버변수명이 같을때 this를 통해 멤버변수를 지정해줄수있다. 실행하는 메인메서드파일은 아래와 같다. 12345678Book book1 = new Book(\"운동하는여자\", \"양민영\", 25000);System.out.println(book1.getTitle());book1.setPrice(20000);System.out.println(book1.setPrice());//출력값운동하는여자20000","link":"/2020/07/01/200702javai/"},{"title":"MYSQL 설치, MYSQL환경변수설정, cmd에서 명령어 잘못입력해서 mysql못빠져나갈때","text":"MYSQL 설치 (p372~)MYSQL 다운로드에 접속아래 이미지의 MYSQL Community(GPL) Downloads를 클릭 MYSQL Installer for Windows 다운로드 full package version 다운르도 No thanks, just start my download 클릭 Check Requirements 탭에서 excute를 클릭하기각각 설치가 완료되면 체크박스가 tick되어진다.꼭 설치되어있어야하는 것은 SERVER와 WORKBENCH이다.설치가 완료되면 NEXT버튼으로 바뀌게되고 클릭하면된다 Installation 탭에서 excute를 클릭하기각각 설치가 완료되면 Status가 Complete로 바뀌게 된다꼭 설치되어야하는 것은 SERVER와 WORKBENCH, NOTIFIER이다.설치가 완료되면 NEXT버튼으로 바뀌게되고 클릭하면된다. 포트번호 : 3306 기억하고 NEXT Account and Roles탭에서 Root계정 비밀번호 설정 후 Add user하기Root계정의 비밀번호를 설정 후 절대 잊어버리면 안된다.혹시 잊어버리면… MYSQL지우고 다시 까는 수밖에 없다고 한다.그래도 찾아보면 방법이 있지않을까? Add User클릭 후 아래 설정 후 OK 클릭하기 User Name : 맘대로 Host : &lt;All Hosts(%)&gt;선택 Role : DB admin (혹시 다른 거원하면 선택하면 됨) Windows Service탭에서 Start the MySQL Server at System Startup tick 해제하기윈도우를 시작할때마다 서버를 킬지 물어보는 체크박스이다. Apply Configuration탭에서 틱완료되었는지 확인 후 Finish를 클릭한다. Connect To Server탭에서 Root계정의 비밀번호를 입력하면 status가 변경된다.기존 running status에서 connection succeeded로 변경성공 Installation Complete탭에서 start MySQL workbanch after Setup 틱을 해제한 뒤 finish를 클릭한다 MySQL 사용방법 두가지.mysql 커맨드 실행다운로드한 파일들 중에 MySQL Command Line Client를 실행시킨 뒤 비밀번호 1234 입력한다.비밀번호가 일치하면 mysql&gt;옆에 쿼리구문을 작성할 수 있다. mysql workbanch실행다운로드한 파일들 중에 MySQL Workbanch를 실행시킨 뒤 비밀번호를 입력한다. 환경변수설정아래 이미지처럼 MySQL 다운로드한 경로의 bin파일 경로를 환경변수에 추가한다 환경변수설정완료했다면 cmd창 종료 -&gt; cmd 다시 시작한 뒤 제대로 다운도르 되었는지 아래 쿼리로 확인한다. 1$ mysql 아래 이미지처럼 나오면 설치가 정상적으로 되었다는 의미이다. cmd에서 명령어 잘못입력해서 mysql못빠져나갈때잘못 명령어를 입력해서 mysql못나갈경우 \\c를 입력하면 된다한참 헤맨 증거…ㅋㅋㅋㅋㅋ mysql 유저 접속아래 명령어를 입력하고 엔터를 치면 password를 입력창이 뜬다. 1$ mysql -u [id] -p 유저 로그인 성공!","link":"/2020/06/30/200701jspi2/"},{"title":"MYSQL 접속순서, DB명령어, 테이블명령어, 데이터명령어","text":"MYSQL 순서 cmd에서 mysql -u [id] -p 입력 비번입력 MySQL로그인 use jspdb show tables; 만약 DB가 켜져있지않다는 에러가 난다면 파일탐색기에서 서비스검색한 후 MySQL을 찾아 더블클릭하고 시작버튼을 누르고 다시 cmd에서 명령어를 입력하면 된다. DB명령어 : DB목록조회, DB생성, DB삭제, DB사용 기능 명령어 목록조회 show databases; DB 생성 create database 디비이름; DB 삭제 drop database 디비이름; DB 사용 use 디비이름; DB생성12$ mysql&gt; create database jspdb;Query OK, 1 row affected (0.01 sec) DB 목록조회12345678910111213$ mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || jspdb || mysql || performance_schema || sakila || test || world |+--------------------+7 rows in set (0.00 sec) DB 사용123456789101112131415$ mysql&gt; use jspdb;Database changedmysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || jspdb || mysql || performance_schema || sakila || test || world |+--------------------+7 rows in set (0.00 sec) DB삭제123456789101112131415$ mysql&gt; drop database jspdb;Query OK, 0 rows affected (0.10 sec)$ mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sakila || test || world |+--------------------+6 rows in set (0.00 sec) 테이블명령어 : 테이블생성, 테이블조회, 테이블삭제, 테이블구조확인 기능 명령어 테이블생성 create table 테이블이름 (필드명1 데이터타입 제약조건, 필드명2 데이터타입 제약조건, …); 테이블삭제 drop table 테이블이름; 테이블전체조회 show tables; 테이블구조확인 desc 테이블이름; 테이블생성12mysql&gt; create table test (idx int);Query OK, 0 rows affected (0.16 sec) 테이블전체조회1234567mysql&gt; show tables;+-----------------+| Tables_in_jspdb |+-----------------+| test |+-----------------+1 row in set (0.01 sec) 테이블구조확인1234567mysql&gt; desc test;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| idx | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+1 row in set (0.02 sec) 테이블삭제12drop table test;Query OK, 0 rows affected (0.09 sec) DB에 따른 데이터타입 차이점 데이터타입 오라클 MySQL 문자형 varchar2 varchar 정수형 number int 실수형 double 데이터명령어 : 입력, 출력(검색), 삭제, 수정 여기서 중괄호는 생략가능을 나타낸다. 데이터입력에서 필드명 생략가능 필드명 사용한 경우 : 지정한 필드에만 값 추가 가능 필드명 사용 안한경우 : 모든 필드에 순서대로 값을 입력해야함. 기능 명령어 데이터 전체출력(검색) select * form 테이블명; 데이터 출력(검색) select 컬럼명 {where 조건} form 테이블명; 데이터 입력 insert into 테이블명 {(필드명1, …)} values(값1, …); 데이터 전체삭제 delete from 테이블명 데이터 일부분삭제 delete from 테이블명 {where 조건} 데이터 전체수정 update 테이블명 set 컬럼명1 = 값, 컬럼명2 = 값, …; 데이터 해당 조건만 수정 update 테이블명 set 컬럼명1 = 값, 컬럼명2 = 값, …where 조건; 내장함수 기능 명령어 사용법 현재시간자동입력 now() insert into 테이블명 {(필드명1, …)} values(now(), …);","link":"/2020/07/01/200702jspi/"},{"title":"MySQL 한글깨짐현상 두가지 해결방법 : cmd와 Workbench, 이클립스와 MYSQL연결","text":"cmd로 한글깨짐현상 해결하기mysql 유저 접속아래 명령어를 입력하고 엔터를 치면 password를 입력창이 뜬다. 1$ mysql -u [id] -p status 명령어를 날리면 현재 DB상태확인가능하다.빨간 부분을 보면 UTF-8이 아니다. 이럴 경우 한글이 깨질수있으므로 utf-8로 설정해줘야한다. 아래 주소 C:\\ProgramData\\MySQL\\MySQL Server 5.6 에서 my.ini파일을 열어준다ctrl+F로 [mysqld]를 찾는다.[mysqld]을 지우고 그 위에 아래 내용을 쓴다.1234567[mysql]default-character-set=utf8[mysqld]collation-server = utf8_unicode_cicharacter-set-server = utf8skip-character-set-client-handshake 설정된 값이 실행되려면 MYSQL를 재부팅하면 된다.정상적으로 utf-8로 뜨는 것을 확인할 수 있다. Workbench로 한글깨짐현상 해결하기DB 한글설정제일 상위 DB에 마우스를 가져다되면 2개의 아이콘이 오른편에 생긴다.그 중 가장 오른쪽인 몽키스패너를 클릭한다.Charset/Collation탭에서 utf8과 utf8_bin으로 지정 후 apploy를 눌러준다 이미 생성된 테이블 한글설정모든 컬럼에 utf8과 utf8_bin으로 지정 후 apploy를 눌러준다. 이클립스와 MYSQL연결라이브러리를 사용해서 MYSQL에 접근할 수 있다.이클립스와 MYSQL연결을 위해 툴 설치가 필요하다. MYSQL 다운로드에서 Connector/J를 클릭한다. ZIP파일로 다운로드 후 압출을 푼 뒤 mysql-connector-java-5.1.49-bin.jar파일을 이클립스에 복붙한다 이클립스에서 MYSQL불러오기드라이버를 로드 : Class.sforName(“com.mysql.jdbc.Driver”)DB연결DriverManager.getConnection(url, user, password)이고 파라미터가 3개이다. 파라미터 자세히 : DriverManager.getConnection(“jdbc:mysql://localhost:포트번호/DB이름”, user, password) import = java.sql.Connection 보라색동그라미 의미 : Interface java.sql로 클릭하면 자동 import생성 123456789101112131415&lt;%@page import=\"java.sql.Connection\"%&gt; //자동import//1단계 드라이버를 로드Class.forName(\"com.mysql.jdbc.Driver\");System.out.println(\"드라이버 로드성공\");//2단계 DB연결Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/jspdb\", \"root\", \"1234\");System.out.println(\"DB연결성공\");%&gt;&lt;h2&gt;연결성공 &lt;%=con %&gt;&lt;/h2&gt;//출력값 : 연결성공 com.mysql.jdbc.JDBC4Connection@4edd8384 골뱅이 앞은 객체주소 -&gt; 만약 null이 나오면 객체가 생성되지않았다는 의미. 골뱅이 뒤는 객체 캐쉬번호.","link":"/2020/07/01/200702jspi2/"},{"title":"[ITWILL : JSP]JDBC활용 - JAVA에서 DB 정보 지우기 2가지방법","text":"ITWILL학원 : 19강 JSP기초 BY 정규태강사JDBC JDBC활용 - import쓰는 이유, form페이지로 받은 데이터를 DB에 insert하는 방법 JDBC활용 - JAVA에서 DB 정보 지우기 2가지방법 JDBC활용 - DB에서 고객정보를 불러와서 HTML테이블에 담기 JDBC활용 - TIMESTAMP주의점, JDBC에서 데이터처리 JDBC활용 - 회원정보수정페이지만들기 JDBC활용 - 회원목록출력하는데 관리자는 빼고 출력하기, 자바 에러 두종류 JAVA에서 DB 정보 지우기이름과 주민번호의 입력값이 DB데이터와 일치하면 회원탈퇴를 진행하는 코드를 만들어보자. 1. 사용자가 작성할 form페이지만들기먼저 이름과 주민번호를 사용자로부터 입력받을 수 있는 deleteForm.jsp파일을 만든다 12345678910&lt;fieldset&gt;&lt;legend&gt;회원정보수정&lt;/legend&gt; &lt;form action=\"deletePro.jsp\" method=\"post\" name=\"fr\"&gt; &lt;h3&gt;본인확인정보&lt;/h3&gt; 이름 &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt; 주민번호 &lt;input type=\"text\" name=\"jumin1\"&gt; - &lt;input type=\"password\" name=\"jumin2\"&gt;&lt;br&gt; &lt;p&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"탈퇴하기\"&gt;&lt;br&gt; &lt;/form&gt;&lt;/fieldset&gt; 2. 사용자가 작성한 데이터를 불러와서 DB에 연결하기 deletePro.jsp에서 사용자데이터를 불러와서 DB데이터와 확인 후 탈퇴를 처리하는 코드를 작성하면 아래와 같다. 순서는 아래와 같다 사용할 변수를 먼저 가져오기 DB연결하기 SQL쿼리작성하기 12345678910111213141516&lt;%//1. 변수가져오기request.setCharacterEncoding(\"UTF-8\");String name = request.getParameter(\"name\");String jumin = request.getParameter(\"jumin1\")+\"-\"+request.getParameter(\"jumin2\");%&gt;&lt;% //2.DB연결final String DRIVER = \"com.mysql.jdbc.Driver\";final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";final String DBID = \"root\";final String DBPW = \"1234\";Class.forName(DRIVER);Connection con = DriverManager.getConnection(DBURL, DBID, DBPW);%&gt; 3. sql작성 &amp; pstmt객체생성이때 두가지 방법이 있다. 3-1. 바로 delete하기 pstmt.executeUpdate();는 return값이 int이므로 int형 변수에 넣은 뒤 if조건문을 통해 진행여부를 html페이지에서 보여줄 수 있다. 사용자입력값이 DB데이터와 일치하면 이클립스 console창에 실행완료(수정완료) : 1 출력 html파일에서는 이름과 함께 정상적으로 탈퇴되었습니다라는 문구 출력된다. 사용자입력값이 DB데이터와 불일치하면 이클립스 console창에 실행완료(수정실패) : 0 출력 html파일에서는 탈퇴실패 문구 출력된다. 12345678910111213141516&lt;%//3. sql작성 &amp; pstmt객체생성String sql = \"delete from itwill_member where name=? &amp;&amp; jumin=?\";PreparedStatement pstmt = con.prepareStatement(sql);pstmt.setString(1, name);pstmt.setString(2, jumin);int val = pstmt.executeUpdate();if(val &gt; 0){ System.out.println(\"실행완료(수정완료) : \"+ val); %&gt;&lt;%=name %&gt;님, 정상적으로 탈퇴되었습니다.&lt;%}else{ System.out.println(\"실행완료(수정실패) : \"+ val); %&gt;탈퇴실패&lt;%}%&gt; 3-2. select 후 delete하기 pstmt.executeUpdate();는 return값이 int이므로 int형 변수에 넣은 뒤 if조건문을 통해 진행여부를 html페이지에서 보여줄 수 있다. 사용자입력값이 DB데이터와 일치하는지 select로 확인후 일치하면 delete구문으로 데이터 삭제 사용자입력값이 DB데이터와 일치하는지 select로 확인후 불일치하면 삭제동작없이 이전페이지로 이동 DB에서 delete은 매우 신중한 작업이다.따라서 정확한 데이터를 찾아 정확하게 처리해야하기때문에 전자보단 후자를 사용해야한다. 1234567891011121314151617181920212223242526272829303132&lt;% //3. sql작성 &amp; pstmt객체생성String sql = \"select name jumin from itwill_member where name=?\";PreparedStatement pstmt = con.prepareStatement(sql);pstmt.setString(1, name);ResultSet rs = pstmt.executeQuery();if(rs.next()){ //레코드셋에서 커서를 옮겨서 데이터가 있을 때 실행하겠다. //이름과 주민번호가 있는 회원의 정보가 존재한다 =&gt;삭제 if(jumin.equals(rs.getString(\"jumin\"))){ sql = \"delete from itwill_member where name=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, name); pstmt.execute(); System.out.println(\"회원삭제완료\"); }else{ //이름은 있지만 주민번호가 다른 경우 =&gt;삭제동작없이 이전페이지로 이동 %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"주민번호 오류\") history.back(); //뒤로가기. &lt;/script&gt; &lt;% }}else{ //이름에 해당하는 주민번호가 존재하지않음 =&gt; 즉,비회원이므로 삭제동작없이 이전페이지로 이동 %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"이름 오류\") history.back(); //뒤로가기. &lt;/script&gt; &lt;%}%&gt;","link":"/2020/07/02/200703jspi2/"},{"title":"[ITWILL : JSP]JDBC활용 - import쓰는 이유, form페이지로 받은 데이터를 DB에 insert하는 방법","text":"ITWILL학원 : 19강 JSP기초 BY 정규태강사JDBC JDBC활용 - import쓰는 이유, form페이지로 받은 데이터를 DB에 insert하는 방법 JDBC활용 - JAVA에서 DB 정보 지우기 2가지방법 JDBC활용 - DB에서 고객정보를 불러와서 HTML테이블에 담기 JDBC활용 - TIMESTAMP주의점, JDBC에서 데이터처리 JDBC활용 - 회원정보수정페이지만들기 JDBC활용 - 회원목록출력하는데 관리자는 빼고 출력하기, 자바 에러 두종류 1. import는 언제, 왜 쓸까?어떤 건 import를 쓰고 어떤 건 import하지않고도 사용가능하다. 왜그럴까? import가 필요없는 경우 : 기본적으로 사용 가능한 클래스인 경우이다. 직접구현해서 접근가능한 범위에서 만들어 놓은 클래스들 java 활용도가 높은 클래스를 패키지 추가 없이 사용가능하도록 만들어 놓은 클래스들 예 ) java.lang.*은 자바에서 제공하는 기본패키지로 import없이 사용가능하다. 대표적으로 String 객체는 java.lang.*에 속해있다. import를 써야하는 경우 : 기본제공되는 클래스가 아닌 경우 클래스가 있는 패키지를 추가(import)해야함 2. form페이지로 받은 데이터를 DB에 insert하는 방법form페이지를 만들어서 이름과 성별, 나이, 주민번호를 사용자로부터 받은 뒤 그 데이터들을 insertPro.jsp파일에서 불어와서 MySQL DB에 넣어보는 코드이다. 아래 코드는 form페이지는 생략하고 insertPro.jsp만 나타낸 코드이다. 총 3단계로 이루어진다. form페이지에서 입력한 데이터를 변수로 불러오기 DB연결하기 SQL구문작성 후 stmt객체생성하기 : SQL구문작성시에는 작은 따음표와 큰 따옴표를 잘 입력해야한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//import 아래 3가지 추가됨&lt;%@page import=\"java.sql.Statement\"%&gt;&lt;%@page import=\"java.sql.DriverManager\"%&gt;&lt;%@page import=\"java.sql.Connection\"%&gt;&lt;% //1. 변수로 가져오서 데이터출력//1-1. 파라미터값 한글처리request.setCharacterEncoding(\"UTF-8\");//1-2. form태그에서 받은 모든 데이터는 string타입으로 전달되므로 -&gt; int는 형변환필수String name = request.getParameter(\"name\");int age = Integer.parseInt(request.getParameter(\"age\"));String gender = request.getParameter(\"gender\");String jumin1 = request.getParameter(\"jumin1\");String jumin2 = request.getParameter(\"jumin2\");String jumin = jumin1 + \"-\" + jumin2;%&gt;&lt;!--1-3. 데이터출력 --&gt;이름 : &lt;%=name %&gt;&lt;br&gt;나이 : &lt;%=age %&gt;&lt;br&gt;성별 : &lt;%=gender %&gt;&lt;br&gt;주민번호 : &lt;%=jumin %&gt;&lt;br&gt;&lt;%//2. DB에 담기//2-1. 필요한 변수들 상수로 정리final String DRIVER = \"com.mysql.jdbc.Driver\";final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";final String DBID = \"root\";final String DBPW = \"1234\";//2-2. 드라이버로드Class.forName(DRIVER);System.out.println(\"드라이버로드성공\");//2-3. DB연결Connection con = DriverManager.getConnection(DBURL, DBID, DBPW);System.out.println(\"드라이버연결\");//3. SQL구문작성, stmt 객체생성//3-1. SQL구문작성 : 작은따옴표와 큰따옴표 주의하기String sql= \"insert into itwill_member values(null,'\"+name+\"','\"+gender+\"',\" +age+\",'\"+jumin+\"')\"; //3-2. stmt 객체생성(java.sql하위의 statement사용) : sql구문을 실행하는 역할.Statement stmt = con.createStatement(); //statement객체생성완료//3-3. stmt 실행stmt.executeUpdate(sql);System.out.println(\"DB저장완료\");%&gt; MySQL가서 select * from 테이블명 명령어를 입력하면 row가 추가된 것을 확인할 수 있다. 3. PreparedStatement 객체생성위의 sql구문작성을 보면 변수, 작은따옴표, 큰따옴표혼재되어있어서 적기에 매우 불편하다이를 해소하기위한 객체PreparedStatement를 이용하면된다. 기존 Statement보다 처리속도도 빠르고 보안도 좋은 PreparedStatement를 사용해야한다. 아래 두 코드를 비교해보자. 3-1. Statement사용1234567891011&lt;%@page import=\"java.sql.Statement\"%&gt;//1.SQL구문작성String sql= \"insert into itwill_member values(null,'\"+name+\"','\"+gender+\"',\" +age+\",'\"+jumin+\"')\"; //2. stmt 객체생성(java.sql하위의 statement사용) : sql구문을 실행하는 역할.Statement stmt = con.createStatement();//3. stmt 실행stmt.executeUpdate(sql); 3-2. PreparedStatement사용3단계 stmt 실행시 기능에 따라 쿼리구문을 두가지로 구분할수있다. pstmt.executeUpdate() : insert, update, delete에 사용 DB조작하는 구문. pstmt.executeQuery() : select에 사용 DB조작없이 값만 사용하는 구문. 123456789101112131415161718&lt;%@page import=\"java.sql.PreparedStatement\"%&gt;//1. SQL구문작성String sql= \"insert into itwill_member values(null,?,?,?,?)\";//2. pstmt 객체생성(java.sql하위의 prepareStatement사용) : sql구문을 실행하는 역할.PreparedStatement pstmt = con.prepareStatement(sql);//물음표 값채우기 pstmt.set테이블데이터타입(물음표위치, 값) //항상 물음표 갯수와 쿼리구문갯수가 동일해야한다.pstmt.setString(1, name);pstmt.setString(2, gender);pstmt.setInt(3, age);pstmt.setString(4, jumin);//3. pstmt 실행 : 업데이트 또는 쿼리pstmt.executeUpdate();//pstmt.executeQuery();","link":"/2020/07/02/200703jspi/"},{"title":"IMG태그, 무료이미지사이트, a태그의 target속성","text":"웹에서 활용하는 대표 이미지형식 3가지 확장자명 특징 .gif 최대 256가지 색상 표현 가능. 투명배경 가능. 움짤가능 .jpg 트루컬러 표현 가능. 색상에 비해 파일 용량이 작음 ex)일반사진 .png 트루컬러 표현 가능. 투명배경가능. ex)로고 무료이미지사이트 Pixabay Pexels Morguefile a태그의 target속성a태그의 target속성은 링크 여는 방식을 지정한다. 총 4가지가 있다.이제는 프레임구조가 없어져서 top과 parent는 더이상 사용하지 않는다. 1234target = \"_self\" : 기본값, 링크가 현재 위치에서 열림.target = \"_blank\" : 링크를 새탭열기.target = \"_top\" : (프레임구조에서) 링크가 전체 창에 하나로 열림.target = \"_parent\" : (프레임구조에서) 링크가 상위창(부모창)에서 열림. 예시12현재페이지열기 : &lt;a href=\"https://www.naver.com/\"&gt;새창열기 : &lt;a href=\"https://www.naver.com/\" target=\"_blank\"&gt;","link":"/2020/07/02/200703webi/"},{"title":"[패스트캠퍼스python] 장고프로젝만들기 전체 순서&#x2F;흐름도(ft.쇼핑몰)","text":"차근차근 순서대로 Django와 python으로 쇼핑몰을 만들어보자. 1. Django 가상환경설정 가상환경 virtualenv 설치하기 : pip3 install virtualenv 가상환경은 첫 사용시 한번만 설치하면 된다. 이미 설지채놓았다면 2번 가상환경 폴더만들기부터 진행하면된다. virtualenv는 일반적으로 글로벌 설치가 되어야하는 유일한 패키지이다. 나머지 패키지들은 가상 환경에 설치하기때문이다. 가상환경 폴더만들기 : virtualenv 새로운파일명(보통은 env) 새로운 프로젝트를 시작할때마다 새로운 가상환경을 설정해주는 것이 좋다. 가상환경폴더는 보통 env라고 정하고 프로젝트 디렉토리 내부에 이를 만드는 것이 일반적인 관습이다. 만약 git과 같은 버전 컨트롤 시스템을 사용한다면, env 디렉토리를 커밋에 포함시키면 안된다. 반드시 .gitignore 파일에 env 디렉토리를 추가해야한다. 가상환경 들어가기 : cd 가상환경을 설치한 파일경로 cd Scripts activate 위에서 만든 가상환경 폴더 안에서 Django설치 : pip3 install django 가상환경 안에 어떤 프로그램이 설치되어있는지 궁금할때는 pip list을 입력하면 된다. 2. 새로운 프로젝트와 앱생성 새로운 프로젝트 생성하기 : django-admin startproject 새로운프로젝트명 app생성하기 : django-admin startapp 새로운앱명 쇼핑몰이므로 user, product, order, delivery등의 app을 생성하면 된다. 위에서 만든 모든 app에 각각 templates 폴더 생성 만든 app을 app(프로젝트명과 동일한 이름)하위의 settings.py에서 Installed_app = []에 연결. 만든 각각의 app하위의 models.py에 class와 그 안에 class Meta를 생성. 아래는 쇼핑몰 user 예시코드이다. 쇼핑몰이니까 user앱뿐만 아니라 product, order, delivery등의 각 app 하위에도 class와 class Meta를 생성한다. 123456789class User(models.Model): email = models.EmailField(verbose_name='이메일') password = models.CharField(max_length=64, verbose_name='비밀번호') register_date = models.DateTimeField(auto_now_add=True, verbose_name='가입일자') class Meta: db_table='shop_user' verbose_name='고객' verbose_name_plural='고객' 3. Database 설정 DB에 변경이 필요한 사항 추출하기 : python3 manage.py makemigrations 예를 들어 클래스를 만들었으면, 클래스에서 모델을 불러와 테이블 생성한다. DB에 변경사항 반영하기 : python3 manage.py migrate 예를 들어 클래스를 만들었으면, 위에서 불러온 테이블(클래스)에 칼럼 및 속성 추가 또는 반영한다. 9번과 10번을 통해서 DB에 테이블 자동 생성이된다. sqlite3 db.sqlite3 명령어등으로 sqlite3를 만질 필요가 없이 장고가 알아서 다 해준다! 이 맛에 장고를 이용한다고 한다. 첫 user생성하기 : python3 manage.py createsuperuser 반영사항 체크하기 : python3 manage.py runserver 4. 부트스트랩 설정 각 app의 templates폴더안에 html파일을 만든다. user app의 templates폴더안에 base.html, index.html product app의 templates폴더안에 order app의 templates폴더안에 templates폴더안에 html파일에 부트스트랩 css와 js를 복붙한다. 부트스트랩 사이트 base.html에 부트스트랩 css코드와 js코드를 head태그안에 복붙한다. index.html은 base.html을 상속받아서 활용한다. 아래는 base.html 코드이다. 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- 부트스트랩 css코드와 js코드 복붙 --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\" integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\" crossorigin=\"anonymous\"&gt; &lt;script src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\" integrity=\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\" integrity=\"sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js\" integrity=\"sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"containner\"&gt; {% block contents %} {% endblock %} &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 아래는 index.html 코드이다. “base.html”를 상속받는다. 123456{% extends \"base.html\" %}{% block contents %}하이{% endblock%} 부트스트랩스타일적용 : 프로젝트디렉토리 하위에 static 폴더생성 (app폴더들과 동급)-&gt; 원하는 디자인 다운로드 후 폴더안에 넣기 html파일을 view.py에 연결하기. 만든 모든 html파일은 view.py에 연결해야한다. 예시로 위에서 만든 index.html을 view.py에 연결하는 방법은 아래와 같다. 1234from django.shortcuts import renderdef index(request): return render(request, 'index.html') usr.py에 연결하기.","link":"/2020/07/04/200705python/"},{"title":"[ITWILL : JSP]JDBC활용 - DB에서 고객정보를 불러와서 HTML테이블에 담기","text":"ITWILL학원 : 20강 JSP기초 BY 정규태강사JDBC JDBC활용 - import쓰는 이유, form페이지로 받은 데이터를 DB에 insert하는 방법 JDBC활용 - JAVA에서 DB 정보 지우기 2가지방법 JDBC활용 - DB에서 고객정보를 불러와서 HTML테이블에 담기 JDBC활용 - TIMESTAMP주의점, JDBC에서 데이터처리 JDBC활용 - 회원정보수정페이지만들기 JDBC활용 - 회원목록출력하는데 관리자는 빼고 출력하기, 자바 에러 두종류 DB저장되어있는 모든 회원정보를 출력하는 코드를 작성해보자. 1. recordset과 resultset recordset = select 구문의 결과. BOF부터 EOF(End Of File)까지의 총 덩어리를 의미. resultset = 테이블을 의미. ex)테이블A, 테이블B, 테이블C 각각이 다 resultset이다. rs.next() = 커서객체를 다음(next)로 넘기는 메서드. row에 데이터가 있으며 true이고 없으면 다음 row로 내려간다. 데이터에 행이 없으면 False가 되고 while문이 종료된다. getString(columnIndex)는 columnIndex안에 테이블의 열번호를 넣으면 된다. 가독성이 떨어지고 모든 열이 어떤 데이터인지 알고있을때 사용할 수있다. 따라서 index값을 사용하는 경우 주석을 적어 무엇을 나타내는 데이터인지 알려주는 것이 좋다. 2. DB에서 고객정보를 불러와서 테이블에 담기.1234567891011121314151617181920212223242526272829303132&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;인덱스&lt;/td&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;성별&lt;/td&gt; &lt;td&gt;나이&lt;/td&gt; &lt;td&gt;주민번호&lt;/td&gt; &lt;/tr&gt;&lt;%//1.변수설정%&gt;&lt;% //2. 드라이버 로드와 DB연결final String DRIVER = \"com.mysql.jdbc.Driver\";final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";final String DBID = \"root\";final String DBPW = \"1234\";Class.forName(DRIVER);Connection con = DriverManager.getConnection(DBURL, DBID, DBPW);//3.쿼리작성String sql = \"select * from itwill_member\";PreparedStatement pstmt = con.prepareStatement(sql);ResultSet rs = pstmt.executeQuery();//3-1.일반출력/* while(rs.next()){ System.out.println(\"이름 : \" + rs.getString(\"name\") //이름만 출력 + \", 성별 : \" + rs.getString(\"gender\") + \", 나이 : \" + rs.getInt(\"age\") + \", 주민번호 : \" + rs.getString(\"jumin\")); //이름, 나이, 성별, 주민번호 -&gt; 콘솔로 출력하기 -&gt; html 테이블생성해서 출력하기 }*/ 2-1. 테이블에 출력가져온 데이터를 테이블형태로 출력해보는데 2가지 방법이 있다. 변수지정없이 바로 while반복문실행SQL구문작성시 select * from itwill_member이라서 while반복문을 사용했다.만약 SQL구문이 select * from itwill_member where id=?로 where조건절을 추가하면 반복문이 아닌 if문으로 사용가능하다. 1234567891011121314151617181920//3.쿼리작성String sql = \"select * from itwill_member\";PreparedStatement pstmt = con.prepareStatement(sql);ResultSet rs = pstmt.executeQuery();while(rs.next()){ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=rs.getString(1) %&gt;&lt;/td&gt; //인덱스 &lt;td&gt;&lt;%=rs.getString(\"name\") %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString(\"gender\") %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getInt(\"age\") %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString(\"jumin\") %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;%}%&gt;&lt;/table&gt; 변수에 저장해서 반복문없이 table에 바로 태그집어넣기rs에서 가져온 값을 변수로 저장해서 html table태그에 바로 표현식으로 집어넣을 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940//3.쿼리작성String sql = \"select * from itwill_member where id=?\";PreparedStatement pstmt = con.prepareStatement(sql);pstmt.setString(1, id);ResultSet rs = pstmt.executeQuery();String name = \"\";int age = 0;String gender = \"\";String email = \"\";Timestamp reg_date = null; //null이 초기값임if(rs.next()){ //id=rs.getString(\"id\"); 세션으로 가져와서 필요없음 name = rs.getString(\"name\"); age = rs.getInt(\"age\"); gender = rs.getString(\"gender\"); email = rs.getString(\"email\"); reg_date = rs.getTimestamp(\"reg_date\");}%&gt;&lt;table border=1&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;나이&lt;/td&gt; &lt;td&gt;성별&lt;/td&gt; &lt;td&gt;이메일&lt;/td&gt; &lt;td&gt;가입일자&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;%=id %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=gender %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=email %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=reg_date %&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","link":"/2020/07/05/200706jspi/"},{"title":"[ITWILL : JSP]JDBC활용 - TIMESTAMP주의점, JDBC에서 데이터처리","text":"ITWILL학원 : 20강 JSP기초 BY 정규태강사JDBC JDBC활용 - import쓰는 이유, form페이지로 받은 데이터를 DB에 insert하는 방법 JDBC활용 - JAVA에서 DB 정보 지우기 2가지방법 JDBC활용 - DB에서 고객정보를 불러와서 HTML테이블에 담기 JDBC활용 - TIMESTAMP주의점, JDBC에서 데이터처리 JDBC활용 - 회원정보수정페이지만들기 JDBC활용 - 회원목록출력하는데 관리자는 빼고 출력하기, 자바 에러 두종류 1. MySQL Workbench에서 Timestamp 추가시 주의점 MySQL Workbench에서 row추가시 Timestamp 데이터타입을 쓰고싶다면 TIMESTAMP라고 직접 작성하거나 드롭다운리스트에서 TIMESTAMP()을 찾은 뒤 꼭 괄호를 삭제하고 TIMESTAMP로 apply해야 에러가 발생하지 않는다. 타임스탬프는 사용자가 입력하는 데이터가 아니라 컴퓨터시간에서 가져오는 데이터이다.따라서 JDBC의 3단계인 sql구문 &amp; DB저장에서 객체생성을 통해 진행할 수 있다. 아래 코드는 JDBC에서 itwill_member테이블에 사용자가 입력한 id, pw와 컴퓨터현재시간을 차례대로 sql구문에 넣는 코드이다. 123456//3. sql구문 &amp; DB저장 진행시 String sql = \"insert into itwill_member value(?,?,?)\";PreparedStatement pstmt = con.prepareStatement(sql);pstmt.setString(1, id);pstmt.setString(2, pw);pstmt.setTimestamp(3, new Timestamp(System.currentTimeMillis())); 2. JDBC에서 데이터처리JDBC 3단계인 SQL작성 &amp; pstmt 객체생성 &amp; 데이터처리를 중점으로 로그인페이지를 작성해보자. 아이디 일치 + 비번일치 =&gt; 로그인, main페이지이동, id값 세션객체 생성 아이디 일치 + 비번불일치 =&gt; 에러(“비밀번호오류”), 뒤로가기 아이디 불일치 =&gt; 에러(“비회원입니다”), 뒤로가기 123456789101112131415161718192021222324252627282930313233343536373839//3-3. 데이터처리if(rs.next()){ //true라는 건 id가 있다는 소리임 즉, 회원인 경우가 됨 if(pw.equals(rs.getString(\"pw\"))){ //비번일치 //세션ID값생성 session.setAttribute(\"id\", id); response.sendRedirect(\"main.jsp\"); //js코드보다 java코드가 좋다 System.out.println(id+\"로그인성공\"); %&gt;&lt;!-- &lt;script type=\"text/javascript\"&gt; location.href=\"main.jsp\" &lt;/script&gt; js코드보다 java코드가 더 좋다 --&gt; &lt;% }else{ System.out.println(\"비밀번호오류\"); //비번불일치 %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"비밀번호가 일치하지 않습니다\") //페이지이동 3가지의 차이점 history.back(); //=&gt;작성한 아이디나 데이터가 살아있다 //location.href=\"loginForm.jsp\" //=&gt;작성한 아이디나 데이터가 없다 //location.reload();//=&gt;새로고침으로 alert창이 반복된다 &lt;/script&gt; &lt;% }}else{ //false이므로 id가 없다는 소리임. 즉, 비회원인 경우. System.out.println(\"아이디오류-비회원입니다\"); %&gt; &lt;script type=\"text/javascript\"&gt; let tmp = confirm(\"비회원입니다. 회원가입하시겠습니까?\") if(tmp){ location.href=\"insertForm.jsp\"; }else{ history.back(); } &lt;/script&gt; &lt;%}%&gt; 2-1. 페이지이동시 js코드보다 java코드가 좋은 이유다른 페이지로 이동시 왜 js코드보다 java코드가 더 좋을까?해당파일의 확장자는 jsp이다. jsp파일이라서 자바코드의 처리가 우선순위에 있다.js코드인 경우, java로 된 코드가 다 실행되고 난 뒤에 실행이 된다.이때 이후에 나오는 java코드에 문제가 생기면 js코드가 실행안될 수 있기때문에 아예 java코드를 쓰는것이실행순서상 좋다. js코드를 이용한 페이지이동 123&lt;script type=\"text/javascript\"&gt; location.href=\"main.jsp\"&lt;/script&gt; --&gt; java코드를 이용한 페이지이동 1response.sendRedirect(\"main.jsp\"); 2-2. 페이지새로고침 3가지의 차이점. history.back(); : 작성한 아이디나 데이터가 살아있다 location.href=&quot;loginForm.jsp&quot;; : 작성한 아이디나 데이터가 없다 location.reload(); : 새로고침으로 alert창이 반복된다","link":"/2020/07/05/200706jspi2/"},{"title":"여러행함수 : Group by절, Having절","text":"SQL함수에는 두가지 유형이 있다. 단일행함수 : 행당 하나의 결과 반환 여러행함수 : 행 집합당 하나의 결과 반환 그룹함수 Group by절 Having절 이 중 여러행함수에 대해 알아보자.그룹함수는 테이블의 전체 행을 하나 이상의 컬럼을 기준으로 그룹화하여 그룹별로 결과를 출력하는 함수 Group by절 모두 사원 전체를 기준으로 데이터를 추출하는 것이 아닌 특정 그룹으로 묶어 데이터를 GROUP BY절로 집계할 수 있다. 즉 테이블안에서 또 다시 작은 테이블로 그룹을 나누고싶을때 사용. GROUP BY 구문은 WHERE와 ORDER BY절 사이에 위치한다. 문법이므로 정확한 위치에 적어여한다. 따라서 암기하기 쉽게 ORDER BY절이 항상 마지막이라고 생각하면된다. 예시1 : 하나의 테이블(emp)에서 부서별(deptno)로 평균급여(AVG(sal)) 조회(select)시 사용 예시2 : employees테이블에서 부서별로 job_id가 동일한 사원들의 평균급여를 출력시 사용.- 모바일사업부에서 동일한 job_id(마케팅)를 가진 사원들의 평균 급여 - 모바일사업부에서 동일한 job_id(총무팀)를 가진 사원들의 평균 급여 - 모바일사업부에서 동일한 job_id(자재구매팀)를 가진 사원들의 평균 급여 - 화이트가전사업부에서 동일한 job_id(마케팅)를 가진 사원들의 평균 급여 - 화이트가전사업부에서 동일한 job_id(총무팅)를 가진 사원들의 평균 급여 - 화이트가전사업부에서 동일한 job_id(자재구매팀)를 가진 사원들의 평균 급여123$ select dept_id, job_id, avg(salary)$ from employees$ group by dept_id, job_id Having 절조건문을 작성할수있는 절이다. Where절과 Having절 차이Where절도 조건문을 작성할 수 있는 절인데 이 둘의 차이가 뭘까? Where절 : 행 제한 조건문, 즉 단일행함수가 들어갈때 사용. Having절 : 행 그룹 제한 조건문, 즉 그룹함수가 들어갈때 사용. 아래 쿼리는 employees테이블에서 job_id에 REP가 들어가지 않은 job_id를 기준으로 salary합계가 13000 초과하는 job_id별로 salary합계를 낮은순으로 정렬한 뒤 PAYROLL로 제목을 나타내서 출력한다. 123456$ select job_id, SUM(salary) PAYROLL$ from employees$ where job_id not like '%REP%'$ group by job_id$ having SUM(salary) &gt; 13000$ order by SUM(salary) Group by절과 Having절 예시","link":"/2020/07/06/200707dbi/"},{"title":"[ITWILL : JSP]JDBC활용 - 회원목록출력하는데 관리자는 빼고 출력하기, 자바 에러 두종류","text":"ITWILL학원 : 22강 JSP기초 BY 정규태강사JDBC JDBC활용 - import쓰는 이유, form페이지로 받은 데이터를 DB에 insert하는 방법 JDBC활용 - JAVA에서 DB 정보 지우기 2가지방법 JDBC활용 - DB에서 고객정보를 불러와서 HTML테이블에 담기 JDBC활용 - TIMESTAMP주의점, JDBC에서 데이터처리 JDBC활용 - 회원정보수정페이지만들기 JDBC활용 - 회원목록출력하는데 관리자는 빼고 출력하기, 자바 에러 두종류 1. 회원목록출력하는데 관리자는 빼고 출력하기이는 두가지 방법이 있다. DB에서 전체 데이터를 불러오고 출력만 관리자빼고하기 DB에서부터 관리자빼고 가져온 뒤 출력하기 어느 방법이 더 좋을까?2번째 방법!WHY?DB에서 데이터를 많이 가져올수록 시간이 오래 걸리므로 2번이 서비스측면에서 효율적이다. 1-1. DB에서 전체 데이터를 불러오고 출력만 관리자빼고하기조건문으로 한줄이면 끝난다! if(rs.getString(&quot;id&quot;).equals(&quot;admin&quot;)) continue; 짜잔! 1234567891011121314151617181920212223242526272829303132333435363738//4. sql구문 &amp; pstmtString sql = \"select * from itwill_member\";PreparedStatement pstmt = con.prepareStatement(sql);ResultSet rs = pstmt.executeQuery();//5. 실행 -&gt;rs저장 -&gt;데이터처리//가져온 최원 정보 모두를 테이블을 사용해서 출력//관리자는 목록에서 빼기%&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;나이&lt;/td&gt; &lt;td&gt;성별&lt;/td&gt; &lt;td&gt;이메일&lt;/td&gt; &lt;td&gt;가입일시&lt;/td&gt; &lt;/tr&gt; &lt;% while(rs.next()){ if(rs.getString(\"id\").equals(\"admin\")) continue; %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=rs.getString(\"id\") %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString(\"pw\") %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString(\"name\") %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getInt(\"age\") %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString(\"gender\") %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString(\"email\") %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString(\"reg_date\") %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% }%&gt;&lt;/table&gt; 1-2. DB에서부터 관리자빼고 가져온 뒤 출력하기위의 코드에서 if구문을 없애고 sql구문만 변경해주면 된다. 1String sql = \"select * from itwill_member where id not in('admin')\"; 2. 자바 에러 두종류(JAVA ERROR) 컴파일에러 = Error 예외발생 = Exception","link":"/2020/07/07/200708jspi/"},{"title":"[ITWILL : JSP]Javabean : 기초","text":"ITWILL학원 : 23강 JSP기초 BY 정규태강사1. 자바빈(JavaBean) (p245~) 디자인부분과 비즈니스로직부분을 분리하기 위해서 자바빈을 사용한다. DTO(Data Transfer Object)로 불리기도 함 2. 자바빈 설계규약 정리하자면 클래스는 public 멤버변수는 private 멤버변수마다 별도의 get/set메소드가 존재해야한다 기본생성자 있어야함 (public) 1234567891011121314151617//1번규칙만족 : 클래스는 publicpublic class Javabean1 { //2번규칙만족 : 멤버변수선언 private private String id; //4번규칙만족 : 기본생성자존재하지만 생략됨 //public Javabean1(){} //3번규칙만족 : 멤버변수마다 별도의 get/set메소드가 존재해야한다. public String getId() { return id; } public void setId(String id) { this.id = id; } } 3. 자바빈사용방법 자바빈 객체를 사용하는 방법 자바빈 액션태그를 사용하는 방법 예시파라미터값으로 가져오는 방법과 위의 자바빈사용방법 두가지 총 3가지를 비교해보자.공통적으로 사용할 페이지는 form.jsp페이지이다 먼저 form페이지이다.사용자가 id와 pw, 좋아하는 숫자를 입력할 수 있는 페이지 코드이다. 123456789&lt;fieldset&gt;&lt;legend&gt;사용자 정보입력&lt;/legend&gt; &lt;form action=\"beanPro2.jsp\" method=\"post\"&gt; 아이디 : &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; 좋아하는 숫자 : &lt;input type=\"text\" name=\"num\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"확인\"&gt; &lt;/form&gt; &lt;/fieldset&gt; 3-1. 자바빈이 아닌 파라미터값을 가져와서 사용하는 방법123456789101112131415161718192021&lt;%request.setCharacterEncoding(\"UTF-8\");String id = request.getParameter(\"id\");String pw = request.getParameter(\"pw\");int num = Integer.parseInt(request.getParameter(\"num\"));%&gt;&lt;%-- 파라미터값으로 출력 =&gt; 아이디 : &lt;%=id %&gt;, 비밀번호 : &lt;%=pw %&gt; 좋아하는 숫자 : &lt;%=num %&gt; --%&gt;&lt;table border=\"1\" style=\"text-align: center\"&gt; &lt;tr&gt; &lt;td&gt;출력방식 &lt;/td&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;좋아하는 숫자&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;파라미터 이용&lt;/td&gt; &lt;td&gt;&lt;%=id %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=pw %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=num %&gt;&lt;/td&gt; &lt;/tr&gt;&lt;table&gt; 3-2. 자바빈 클래스 생성데이터를 한번에 들고 다니기 위해 Javabean.java 객체를 만들어야 자바빈 객체와 자바빈 액션태그를 사용할 수 있다.자바페이지는 자바빈설계규약에 맞게 작성해야한다. 12345678910111213141516171819202122232425262728293031323334353637//1번규칙만족 : 클래스는 publicpublic class Javabean2 { //2번규칙만족 : 멤버변수선언 private private String id; private String pw; int num; //4번규칙만족 : 기본생성자존재하지만 생략됨 //public Javabean2(){} //3번규칙만족 : 멤버변수마다 별도의 get/set메소드가 존재해야한다. public String getId() { return id; } public void setId(String id) { this.id = id; } public String getPw() { return pw; } public void setPw(String pw) { this.pw = pw; } public int getNum() { return num; } public void setNum(int num) { this.num = num; }//전체데이터를 효율적으로 한번에 표시하기위해 toString은 필수다//toString은 자동 단축키로 만들어서 쓰는 거임 : alt+shift+s에서 `Generate toString()`클릭 @Override public String toString() { return \"Javabean2 [id=\" + id + \", pw=\" + pw + \", num=\" + num + \"]\"; }} 3-3. 자바빈 객체 사용자바빈 객체를 사용하여 Form페이지에서 입력받은 값을 화면에 출력하는 코드이다. javabean타입의 객체생성 -&gt; import생성 변수 Jb는 private이므로 get메서드와 set메서드로 접근해야함 1234567891011121314151617//1. javabean타입의 객체생성 -&gt; import생성Javabean2 jb = new Javabean2(); //2. 값 가져오기 : private이므로 get/set메서드로 접근.jb.setId(request.getParameter(\"id\"));jb.setPw(request.getParameter(\"pw\"));jb.setNum(Integer.parseInt(request.getParameter(\"num\")));//3. 값 출력&lt;table border=\"1\" style=\"text-align: center\"&gt; &lt;tr&gt; &lt;td&gt;자바빈 객체 이용&lt;/td&gt; &lt;td&gt;&lt;%=jb.getId() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=jb.getPw() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=jb.getNum() %&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 3-4. 자바빈 액션태그 사용 액션태그방식은 html문법이며 공통으로 사용되는 메뉴들을(주로 페이지) 특정 공간에 추가한다. 해당 페이지가 java파일(서블릿)으로 컴파일 된 후에 include한다. 따라서 컴파일을 두번하게된다. 액션태그방식은 jsp가 java파일이 되고 거기에 include를 하고 class파일이 된다. jsp:useBean태그의 속성중 하나인 scope를 이용하면 더욱 효과적이다. scope 속성에 page, request, session, application값을 설정하면 해당 영역에 지정해서 저장가능하다. scope 속성의 설정값이 없으면 기본 page에 저장된다. 3-4-1. jsp:useBean 태그id =객체참조변수 class=사용할 클래스파일 경로(객체의 경로) 12&lt;jsp:useBean id=객체참조변수 class=사용할 클래스파일 경로(객체의 경로) /&gt;// 객체아래 코드는 Javabean1 jb = new Javabean1(); 3-4-2. jsp:setProperty 태그3가지 속성이 있다. property속성 : 자바빈 객체의 멤버변수(저장공간) name속성 : 자바빈 객체의 레퍼런스( = jsp:useBean의 id값) param속성 : 전달되는 파라미터값 123jsp:setProperty property=변수명 name=객체생성 id와 동일한 값 param=파라미터값//예시&lt;jsp:setProperty property=\"id\" name=\"bean\" param=\"id\"/&gt; 만약 setProperty에서 파라미터 가져올때 파라미터가 2개 이상인 경우는?property값과 param값이 동일하면 param값 생략가능하다. 123456&lt;jsp:useBean id=\"bean\" class=\"com.itwillbs.bean.Javabean1\"/&gt;&lt;jsp:setProperty property=\"*\" name=\"bean\" param=\"*\"/&gt;&lt;! -- 여기서 property값과 param값이 동일하면 아래처럼 param값 생략가능 --&gt;&lt;jsp:setProperty property=\"*\" name=\"bean\"/&gt; 3-4-3. jsp:getProperty 태그123456789&lt;jsp:getProperty property=\"set했던변수와 동일한 변수명\" name=\"객체생성 id와 동일한 값\"/&gt;&lt;br&gt;//예시&lt;jsp:getProperty property=\"id\" name=\"bean\"/&gt;&lt;br&gt;&lt;!-- 스크립틀릿을 통한 출력 --&gt;&lt;%out.println(\"자바빈 액션태그객체를 자바코드로 출력 : \" + bean.getId());%&gt; 3-4-4. 액션태그 전체 예시123456789101112131415161718192021//1. 액션태그만드는 객체&lt;jsp:useBean id=\"bean\" class=\"com.itwillbs.bean.Javabean2\"/&gt;//2. 파라미터값 저장(파라미터 모든 값을 저장하려면 * 아니면 각각 입력)&lt;jsp:setProperty property=\"*\" name=\"bean\"/&gt;//3. 파라미터값 출력 &lt;jsp:getProperty property=\"id\" name=\"bean\"/&gt;&lt;jsp:getProperty property=\"pw\" name=\"bean\"/&gt;&lt;jsp:getProperty property=\"num\" name=\"bean\"/&gt;//4. 데이터 처리 : 테이블사용&lt;table border=\"1\" style=\"text-align: center\"&gt; &lt;tr&gt; &lt;td&gt;자바빈 액션태그 이용&lt;/td&gt; &lt;td&gt;&lt;%=bean.getId() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bean.getPw() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bean.getNum() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bean.toString() %&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","link":"/2020/07/08/200709jspi/"},{"title":"[자바JAVA]클래스 : 패키지, 임포트, 접근제어자, 데이터 은닉과 보호, 싱글턴디자인패턴","text":"toString()Object는 최상위객체이다.이 객체의 메서드중의 하나는 toString()이다.따라서 모든 클래스에서 toString()을 사용할 수 있다. retrun : 객체생성했을때 메모리에 올라가진 주소값을 유니크한 표현방식인 해쉬코드로 리턴. 하지만 리턴값이 객체의 특성을 충분히 반영하지는 못한다.따라서 그대로 사용하는 개발자는 아무도 없고 메서드오버라이딩을 해서 원하는 리턴값으로 변화시킨다.리턴값을 변화시킬때 이클립스에서 개발자가 보기편하게 포맷팅해서 제공하는 단축키가 있다. alt + shift + s 후에 Generate toString()을 클릭해서 ok누르면 리턴값 보기편하게 자동생성됨. toString은 하나하나 직접 타이핑하기 보단 자동 단축키로 만들어서 쓰는 거임. 참고링크 : java 도큐먼트 패키지작성한 많은 클래스를 체계적으로 관리해야한다.이때 자바는 디렉토리(폴더)대신 패키지라는 것을 사용한다. 패키지 : 클래스를 모아 놓은 것 폴더 : 데이터를 모아 놓은 것 패키지 작성규칙패키지명작성시 회사의 도메인주소를 거꾸로 작성 후 뒤에 점(.)을 찍고 회사에서 진행중인 프로젝트명을 이어서 작성한다. 맨 처음에는 회사 등소속늘 나타내고 주로 도메인을 사용하며 거꾸로 사용. 그 다음은 그 소속에서 벌어지고 있는 프로젝트 이름을 작성. 왜 도메인 주소를 쓸까?도메인은 중복이 없는 고유한 값이다.만약 세계 여러사람들과 겹치는 class 이름을 쓰더라도 패키지가 다르면 아예 구분이 되기때문에 패키지명은 꼭 고유한 값인 도메인주소를 사용한다. 1234//회사도메인주소거꾸로.프로젝트명.용도 순으로 작성한다.package com.itwillbs.test;package kr.co.itwillbs.test; 임포트 (Import)다른 패키지에 선언된 클래스를 사용하기 위해 필요한 키워드이다. import 선언위치 : package선언과 class선언 사이에 위치. import 선언방법 import 키워드 뒤에 package명을 포함한 클래스명까지 모두 입력. * 를 사용하면 해당 package의 모든 클래스를 포함. but 하위패키지에 있는 클래스 import하진않는다 12import package_name.[package_name]class_name;import package_name.[package_name]*; 제어자(Modifier)제어자란 클래스, 변수, 메서드의 작성 시 함께 사용하여 부가적인 의미를 주는 키워드이다.제어자의 종류는 크게 두종류이다. 접근제어자 : 총 4가지 public, protected, default, private암기필수, 멤버변수등을 사용할 수 있는 범위를 지정하는 키워드. 동시에 한개만 쓸수있다 그 외의 제어자 : final, static, abstract, synchronized등으로 접근지정자와 달리 public static final 처럼 여러개가 동시에 올 수도 있으며, 변수나 함수 등을 특별한 형태로 동작시키기 위한 용도로 쓰입니다. 접근제어자(Access Modifier)자바에서는 접근지정자 = 접근제어자로 생각하면된다사실 두 단어의 차이점이 존재하는데 자바에서는 크게 중요하지않다. 참고링크 : C++상속의 접근제한자 멤버등에 사용되며 해당 요소를 외부에서 사용할 수 있게 할 것인지를 제어한다. public : 누구나 접근 가능하다 하나의 파일에 하나의 public클래스만 있어야한다. public클래스는 main메서드를 포함하고 있는 클래스이다. protected : 같은 패키지 내에 있거나 상속받은 자손클래스에서만 졉근가능 default(package-private) : 아무런 접근 제어자를 적어주지 않을 때이며, package-private라고도 불린다. 같은 패키지 내에 있을 때만 접근 가능하다. private : 해당 클래스 내에서만 접근 가능하다. 접근제어자 해당클래스안에서 같은패키지에서 상속받은클래스에서 import한 클래스에서 public O O O O protected O O O X default O O X X private O X X X 접근지정자 범위 public &gt; protected &gt; 기본접근지정자(디폴트) &gt; private public이 가장 넓은 범위이다. 매서드오버라이딩시 접근지정자는 슈퍼클래스의 메서드보다 범위가 줄어들어서는 안된다. 커지는 건 가능. 그외의 제어자 : final 제어자 더는 바꿀 수 없음을 의미한다 final사용위치 클래스 왼쪽 : 더 확장이 불가하므로 상속받을 수 없는 클래스다. 슈퍼클래스가 될 수 없다. 메서드 왼쪽 : 재정의 할 수 없다 = 오버라이딩할 수 없다. 변수 오른쪽 : 상수, 상속이 불가한 클래스 데이터 은닉과 보호(Encapsulation)객체지향의 4대 특징(OOP Is A P.I.E)에서 E에 해당하는 특성이다.개인정보의 경우 외부에서 변수에 직접 접근가능해서는 안된다. 따라서 정보에 대한 직접 접근을 막아야한다.따라서 소중한 멤버번수들은 모두 private접근 제어자를 가진다. 그럼 외부에서 private 변수를 사용할 수 없을까? 직접적으로 접근할 수 없고, getter, setter메서드를 통해서 접근할 수 있다. 캡슐화 = getter와 setter내에는 정보 보호를 위한 필요한 로직을 넣어서 부적절한 값의 설정을 방지할 수 있다. Singleton 디자인패턴객체가 여러 개 필요한 경우는 객체마다 가지는 멤버 변수의 값이 다를 경우이다.만약 멤버변수가 없거나 같은 값만 사용되는 경우에는 굳이 여러 객체를 만들어 사용할 필요가 없다. 필요성 계속 연결과 반환을 반복하는 것보다 하나 또는 몇 개를 미리 만들어놓고 재사용하는 것이 리소스사용에 유리 특징 private 접근 제어자 : 싱글턴 디자인 패턴의 출발점은 대상 객체를 외부에서 직접 생성할 수 없어야 하니까. 따라서 이 생성자에 접근할 수 있는 것은 이 클래스 내부만 가능.1private SingletonClass() {} getter 메서드 : private 멤버변수에 접근할 수 있는 setter와 getter가 필요한데 외부에서는 어차피 객체를 만들 수 없기때문에 setter는 필요 없고 getter만으로 충분하다. static : 막상 getter를 쓰려고 보니 메서드에 접근할 수 있는 객체가 없다. 객체 없는 메서드를 사용하기 위해 메서드와 멤버변수에 static 선언이 필요해진다. 사용법 객체가 필요할 때 객체를 생성하는 것이 아니라 메서드를 호출하면 되고 이 메서드의 리턴은 언제나 하나의 객체일 것이다. 1234private static SingletonClass instance = new SingletonClass();public static SingletonClass getInstance(){ return instance;} 참고링크 : 싱글톤 패턴(Singleton pattern)을 쓰는 이유와 문제점","link":"/2020/07/08/200709javai/"},{"title":"[ITWILL : JSP]Javabean 1 : 회원가입페이지만들기","text":"ITWILL학원 : 23강 JSP기초 BY 정규태강사자바빈 프로젝트 1 : 회원가입페이지만들기자바빈 프로젝트 2 : 로그인 및 로그아웃페이지만들기자바빈 프로젝트 3 : 회원정보조회 및 수정페이지만들기 자바빈(JavaBean)을 이용한 회원가입 폼 작성(p261~)1. 자바빈 클래스 생성 : MemberBean.java 클래스 생성 자바빈클래스를 만들때는 자바빈설계규약을 꼭 지켜야한다 toString()을 하는 이유는 MemberBean클래스의 데이터 전체를 가져다 쓰고 싶기 때문이다. 123456789101112131415161718192021222324252627282930313233343536//자바빈 -&gt; 회원정보를 저장해서 이동시키기 위한 객체//DTO(데이터 전송 객체)로도 불린다.//1. 클래스는 publicpublic class MemberBean {//2. DB의 테이블의 컬럼을 자바빈의 private 멤버 변수로 생성private String id;private String pw;private String name;private int age;private String gender;private String email;private Timestamp reg_date; //import필수//4. 디폴트생성자 public MemberBean(){} 생략//3. getter 와 setter생성 : alt+shift+s에서 getter and setter 클릭 -&gt; 자동생성public String getId() { return id;}public void setId(String id) { this.id = id;}(이하 생략)//5. toString생성 : alt+shift+s에서 toString클릭 -&gt; 자동생성@Overridepublic String toString() { return \"멤버 [id=\" + id + \", pw=\" + pw + \", name=\" + name + \", age=\" + age + \", gender=\" + gender + \", email=\" + email + \", reg_date=\" + reg_date + \"]\";}} 2. insertForm.jsp만들기1234567891011121314&lt;fieldset&gt;&lt;legend&gt;회원가입&lt;/legend&gt; &lt;form action=\"insertProM.jsp\" method=\"post\" name=\"fr\"&gt; 아이디 &lt;input type=\"text\" name=\"id\" required&gt;&lt;br&gt; 비밀번호 &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; 이름 &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt; 나이 &lt;input type=\"text\" name=\"age\"&gt;&lt;br&gt; 성별 &lt;input type=\"radio\" name=\"gender\" value=\"여\"&gt; 여성 &lt;input type=\"radio\" name=\"gender\" value=\"남\"&gt; 남성&lt;br&gt; 이메일 &lt;input type=\"text\" name=\"email\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"회원가입하기\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 3. insertProM.jsp 페이지 만들기 파라미터값을 저장할때 가입일자의 경우 사용자의 입력값을 받아오지 않고 시스템의 시간을 넣는다. 따라서 별도로 파라미터값을 설정해줘야한다. 123456789101112131415161718192021222324252627282930&lt;%//1. 한글처리request.setCharacterEncoding(\"UTF-8\");%&gt;&lt;!-- 2. 액션태그 이용 : 전달되는 파라미터 정보저장2-1. 자바빈 객체 생성 --&gt;&lt;jsp:useBean id=\"mb\" class=\"com.itwillbs.member.MemberBean\" /&gt;&lt;!-- 2-2. 파라미터 값 저장 , 가입일자는 별도로 직접 저장--&gt;&lt;jsp:setProperty property=\"*\" name=\"mb\"/&gt;&lt;%System.out.println(mb); mb.setReg_date(new Timestamp(System.currentTimeMillis()));System.out.println(mb);//3. DB로 값 전달해서 회원가입 처리//3-1. MeberDAO객체 생성MemberDAO mdao = new MemberDAO();//3-2. 회원가입메서드호출mdao.insertMember(mb);//4. 성공시 -&gt; login페이지로 이동%&gt;&lt;script type=\"text/javascript\"&gt; alert(\"회원가입성공!\") location.href=\"loginForm.jsp\"&lt;/script&gt; 4. MemberDAO.java 페이지 만들기 DAO (데이터 처리 객체) -&gt; DB처리 모든 것은 이 페이지에서 한다 DB 데이터 생성, 조회, 수정은 여기서 진행 / 다른페이지는 출력만 함 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class MemberDAO { //1. DB변수 생성 : 일부러 멤버변수로 선언함. 메서드에서 멤버변수 호출해서 사용할 예정 Connection con = null; String sql = \"\"; PreparedStatement pstmt = null; ResultSet rs = null; //2. DB연결 메서드 생성: 리턴해도되고 안해도 됨 private Connection getCon(){ //2-1. 드라이브로드 &amp; DB연결 final String DRIVER = \"com.mysql.jdbc.Driver\"; final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\"; final String DBID = \"root\"; final String DBPW = \"1234\"; //2-2. Class.forName(DRIVER);면 에러메세지가 뜨는데 거기서 try catch구문의 해결방법을 누른다 try { Class.forName(DRIVER); System.out.println(\"드라이버 로드 성공!\"); con = DriverManager.getConnection(DBURL, DBID, DBPW); //getConnection() 에러메세지가 뜨는데 거기서 try catch구문의 해결방법을 누른다 System.out.println(\"DB 연결 성공!\" + con); } catch (ClassNotFoundException e) { System.out.println(\"드라이버 로드 실패!\"); e.printStackTrace(); } catch (SQLException e) { System.out.println(\"DB 연결 실패!\"); e.printStackTrace(); } return con; } //4. 자원해제 메서드 구현 public void closeDB(){ try{ if(rs != null) rs.close(); if(pstmt != null) pstmt.close(); if(con != null) con.close(); } catch (SQLException e) { e.printStackTrace(); } } //3. 회원가입처리 (외부에서 접근가능해야하니까 public) public void insertMember(MemberBean mb){ //파라미터로 정보를 받아서 DB에 저장 try { //3-1. DB연결메서드 불러오기 con = getCon(); //3-2. SQL &amp; pstmt 생성 &amp; 실행 sql = \"insert into itwill_member value(?,?,?,?,?,?,?)\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, mb.getId()); pstmt.setString(2, mb.getPw()); pstmt.setString(3, mb.getName()); pstmt.setInt(4, mb.getAge()); pstmt.setString(5, mb.getGender()); pstmt.setString(6, mb.getEmail()); pstmt.setTimestamp(7, mb.getReg_date()); //insertForm에는 reg_date를 입력하는 란이 없기에 mb에 따로 넣어줘야한다. //즉, 파라미터로 전달되지 않는 정보는 insertForm에서 직접생성 pstmt.executeUpdate(); System.out.println(\"회원가입성공\"); } catch (SQLException e) { // TODO Auto-generated catch block System.out.println(\"회원가입실패\"); e.printStackTrace(); } finally { //자원해제로 DB 효율성을 높일수있다. closeDB(); } }}","link":"/2020/07/08/200709jspi2/"},{"title":"[ITWILL : JSP] try catch구문","text":"ITWILL학원 : 23강 JSP기초 BY 정규태강사try catch구문 예외처리라고도 부른다. 개발자가 예측하기 어려운 에러들을 예외라고 한다. 이러한 예외를 java 컴파일러가 객체로 만들어서 처리해준다. 우리는 try catch를 만들기만 하면 컴파일러가 알아서 한다. 실무에서 가장 많이 사용하는 방식은 아래 방식이다ClassNotFoundException과 SQLException은 여러 Exception종류 중에 임의로 작성한 것이고 제외한 나머지 코드들은 통으로 함께 쓰이는 코드이다.생각할 수 있는 구체적인 Exception을 찾아서 작성한 뒤 그 외에 발생할 수있는 예외를 대비해 catch(Exception e)로 추가 예외처리를 해준다. catch(Exception e)로 한번에 다 예외처리가 가능한데 왜 따로따로(ClassNotFoundException와 SQLException등등) 먼저 예외처리를 할까?예외마다 처리방법이 각기 다르다.따라서 각각 예외처리를 해주고 혹시 모를 또다른 예외를 위해 catch(Exception e)구문으로 예외처리를 해주는 것이다. 1234567891011121314151617181920212223try{ 예외가 발생할 수도 있는 코드를 작성 } catch(ClassNotFoundException e){ //class예외만 처리 예외정보를 출력 예외처리}catch(SQLException e) { //SQL예외만처리 예외정보를 출력 예외처리}catch(Exception e) { //모든 예외를 처리할 수 있음. 예외정보를 출력 예외처리}finally{ 예외 발생 유무와 상관없이 반드시 실행되는 코드 //ex)보통 자원해제로 메모리효율성을 높인다. //ex) if(pstmt != null) pstmt.close(); if(con != null) con.close();}","link":"/2020/07/08/200709jspi3/"},{"title":"JOIN","text":"join 조인여러 테이블에 있는 데이터를 합쳐서 출력.join은 FROM절에 작성된다. join은 정말 많이 사용된다. join(조인) 유형 Natural Join Using On : self-join, Nonequijoin Outer join : left, right, full Cartesian Product : cross join Natural Join오라클이 다중 테이블을 뒤져봐서 컬럼명이 같고 데이터타입이 같은 컬럼을 기준으로 join을 하여 데이터를 보여준다. 예시 :test1테이블과 test2테이블을 natural join해서 오라클이 직접 두 테이블을 찾아보고 컬럼명과 데이터타입리 같은 컬럼을 기준으로 모든 컬럼을 출력한다.이때 오라클이 자동으로 찾은 기준 컬럼은 양쪽 테이블에서 컬럼명이 같고 데이터타입이 같다 12$ select * $ from test1 natural join test2; 만약 컬럼명이 같도 데이터타입이 같은 컬럼이 한 개이상이면 어떻게 될까?해당 컬럼들의 조합값으로 기준으로 조인을 시켜준다. Using 여러 컬럼의 이름은 동일하지만 데이터 유형이 다른 경우 using 절을 사용한다. 꼭 괄호를 작성하고 그 괄호안에 컬럼명을 넣어줘야한다 예시 :test1테이블과 test2테이블을 ex이라는 컬럼을 기준으로 join해서 모든 컬럼을 출력한다.test1과 test2테이블의 name컬럼명이 같지만 데이터 유형이 다를때 using사용한다. 123$ select * $ from test1 join test2$ using (ex); 테이블의 엘리아스를 사용하여 컬럼들이 어느 소속인지 엘리아스 접두어를 컬럼앞에 붙여주면 명령문 구문 분석 속도를 향상시킨다. 하지만 using절에서 참조하고 있는 컬럼은 절대 엘리야스 붙이면 안된다. On 가장 기본이 되는 join유형이고 가장 많이 사용한다. 컬럼명이 달르고 데이터타입이 달라도 상관없이 사용가능하다. 예시 :test1테이블과 test2테이블을 ex이라는 컬럼을 기준으로 join해서 모든 컬럼을 출력한다.test1과 test2테이블의 name컬럼명도 다르고 데이터 유형이 달라도 사용할 수 있는 것이 on이다. 123$ select * $ from test1 join test2$ on (test1.ex = test2.example); self-joinself-join : 하나의 테이블을 엘리아스를 달리 주면 한 개의 테이블로 join이 가능하다많이 사용된다. 예를 들면 회사의 매니저들이 어떤 사원들을 관리하고 있는지 출력하고 싶다.이때 회사의 매니저들도 사원이기에 employee_id가 있기에 결국 내 테이블을 2번 참조해야하는 self-join이 된다 123$ select manager.name, worker.name$ from employees worker join employees manager$ on worker.manager_id = manager.employee_id); Natural Join, Useing, On 비교 절종류 컬럼명 데이터타입 엘리아스 Natural Join 일치 일치 join할 테이블의 컬럼명들 중 같은 컬럼명 있다면 필수 useing 일치 상관없음 컬럼의 엘리아스 쓰면안됨 on 상관없음 상관없음 필수 비교 : 아래 세개는 결과값이 똑같다. from departments natural join location from departments d join location l using(location_id) from departments d join location l on d.location_id = l.loc_id) non-equi join과 equi join 비교equi(이퀴)조건과 non-equi(넌 이퀴)조건을 비교해보자 절종류 특징 종류 non-equi join 조인조건에 동등연산자가 사용된 조인 유형 Natural join, Using join, On(=) join equi join 조인조건에 동등연산자가 아닌 그 외 다른 비교연산자가 사용된 조인 유형 On(=이 아닌 비교연산자) join inner join과 outer join 비교 절종류 특징 종류 inner join 조인조건을 만족하는 행만 반환하는 조인 유형 Natural join, Using join, On join outer join 조인조건을 만족하는 행과 조인조건을 만족하지않는 행을 모두 반환하는 조인 유형 left outer join, right outer join, full outer join Cartesian Product (카테시안 곱 = 곱집합) 한 테이블의 모든 행을 다른 테이블의 모든 행과 조인한다. 모든 경우의 수를 나열. 다수의 행을 생성하므로 결과는 그다지 유용하지 않다. cross join 두 테이블의 Cartesian Product 를 생성하는 join작업이다. 123$ select last_name, department_name$ from employees$ cross join departments join 예시employees 테이블로부터 모든 사원의 last_name, employee_id, 매니저이름, manager_id를 함께 출력하는 쿼리를 작성하시오 join에 있어 자주 틀리는 오답도 확인해둬야한다. 12345678910111213141516//첫번째 방법$ select e1.last_name as &quot;Employee&quot;, e1.employee_id as &quot;Emp#&quot;, e2.last_name as &quot;Manager&quot;, e1.manager_id as &quot;Mgr#&quot;$ from employees e1 join employees e2$ on (e1.manager_id = e2.employee_id);//두번째 방법$ select e1.last_name as &quot;Employee&quot;, e1.employee_id as &quot;Emp#&quot;, e2.last_name as &quot;Manager&quot;, e2.employees_id as &quot;Mgr#&quot;$ from employees e1 join employees e2$ on (e1.manager_id = e2.employee_id);//오답$ select e1.last_name as &quot;Employee&quot;, e1.employee_id as &quot;Emp#&quot;, e2.last_name as &quot;Manager&quot;, e2.manager_id as &quot;Mgr#&quot;$ from employees e1 join employees e2$ on (e1.manager_id = e2.employee_id);","link":"/2020/07/09/200710dbi2/"},{"title":"SQL DEVELOPER사용방법","text":"SQL디벨로퍼(SQL Developer) 접속방법DB를 켜고 끄는 중대한 DB관리작업은 SQL Developer에서 할 수 없다. 터미널 lsnrctl start : 리스너를 작동시키는 명령어 sqlplus /nolog : sql+실행시키는 명령어 connect sys/oracle as sysdba : DB에 sys로 접속하는 명령어 startup : DB에 sys로 로그인한 후 DB실행하는 명령어 conn hr/hr : 유저 hr로 로그인 접속탭에서 초록색 + 클릭 아래 부분 중점으로 작성 후 접속 클릭 접속이름 : 원하는 이름 입력 사용자 이름 : 만들었던 유저명 입력 ex)hr 비밀번호 : 만들었던 유저 비번 입력 ex)hr SID : 사용하고 있는 DB명 입력 ex)orcl","link":"/2020/07/09/200710dbi/"},{"title":"meta태그, 내부링크, id와 name속성의 차이","text":"meta 태그 (메타태그) meta태그는 웹사이트의 안내자이다.대부분의 포털사이트는 웹 사이트의 제목, 태그의 내용, 본문의 첫 100여 단어등을 검색한 후 사용자의 검색어와 비교해서 검색 결과를 나열해준다. 위치 : head태그 사이에 입력한다. 구글에서 인식하는 메타태그들 네이버에서 인식하는 메타태그들 자주 사용하는 메타태그들 속성 값 설명 name application-name 웹어플리케이션의 이름을 표시 name author 문서의 저자 표시 name description 문서의 설명 표시 name generator 저작 툴을 표시 name keywords 문서의 키워드 표시 http-equiv content-type 문서의 인코딩 선언 http-equiv default-style 대체 스타일시트를 선언 http-equiv refresh 문서의 새로고침 주기 및 이동선언 content 텍스트 http-equiv나 name속성의 값 표시 charset 문자셋 문서의 문자 셋을 선언 예제아래 예시는 메타태그 refresh를 이용하여 5초뒤에 다른 페이지(test06.html)로 이동하는 태그이다 content = “숫자(단위는 초); url=”이동할페이지주소” 123456789&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; url=test06.html&quot;&gt; &lt;title&gt;메타태그이용 5초뒤 페이지변화&lt;/title&gt;&lt;/head&gt;&lt;body&gt;메타태그 refresh예시&lt;/body&gt; 페이지 최상단으로 옮기는 링크 싱글 페이지에서 이동하는 것을 내부링크라고 칭한다. id속성값을 활용하여 내부링크이동가능 123&lt;a href=\"#\"&gt; //=&gt; 페이지 최상단으로 이동&lt;a href=\"#top\"&gt; //=&gt;id값이 top인 곳으로 이동&lt;a href=\"#id명\"&gt; //=&gt;id값이 id명인 곳으로 이동 nav태그는 메뉴바를 칭함 css와 함께 작업할때는 nav태그 안에는 ul태그와 li태그로 데이터처리 지금은 html만했기때문에 a태그로만 진행 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;h1 id=\"top\"&gt;사진 라이브러리&lt;/h1&gt;&lt;!-- 메뉴바는 nav태그, 지금은 a태그로 처리하지만 만약 css와 함께하면 ul과 li태그로 처리함--&gt;&lt;nav&gt; &lt;a href=\"#dog\"&gt;&lt;img src=\"img/1.jpg\" alt=\"dog\" width=\"50px\" height=\"50px\"&gt;&lt;/a&gt; &lt;a href=\"#cat\"&gt;&lt;img src=\"img/3.jpg\" alt=\"cat\" width=\"50px\" height=\"50px\"&gt;&lt;/a&gt; &lt;a href=\"#otter\"&gt;&lt;img src=\"img/4.jpg\" alt=\"otter\" width=\"50px\" height=\"50px\"&gt;&lt;/a&gt; &lt;a href=\"#babydog\"&gt;&lt;img src=\"https://lh3.googleusercontent.com/proxy/4JnvdaxyuL_oqz_o9-ZCMRbKRmo8JwcfvFbl0xWgoTM-yq2MaRCXsrB8rrgwZJP9rUiYD9Vi4w6QgXDo5kg-cTte510-1eB5V-4iLJcHcaVR4s6ZgIDS-zSBKJ5KXH9dkgc-DaynHLLe1r0utiGlztAVeYibEUIc4YsuYZ0n9yHBMUZTI6V6d3h0qJ9VDWZkD8r54Bs_Xu43yMneNzweq4sxA2AB5UZn1EGaerh_PrtO4I-mwB3Wh7_KRiZnOGIKbnCp5MbnQyOmO4dsdAl-ovNb4LG393U4ijVCEktc687awdhNqsmJBTFVKvC3_ak4PX84-2ZFbIQybWFuEoi7\" alt=\"babydog\" width=\"50px\" height=\"50px\"&gt;&lt;/a&gt; &lt;/nav&gt;클릭하면 사진으로 이동합니다&lt;button type=\"button\"&gt;&lt;a href=\"#down\"&gt;DOWN&lt;/a&gt;&lt;/button&gt; &lt;main&gt; &lt;div&gt; &lt;hr&gt; &lt;h2 id=\"dog\" id=\"top\"&gt;강아지&lt;/h2&gt; &lt;a href=\"#top\" title=\"사진 클릭하면 최상단으로 이동\"&gt;&lt;img src=\"img/1.jpg\" alt=\"dog\" height=\"400px\"&gt;&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;div id=\"cat\"&gt; &lt;hr&gt; &lt;h2 &gt;고양이&lt;/h2&gt; &lt;a href=\"#top\" title=\"사진 클릭하면 최상단으로 이동\"&gt;&lt;img src=\"img/3.jpg\" alt=\"cat\" height=\"400px\"&gt;&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;div id=\"otter\"&gt; &lt;hr&gt; &lt;h3&gt;수달&lt;/h3&gt; &lt;a href=\"#top\" title=\"사진 클릭하면 최상단으로 이동\"&gt;&lt;img src=\"img/4.jpg\" alt=\"otter\" height=\"400px\"&gt;&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;div id=\"babydog\"&gt; &lt;hr&gt; &lt;h3&gt;앞발 영차&lt;/h3&gt; &lt;a href=\"#top\" title=\"사진 클릭하면 최상단으로 이동\"&gt;&lt;img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcQqnXObJInmijzH378WQEfyZiKykrJC5OytLA&amp;usqp=CAU\" height=\"400px\" onmouseover=\"this.src='https://lh3.googleusercontent.com/proxy/utTrPxQ41R1DUb4-1FKuFuY86gmdy0CJ7GMllfStudciKalXjTldOSegJoDOrzOhPpxI7N0GXxaJUGdS5_M-B-yKVJSdfSCJDR5RLPaXC9N_WxCdxtJssEiS0gWKd5u5BuUSTb6N02pXvJpmRkpIu8A0ALQrnaSKuIrlyz06baXhjtms4VnDyLnzACOncR-Aoqs5zZ-UqqZUNgk00k6rBRGO0DfgXlDdFoz1hsjPu6UPqND-jyxlw6De1_yRI-dtnqaHtXwukoLWWuDQfWcCNKZSY2Kpz9scZIUPj4rVbjI8TzodeziBsyr39EDIsRJdfmnMfkeNpVb2x8ttVQ1_'\" onmouseout=\"this.src='https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcQqnXObJInmijzH378WQEfyZiKykrJC5OytLA&amp;usqp=CAU'\" &gt; &lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt;&lt;button type=\"button\" id=\"down\"&gt;&lt;a href=\"#\"&gt;TOP&lt;/a&gt;&lt;/button&gt; nav태그 css로 고정시키기12345678910111213141516171819202122&lt;style type=\"text/css\"&gt; * { box-sizing: border-box; } body{ text-align: center; } header{ position: fixed; top: 0; left: 0; right: 0; background-color: lightcyan; height: 200px; } div{ padding-top: 195px; } a{ text-decoration: none; }&lt;/style&gt; id속성과 name속성의 차이 속성 설명 주사용처 id 하나의 요소에만 적용가능.페이지에서 유일한 고유값 form태그 데이터처리할때 사용 class 여러요소에 적용가능 CSS에서 식별자로 사용 name 여러요소에 적용가능 CSS에서 식별자로 사용 name속성 FORM 태그를 사용하여 서버에 페이지에 작성된 데이터전송하고 그 서버측에서 전달받은 데이터처리한다면 NAME속성값 필수 전송된 form의 데이터처리가 필요없다면 name속성값 필요없음 CSS사용불가 중복가능 ex) radio버튼은 name이 같아야 하나의 카테고리로 묶여짐. id속성 페이지에서 딱 하나만 가질 수 있는 고유한 값. 페이지에서 유일 CSS에서 식별자로 사용","link":"/2020/07/09/200710webi/"},{"title":"iframe태그","text":"iframe태그브라우저 영역에 다른 문서를 보여주는 태그이다.화면을 독립적으로 사용하길 원할때 사용한다. iframe형태 iframe영역에 보여질 내용을 src 속성으로, 크기는 width와 height 속성으로 지정하고 name 속성으로 iframe을 구별하여 링크의 target 속성값으로 활용할 수 있다. iframe 태그 사이에 위치한 글자는 iframe을 지원하지 않는 브라우저에 보여지는 문구이다. alt속성과 동일한 역할을 한다. 12345678910111. 기본형태&lt;pre&gt; &lt;iframe src=\"\" width=\"\" height=\"\" name=\"\"&gt; (iframe을 지원하지 않는 브라우저 사용자를 위한 구문) &lt;/iframe&gt;&lt;/pre&gt;2. 예시&lt;iframe&gt; 최신 브라우저를 설치해주세요.&lt;/iframe&gt; iframe속성 name : 프레임의 이름을 설정. width : 프레임의 너비를 설정. height :프레임의 높이를 설정. frameborder : 0으로 설정하면 프레임의 테두리선을 보이지 않음, 1을 설정하면 프레임의 테두리선을 나타남. scrolling : 스크롤바의 표시 여부를 나타냄. (yes, no, auto) 사용처 웹페이지 이미지 동영상 텍스트파일 외부사이트 주소 게시판형식 : iframe태그에 name속성의 값을 주고 링크를 걸 때 a태그에 그 값을 target의 값으로 지정하면 해당 iframe안에 링크를 열어줄 수 있다. 즉 name과 target의 이름이 동일해야한다. 게시판으로 활용을 많이 한다. target속성 blank : 내용을 새 창에 나타냄. self : 내용을 현재 프레임 영역(포커스가 있는 프레임)에 나타냄. (기본값) parent : 내용을 부모 프레임 영역에 나타냄. top : 내용을 무조건 전체 영역에 나타냄. 프레임명 : 해당 이름을 가진 프레임 영역에 나타냄. 123456789101112131415161718192021222324252627282930&lt;h3&gt;1. 웹페이지 (.htm/.html)&lt;/h3&gt;&lt;iframe src=\"test08-1.html\" width=\"800px\" height=\"400px\"&gt;&lt;/iframe&gt;&lt;h3&gt;2. 이미지 (.jpg/.gif/.png)&lt;/h3&gt;&lt;iframe src=\"img/2.jpg\" width=\"550px\" height=\"650px\"&gt;&lt;/iframe&gt;&lt;h3&gt;3. 동영상 (.mp4/.webm/.ogg)&lt;/h3&gt;&lt;iframe src=\"night.mp4\" width=\"600px\" height=\"500px\"&gt;&lt;/iframe&gt;&lt;h3&gt;4. 텍스트파일 (.txt)&lt;/h3&gt;&lt;iframe src=\"폼테스트용텍스트.txt\"&gt;&lt;/iframe&gt;&lt;h3&gt;5. 외부사이트 주소 (URL)&lt;/h3&gt;&lt;iframe src=\"https://itwillbs.co.kr/\" width=\"1000px\" height=\"600px\"&gt;&lt;/iframe&gt;&lt;h3&gt;6. 게시판형식&lt;/h3&gt;&lt;iframe src=\"test02.htm\" width=\"1000px\" height=\"600px\" name=\"html-box\"&gt;&lt;/iframe&gt; &lt;nav&gt; &lt;a href=\"test03.htm\" target=\"html-box\"&gt;test03.htm&lt;/a&gt; &lt;a href=\"test04.htm\" target=\"html-box\"&gt;test04.htm&lt;/a&gt; &lt;a href=\"test05.html\" target=\"html-box\"&gt;test05.htm&lt;/a&gt; &lt;a href=\"test06.html\" target=\"html-box\"&gt;test06.htm&lt;/a&gt; &lt;a href=\"test07.html\" target=\"html-box\"&gt;test07.htm&lt;/a&gt; &lt;a href=\"test08.html\" target=\"html-box\"&gt;test08.htm&lt;/a&gt; &lt;a href=\"test08-1.html\" target=\"html-box\"&gt;test08-1.htm&lt;/a&gt; &lt;/nav&gt; a태그와 iframe태그의 차이점 a태그 : 모든 페이지 내용이 링크로 이동된다. iframe태그 : 다른 요소들은 건들지 않고 해당 frame안에서만 링크이동할 수 있다. 주의사항HTML5 이전에도 이후에도 iframe을 사용하지 않는 것을 권고한다. 반응형 웹 사이트가 대세인 오늘날의 트렌드와 상극이다. 페이지의 파편화 문제가 생긴다 : 검색 엔진 등록 시 frameset 뿐만 아니라 메뉴용 페이지, 콘텐츠용 페이지 까지 함께 크롤링 할 수 있다. 웹접근성 저해의 요인이 될 수 있음으로 남용에 주의해야한다. 프레임 구조가 가지고 있던 장점을 CSS와 jQuery로 해결 할 수 있다. 참고링크 : 쪼랩의 저장소","link":"/2020/07/12/200713webi/"},{"title":"Subquery1: Subquery개념, 중첩Subquery","text":"Subquery 하나의 SQL 문 안에 포함되어 있는 또 다른 SQL문 형태 Oracle이 sub쿼리를 먼저 실행한 뒤 main쿼리를 실행한다. 출력값은 main쿼리값만 출력된다. sub쿼리값은 출력되지않는다. main쿼리안에 sub쿼리는 여러번 작성가능하며 sub쿼리에 sub쿼리를 넣는 듯 중첩도 가능하다 이론상으로 256개가능ㅋㅋㅋㅋ&lt;쌤은 이걸 어떻게 외우시는거지..?! group by절 제외한 select, from, where, having등 모든 절에 sub쿼리 사용가능 sub쿼리가 제일 많이 사용되는 절은 where절과 having절이다 Subquery 사용시 주의점 반드시 괄호()안에 존재하여야 한다. 참고링크 : 서브쿼리(Subquery) 총 정리 위치에 따라 다르게 불리는 서브쿼리 WHERE 중첩 서브쿼리 FROM 인라인 뷰 SELECT 스칼라 서브쿼리 중첩Subquery 종류 single-row subquery 단일행 서브쿼리 : 서브쿼리로부터 메인쿼리로부터 값이 하나만 반환되는 경우 단일행 연산자 : =, &lt;, &gt;, &lt;&gt;, &lt;=, &gt;= 등 multiple-row subquery 다중행 서브쿼리 : 서브쿼리로부터 메인쿼리로부터 값 리스트(값이 여러개)가 반환되는 경우 다중행 연산자 : in, any, all 등 중첩서브쿼리종류 설명 단일행 서브쿼리 단일행 비교연산자사용 다중행 서브쿼리 다중행 비교연산자사용 단일컬럼 서브쿼리 비쌍비교 다중컬럼 서브쿼리 쌍비교 single-row subquery 단일행 서브쿼리 한 행만 반환함. 단일행 비교연산자를 사용해야함. 예시: 사내에서 최소한의 연봉을 받는 사람과 최대의 연봉을 받는 사람을 구하는 쿼리. 1234$ select last_name, job_id, salary$ from employees$ where salary = (select min(salary) from employees) $ or salary = (select max(salary) from employees); multiple-row subquery 다중행 서브쿼리 두개 이상의 행을 반환함. 다중행 비교연산자를 사용해야함. 연산자 의미 성격이 비슷한 단일행연산자 동일한 다중행비교연산자 in 목록의 어떤 값과 일치한다 =, OR I=ANY any 메인쿼리값과 서브쿼리의 리턴된 각각의 값을 비교하여 하나이상 만족하면 참. 사용시 단일행연산자가 앞에 있어야함 OR all 메인쿼리값과 서브쿼리의 리턴된 모든 값을 비교하여 모든값이 만족하면 참. 사용시 단일행연산자가 앞에 있어야함 AND &lt;&gt;ALL = NOT IN 예시 : job_id가 IT인 사원들의 연봉보다 작은 연봉을 받는 사원이름과 연봉을 출력하는 쿼리 즉 &lt; any는 서브쿼리 결과값들 중 최대값 보다 작거나 같으면 그 결과를 리턴. 12345select last_name, salaryfrom employeeswhere salary &lt; any(select salary from employees where job_id = 'IT')and job_id &lt;&gt; 'IT'; 참고링크 : 오라클 ANY, SOME, ALL 연산자 사용법 완벽 정리 subquery의 null값 subquery에서 반환되는 값 중 하나라도 null이면 subquery가 행을 반환하지 않는다. 따라서 항상 null값을 빼는 조건절을 쿼리에 넣어서 결과값을 반환해야한다 null값 해결법 =&gt; nvl()함수사용 또는 not null 연산자 사용 테이블 규모가 클때(500행이상)는 함수(nvl)보다 연산자(not null)이 성능이 더 좋다 테이블 규모가 작을때는 성능이 차이나지않는다. 12345//첫번째 방법 : not nullwhere 컬럼 is not null;//두번째 방법 : nvl()where nvl(컬럼, 0);","link":"/2020/07/13/200714dbi/"},{"title":"[ITWILL : JSP]Javabean 2 : 로그인,로그아웃페이지만들기","text":"ITWILL학원 : 24강 JSP기초 BY 정규태강사자바빈 프로젝트 1 : 회원가입페이지만들기자바빈 프로젝트 2 : 로그인 및 로그아웃페이지만들기자바빈 프로젝트 3 : 회원정보조회 및 수정페이지만들기 1. 로그인폼페이지 작성123456789&lt;fieldset&gt;&lt;legend&gt;로그인&lt;/legend&gt; &lt;form action=\"loginPro.jsp\" method=\"post\" name=\"fr\"&gt; 아이디 &lt;input type=\"text\" name=\"id\" required &gt;&lt;br&gt; 비밀번호 &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"로그인하기\"&gt; &lt;input type=\"button\" value=\"회원가입하기\" onclick=\"location.href='insertForm.jsp'\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 2. 로그인프로페이지 작성파라미터를 저장할 때 세가지 방법이 있다. 파라미터 사용 : getParameter() 자바빈객체사용 : Javabean jb = new Javabean(), jb.set변수() 액션태그 사용 : useBean(), setProperty() 자세히 : 자바빈기초 getParameter() : 주소줄과 폼태그에 작성한 INPUT은 getParameter로 가져온다. getAttribute() : 세션, 페이지에서 저장한 값들은 getAttribute로 가져온다. 이 중 로그인 페이지에선 파라미터를 사용할 예정이다. 로그인페이지 작성 순서 한글처리 &amp; 파라미터저장 1-1. 파라미터저장 -&gt; 파라미터사용 1-2. 파라미터저장 -&gt; 액션태그사용 로그인처리 -&gt; DAO에서 처리 why? DB와 관련된 모든 사항은 DAO에서 처리하니까. 로그인 메서드는 DB에서 해당 값이 있는지 체크하고 결과를 리턴 리턴값은 정수형 데이터값 사용(1-로그인처리, 0-비번오류, (-1)-아이디없음) 결과(result가 -1,0,1)에 따른 페이지 이동처리 result = 1 : 아이디정보를 세션값으로 저장(키값, 저장할 데이터이름), main.jsp로 이동 result = 0 : 비번불일치 알림창, history.back() result = -1 : 없는아이디 알림창, history.back() 12345678910111213141516171819202122232425262728293031323334353637&lt;%//1. 한글처리request.setCharacterEncoding(\"UTF-8\");//1-1. 파라미터사용 : 전달된 파라미터값 저장(아이디,비번)String id = request.getParameter(\"id\");String pw = request.getParameter(\"pw\");%&gt;&lt;!--1-2.액션태그사용 : 전달된 파라미터값 저장(아이디,비번) `useBean`객체생성(id값 아무거나 작성해도 됨) -&gt; `setProperty`로 파라미터저장&lt;jsp:useBean id=\"mb\" class=\"com.itwillbs.member.MemberBean\" /&gt;&lt;jsp:setProperty property=\"*\" name=\"mb\"/&gt;--&gt;&lt;% //2. 로그인처리 -&gt; DAO에서 처리 따라서 객체만 생성MemberDAO mdao = new MemberDAO();mdao.idCheack(id, pw);//3. 결과(result가 -1,0,1)에 따른 페이지 이동처리if(result == 1){ //3-1. 아이디정보를 세션값으로 저장(키값, 저장할 데이터이름) session.setAttribute(\"id\", id); //object자리에 string을 담았기에 업캐스팅발생 response.sendRedirect(\"main.jsp\");}else if(result == 0){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"비밀번호가 일치하지 않습니다\"); history.back(); &lt;/script&gt; &lt;%}else{ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"없는 아이디입니다\"); history.back(); &lt;/script&gt; &lt;%}%&gt; 3. DAO페이지 작성기존에 만들었던 MemberDAO를 그대로 가져온 뒤 idCheck()메서드만 생성하면 된다. 기존 MemberDAO 태그 순서 드라이브로드 디비연결 SQL &amp; pstmt 생성 실행 -&gt; rs저장 데이터 처리 왜 while이 아닌 if인가? where절에서 id는 pk조건을 가지고 있으므로 중복이 없기때문. 세션정보를 만들 수 있을까? session.setAttribute(); 만들 수 없다. why? session은 jsp내장객체이다. java에서 사용할 수 없지만 추후 서블릿을 통해 사용할 수 있다. 그래서 지금은 main.jsp페이지에서 세션만들거임. 자원해제 12345678910111213141516171819202122232425262728293031323334public int idCheack(String id, String pw){ int result = -1; try { //4-1. 드라이브로드 디비연결 con = getCon(); //4-2. SQL &amp; pstmt 생성 sql = \"select pw from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); //4-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //4-4. 데이터 처리 //왜 while이 아닌 if인가? where절에서 id는 pk조건을 가지고 있으므로 중복이 없기때문 if(rs.next()){ if(pw.equals(rs.getString(\"pw\"))){ result = 1; System.out.println(\"아이디,비번일치 = 로그인성공(1)\"); //4-5. 세션정보를 만들 수 있을까? 만들 수 없다. }else{ result = 0; System.out.println(\"아이디있지만 비번다름 (0)\"); } }else{ result = -1; System.out.println(\"아이디,비번없음 (-1)\"); } } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { //4-6. 자원해제 closeDB(); } return result;}//idCheck닫힘 4. main 페이지작성 후 로그아웃 페이지 연결하기.순서 메인페이지, 한글처리 파라미터 저장 세션생성 메인페이지에 로그아웃버튼을 만들고 로그아웃페이지에 연결한다. 12345678910111213141516&lt;%//1.한글처리, 파라미터 (세션생성)request.setCharacterEncoding(&quot;UTF-8&quot;);String id = (String) session.getAttribute(&quot;id&quot;);//object를 string으로 다운캐스팅//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동if(id == null){ response.sendRedirect(&quot;loginForm.jsp&quot;);}%&gt;&lt;h2&gt;&lt;%=id %&gt;님 환영합니다.&lt;/h2&gt;//2. 버튼생성&lt;input type=&quot;button&quot; value=&quot;회원정보조회&quot; onclick=&quot;location.href='memberinfo.jsp'&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;회원정보수정&quot; onclick=&quot;location.href='updateForm.jsp'&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;로그아웃&quot; onclick=&quot;location.href='logout.jsp'&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;회원탈퇴&quot; onclick=&quot;location.href='deleteForm.jsp'&quot;&gt; 4-1. 로그아웃페이지작성메인페이지 연결한 로그아웃페이지를 만든다. 12345678&lt;%session.invalidate();System.out.println(\"로그아웃성공\");%&gt;&lt;script type=\"text/javascript\"&gt; alert(\"정상적으로 로그아웃 되었습니다\"); location.href=\"loginForm.jsp\";&lt;/script&gt;","link":"/2020/07/13/200714jspi/"},{"title":"데이터조작어DML : insert&#x2F;update&#x2F;delete구문","text":"[]대괄호로 묶여져 있는 부분은 생략가능하다는 의미. 데이터조작어DML과 트랜잭션(Transaction)데이터조작어DML 테이블에 새로운 행 추가 = insert 테이블의 기존 행 수정 = update 테이블의 기존 행 삭제 = delete 트랜잭션(Transaction) 아주 중요한 개념 논리적인 작업 단위 여러 DML(insert, update, delete)이 모여서 하나의 트랜잭션이 구성됨 DML 작업 후 commit, rollback으로 트랜잭션 종료해야함 insert구문 컬럼명은 생략가능한다면 값은 기본컬럼순서대로 작성해야한다. 문자리터럴은 작은따옴표안에 작성 sub쿼리가 있다면 괄호()를 생략해야한다. 있으면 안됨. 1$ insert into 테이블명 [(컬럼명, 컬럼명, ...)] values (값, 값, ...) insert가 끝난 상태는 저장된 상태가 아닌 임시데이터상태이다. 따라서 트랜잭션을 통해 저장(commit)하든지 취소(rollback)하는 명령어를 입력해야지 변경된 데이터가 저장된다. commit한 뒤에는 rollback할수없다. 따라서 commit은 신중히! update구문 update구문에서도 Subquery사용이 가능하다. 12$ update 테이블명 set 컬럼명 = 값 [, 컬럼명 = 값, ...]$ [where 조건]; delete구문 행전체를 삭제. 레코드값 하나(한 칸)를 삭제하고 싶다면 그건 update구문을 이용해야한다. delete가 아니다! where절없는 경우, 테이블 전체가 삭제되는 거 아님. 테이블형태는 남고 안의 데이터가 다 삭제됨. 만약 행 몇개 삭제할려고했는데 where절을 깜박해서 전체 데이터를 날렸다면? rollback하면 해결되지만 만약 commit을 해버렸다면? Oracle Flashback기술을 이용해서 아주 가까운 과거 특정시점으로 DB를 되돌릴수있다.EX) 3분,10분 모든 순간을 다 Flashback할 수는 없고 특정 조건들이 맞아야지만 가능하다. 그러니 commit은 항상 신중히! 각 DBMS마다 Flashback기술이 있을 수도 있고 없을 수도 있다. 12$ delete [from] 테이블명$ [where 조건];","link":"/2020/07/13/200714dbi2/"},{"title":"[ITWILL : JAVA]기본클래스 이외에 자바 구성요소1 : 추상클래스, 인터페이스","text":"ITWILL학원 : 17강 JAVA BY 윤미영강사1. 추상클래스(Abstract Class) 슈퍼클래스에서 메서드의 선언부까지는 작성가능하지만 구현부는 어떻게 될지 확정되지 않아 작성하기 어려울때 사용 서브클래스들에서 어차피 재정의해서 사용하기 때문에 슈퍼클래스에서 아직 작성할 수 없는 메서드에 대해 선언부에 abstract를 추가 작성하고 구현부를 세미콜론(;)으로 대체한다. 이를 abstract method design pattern 프로그래밍기법이라고 한다. 123456abstract class A { //멤버변수, 메서드, 생상자 public abstract void 메서드이름();}//abstract()메서드는 중괄호없이 세미콜론만. 추상클래스도 클래스이기에 클래스 구성요소(멤버변수, 메서드, 생성자)를 다 갖춰야하고 그 중 특이하게 abstract메서드를 가지는 클래스를 말한다. 참조변수로 사용가능 객체생성 불가능 : 구현부가 없어서 호출될 수 없기때문에 즉 abstract메서드때문에 미완성 미완성을 어떻게 완성시킬까? 상속하여 재정의! 상속관계의 @override해줘야한다. 반드시 재정의해줘야한다. 재정의를 통해 서브클래스를 객체생성해서 사용할 수 있다. 123456class B extends A { @Override public void 메서드이름(){ //구현부작성 }} 장점 : 재사용성 향상 참고링크 : 추상 클래스 및 추상 메서드(abstract class and abstract method) 2. 인터페이스 두 시스템 간에 만나는 접점이라는 의미. 모든 메서드가 abstract메서드인 클래스를 인터페이스라고 한다. 자주 사용하는 인터페이스 : GUI(Graphic User Interface). 인터페이스이름의 첫글자는 대문자. 인터페이스는 클래스가 아니라서 클래스와 구성요소의 차이가 있다. 객체생성 불가능 : abstract메서드가 있어서, 즉 메서드가 미완성 미완성을 어떻게 완성시킬까? 재구현! 클래스의 재구현을 통해서 객체생성할 수 있다. 2-1. 인터페이스와 클래스 차이점 인터페이스와 클래스는 정의법과 구성요소의 차이가 있다. 인터페이스 정의시에 왜 예약어가 생략가능할까? 컴파일러입장에서는 final과 abstract가 너무나 당연하기때문에 123456789101112//클래스 정의법class A{ 멤버변수 메서드 생성자}//인터페이스 정의법interface Interf { 상수(final 생략가능) abstract()메서드(abstract 예약어 생략가능)} 인터페이스와 클래스 차이 인터페이스 : 다중구현 가능 (헷갈릴까봐 다중상속이라고하지않고 다중구현이라고부른다) 클래스 : 다중상속 불가능 인터페이스는 객체 생성이 가능할까?NOPE! 클래스로 구현한 뒤 클래스를 객체생성할 수있다(업캐스팅) 2-2. 구현(implements) 클래스의 구현을 통해서 인터페이스를 사용할 수 있다. 키워드는 implements 사용! abstract 예약어 생략가능. 따라서 abstract 예약어 안써도 다 생략되어있다고 생각하면됨 왜냐면, 인터페이스안에는 일반변수와 일반메서드 사용할 수 없기 때문에 인터페이스의 모든 abstract method를 재구현하기 위해서 단축키 alt + shift + s를 통해 Override/implements method를 클릭한 뒤 abstract method를 tick해서 재구현해준다. 12345678//구현 키워드는 implementsclass interA implements Interf{ //멤버변수, 메서드, 생성자 //인터페이스가 가지고있는 모든 abstract method를 재구현해야함. @Override void method(){}} 2-3. 인터페이스의 필요성만들어놓은 라이브러리를 사용하기 위해 인터페이스를 시용한다. 구현의 강제로 표준화 인터페이스를 통해 간접적인 클래스 사용으로 손쉬운 모듈교체지원 서로 상속의 관계가 없는 클래스들에게 인터페이스를 통한 관계 부여로 다형성 확장 모듈 간 독립적 프로그래밍으로 개발 시간 단축 stub : 아직 개발되지 않은 코드를 임시로 대치하는 역할. 2-4. 인터페이스에 추가할 수 있는 다양한 메서드 JDK 1.8버전에서부터 default메서드와 static메서드가 추가되었다. default()메서드 : 구현부가 포함된 일반 메서드 interface클래스 구현한 뒤 디폴트메서드는 오버라이딩필요없이 사용가능. 중요 : 접근제어자는 public만 사용가능 문제점 : 인터페이스 다중구현할때 디폴트메서드가 이름이 똑같은 경우 우선순위를 어떻게 두는가? =&gt; 아래 규칙으로 충돌을 회피한다. 조상클래스의 메서드가 가장 높은 우선순위. 조상클래스의 메서드와 인터페이스의 디폴트메서드가 충돌하면 디폴트메서드는 무시된다. 하나의 인터페이스에서 디폴트메서드를 제공되고 다른 이터페이스에 충돌하는 메서드가 있는 경우(디폴트메서드가 아니더라도) 서브클래스는 반드시 조상의 메서드를 재정의해야한다.","link":"/2020/07/14/200715javai/"},{"title":"[ITWILL : JSP]Javabean 4 : web.xml, 회원정보삭제페이지","text":"ITWILL학원 : 25강 JSP기초 BY 정규태강사1. web.xml 배포서술자 : 프로젝트 실행시 가장 먼저 실행되는 파일. 프로그램에 필요한 전반적인 설정을 지정함. 에러코드별 데이터 처리필요 : 프로그램배포시 꼭 필요한 페이지. 위치 : WEBCONTENT하위의 WEB-INF폴더안에 위치함. 1-1. 404에러 예시 만약 404에러가 뜨면 location 아래로 이동해서 처리하겠다는 의미 webcontent하위에 error폴더 생성 후 그 안에 404code.jsp생성 web.xml파일에 </web-app>태그 위에 아래 코드를 입력한다. 123456&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt; /error/404code.jsp &lt;/location&gt;&lt;/error-page&gt; ‘error’폴더를 따로 생성한 뒤 404code.jsp를 만든다. 1234&lt;h1&gt;404code&lt;/h1&gt;&lt;h2&gt;페이지를 찾을 수 없습니다.&lt;/h2&gt;&lt;h2&gt;관리자에게 문의하세요.&lt;/h2&gt;&lt;input type=\"button\" value=\"로그인페이지로 이동\" onclick=\"location.href='loginForm.jsp'\"&gt; 1-2. 500에러 예시 만약 500에러가 뜨면 location 아래로 이동해서 처리하겠다는 의미 webcontent하위에 error폴더 생성 후 그 안에 500code.jsp생성 위와 동일한 방법에 코드만 404에서 500으로 변경해주면 된다 123456&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt; /error/500code.jsp &lt;/location&gt;&lt;/error-page&gt; 1234&lt;h1&gt;500code&lt;/h1&gt;&lt;h2&gt;페이지를 찾을 수 없습니다.&lt;/h2&gt;&lt;h2&gt;관리자에게 문의하세요.&lt;/h2&gt;&lt;input type=\"button\" value=\"로그인페이지로 이동\" onclick=\"location.href='loginForm.jsp'\"&gt; 2. 회원정보삭제페이지2-1. 메인페이지 main.jsp에서 회원정보삭제버튼 추가메인페이지에 회원정보삭제 버튼을 만든다 123456789101112131415&lt;%//1.한글처리, 파라미터 (세션생성)request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅String name = request.getParameter(\"name\");//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동if(id == null){ response.sendRedirect(\"loginForm.jsp\");}%&gt;&lt;h2&gt;&lt;%=id %&gt;님 환영합니다.&lt;/h2&gt;&lt;input type=\"button\" value=\"회원정보조회\" onclick=\"location.href='memberinfo.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" onclick=\"location.href='updateForm.jsp'\"&gt;&lt;input type=\"button\" value=\"로그아웃\" onclick=\"location.href='logout.jsp'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" onclick=\"location.href='deleteForm.jsp'\"&gt; 2-2. 회원정보삭제폼페이지 deleteForm.jsp 생성사용자로부터 비밀번호 받는 폼페이지 생성 123456789101112131415161718&lt;%//1. 로그인 처리 -&gt; 로그인 x (로그인페이지 이동)String id = (String) session.getAttribute(\"id\");if( id == null ){ response.sendRedirect(\"loginForm.jsp\");}//2.회원 비밀번호만 입력받아서 deletePro.jsp페이지 이동후 삭제%&gt; &lt;fieldset&gt; &lt;legend&gt;회원탈퇴&lt;/legend&gt; &lt;form action=\"deletePro.jsp\" method=\"post\"&gt; &lt;!-- input타입중 hidden은 화면에 있는 해당 input태그를 숨겨서 정보 전달 --&gt; 아이디 : &lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=id %&gt;\" readonly&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"탈퇴하기\"&gt; &lt;input type=\"button\" value=\"뒤로가기\" onclick=\"location.href='main.jsp'\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 2-3. 회원정보삭페이지 deletePro.jsp 생성순서 한글처리 &amp; 로그인여부체크 -&gt;로그인페이지이동 삭제할 비밀번호 가져오기 : 파라미터이용 MeberDAO객체 생성 -&gt; deleteMember()메서드 호출 데이터처리 : 1-삭제완료, 0-비번오류, -1-아이디없음 삭제 후 session 초기화 까먹으면 안된다! 세션 꼭 없앨 것! 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%//1.한글처리 &amp; 로그인확인 request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");if(id == null){ response.sendRedirect(\"loginForm.jsp\");}//2. 삭제할 비밀번호 가져오기String pw = request.getParameter(\"pw\");%&gt;&lt;%//3.DAO객체생성 -&gt; 결과를 리턴(1=정상처리 2=비번오류 -1=아이디가없음)MemberDAO mdao = new MemberDAO();int result = mdao.deleteMember(id, pw); //2-4에서 만든 메서드 호출//4.데이터처리 -&gt; 삭제후 login페이지로 이동if(result == 1){ session.invalidate(); //초기화 필수! 까먹지마! %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"회원정보삭제 성공\"); location.href=\"loginForm.jsp\"; &lt;/script&gt; &lt;%}else if(result == 0){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"비밀번호오류로 회원정보삭제실패\"); history.back(); &lt;/script&gt; &lt;%}else{ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"존재하지않는 아이디입니다.\"); history.back(); &lt;/script&gt; &lt;%}%&gt; 2-4. DAO에서 deleteMember()메서드만들기순서 DB연결메서드 불러오기 SQL &amp; pstmt 생성 : 사용자가 입력한 비밀번호가 DB비번과 일치하는 지 확인 실행 -&gt; rs저장 데이터처리 : DB에 있는 비번일치하면 정보삭제 작업, 아닌 경우 에러 4-1. DB에 있는 회원 -&gt; 비번체크 : 비번일치(-&gt;수정) 비번불일치(-&gt;에러) 비번일치하는 경우 : SQL 구문작성 &amp; pstmt 생성 -&gt; 실행 4-2. DB에 없는 회원 -&gt; 에러 자원해제 1234567891011121314151617181920212223242526272829303132333435363738394041public int deleteMember(String id, String pw){ int result = -1; try { //7-1. DB연결메서드 불러오기 con = getCon(); //7-2. SQL &amp; pstmt 생성 sql = \"select pw from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); //7-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //7-4. 데이터처리 : DB에 있는 회원인 경우 삭제, 아닌 경우 에러 if(rs.next()){ if(pw.equals(rs.getString(\"pw\"))){ //7-4-1. SQL 구문작성 &amp; pstmt 생성 sql = \"delete from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); pstmt.executeUpdate(); result = 1; System.out.println(\"회원삭제성공-아디일치,비번일치\"); }else{ result = 0; System.out.println(\"회원삭제실패-아디일치,비번불일치\"); } }else{ result = -1; System.out.println(\"회원삭제실패-아이디불일치\"); } } catch (SQLException e) { e.printStackTrace(); //7-5. 자원해제 } finally { closeDB(); } return result; }//delete닫힘","link":"/2020/07/14/200715jspi/"},{"title":"[ITWILL : JSP]커넥션풀(Connection Pool)","text":"ITWILL학원 : 25강 JSP기초 BY 정규태강사1. JNDI(Java Naming and Directory Interface)(p444~) 필요한 데이터를 키-값 쌍으로 저장해서 필요시마다 키를 사용하여 값을 가져오는 방법 예시 : 내장객체.setAttribute(“키”, 값); 내장객체.getAttribute(“키”); 컬렉션의 해시맵/해시테이블 (“키”, 값); DNS서버(도메인서버) : 도메인네임에 해당하는 ID정보를 저장해서 사용 사용법 컨테이너(예:톰캣)를 사용하여 Connection Pool생성하여 그 안에 이름에 해당하는 정보를 저장(=키), 해당하는 DB정보를 저장(=값)해서 사용. 그렇다면 커넥션풀이 뭘까? 2. 커넥션풀(Connection Pool) DB연결을 하기위한 객체 효율적인 데이터 처리 가능 도입된 배경 : 빈번한 디비연결/호출로 인해서 메모리낭비(누수)발생을 줄이고자 도입되었다. 사용법 : 미리 연결정보(Connection)를 생성 필요할때마다 빌려주고 다 쓰면 반납하는 방식 작동방식 : 사용자 요청(Service)에 따른 Connection Pool에 쓸 쑤 있는 connection체크 후 connection 1개씩 할당 -&gt; 있으면 바로 사용, 없으면 대기(반납되기를 기다리기)거나 임시객체를 생성 커넥션(연결정보)개수를 제한(커넥션풀이 알아서 효율적으로 관리함) 커넥션 객체를 다 쓰게되면 자원회수 2-1. 라이브러리 다운로드커넥션풀을 사용하기 위해선 라이브러리를 다운받아야 한다. 라이브러리 다운로드 주소 : Apache Commons zip파일 다운로드 3가지 collections dbcp pool 위의 세가지를 차례대로 다운받으면 된다.먼저 collections zip파일다운로드 그다음 dbcp zip파일다운로드 마지막 pool zip파일다운로드 압축 푼 뒤 D:\\workspace_jsp7\\JSP7\\WebContent\\WEB-INF\\lib경로에 아래 세가지 파일을 복붙 commons-collections4-4.4.jar commons-dbcp2-2.7.0.jar commons-pool2-2.8.0.jar 2-2. 라이브러리를 서버에 연결 META-INF폴더에 Context.xml 생성 DB연결에 필요한 정보를 저장할 수 있다. 속성작성 name : 외부에서 해당정보에 접근할 수 있도록하는 이름값(필요에 따라 변경가능) auth : 자원관리자를 지정(Container/Application 고정) type : 웹에서 사용될때(name속성으로 호출할때) 표시되는 객체 타입(고정) driverClassName : JDBC드라이버주소(필요에 따라 변경가능) mysql쓴다면 : com.mysql.jdbc.Driver 오라클쓴다면 : oracle.jdbc.driver.OracleDriver url : DB가 존재하는 위치 = 디비서버의 주소(필요에 따라 변경가능) mysql쓴다면 : jdbc:mysql://localhost:3306/jspdb 오라클쓴다면 : jdbc:oracle:thin:@localhost:1521:orcl username/password : DB접속 계정 정보 maxWait : 커넥션풀에 사용가능한 커넥션이 없을 경우 커넥션의 회수를 기다리는 시간 지정(단위: 밀리초) 1234567891011&lt;Context&gt; &lt;Resource name=\"jdbc/mysqlDB\" auth=\"Container\" type=\"javax.sql.DataSource\" //DataSource라는 객체가 DB정보를 저장 driverClassName=\"com.mysql.jdbc.Driver\" //DataSource객체에 들어있는 정보 url=\"jdbc:mysql://localhost:3306/jspdb\" //DataSource객체에 들어있는 정보 username=\"root\" //DataSource객체에 들어있는 정보 password=\"1234\" //DataSource객체에 들어있는 정보 /&gt;&lt;/Context&gt; 2-3. JNDI 리소스 설정 web.xml파일에서 아래 코드 작성 description : 설명작성(의미없음, 원하는대로 작성하면됨) 나머지정보들은 Context.xml파일에서 해당 설정값을 그대로 복붙할 것! 123456&lt;resource-ref&gt; &lt;description&gt;ConnectDB&lt;/description&gt; &lt;res-ref-name&gt;jdbc/mysqlDB&lt;/res-ref-name&gt; &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt;&lt;/resource-ref&gt; 작동방식 : 서버를 실행하면 web.xml 먼저 접속 후 resource-ref코드를 보고 Context.xml을 읽어서 DB를 연결한다. 2-4. getCon()메서드 작성 : 커넥션풀 사용memberDAO.java파일로 이동해서 getCon()메서드를 커넥션풀을 사용한 아래 코드로 변경해준다. InitialContext클래스는 Context클래스를 재구현한 클래스이고 Object를 상속받았다 123public class InitialContextextends Objectimplements Context DataSource ds = (DataSource) init.lookup(“java:comp/env/jdbc/context파일의 name값그대로 입력”); 123456789101112131415161718192021//드라이버로드 디비연결 : 커넥션 풀 사용private Connection getCon(){ //Context 객체 생성 try { Context init = new InitialContext(); //업캐스팅 //디비연결정보를 불러오기 -&gt;DataSource 타입으로 저장 // 고정문구\"java:comp/env/jdbc/다른문구context파일의 name값입력\" DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/mysqlDB\"); //ds 사용해서 연결 con = ds.getConnection(); System.out.println(\"연결성공\" + con); } catch (SQLException e) { e.printStackTrace(); } catch (NamingException e) { e.printStackTrace(); } return con;}","link":"/2020/07/14/200715jspi2/"},{"title":"7월 우아한테크세미나 : 주니어개발자로 성장하는 우아한 방법들","text":"소개 프론트엔드 개발자가 되기 위한 10가지 방법 by 윤지수 강연소개웹프론트엔드 개발자 채용 수요가 꾸준히 증가 중입니다.하지만 여전히 기업에서는 괜찮은 웹 프론트엔드 개발자가 없다고 아우성입니다.기업이 원하는 인재상과 개발자를 준비하는 사람들 간에는 어떤 차이가 있는걸까요?2020년 현재, 웹프론트엔드 개발자가 되기 위해서 준비해야할 것 10가지를 알아봅니다. 우아한테크캠프에서 공부하는 법 by 정호영 강연소개요즘 우아한 테크캠프가 여름의 열기보다 더 뜨겁게 진행중입니다.많은 개발자 지망생 분들이 오고 싶어하는 우아한테크캠프에서는 무엇을 어떻게 배우고 있을까요?그리고 테크캠프에 아쉽게 합류 못하신 분들과 준비중인 분들을 위한 팁도 살짝 알려드립니다. 중요포인트 깃헙 이슈/프로젝트로 일감 만들어서 관리하기 PR보내기 코드리뷰 깃브런치 전략 주변에 사람이 없다면? 커뮤니티를 활용해서 사람들과 함께하기 자료구조와 알고리즘 중요 = 기초체력임. 시간재고 코드푸는 거 연습 한 문제를 다양한 방법으로 푸는 연습 다른 사람 코드보는 거 쉬운 문제를 여러번 풀어서 지속가능한 공부를 하기 네트워크 중에서 HTTP는 필수다! HTTP중심으로 알아야한다 :HTTP 기본기 추천도서 : ​모두의 네트워크, 그림 HTTP, HTTP 완벽 가이드 개인적으로 그림으로 쉽게 배우는 HTTP 라는 책으로 빠르게 한 번 훝고 HTTP 완벽 가이드 같은 두꺼운책으로 넘어가는게 좋은거 같아요 개발자도구의 네트워크탭의 항목을 모조리 다 이해하려고 노력해야한다. 서비스업체는 모든 키워드를 알아야한다. NODE.JS를 중심으로 웹애플리케이션 서버와 연동하는 것 필수 SSR을 위한 서버를 운영해야한다면? 에 답을 공부해보기 조금 더 욕심내자면 DATABASE, OS, 클라우드(AWS)등의 지식 Component 기반 개발이 표준이 된 세상 : html css js를 따로 개발하기보다 함께 개발해야 하는 시대. 주니어는 양보다 질이다. 기억에 남은 면접자는 하나를 깊게 판 면접자가 기억에 남는다. 프레임워크 코딩테스트는 프로그래머스 레벨 3까지 풀어보시고 백준에서 골드 3이하 문제 풀어보면 도움이 된다 바닐라js로 프레임워크 흉내내는거 도전해보기 피드백받을 수 있는 방법 찾아보기 : 커뮤니티, 세미나 나가서 멘토를 찾아라. 좋은 회사기준 : 그 회사의 채용공고를 이전것들까지 찾아보면 됨. 면접에서 내가 털리면 좋은 회사 웹은 SOP, 쿠키,세션,https 도 중요한 키워드이다! 포트폴리오/프로젝트 아이디어 바닐라JS에서 웹펙 바벨 연동가능 포트폴리오는 깃헙소스코드를 주로본다. 화면구현에 올인하지말것. 프로젝트주제는 크게 상관없고 자신이 무엇을 했는지 중요 자신이 사용하는 사이트에서 불편했던 걸 개선해보는 경험이 오히려 더 중요하다 면접팁 프로토타입설명 : 상속틀징 const와 let의 차이 설명 현업에서 가장 큰 이슈는 협엽, 협업에서 일어난 의사소통문제를 어떻게 해결했는지는 무조건 물어본다 답변듣고싶었던 질문들 프로젝트를 구현 시 필요한 프레임워크를 선택하는 기준이 궁금합니다. 각 프로젝트 성향마다 알맞는 프레임워크가 있는데 그 프레임워크를 선택하실때 프로토타입을 제작해보시나요? 일정이 촉박하다면 어떻게 선택하시나요? 예시 : (ex리덕스, 몹엑스) 비슷한 라이브러리가 존재할 시 깃허브 별 개수로 정하기 등등 코드리뷰 도입 시 자존심이 강한 동료분들이 있을수도 있고 계급으로 인해 의견을 제시하기 힘든 경우가 있을거라 생각합니다. 이러한 상황을 겪어보셨다면 어떻게 해결하셨는지 궁금합니다. 프론트 엔드 포폴 만들려면 nodejs로 curd부터 만들어야 붙일 수 있지 않나요? 결국에 그렇다면 풀스택 공부해야 포트폴리오 제작 할 수 있는거 아닌가요?포폴정도의 정적 페이지면 프론트 빌드하고 S3 정적 페이지 서비스 이용하시면 서버 없어도 괜찮았습니다. 후기연사님 두분 다 어쩜 그렇게 말씀을 재미있게 하시는 지 강연하는 두시간내내 빵빵터지며 재미있게 들었다.역시 중요키워드는 의사소통이다.그리고 IT업계는 변화의 속도가 빠른데 거기서 적응하는 것도 중요하다. 우아한테크캠프같은 경우 이번년에 도전했는데 아쉽지않게(?) 떨어졌다.도전을 했으니 실패가 있는 거겠지.도전하지않았으면 실패도 없었을거라는 마음가짐으로 가볍게 털고 다시 공부를 시작했다. 강연을 들으면서 토이프로젝트에 대해 많이 생각해보게되었고 좋은 리프레시시간이었다. 그런데 강연에서 말해준 중요한 것들이 이렇게나 많고 해야할 것들도 이렇게나 많으면 결국 프론트앤드니 백앤드니한 경계는 사라지고 풀스택개발자가 되어야만 한다는 느김이 들었다.ㅋㅋㅋㅋㅋ열심히하자!","link":"/2020/07/14/200715webina/"},{"title":"[ITWILL : JSP]Javabean 5 : 관리자만 확인할 수 있는 회원목록페이지만들기","text":"ITWILL학원 : 25강 JSP기초 BY 정규태강사1. main.jsp에 버튼추가관리자만 확인할 수 있는 회원목록페이지만들어보자. 12345678910111213141516171819202122232425&lt;%//1.한글처리, 파라미터 request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅String name = request.getParameter(\"name\");//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동if(id == null){ response.sendRedirect(\"loginForm.jsp\");}%&gt;&lt;h2&gt;&lt;%=id %&gt;님 환영합니다.&lt;/h2&gt;&lt;%=name %&gt;&lt;br&gt;&lt;input type=\"button\" value=\"회원정보조회\" onclick=\"location.href='memberinfo.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" onclick=\"location.href='updateForm.jsp'\"&gt;&lt;input type=\"button\" value=\"로그아웃\" onclick=\"location.href='logout.jsp'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" onclick=\"location.href='deleteForm.jsp'\"&gt;&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id != null){ if(id.equals(\"admin\")){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" onclick=\"location.href='memberList.jsp'\"&gt;&lt;% }}%&gt; 이때 관리자메뉴확인 if조건문을 아래 한줄짜리 코드로 바꿔보자 잘 실행될까? 12345678&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id.equals(\"admin\") &amp;&amp; id != null){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" onclick=\"location.href='memberList.jsp'\"&gt; &lt;%}%&gt; NOPE : 코드는 왼쪽에서부터 순서대로 실행되기때문 아래코드처럼 순서만 바꾼다면 잘 실행될까? 12345678&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id != null &amp;&amp; id.equals(\"admin\")){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" onclick=\"location.href='memberList.jsp'\"&gt; &lt;%}%&gt; YES! 이제 잘 실행된다 2. 회원전체페이지 출력하는 memberList.jsp 생성DB에서 모든 회원의 정보를 가져와서 페이지에 출력한다이때, 관리자는 목록에 제외되어야한다. 순서 로그인세션제어(관리자는 제외) DAO객체생성 회원목록을 가져오는 메서드 사용 ArrayList는 가변배열이므로 length가 없고 size가 존재한다. size()메서드는 배열의 요소의 갯수를 리턴한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%//1. 로그인세션제어(관리자는 제외)String id = (String) session.getAttribute(\"id\");//다운캐스팅if(id == null || !id.equals(\"admin\")){ //순서바뀌면 에러발생하므로 항상 null 먼저 비교할 것 response.sendRedirect(\"loginForm.jsp\");}//2. DAO객체생성MemberDAO mdao = new MemberDAO();//3. 회원목록을 가져오는 메서드 사용mdao.getMemberList();//아래 4번에서 DAO객체에 만들 메서드ArrayList memberList = mdao.getMemberList();%&gt;&lt;h2&gt;마이페이지&lt;/h2&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;나이&lt;/td&gt; &lt;td&gt;성별&lt;/td&gt; &lt;td&gt;이메일&lt;/td&gt; &lt;td&gt;회원가입일&lt;/td&gt; &lt;/tr&gt; &lt;%//반복문 //ArrayList는 가변배열이므로 length가 없고 size가 존재한다. //size()메서드는 배열의 요소의 갯수를 리턴 for(int i=0;i&lt;memberList.size(); i++){ MemberBean mb = (MemberBean) memberList.get(i); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=mb.getId() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getPw() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getAge() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getGender() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getEmail() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getReg_date() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt;&lt;/table&gt;%&gt; 3. DAO객체에 getMemberList()메서드 생성 DB연결메서드 불러오기 SQL &amp; pstmt 생성 실행 -&gt; rs저장 데이터처리 : 4-1. 회원이 몇명인지 알지 못하므로 가변길이 배열을 생성 : 배열안에 자바빈을 넣어서 가져 갈 예정이다. 근데 데이터갯수를 몰라서 배열을 못만든다. 따라서 데이터형태 ArrayList로 가져갈거다. ArrayList<E> 여기서 e를 제네릭타입이라고 칭함 ArrayList<> 다이아몬드 오퍼레이터라고 칭함 mb는 MemberBean데이터타입인데 add(Object)가 들어가야한다 따라서 업캐스팅 (MemberBean -&gt; Object)해서 넣어야한다. add(mb)를 빼서 쓸때는 다운캐스팅을 해야지 사용할 수 있다. 4-2. DB테이블 결과 1행의 정보 모두를 MemberBean데이터타입으로 저장 4-3. 1행정보를 배열 한칸에 저장 finally 로 자원해제 12345678910111213141516171819202122232425262728293031323334353637383940414243public ArrayList getMemberList(){ //가변길이 배열 생성 ArrayList memberList = new ArrayList(); try { //8-1. DB연결메서드 불러오기 con = getCon(); //8-2. SQL &amp; pstmt 생성 sql = \"select * from itwill_member\"; pstmt = con.prepareStatement(sql); //8-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //8-4. 데이터처리 : //8-4-1. DB테이블 결과 1행의 정보 모두를 MemberBean데이터타입으로 저장 //8-4-2. 1행정보를 배열 한칸에 저장 while(rs.next()){ MemberBean mb = new MemberBean();//1.MemberBean객체생성 mb.setAge(rs.getInt(\"age\")); mb.setEmail(rs.getString(\"email\")); mb.setId(rs.getString(\"id\")); mb.setName(rs.getString(\"name\")); mb.setPw(rs.getString(\"pw\")); mb.setReg_date(rs.getTimestamp(\"reg_date\")); //여기까지가 한 행의 데이터를 변수mb에 저장한 것임. while로 모든 행을 반복해서 변수mb에 저장 //가변배열(ArrayList)에 위의 데이터mb를 저장 //즉 배열 한 칸에 회원 1명의 정보를 저장함. memberList.add(mb); //업캐스팅 (MemberBean -&gt; Object) //System.out.println(memberList); 배열한 칸에 잘 들어갔는지 콘솔로 확인 } System.out.println(\"정보검색완료\"); //System.out.println(memberList); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { closeDB(); } return memberList;}","link":"/2020/07/14/200715jspi3/"},{"title":"트랜잭션(Transaction), 치환변수, save명령어, 리소스부족에러발생시","text":"트랜잭션(Transaction) 아주 중요한 개념 하나의 논리적인 작업단위 논리적이다보니 언제 트랜잭션이 시작되고 끝나는지 눈에 보이지않는 작업이다. 여러 DML이 모여서 하나의 트랜잭션으로 구성되기도 함 : insert, update, delete DML 작업 후 commit, rollback으로 트랜잭션 종료해야함 하나의 DDL 구문이 하나의 트랜잭션으로 구성되기도 함 : create, alter, drop, truncate 하나의 DCL 구문이 하나의 트랜잭션으로 구성되기도 함 : grant, revoke 트랜잭션 시작 및 종료 트랜잭션 시작 : 첫번째 DML구문이 실행 시 트랜잭션 종료 : commit, rollback실행 시 DDL 또는 DCL구문 실행 시 (autocommit) SQL PLUS 정상 종료 시 (autocommit) 터미널창 X를 닫는 건 비정상적인 종료 터미널창에서 EXIT() 명령어를 통한 종료는 정상적인 종료 SQL Developer 정상 종료 시 (autocommit) SQL Developer의 X를 누르면 저장하시겠습니까 팝업이 뜨는데 저장 안하고 종료하면 비정상적인 종료 SQL Developer의 X를 누르면 저장하시겠습니까 팝업이 뜨는데 저장하고 종료하면 정상적인 종료 시스템 장애 시 (autorollback) savepoint 트랜잭션안에서만 사용가능 1$ savepoint 세이브포인트명 치환변수아래 쿼리에서 모든 건 다 똑같고 employee_id만 100,101,102,… 변화시키고싶다.이때 치환변수를 이용하면 훨씬 용이하다 123$ select employee_id, last_name, salary$ from employees$ where employee_id = 치환변수 치환변수사용법 : &변수명 변수명은 항상 의미있게 작성해야한다. 문자, 날짜가 들어와야하는 데이터인 경우는 ‘&변수명’로 입력하면 된다. 문자는 대소문자를 구분하므로 lower()나 upper()를 양쪽변에 같이 써서 맞춰주면 된다. 123456789//데이터가 숫자$ select employee_id, last_name, salary$ from employees$ where employee_id = &amp;emp_id//데이터가 문자나 날짜$ select employee_id, last_name, salary$ from employees$ where lower(last_name) = lower('&amp;last_name') 쿼리구문을 작성하면 자동으로 변수를 물어봐준다. 이에 응답하면 데이터를 출력해준다. save명령어 : 자주 실행되는 쿼리구문 저장하기만약 회사가 department를 자주 생성하는 회사이다.이럴경우 치환변수를 넣어 쿼리구문을 저장하고 필요할때마다 편하게꺼내서 실행할 수 있다.자주 실행되는 쿼리구문은 save 명령어로 저장한다 save명령어로 쿼리구문을 저장하는 방법 sql plus에서만 있는 명령어. sql develoepr는 save 명령어가 없다. why? 걍 저장버튼을 누르면 되기때문 1234567//1. SQL구문입력$ insert into departments$ values (&amp;dept_id, '&amp;dept_name', &amp;mgr_id, &amp;loc_id)//2. 첫 치환변수들 물음에 답하기//3. insert성공//4. save명령어작성 save 저장원하는경로/저장할이름.sql save명령어 저장된 쿼리구문 사용하는 방법 sql plus에서만 있는 명령어. sql develoepr는 @명령어가 없다. why? 걍 열기버튼을 누르면 되기때문 1$ @/저장한경로/저장한이름.sql 예시 1$ @/home/oracle/new_dept.sql 터미널창에서 리소스부족에러 발생시보통은 유저가 많이 접속된 경우에 리소스부족에러가 자주 발생한다.따라서 제일 먼저 의심해봐야하는 건 유저가 동시접속되어있지않은가이다.터미널창에서 exit 명령어를 이용해서 접속되어있는 유저 한명씩 종료시켜준다. 마지막 한 유저만 남을 때까지.","link":"/2020/07/16/200717dbi/"},{"title":"[ITWILL : JSP]Wrapper클래스, 오토 박싱과 오토 언박싱, hierarchy확인법","text":"ITWILL학원 : 26강 JSP기초 BY 정규태강사1. Wrapper클래스 자바에서는 모든 것을 담을 수 있는 Object가 있다. Object로 배열을 만들면 다양한 종류의 객체들을 담을 수 있게된다. 단 기본형은 제외된다. WHY? 기본형데이터타입은 Object를 상속받지 않기때문! 이때 기본형 데이터를 wap해서 객체로 만들어 주는 것이 Wapper클래스이다. 기본형 데이터를 객체로 사용할 수 있도록 만든 클래스 기본형 데이터의 본질은 그대로두고, 해당 인터페이스만 제공하는 클래스이다. 자바는 대소문자를 구분하기때문에 아래 두 형태는 서로 다른 값이다. 기본형데이터타입은 상속이 불가능하다. why? 객체가 아니니까. 상속은 객체간의 관계를 표현하는 것. 기본형데이터타입 Wrapper클래스(참조형데이터타입) byte Byte short Short int Integer float Float double Double boolean Boolean char Character 2. 오토 박싱과 오토 언박싱기본적인 박싱과 언박싱이 있던 개념이지만 JDK6이후로 오토박싱과 오토언박싱이 가능해졌음이건 새로운 개념이며 형변환개념과 다르다. 박싱 : 값 형식의 데이터(기본형데이터타입)를 참조형데이터타입인 Wrapper클래스로 변환하는 것 메모리상에서 stack에 있는 값을 heap에 전달함. 언박싱 : Wrapper클래스를 기본형데이터타입으로 변환하는 것 heap에 있는 값을 stack에 전달함. 예시 12345678910111213141516int num01 = 100;int num02; //래퍼런스만 준비Integer inum01 = new Integer(200); //인티져는 객체이기때문에 생성해줘야함Integer inum02; //래퍼런스만 준비//JDK1.6이전inum02 = new Integer(num01); //박싱 : 직접 객체안에 담아야함num02 = inum01.intValue(); //언박싱System.out.printf(\"박싱 : %d, 언박싱 : %d%n\", inum02, num02);//JDK1.6이후inum02 = num01; //오토박싱num02 = inum01; //오토언박싱System.out.printf(\"박싱 : %d, 언박싱 : %d%n\", inum02, num02); 3. inner 클래스접근제어자(Access Modifier) public 누구나 접근 가능하다 public클래스는 main메서드를 포함하고 있는 클래스이다. 하나의 파일에 하나의 public클래스만 있어야한다. 진짜 딱 하나만 사용가능할까? inner 클래스에서 public클래스 추가 생성이 가능하다 12345class a{ public class b{ //이너클래스 }} 4. 클래스명에서 키보드 f3, f4를 누르면클래스명에서 아래 키보드를 누르면 상속관계(hierarchy)를 확인할 수 있다. f3 : 어떤 클래스나 인터페이스를 상속받는 지 알수있음. f4 : 계층도를 나타냄.","link":"/2020/07/15/200716jspi/"},{"title":"[ITWILL : WEB]더미텍스트&#x2F;이미지만들기(Lorem Ipsum&#x2F;placeholder), 기본선택자 종류 및 우선순위, 섹션요소","text":"ITWILL학원 : 9강 WEB(HTML, CSS) BY 김영희1. 더미데이터 만들기1-1. Lorem Ipsum 로렘입숨 : 더미텍스트만들기 줄여서 립숨, lipsum 임의의 텍스트를 넣어서 HTML구조와 CSS 디자인을 보고싶을때 자주 사용 vscode에서는 lorem검색하고 tab치면 자동완성 이클립스(Eclipse)는 아래 사이트에서 원하는 모양대로 설정뒤에 복붙하면 된다 참고링크 : 입숨 1-2. placeholder : 더미이미지만들기123&lt;img src=\"http://via.placeholder.com/가로길이x세로길이/바탕색코드/글자색코드?text=이미지안글자\" /&gt;//예시&lt;img src=\"http://via.placeholder.com/400x600/000000/ffffff?text=400x600\"&gt; 참고링크 : placeholder 2. 기본 선택자 종류 및 우선순위선택자는 기본선택자와 가상선택자가 있다 그 중 기본선택자를 보자. 기본선택자종류 선택자 우선순위기본적으로 가까울수록 우선순위가 높다.아래 이미지로 대략적으로 확인할 수 있고 위의 이미지처럼 계산할 수 있다계산해주는 사이트도 있다 참고링크 : css 선택자 우선순위 계산사이트 주요 가상선택자종류 3. 섹션요소홈페이지 용도별 태그명이 다르다. BODY, HEADER, NAV, SECTION, ARTICLE, MAIN, ASIDE, FOOTER","link":"/2020/07/16/200717webi/"},{"title":"Git branch 기초","text":"브랜치(Branch)활용 브랜치 : 같은 폴더인데 다른 세상처럼 이용할 수 있음 기본 브랜치 : master 브랜치생성 : 브랜치네이밍을 할때 꼭 작업키워드에 맞출것 1234$ git checkout -b 브랜치명# 예시 : fix-mnist브랜치 만들기$ git checkout -b fix-mnist 브랜치 master로 변경 1234$ git checkout 연결할브랜치명# 예시 : 현재 작업중인 브랜치를 master브랜치로 변경$ git checkout master 브랜치삭제 속성 -d와 -D의 차이 -d는 정상적인 상황일 때 사용가능한 옵션 -D는 강제로 처리하게 하는 옵션 1234# 추가생성한 브랜치 삭제를 위해 master브랜치로 이동$ git checkout master# 브랜치삭제$ git branch -d fix-mnist 어떤 브랜치에 접속되어있는지 확인 git status는 정말 다양한 정보를 가지고 있는데 그 중 현재 내가 작업진행중인 브랜치를 알려준다. 1$ git status","link":"/2020/07/17/200718opensource3/"},{"title":"Git config(깃설정), 오픈소스 참여를 위한 GIT 순서 (팀협업)","text":"깃이란? git은 텍스트파일로 변화내역(역사)를 관리하는 것 참고링크 : git 버전관리 오픈소스 개발 참여를 위한 Git config(깃설정)Github ID/PW 캐싱데이터 삭제 삭제해도 문제없음 목적 : 다른 github계정과 충돌방지 12$ git config --global --unset credential.helper$ git config --system --unset credential.helper 내 github계정연결 차후 소스코드 커밋파일에 저자정보에 기입됨 12$ git config --global user.email \"본인이메일주소\"$ git config --global user.name \"본인이름\" 12$ git config --global user.email \"본인이메일주소\"$ git config --global user.name \"본인이름\" 소스코드 수정할 기본 편집기 설정 원하는 편집기 설정가능 : vim, emacs, nano, notepad 등 12345# 예시 : nano편집기로 설정$ git config --global core.editor nano# nano편집기 사용시 설치필요$ sudo apt install -y nano git 설정 내용 확인 수정원할시 위의 명령어로 재입력하면 덮어쓰기됨. 1$ git config --list 오픈소스 참여를 위한 GIT 순서 (팀협업)오픈소스에 참여하기 위해서는 공식 오픈소스 프로젝트 레포지토리에서 프로젝트를 복사하여 내 로컬에서 사용할 수 있게해야한다. 공식 레포에 가서 Fork버튼을 누른다.Fork해온 레포의 code를 클릭하여 Clone with HTTPS를 복사한다.git bash 또는 IDE의 터미널을 연다.아래 명령어를 입력한다.123456# 오픈소스 프로젝트 소스코드 준비$ git clone 복사한 https://github.com/본인깃허브ID/fork한프로젝트명.git$ cd fork완료한폴더 -&gt; (master) 라는 브랜치명이 생성됨. # remote저장소에 공식레포 upstream으로 준비$ git remote add upstream 공식레포주소 코딩을 하기전 최신base로 갱신하기내가 clone을 해온 뒤 공식레포 base가 변경될수도 있다.따라서 작업전 공식레포에서 최신base를 내 fork레포로 가져와야한다로컬저장소를 최신으로 만드는 방법에는 두가지가 있다. pull과 fetch이다. 12345678910111213141516# 1. pull사용# upstream(팀프로젝트)의 최신버전을 가져오기.$ git pull upstream 레포주소# 가져온 최신버전을 내 fork한 저장소에 저장하기 $ git push origin master# 2. fetch사용# upstream(팀프로젝트)에서 새로운 commit가져오기$ git fetch upstream# 가져온 upstream을 내 fork저장소의 master브랜치에 병합하기$ git merge upstream/master# 병합된 내역을 내 fork저장소에 푸쉬하기$ git push origin master Git 협업하기 : Upstream Merge 후, 최신상태 Pull 받기 코딩 후 내 fork레포에 commit하기.내 fork레포에만 저장된다. 123456789101112131415161718# 1. 내가 수정한 파일 add하기$ git add 내가수정한파일명# 2. add상태확인$ git status# 3. commit하기$ git commit -m \"커밋이유 자세히\"# 4. 내가 작성한 커밋 확인하기# q키 누르면 나감.$ git show# 5. 현재 작업 브랜치 확인$ git branch# 6. 내 fork저장소에 업로드하기$ git push origin 브랜치명 로컬저장소 최신버전으로 갱신하기현재 내 커밋은 내 fork레포에만 있다.내가 수정한 코드를 공식 레포에 올려달라고(Merge) 요청해야한다(Pull request).하지만 내가 코드수정하는 동안 또다시 공식레포의 base가 달라질수있다.따라서 pr전에 merge충돌을 방지하기 위해서 rebase한 뒤 내 커밋을 얹어서 함께 push해야한다. fetch : 최신 base가져오기 rebase : rewind : 내 커밋전의 과거시점으로 감 가져온 fetch를 그 위에 올린다(다른사람의 PR한 커밋포함) 그 위에 내 커밋을 올린다 (이때 다른사람의 커밋과 내커밋이 충돌날수있다) 자동PR됨 123456789101112131415161718192021222324# 원격저장소확인$ git remote -v# 공식 upstream 저장소에서 최신 commit history가져오기$ git fetch upstream master# 최신 comit history 기준으로 베이스 갱신 = rebase 감기$ git rebase upstream/master# 충돌 상황확인하기$ git status$ git diff# 충돌부분 수정후 add하기$ vi 수정할려는파일명(GIT BASH상에서) 또는 IDE상에서는 패널에 파일열어서 수정가능$ git add 수정할려는파일명# rebase 풀기$ git rebase --continue# 내 fork한 레포에 최신 master브랜치에 가져온 commit내용 갱신하기$ git checkout master$ git reset --hard upstream/master$ git push origin master -f 공식저장소에 PR하기12345678910# PR 하기 두가지방법# 첫번째 : 추천방법$ git push origin 브랜치명# PR 하기 예시 : master 브랜치인 겨우$ git push origin master -f# 두번째 : PR시 force push(강제푸시)사용# 두번째 방법을 이용하면 내 fork한 저장소가 수정되면서 PR자동갱신된다. 따라서 아래 7번8번을 생략할수있다.# 강제푸시이므로 팀프로젝트에 이용시 꼬일 수 있다$ git push --force origin master upstream저장소의 pull request게시판에서 회색 merge버튼이 초록색으로 변했는지 확인후 maintainer에게 merge요청하기 fetch 와 pull 차이 pull은 하는 순간 merge가 된다. fetch + merge = pull force push fork한 저장소가 꼬인 경우는 로컬에서 잘 정리해서 force push(강제푸시)를 쓰면된다. 나혼자 쓰니까 괜찬. 하지만 다같이쓰는 저장소는 절대 force를 쓰면 안된다. origin의 의미 수업중 질문 : origin은 master처럼 기본적으로 지정된 폴더 이름인가요? origin이 어떤 의미를 가지는지 알고싶습니다답변 : origin이나 upstream은 remote repository에 붙이는 이름표같은거라고 생각하시면되요. 그런데 대부분의 튜토리얼들이 fork뜬 저장소는 origin으로, 원본 저장소는 upstream이라고 식별한걸 가정하고 진행되기때문에 미리 알아두시는게 좋구요","link":"/2020/07/17/200718opensource/"},{"title":"add 취소, commit 명령어 수정, commit 취소, 라이센스 commit 생성, reset과 revert의 차이","text":"add 명령 취소하기 123456789$ git add 파일명# git status에서 add 되어있는지 확인 (초록색)$ git status # add 명령 취소$ git reset# git status에서 add 취소되어있는지 확인 (빨간색)$ git status commit 메세지 수정하기 = commit amend 최신 히스토리 기준으로 커밋명 수정 가능 수정하면 커밋ID는 바뀌게 된다 1$ git commit --amend commit 삭제하기커밋이 크면 어떻게 나누는게 적당할까? 그리고 커밋이 크다는 건 어느정도를 말할까? 정답 : 테스트의 단위로 나누는 것이 좋다. 123456789101112131415$ git add 파일명$ git commit -m \"커밋메세지입력\"# 생성한 커밋정보확인$ git show$ git log --oneline -1# commit 정보삭제# 예시 : 가장 최근 commit 한개 삭제하기# HEAD위치 확인$ git log --oneline# HEAD의 커밋 한개 삭제$ git reset --hard HEAD~1# 삭제 후 최신 commit 확인$ git log --oneline -1 라이센스넣어서 커밋하기 일반 커밋이외에 라이센스를 넣어서 커밋을 할 수 있다. 어떤 경우에 사용할까? 라이센스를 정확히 이해했을때 오픈소스 커밋시 의무사항인 곳도 있다. 자신의 라이센스 권리를 주장할 수 있다. 12라이센스를 이해하고 넣는 속성 `-sm`.$ git commit -sm \"커밋명\" reset과 revert의 차이 revert : 커밋을 취소한다고 커밋을 남기며 되돌림. 1git revert 커밋넘버 reset : 커밋을 작성한 걸 아예 되돌림. 이전 커밋기록은 삭제. 프로덕션에 올라간 커밋은 reset을 하면 안된다. 히스토리가 안 남기때문.","link":"/2020/07/17/200718opensource4/"},{"title":"개발자가 오픈소스를 읽는 방법(Git log)","text":"개발자가 오픈소스를 읽는 방법(Git project Reading Skill) 오픈소스개발자입장에서 프로젝트 내용 확인해보려고하는 명령어들 프로젝트를 볼때 커밋히스토리를 기준으로 소스코드리딩하면 훨씬 전략적으로 읽을 수 있다. 프로젝트레포지토리에 있는 Contributing을 꼭 읽어야한다. 그래야 공통작성하는 방법은 코딩스타일을 확인할 수있다. 정해놓은 코딩스타일로 꼭 작성해야한다 ex) 빈칸, 중괄호위치 등등 commit ID는 소스파일이 수정될때마다 생기거나 바뀌는 고유한 ID(SHA1해시값) 속성 | wc -l : 파일 라인개수를 측정. | nl : 파일의 line number명시(순위표시용으로 사용) --no-merges : 머지커밋은 병합커밋(빈커밋)으로 수정내역을 보고자할때 굳이 필요없기에 no-merges 옵션사용. --reverse : 옛날 것부터 출력 123456789101112131415161718192021222324252627282930# 1. 전체 소스파일 커밋 리스트# `q`키 눌러서 나가기$ git log --oneline# 2. 전체 소스파일 커밋 자세히 보기# oneline보다 자세하게 전체 소스파일 수정내역을 확인할 수 있다.$ git log -p# 3. 전체 소스파일 커밋 리스트(Merges커밋제외)$ git log --oneline --no-merges# 4. 전체 소스파일 수정내역 개수 세기# | wc -l속성으로 커밋개수를 확인할 수 있다.$ git log --oneline | wc -l# 5. ID값으로 어떤 커밋을 언제 어떻게 커밋했는지 확인가능$ git show ID값 # 6. 요약 소스파일 리스트$ git shortlog -sn# 7. 특정날짜기준 커밋리스트# 날짜를 기준(inclusive)으로 커밋리스트를 확인할 수 있다# 예시 : 2020년1월1일부터 2020년6월30일까지의 커밋리스트를 확인$ git log --oneline --after=2020-01-01 --before=2020-06-30# 예시 : 2020년6월1일부터 2020년6월30일까지의 폴더명(mnist)의 커밋리스트 갯수(|wc -l)를 확인$ git log --oneline --after=2020-06-01 --before=2020-06-30 -- mnist/ | wc -l# 8. 옛날 것부터 소스파일 커밋리스트보기$ git log --reverse","link":"/2020/07/17/200718opensource2/"},{"title":"rebase로 commit 추가,수정,삭제하기","text":"rebase 리베이스 12345678910111213141516# rebase -i :인터렉트 즉, 되감기를 하겠다는 의미$ git rebase -i --root# 감았던 rebase 풀기$ git rebase --continue# rebase 취소하는 것$ git rebase --abort# rebase 초기화# rebase$ git reset --hard HEAD~1$ git reset --hard origin/master# vi편집기 나가기:wq -&gt; write and quit(저장하고 나가기의 줄임말) 리베이스 예시 : 커밋추가가장 오래된 것부터 두번째 커밋 이후에 새로운 커밋 3개 추가하기 1234567891011121314151617181920212223242526# 리베이스감기 : 오래된 것부터 두번째 커밋에 pick을 edit으로 변경$ git rebase -i --root# 새로운 커밋 3개 추가$ touch 새로운파일1.txt$ git add 새로운파일1.txt$ git commit -n \"Added 새로운파일1\"$ touch 새로운파일2.txt$ git add 새로운파일2.txt$ git commit -n \"Added 새로운파일2\"$ touch 새로운파일3.txt$ git add 새로운파일3.txt$ git commit -n \"Added 새로운파일3\"# HEAD위치 확인$ git log --oneline# 리베이스풀기$ git rebase --continue# 커밋이 잘 추가되었는지 결과확인$ git shortlog$ git log --oneline$ gitk 리베이스 예시 : 커밋수정위에서 추가한 커밋 1번2번3번 중에 2번과 3번을 커밋을 한 개로 합치고 싶다면? rebase -i --root에서 커밋3번에 pick을 edit로 변경해야한다. 그 뒤 커밋 3번을 reset --soft HEAD~1를 해주면 커밋에서는 사라졌지만 파일은 남아있다. commit --amend를 해주면 커밋3번이 커밋2번에 흡수된다. show 커밋ID를 검색하면 2번과 3번이 합쳐진것을 볼 수 있다. 12345678910111213141516171819202122# 리베이스감기$ git rebase -i --root# 위의 세번째커밋에 pick을 edit으로 변경해준다.# HEAD위치 확인$ git log --oneline# 세번째커밋삭제$ git reset --soft HEAD~1$ git status# 두번째커밋에 흡수 합치기$ git commit --amend$ git show 커밋ID# 리베이스풀기$ git rebase --continue# 커밋이 잘 수정되었는지 결과확인$ git log --oneline$ git show 합쳐진commitID 리베이스 예시 : 커밋삭제가장 오래된 것부터 두번째 커밋 “Add secondCommit” 삭제하려면? 12345678910$ git rebase -1 -root# 두번째 pick Add secondCommit을 edit으로 바꿈$ git status$ git reset --hard HEAD~1$ git rebase --continue# 커밋이 잘 삭제되었는지 결과확인$ git log --oneline$ git shortlog$ gitk","link":"/2020/07/17/200718opensource5/"},{"title":"[ITWILL : WEB]폰트속성","text":"ITWILL학원 : 9강 WEB(HTML, CSS) BY 김영희1. font속성(폰트속성)속성은 크게 두가지 그룹이 있다 font text 그 중 폰트속성 먼저 알아보면 아래와 같다. font 속성종류 특징 font-size 글자 크기 font-weight 글자 두께 font-style 글자 기울기 font-family 글자(서체) 지정 2. font-size다양한 단위가 있다.실무에서 주로 쓰이는 단위는 px, pt(포인트)이다. 참고링크 : 폰트사이즈변환 3.font-family한글 본문은 고민하지말고 맑은 고딕으로 쓰면 된다. 기본폰트 :기본글꼴종류는 크게 세 가지로 나뉜다 Sans-serif 고딕형 : sans의 의미는 without이다. 글자의 끝이 딱 떨어지는 느낌, 가독성이 제일 좋음 Serif : 끝에 장식이 있는 클래식한 느낌 Monospace : 고정글꼴. width가 same한 글꼴이다.글꼴이름을 넣을때는 쌍따옴표를 넣고 글꼴종류를 적을때는 쌍따옴표를 적으면 안된다. 참고링크 : w3schol 웹폰트 :폰트패밀리로 기본폰트를 지정해주었을 때, 만약 사용자의 컴퓨터에 해당 폰트가 없다면 폰트 적용이 아예 안된다.이를 예방하기위해 웹폰트를 사용할 수 있다. 사용자가 굳이 다운로드하지않더라고 웹폰트가 적용된 채로 홈페이지를 볼 수 있다. 웹폰트는 무료도 있고 유료도 있지만 제일 유명한 구글폰트는 무료이다. 구글웹폰트 구글웹폰트깃허브 : 한글 눈누 : 한글폰트로 유로뿐만 아니라 무료상업용웹폰트도 쉽게 찾을 수 있다. 웹폰트 사용법은 간단하다. 해당 웹폰트의 html의 link태그를 복사하여 head태그 사이에 붙여넣기. 해당 웹폰트의 css코드를 복사하여 css페이지에 붙여넣기.","link":"/2020/07/16/200717webi2/"},{"title":"특정 소스라인에 대해서 누가 마지막으로 수정을 했는지 찾기 git blame","text":"blame 특정 소스라인에 대해서 누가 마지막으로 수정을 했는지 commit ID로 추적가능하다. /class 첫글자대문자키워드 : string검색가능 ex)/class Parser } 닫힘 중괄호같은 경우 수정되지 않을 가능성이 많기때문에 옛날것 그대로 유지할 확률이 높다. 복구 (clone받은 데이터로) : git reset --hard origin/master 예시 : git blame이용하여 exam.txt파일에서 Parser클래스를 만든 최초의 commit을 찾아보기 123$ git blame exam.txt;# /class Parser 검색하기 -&gt; 검색결과 하이라이팅됨 -&gt; 해당 커밋ID복사$ git show 커밋ID","link":"/2020/07/17/200718opensource6/"},{"title":"[ITWILL : JAVA]기본클래스 이외에 자바 구성요소2 : enum","text":"ITWILL학원 : 18강 JAVA BY 윤미영강사1. enum(이넘)의 정의 enum은 열거형 데이터 타입이라고 한다. 데이터가 몇 가지 한정된 상수값으로 구성될때 주로 사용. ex) 계절을 나타낼때 String타입보다 enum을 생성하여 봅, 여름, 가을, 겨울의 딱 4개의 값만 설정하는 것이다. 2. enum 사용법 키워드 class대신 enum사용, enum내부에는 상수값 나열 -&gt; 이 상수값들을 enum상수라고 부름 대소문자 구분함 123enum Season{ SPRING, SUMMER, FALL, WINTER //=&gt;각각 0,1,2,3의 ordinal값을 가짐} 선언위치에 따른 변화 같은 클래스 내부에서 enum사용시 (innerEnum) : Season.SPRING 외부 클래스에서 enum사용시 (OuterEnum) : 해당클래스명.Season.SPRING 3. 일반 클래스와 enum 차이점 접근제어자 : public, default만 사용가능 내부적으로 java.lang.Enum클래스 상속 -&gt; 따라서 별도로 다른 클래스 상속받을 수 없다. 여러 인터페이스를 구현하는 것은 상관없다. enum을 이용하면 비교할때 단순히 값만을 비교하는 것이 아니라 타입까지 비교한다. =&gt; 안정적인 프로그래밍가능 4. enum메서드enum타입들은 java.lang.Enum 클래스를 기본적으로 상속받고 있기 때문에 java.lang.Enum 클래스에 선언된 메서드들을 사용가능하다. 메서드명 선언부 설명 name() public final String name() enum상수의 이름을 문자열로 리턴한다 ordinal() public final int ordinal() 0부터 시작하는 enum 상수의 순서를 리턴한다 comparedTo() public final int com[aredTo(E o) enum상수의 ordinal 차이를 리턴한다 values() public static T[] values() enum타입에 선언된 enum상수를 배열로 리턴한다 valueOf() public static T<extends Enum<T>> T valueOf(Class<T> enumType, String name) 문자열로 매핑된 enum상수 객체를 리턴한다 5. enum상수를 이용한 연산 enum상수는 주로 비교연산에서 사용된다. enum을 사용하여 계절별로 다른 출력값을 나타내는 코드를 작성해보자. OuterEnum사용 첫번째방법 : if조건문 + comparedTo() 두번째방법 : switch 1234567891011121314151617181920212223242526272829303132333435363738394041424344enum Season{ SPRING, SUMMER, FALL, WINTER}public class SeasonEnumTest { //첫번째방법 : if조건문 + comparedTo() public void compareEnum(Season s){ if(s.equals(Season.SPRING)){ System.out.println(s.compareTo(Season.WINTER)); System.out.println(\"따뜻한 봄\"); }else if(s.compareTo(Season.WINTER) &lt; 0){ System.out.println(s.compareTo(Season.WINTER)); System.out.println(\"최소한 겨울은 아니잖아요\"); }else{ System.out.println(s.compareTo(Season.WINTER)); System.out.println(\"추운 겨울\"); } } //두번째방법 : switch public void enumSwitch(Season s){ switch(s){ case SPRING : System.out.println(\"봄\"); break; case SUMMER : System.out.println(\"여름\"); break; case FALL : System.out.println(\"가을\"); break; default: System.out.println(\"겨울\"); } } public static void main(String[] args) { // TODO Auto-generated method stub SeasonEnumTest set = new SeasonEnumTest(); set.compareEnum(Season.SPRING); set.enumSwitch(Season.SPRING); }} 6. enum에 멤버 추가 가능 enum에도 사용자가 원하는 멤버변수와 멤버메서드를 추가할 수 있다 주의점 : enum상수들만을 정의할때는 세미콜론이 필료없지만 별도의 멤버를 추가하는 경우에는 세미콜론을 추가해서 상수 선언이 끝나는 것을 표시해줘야한다. 7. enum에 생성자 추가 가능 enum의 생성자의 접근 제어자 : private만 가능하고 생략가능. 외부에서 해당 생성자를 호출할 수는 없으며 내부에서 상수를 정의하면서 파라미터로 전달.","link":"/2020/07/19/200720javai/"},{"title":"[ITWILL : JSP]자료구조2 : Stack클래스, Queue인터페이스, Map인터페이스","text":"ITWILL학원 : 27강 JSP기초 BY 정규태강사 1. 자료구조 : Stack 클래스 top에서만 데이터의 입출력 발생하기 때문. LIFO 구조(FILO 구조) : 가장 먼저 들어온 데이터가 가장 마지막에 나가는 구조. 데이터 입력 -&gt; push 데이터 빼내기 -&gt; pop 장점 : 특정 자료구조의 형태로 처리했을때 데이터처리가 가장 효율적이다. 12345678910111213141516171819202122Stack st = new Stack();//데이터삽입st.push(\"1-java\");st.push(\"2-jsp\");st.push(\"3-web\");st.push(\"4-db\");System.out.println(st);//데이터 빼내기while(! st.isEmpty()){ //스택클래스가 비어있지 않은 경우 System.out.println(st.pop()); //LIFO}System.out.println(st);//출력값[1-java, 2-jsp, 3-web, 4-db]4-db3-web2-jsp1-java[] 출력값을 보면 데이터가 빠져나가는 순서가 LIFO이다. 2. 자료구조 : Queue 인터페이스 FIFO/LILO : 먼저 들어온 데이터가 먼저 처리되는 구조. 즉 입력된 순서대로 처리되는 구조 First Input First Output Last Input Last Output 스택은 클래스이지만 큐는 인터페이스이다 -&gt; 따라서 큐는 객체생성을 할수없지만 구현을 통해서 생성가능하다 LinkedList 클래스 : 큐인터페이스를 구현한 클래스 인터페이스는 업캐스팅이 가능할까? ㅇㅇ 가능! 1234567891011121314151617181920Queue que = new LinkedList(); //업캐스팅(LinkedList클래스-&gt;Queue인터페이스)//데이터입력que.offer(\"1-java\");que.offer(\"2-jsp\");que.offer(\"3-web\");que.offer(\"4-db\");System.out.println(que);//데이터빼내기//peek() : Queue안에 데이터가 있는지 없는지 판단하는 메서드 -&gt; 없으면 null리턴while(que.peek() != null){ // 큐 안에 데이터가 있는지 없는지 판단, 없을경우 null System.out.println(que.poll());}//출력값[1-java, 2-jsp, 3-web, 4-db]1-java2-jsp3-web4-db 출력값을 보면 빠져나가는 순서가 FIFO이다. 3. 자료구조 : Map인터페이스 Map, table 접미어가 붙은 자료구조이다. 데이터저장시 (키, 데이터)쌍으로 저장하여 사용하는 구조 map은 인터페이스이므로 객체생성을 할수없지만 구현을 통해서 생성가능하다 hashtable 클래스 : 맵인터페이스를 구현한 클래스 키값을 사용해서 검색 인덱스생성 -&gt; 데이터 검색시간이 짧음. 참고링크 : 컬렉션 프레임워크 Map계열 자세히 예시 : Map계열의 hashtable12345678910111213141516Map m = new Hashtable(); //업캐스팅//데이터입력m.put(\"사과\", \"apple\");m.put(\"오렌지\", \"orange\");m.put(\"복숭아\", \"peach\");System.out.println(m);//데이터출력하기System.out.println(m.get(\"복숭아\"));System.out.println(m.get(\"바나나\"));//출력값{오렌지=orange, 사과=apple, 복숭아=peach}peachnull","link":"/2020/07/19/200720jspi/"},{"title":"[ITWILL : JAVA]기본클래스 이외에 자바 구성요소3 : annotation, generic","text":"### ITWILL학원 : 18강 JAVA BY 윤미영강사 annotation(애노테이션)과 generic(제네릭)에 대해 정리해봤다. 1 annotation 애노테이션 사전적 의미는 주석이다 애노테이션은 개발자가 읽기 위한 주석이 아니라 컴파일러등에게 전달하는 일종의 메타데이터이다. 메타데이터란 : 다른 데이터를 설명해주는 데이터로 속성 정보라고도 한다. 함수형인터페이스란 : 인터페이스 중에서 한 개의 abstract메서드를 가진 인터페이스. 함수형인터페이스 중 익명클래스를 사용했다면 람다식사용가능 애노테이션 설명 @Override 컴파일러에게 재정의된 메서드라고 알려줌 @Deprecated 앞으로 없어질 수 있으니 사용을 자제하라고 알려줌 ex)보안적인 이슈가 발생했거나 더 좋은 성능의 메서드로 대체를 권장할 때 사용함 @SupressWarnings(“all/unused”) 컴파일러에게 특정 경고 메시지를 무시하라고 알려줌 ex)경고내용에 이미 알고 있으니 컴파일러가 보여주지 않아도 될때 사용함 @Functionallnterface 함수형 인터페이스라는 것을 알려줌 2 Generic 제네릭의 사전적 의미 : 일반화 장점 : 컴파일 시점에서 사용할 수 있는 객체타입을 체크함 -&gt; 프로그램의 안정성이 획기적으로 향상되고 코드도 줄어듬. 타입 파라미터를 사용하면 클래스에 넘겨줄 수 있는 데이터타입을 제한할 수 있다. 123456// 꺽쇠 전체&lt;T&gt;를 제네릭이라고 부른다.//그 안의 파라미터 T를 타입파라미터라고 부른다.class test&lt;T&gt;{} 사용처 : 데이터 저장 구조 사용 주의점 타입 파라미터는 인스턴스변수임 -&gt; static멤버에는 타입파라미터 적용못함. 타입 파라미터를 이용해서 객체생성 못함 why? new 연산자는 컴파일 타입에 정확한 타입을 알아야하는데 클래스 내부에서 파라미터만 보아선 타입을 알 길이 없기때문에. 타입 파라미터에서 사용가능한 메서드는 Object에 선언된 것으로 한정한다 why? 아직 타입이 정해지지 않은 상태에서 누구의 메서드를 가져다 쓸 수 없기때문에 최상위클래스인 Object의 메서드들만 사용가능. 2-1 사용 가능한 파라미터 타입의 제한 가변인자 : 파라미터의 갯수를 모를때 가변인자를 사용할 수 있다 가변인자 파라미터 타입의 제한 제네릭 예시 코드 123456789101112131415161718192021222324252627class NumberBox&lt;T extends Number&gt;{ public void addSomes(T ... ts){ //가변인자 double d =0; for (T t: ts){ //d = t+d; //t가 뭔지 모르기때문에 double과 더할수가없다. //따라서 t를 double로 바꿔줌. //Number클래스의 doubleValue()메서드를 사용하면 된다. d = t.doubleValue() + d; } System.out.println(\"총 합은 : \"+ d); }}public class ExtndsTest { public static void main(String[] args) { NumberBox&lt;Number&gt; numBox = new NumberBox&lt;&gt;(); numBox.addSomes(1.5, 5, 4L); NumberBox&lt;Integer&gt; intBox = new NumberBox&lt;&gt;(); intBox.addSomes(1,2,3); //Number의 하위 클래스만 사용 가능. //NumberBox&lt;String&gt; strBox = new NumberBox&lt;&gt;(); }} 메서드 오버로딩과 가변인자의 차이점은 무엇일까? 메서드 오버로딩 : 다양한 데이터 타입 받을 수 있음 가변인자 : 데이터타입 한 종류만 받을 수 있음 메서드 오버로딩 예시 코드 12345678910111213141516171819OverloadConstructorPerson(String name, int age, boolean isHungry){ this.name = name; this.age = age; this.isHugry = false;}OverloadConstructorPerson(String name, int age){ //this()용법사용 this(name, age, false);}OverloadConstructorPerson(String name){ //this()용법사용 this(name, 0, false);}OverloadConstructorPerson(){ //아무 코드도 없으면 기존 멤버변수값이 출력된다.} 2-2 메서드에 선언된 제네릭12345678910111213141516171819202122232425262728293031323334353637public class TypeParam&lt;T&gt; { T some; //데이터타입 : T, 변수명 = some T some1; //데이터타입 : T, 변수명 = some1 public TypeParam(T some, T s1){ //생성자 (파라미터2개 : 파라미터의 데이터타입은 T이다) this.some = some; //멤벼변수와 파라미터 이름이 같아서 this를 사용 some1 = s1; //멤버변수와 파라미터 이름 달리해서 this생략가능 } public &lt;P&gt; void method1(P p){ //파라미터 데이터 타입이 p System.out.println(\"클래스 레벨의 T : \"+some.getClass().getName()); System.out.println(\"파라미터 : \"+p.getClass().getName()); } public &lt;P&gt; P method2(P p){ //리턴값의 데이터타입 p인 메서드 System.out.println(\"클래스 레벨의 T : \"+some.getClass().getName()); System.out.println(\"파라미터 : \"+ p.getClass().getName()); return p; } public static void main(String[] args) { //데이터타입 T -&gt; String으로 지정 후 객체생성 TypeParam&lt;String&gt; tpmt = new TypeParam&lt;&gt;(\"멤버변수some값설정\", \"멤버변수some1값설정\"); //some에다가 파람값 넣어줌 //멤버변수출력 System.out.println(tpmt.some); System.out.println(tpmt.some1); //파라미터 타입 명시하지않음 : 컴파일러가 매개변수의 값을 보고 파라미터 p의 데이터 타입을 결정 tpmt.method1(10); tpmt.method2(10); //파라미터 타입 직접 지정 : 파라미터타입 p -&gt; Long으로 지정 tpmt.&lt;Long&gt;method2(20L); }} 만약 객체생성시 TypeParam&lt;String&gt; tpmt = new TypeParam&lt;&gt;()하고싶다면 어떻게하면될까?생성자 오버로딩을 하면된다. 1234//생성자오버로딩 public TypeParam(){ //생성자 ( }TypeParam&lt;String&gt; tpmt = new TypeParam&lt;&gt;(); 에러가 뜨지않고 객체생성은 잘되지만 멤버변수의 데이터타입이 제네릭이기때문에 멤버변수에 값을 넣을수도없고 파라미터도 없기때문에 현 코드에서는 쓸수있는 방법이 없다. 2-3 와일드카드의 사용 제네릭 메서드에서는 사용되는 타입 파라미터에 제한을 두기 위해 와일드카드로 ‘?’를 사용 단독사용 가능 extends나 super와 함께 사용가능. 기호 설명 &lt;?&gt; 타입의 제한이 없으며 &lt;? extends Object&gt;와 동일 &lt;? extends T&gt; 와일드카드의 상한을 제한. 이 타입 파라미터에는 T와 T를 상속받은 자손만 대입할 수 있다. &lt;? super T&gt; 와일드카드의 하한을 제한. 이 타입 파라미터에는 T와 그 조상타입만 대입할 수 있다. 예시 코드 getClass() : 객체가 속하는 클래스의 정보를 알아내는 메소드이다. getName() : 클래스의 이름을 리턴하는 메소드이다. 123456789101112131415161718192021222324252627282930313233class Person{};class SpiderMan extends Person{};class PersonBox&lt;T&gt;{};public class wildTypeTest { //일반클래스 //제네릭메서드 public void method1(PersonBox&lt;?&gt; some){} //제네릭메서드 + 일반클래스상속 public void method2(PersonBox&lt;? extends Person&gt; some){} //제네릭메서드 + Person의 조상인 Object클래스 상속 public void method3(PersonBox&lt;? super Person&gt; some){} public static void main(String[] args) { wildTypeTest wtt = new wildTypeTest(); //객체생성 //메서드1의 파라미터는 사실상 제약이 없다. wtt.method1(new PersonBox&lt;Object&gt;()); wtt.method1(new PersonBox&lt;Person&gt;()); wtt.method1(new PersonBox&lt;SpiderMan&gt;()); //메서드2의 파라미터는 Person또는 Person을 상속받은 클래스를 타입 파라미터로 받을 수 있다. //wtt.method2(new PersonBox&lt;Object&gt;()); wtt.method2(new PersonBox&lt;Person&gt;()); wtt.method2(new PersonBox&lt;SpiderMan&gt;()); //메서드3의 파라미터는 Person또는 Person조상만 가능. wtt.method3(new PersonBox&lt;Object&gt;()); wtt.method3(new PersonBox&lt;Person&gt;()); //wtt.method3(new PersonBox&lt;SpiderMan&gt;()); }}","link":"/2020/07/19/200720javai2/"},{"title":"[JAVA]예외처리기법3가지 및 Error와 Exception 차이","text":"1. 오류 Error 발생하면 복구하거나 되돌릴 수 없는 심각한 상황. 발생상황 예시 : 메모리부족, 메서드끼리 호출을 무한반복등등. 처리방법 : 오류를 발생하는 요인을 찾아서 업애는 디버깅. 예방법 : 코드 짜임새있게 짜기.즉, 프로그램을 잘 짜는 것만이 대안이기때문에 예외처리와 무관하다. 2. 예외 Exception 오류와 비교하면 심각도가 낮으며 프로그램의 정상적인 흐름을 방해하는 상황. 발생상황 예시 : 네트워크 연결 끊기는 상황, 해당 파일을 읽지 못하는 상황등등. 예외처리란 : 예외가 발생했을때 비정상적인 종료를 막고 계속해서 사용할 수 있도록 처리하는 것 예외처리 라이브러리 = 최상위 클래스 = Throwable RuntiomeException = unchecked Exception : 중간에 throws 할 필요없다 그 외 예외 = checked Exception 3. 예외 처리 기법3-1. try catch finally구문 단축키 : ctrl + space try catch finally : finally블록은 무조건 실행. 예외 발생 여부와 상관없이 반드시 실행되어야하는 내용을 작성. 심지어 return문을 만날때에도 먼저 finally 블록을 실행 후 메서드가 리턴된다. finally 주요 목적 : try블록에서 사용한 시스템 자원(System Resource)의 반납처리. 1234567891011121314151617181920212223242526272829public class TryCatchFinallyFlow { public static void main(String[] args) { int num = new Random().nextInt(2); try{ System.out.println(\"코드1 : \"+ num); int i = 1/num; System.out.println(\"랜덤숫자 1일경우 예외없음\"); return; } catch (ArithmeticException e){ System.out.println(\"랜덤숫자0일경우 예외처리완료\"); } finally { System.out.println(\"코드4 : 파이널리 항상 실행\"); } System.out.println(\"코드5\"); }}//랜덤숫자가 1일경우 출력값 - return때문에 코드5출력되지않음코드1 : 1랜덤숫자 1일경우 예외없음코드4 : 파이널리 항상 실행//랜덤숫자가 0일경우 출력값코드1 : 0랜덤숫자0일경우 예외처리완료코드4 : 파이널리 항상 실행코드5 3-2. Exception 객체 정보 활용참고링크 : Throwable 메서드 getMessage()사용 123456789101112131415public class SimpleException { public static void main(String[] args) { int[] intArr = {10}; try { System.out.println(intArr[2]); } catch (Exception e) { System.out.println(\"예외발생 - 배열확인필요 : \"+ e.getMessage()); } System.out.println(\"프로그램을 종료합니다.\"); }}//출력값예외발생 - 배열확인필요 : 2프로그램을 종료합니다. printStackTrace()사용 123456789101112131415public class SimpleException { public static void main(String[] args) { int[] intArr = {10}; try { System.out.println(intArr[2]); } catch (Exception e) { e.printStackTrace(); } System.out.println(\"프로그램을 종료합니다.\"); }}//출력값java.lang.ArrayIndexOutOfBoundsException: 2프로그램을 종료합니다. at ch9.SimpleException.main(SimpleException.java:8) 3-3. try with resources 구문 try catch finally 코드가 길다. 따라서 java 7버전에서 새롭게 추가된 기능이 try with resources구문이다. 12345try (리소스타입1 res1 = 초기화; 리소스타입2 res2 = 초기화; ...){ //예외 발생 코드}catch(Exception e){ //예외 처리 코드} 4. throws 키워드를 통한 예외처리 위임예외 처리의 두번째방법은 throws 키워드를 통한 위임 또는 전달이다. throws 키워드 throws는 메서드에서 처리해야 할 하나 이상의 예외를 메서드를 호출한 곳으로 던져버린다. 이러한 위임은 처리와는 다름. 첫번째 방법이었던 try catch 에서 catch블록은 예외를 처리해서 없애 버림 BUT 위임은 예외를 없애지 못하고 그냥 호출한 곳으로 예외를 전달만 함. 예외를 전달받은 메서드는 다시 예외 처리 책임이 발생함. throws를 왜 사용할까? 항상 try catch로 처리하는 것은 좋지않다 WHY? 특히 API나 다른 모듈에서 사용되는 기능을 제공하는 경우 예외를 전달해서 그 예외에 대해 적절히 대응할 수 있는 코드를 작성할 수 있게 해줄 필요가 있기때문이다. 예 : 어떤 프로그램을 install할때 5. 사용자 정의 예외 예외가 unchecked exception계열이면 중간에 throws절차가 필요없다. (ex : runtiomeException) 고급스러운 코딩이 가능하다. 6. throw와 throws 차이둘 다 Exception을 발생시키지만 큰 차이가 있다. throws : 예외를 위임하는 예약어 throw : 억지로 예외를 발생시키는 예약어, 즉 사용자 정의에 의한 exception = 인위적인 exception이다. 생성자에 exception을 넣으면 예외 문구로 출력된다. 1throw = new throw(\"나만의 예외메세지\");","link":"/2020/07/21/200722javai/"},{"title":"[ITWILL : JAVA]내부클래스","text":"ITWILL학원 : 20강 JAVA BY 윤미영강사1. 내부클래스(p363) 클래스가 서로 밀접한 관련이 있을때 객체생성없이 사용하기 용이하다 주로 이미 만들어진 내부클래스라이브러리를 사용. 공통점 : static 변수는 가질 수 없지만, final static 변수는 가질 수 있다. 만약 상수가 아닌 변수형태로 선언이 되어있다면 그건 앞에 final이 생략되어진 것임. 변수를 사용하고싶다면 차라리 외부클래스의 멤버변수로 선언하는 것이 낫다. 내부클래스의 종류 4가지 : 2. 인스턴스 내부클래스 내부클래스를 외부클래스의 멤버변수 선언위치에 선언하는 것. 인스턴스내부클래스는 외부클래스의 멤버변수를 자신의 멤버변수처럼 불러와서 쓸 수 있다. 단독으로 사용하기도한다. 내부클래스의 메서드 사용하는 방법 : 외부클래스 객체생성 : 외부클래스명 A = new 외부클래스명(); 내부클래스 객체생성 : 내부클래스명 B = A.new 내부클래스명(); 내부클래스의 메서드 사용 : B.method(); 이러한 것을 단독사용이라고 한다. 123456789101112131415161718192021222324252627public class InstanceInner { private int outerMember = 1; private void outerMethod(){ Inner inner = new Inner(); inner.innnerMember = 11; inner.innerMethod(); } class Inner{ int innnerMember = 10; //static int staticMember = 10; staitc멤버변수 선언 불가. 만약 상수가 아닌 변수형태로 선언이 되어있다면 그건 앞에 static이 생략되어진 것임. static final int finalStaticMember = 20; //단 static final형태는 선언할 수 있다. private void innerMethod(){ System.out.printf(\"out : %d, inner %d%n\", outerMember, innnerMember); } } //내부클래스 메서드 사용은 어떻게 할까? public static void main(String[] args) { InstanceInner ilt = new InstanceInner(); //1.외부클래스객체생성 Inner inner = ilt.new Inner(); //2.내부클래스객채생성 inner.innerMethod(); //3.내부클래스의 메서드사용 }} 3. 지역클래스(local class) 내부클래스가 외부클래스의 메서드안에서 정의되어지는 것. 지역클래스는 단독으로 사용하지않고 내부에서 객체생성 후 호출해서 사용. 단독사용의 의미 : 직접 메서드를 불러와서사용, 지역클래스인 경우 메서드를 호출하는 순간 객채생성하고 바로 사용할 수 있게해야한다. 즉 단독사용처럼 직접 클래스이름을 불러 사용하는 것이 아니라 지역클래스가 속한 외부클래스메서드를 부르면서 그 속에 있는 클래스가 자동으로 사용되게끔 하는 것이다. 12345678910class OuterClass(){ ... public methodA(){ //멤버메서드 class InnerClass(){ //로컬클래스 ... } }}//객체생성 후 호출해서 주로 사용 4. 익명클래스(p373) 인터페이스를 구현할 목적으로 사용. 실무에서 자주 사용. 익명클래스의 override는 인터페이스 규칙에 의해 public을 붙여줘야한다 익명클래스를 어떨때 사용할까? 독립적인 클래스 사용 : 인터페이스를 구현한 클래스를 여러번 사용할때 용이.Intf a는 언제어디서나 불러서 사용가능 익명클래스 사용 : 인터페이스를 구현한 클래스를 딱 한번 사용할때 용이. 익명클래스는 Intf b에서만 사용가능. 이름이 없기때문에 불러서 사용할 수 없다. 1234567891011121314151617181920212223242526272829interface Intf{ void methodInf();}class A implements Intf{ @Override public void methodInf() { System.out.println(\"인터페이스 메서드 오버라이딩\"); }}public class test { public static void main(String[] args){ //기본적인 interface구현(독립적인 클래스사용) Intf a = new A(); a.methodInf(); //익명클래스를 이용한 interface구현 Intf b = new Intf(){ @Override public void methodInf() { System.out.println(\"익명클래스로 인터페이스 메서드 오버라이딩\"); } }; b.methodInf(); }} 5. 내부클래스 예시다양한 내부클래스를 생성한 뒤 main메서드로 호출해보자 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071interface InfoPrintable{ public void printInfo();}public class VariousInnerClassTest { //멤버메서드(매개변수가 인터페이스) public void useInnerClass(InfoPrintable inner){ inner.printInfo(); } //멤버메서드 public void useSpeakerTest(){ //로컬 내부클래스생성(메서드안에 선언한 내부클래스=로컬클래스) class EngSpeaker implements InfoPrintable{ @Override public void printInfo() { System.out.println(\"로컬 내부 클래스\"); } }//EngSpeaker닫음 //멤버메서드사용하여 클래스 부르기 //1. 익명의 내부클래스 생성 useInnerClass(new InfoPrintable(){ @Override public void printInfo() { System.out.println(\"익명의 내부클래스\"); } }); //2. 로컬내부클래스부르기 useInnerClass(new EngSpeaker()); //3. 인스턴스내부클래스부르기 useInnerClass(new InstanceInnerClass()); //4. 걍 밖에있는클래스 useInnerClass(new SomeClass()); }//useSpeakerTest메서드닫음 //인스턴스 내부클래스(외부클래스의 멤버에 생성) class InstanceInnerClass implements InfoPrintable{ @Override public void printInfo() { System.out.println(\"인스턴스 내부클래스 사용\"); } }//InstanceInnerClass닫음 //만든 내부클래스를 main메서드로 호출해보자 public static void main(String[] args){ VariousInnerClassTest vt = new VariousInnerClassTest(); vt.useSpeakerTest(); } }//VariousInnerClassTest닫음//걍 다른 클래스인데 인터페이스구현class SomeClass implements InfoPrintable{ @Override public void printInfo() { System.out.println(\"걍 상관없는 일반 클래스\"); } }","link":"/2020/07/22/200723javai2/"},{"title":"[ITWILL : WEB]TEXT속성","text":"1. text속성속성은 크게 두가지 그룹이 있다 font text 그 중 텍스트속성에 알아보면 아래와 같다. text 속성종류 특징 text-align 글자 정렬 text-decoration 링크속성에서 밑줄없앨때 사용 text-indent 글자 들여쓰기 text-transform 영문글자의 대소문자 지정 text-shadow 글자 그림자효과 2. text-align text-align: justy : 웹에서 많이 쓰지않지만 양끝정렬이다. 내용텍스트가 많아야 효과가 있다. 3. text-decoration 글자의 여러 줄들 active : 꾸욱 누르고있을때 나타낼수있는 속성 보통 두개를 같이 사용, 순서바뀌면 안됨 -&gt; a:link, a:visited 보통 두개를 같이 사용, 순서바뀌면 안됨 -&gt; a:hover, a:active See the Pen WNrmZgV by sowon-dev (@gracehopperdev) on CodePen. 4. text-indent 글자들여쓰기와 text-transform 영문 글자의 대소문자 지정 See the Pen oNbVGap by sowon-dev (@gracehopperdev) on CodePen.","link":"/2020/07/23/200724webi/"},{"title":"데이터정의어DDL : 테이블수정(컬럼수정, 제약조건수정, 컬럼명수정, 제약조건명수정), 테이블명변경, 테이블삭제, 테이블절단, truncate과 delete과 drop차이","text":"테이블 수정 : 컬럼컬럼추가 괄호생략가능 12alter table 테이블명add (추가할 쿼리); 예시 : 123//잡아이디컬럼을 추가하는 예시alter table dept80add (job_id varchar2(9)); 컬럼수정 괄호생략가능 수정가능한 데이터 데이터타입 : 항상 되는 건 아니다. 현재 들어가 있는 데이터에 따라 다를 수 있다. number -&gt; varchar2 변경가능 number -&gt; date 변경불가능 date -&gt; varchar2 변경가능 date -&gt; number 변경불가능 varchar2 -&gt; number 변경불가능, , BUT 컬럼 안 모든 데이터가 number형식인 경우 변경가능. varchar2 -&gt; date 변경불가능, BUT 컬럼 안 모든 데이터가 date형식인 경우 변경가능. 컬럼사이즈 : 컬럼사이즈 늘리는 건 언제나 가능한데 컬럼사이즈를 줄이는 건 에러가 발생할 수도 있다. 에러 : 오류 보고 - ORA-01441: 일부 값이 너무 커서 열 길이를 줄일 수 없음. 01441. 00000 - “cannot decrease column length because some value is too big” default값 등등 12alter table 테이블명modify (수정할 쿼리); 예시 : 123//컬럼사이즈를 30으로 수정alter table dept80modify last_name varchar(30); 컬럼삭제 column명 생략가능 -&gt; 생략시 삭제조건에 괄호필수 12345alter table 테이블명drop column 삭제하고싶은컬럼명;//또는alter table 테이블명drop (삭제하고싶은컬럼명); 예시 : 12345alter table dept80drop COLUMN job_id;//또는alter table dept80drop (job_idd); 컬럼명변경123456alter table 테이블명rename 기존컬럼명 to 새로운컬럼명;//예시alter table emp2rename cloumn employee_id to emp_number; 테이블 수정 : 제약조건기존테이블에 제약조건 추가문법이 두가지이다. 1234567//테이블레벨 문법 : PK, FK, UK, CK사용가능alter table 테이블명add constraint 고유한제약조건명 제약조건유형(컬럼명);//컬럼레벨 문법 : PK, FK, UK, CK, NN사용가능alter table 테이블명modify 컬럼명 contsraint 고유한제약조건명 제약조건유형; 예시 1234567891011121314151617//테이블레벨 문법 - primary key 추가alter table emp2add constraint e2_eid_pk PRIMARY KEY(employee_id);//컬럼레벨 문법 - primary key 추가alter table emp2modify employee_id constraint e2_eid_pk PRIMARY KEY//테이블레벨 문법 - Foreign Key 추가alter table emp2add constraint e2_did_fk foreign key(department_id) references departments(department_id);//컬럼레벨 문법 -Foreign Key 추가alter table emp2modify department_id constraint e2_did_fkreferences departments(department_id); 제약조건 확인하는 쿼리 123select constraint_name, constraint_type, search_condition, r_constraint_namefrom user_constraintswhere lower(table_name) = lower( '&amp;table_name'); 기존테이블의 제약조건 삭제 제약조건을 삭제하고싶으면 해당 제약조건명을 알고 있어야한다 제약조건명을 모르는 경우 위의 제약조건 확인하는 쿼리로 검색해서 알아내면됨 primary key 경우 제약조건명을 알지못해도 제약조건 삭제 가능. WHY? 테이블당 PK는 한번만 가능하기때문에. 헷갈리지않음 BUT, PK컬럼에 FK가 걸려있는 경우 삭제할 수 없다. 만약 FK 먼저 삭제해주면 PK삭제가능 cascade 옵션 : PK삭제시 걸림돌이 되는 제약조건까지 함께 삭제하겠다는 의미. 12345678910alter table 테이블명drop constraint 제약조건명;//primary key인경우alter table 테이블명drop primary key;//PK컬럼에 FK가 걸려있는데도 삭제하고싶은경우 (캐스캐이드옵션사용)alter table 테이블명drop primary key cascade; 예시 : 12alter table emp2drop constraint e2_eid_pk 제약조건명 변경123456alter table 테이블명rename constraint 기존제약조건명 to 새로운제약조건명;//예시alter table emp2rename constraint employee_id to emp_number; 테이블명 변경alter 명령어가 아니다. 1234rename 테이블명 to 새로운테이블명//예시rename emp2 to emp3; 테이블 삭제 가장 신중하게 명령어입력할 것. DDL구문은 오토트랜잭션에 의해 rollback 안됨. oracle은 휴지통에 잘못삭제한 테이블이 있으면 flashback가능. oracle은 휴지통을 거치지않고 테이블삭제 가능(purge) : 보안때문에 완벽하게 테이블을 지울때 사용 언제까지 휴지통에 데이터가 남아있을까? 기준은 시간이 아니라 덮어쓰여지는 작업량이다. 내가 삭제한 후 삭제됐던 테이블이 많이 없을경우 일년이 지나도 flashback할수있다. 휴지통에 버려지면 테이블명만 자동으로 바뀐 후(object_name) 일정 데이터가 휴지통에 차면 이전에 있던 데이터가 덮어쓰여지게된다. 123456789101112drop table 테이블명//1oracle만 가능한 flashback//1-1. 오라클 휴지통에 내가 drop한 테이블있는 지 확인select original_name, object_name, operation, droptimefrom recyclebin;//1-2. flashbackflashback table emp3 to before drop;//1-3. 휴지통을 거치지않고 테이블삭제 가능drop table emp3 purge; 테이블절단 truncate table 테이블 구조는 남겨두고 테이블의 모든 행 제거함 DLL구문으로 rollback안됨. 추가가능한 속성값없음. 딱 아래 코드 한 줄이 다름. 응용없음. 1truncate table table_name; truncate과 delete, drop 차이 면접질문에서 자주 물어봄 기본이 다르다. delete의 기본 : 특정행 삭제, 단 where절 생략시 모든 행 삭제도 가능. DML이다. truncate의 기본 : 모든 행 삭제, DDL이다 drop의 기본 : 테이블삭제, DDL이다.","link":"/2020/07/23/200724dbi/"},{"title":"오픈소스컨트리뷰톤 킥오프미팅 후기","text":"계기첫만남은 항상 중요하다.온라인보다 오프라인으로 함께 할 팀원들과 멘토님을 직접 대면하고 싶어 서울로 올라갔다. 오바인가싶었지만 역시 직접 만나봐야 어떤 사람인지 서로를 알 수 있고 친밀감이 생긴다.결론적으로 가길 잘했다. 환영1 격한환영2 킥오프미팅 선물 아래 두 코드의 차이점은 무엇일까?12$ git --version$ node -v : 여기서 V는 버전의 약자 깃허브에 버전관리할때 node_modules파일은 올릴 필요가 없다. why? 항상 인터넷에서 다운로드할수있으니까 gitignore에 기재하여 깃허브에 올라가지않도록 하기 참고링크 : gitignore 항상 localhost:3000/intro에서 꼭 확인하고 버그있는지 확인하고 푸쉬하기 (새로고침 안해도 바로 보임) 매번 사이트구동하기 나가는 방법 : ctrl + c 엔터를 md에서 치면 lf(맥)이거나 crlf(윈도우)일수도 있는데 머지했을때 충돌이 일어날수있다. 따라서 원본과 번역본의 라인 수가 같아야지 번역 머지를 해줌. 기본 세팅은 lf(맥)이다 =&gt; 코어자바스크립트 문자열 : https://ko.javascript.info/string 에디터 추천 에디터 : 웹스톰, vs코드 중에 웹스톤을 추천큰 회사는 스프링기반으로 백앤드를 한다.프론트개발자도 서버를 써야하니까 인텔리제이를 추천한다.(유료)왠만한 회사는 다 인텔리제이를 쓴다. 자바개발 인텔리제이 이클립스 자바스크립트개발 vs코드 웹스톰 컨트리뷰톤 목표 파트1(코어단JS) : 이미지번역 svg 파트2(브라우저별JS)번역 2020 오픈소스 컨트리뷰톤 - 발대식 라떼는말이야(방진호) 2020 오픈소스 컨트리뷰톤 - 컨트리뷰톤 지난 3년간의 회고(나동희) 주간활동계획 8월 1일 시작 그 전까지 깃플로우 완강, 번역할 아티클 잡기 1주차 : 기여목표설정, PR 2개 올리기 2주차 : 번역진행 3주차 … 등등 미팅계획 온라인 : 주2회 (주중 모임 저녁 9시이후) 오프라인 + zoom미팅: 2주1회(8월1일, 2일,8일,9일,22일,23일,9월12일,13일) 정해야할 것 Hotlist = goodFirstBug 라벨검색 보통 오타수정등이 있음. 간단한거 2개정도 돌리고 큰 빌드를 하면 시스템흐름을 알 수 있어 좋다. 빌드하는 법, 테스트돌리는법, 이슈트래커관리하는법이 중요 배울거리이다. 오픈소스에 내 패치를 보낸다 = 많은 사람들에게 내 의견을 설득하는 과정이다. 구체적인 목표를 정하기 : (이상적)최소한 일주일에 3개 패치. 하루3시간이상씩 오픈소스에 쓸 것. 이슈 -&gt; 대시보드 남기고 -&gt; 컨벤션시작 (PM과정) =&gt; 지금은 PR 마스터에 반영(BUT 실무에서는 브랜치는 나눔 git flow방법론 사용예정) 6주면 파트1다볼수있다. =&gt; 마음 맞는 사람과 스터디진행하면 좋을 듯 pull보단 fetch를 자주 씀 오픈소스컨트리뷰톤 대회심사기준커밋수, 리뷰수, 커뮤니케이션 활발한지를 중점으로 평가","link":"/2020/07/24/200725opensource/"},{"title":"[ITWILL : JSP]Javabean 10 : 게시판만들기(답글쓰기)","text":"ITWILL학원 : 30강 JSP기초 BY 정규태강사1. 답글처리구현 순서 일반글 = 답글이 아닌 글. num : 일반글+답글 둘 다 작성할때마다 계속 증가된 값으로 사용(순차적) re_ref : 답글의 그룹번호(일반글번호와 동일), 답글을 다는 원글의 그룹번호를 사용 re_lev (level) : 답글의 레벨값 (깊이), 원글을 기준으로한다 ex)한번내려가면1 두번내려가면 2 re_seq (sequence) : 답글의 순서, 원글에 답글이 몇개인지하는 순서대로 카운트. 일반글은 ref만 num값과 동일하게 초기화 답글은 lev, seq는 0으로 초기화 만약 여기서 3번글의 답글 1개를 추가한다면?6 / 답급3-1 / 3 / 1 / 1 만약 여기서 3번글의 답글 1개를 추가한다면?6 / 답글3-1 / 3 / 1 / 1 만약 여기서 3번글의 답글 1개를 또 추가한다면?7 / 답글3-2 / 3 / 1 / 2 만약 여기서 3번답글인 3-1에 답글 1개를 추가한다면?8 / 답글3-1-1 / 3 / 2 / 3 만약 여기서 4번밑에 답글을 단다면?9 / 답글4-1 / 4 / 1 / 1 만약 여기서 일반글 작성한다면?10 / 일반글 / 10 / 0 / 0 만약 여기서 답글4-1에 답글을 단다면?11 / 답글4-1-1 / 4 / 2 / 2 2. reWriteForm.jsp 작성123456789101112131415161718192021222324252627282930&lt;%//한글처리request.setCharacterEncoding(\"UTF-8\");//전달한 데이터 저장 (bno,re_ref, re_lev, &amp;re_seq)int bno = Integer.parseInt(request.getParameter(\"bno\"));int re_ref = Integer.parseInt(request.getParameter(\"re_ref\"));int re_lev = Integer.parseInt(request.getParameter(\"re_lev\"));int re_seq = Integer.parseInt(request.getParameter(\"re_seq\"));//어떻게 가져갈 것인가? 폼태그안에 담아갈까? 주소창에 GET방식으로 가져갈까?//bean의 멤버변수에 있는 변수는 폼태그안에 담아가면된다. =&gt;hidden 인풋태그%&gt;&lt;fieldset&gt;&lt;legend&gt;게시판 답글쓰기&lt;/legend&gt; &lt;form action=\"reWritePro.jsp\" method=\"post\" name=\"fr\"&gt; &lt;input type=\"hidden\" name=\"bno\" value=\"&lt;%=bno%&gt;\"&gt; &lt;input type=\"hidden\" name=\"re_ref\" value=\"&lt;%=re_ref%&gt;\"&gt; &lt;input type=\"hidden\" name=\"re_lev\" value=\"&lt;%=re_lev%&gt;\"&gt; &lt;input type=\"hidden\" name=\"re_seq\" value=\"&lt;%=re_seq%&gt;\"&gt; 글쓴이 : &lt;input type=\"text\" name=\"name\" required&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\" required&gt;&lt;br&gt; 제목 : &lt;input type=\"text\" name=\"subject\" maxlength=\"15\" value=\"[답글] \" required&gt;&lt;br&gt; 내용 : &lt;br&gt; &lt;textarea rows=\"10\" cols=\"35\" name=\"content\" placeholder=\"여기에 답글을 작성해주세요\" required&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"답글등록\" class=\"btn\"&gt; &lt;button type=\"reset\" class=\"btn\"&gt;초기화&lt;/button&gt; &lt;input type=\"button\" value=\"목록으로\" class=\"btn\" onclick=\"location.href='boardList.jsp'\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 3. reWritePro.jsp 작성1234567891011121314151617181920&lt;%// 한글 처리 request.setCharacterEncoding(\"UTF-8\");// 액션태그 사용 파라미터값 저장// useBean,setProperty%&gt;&lt;jsp:useBean id=\"bb\" class=\"com.itwillbs.board.BoardBean\"/&gt;&lt;jsp:setProperty property=\"*\" name=\"bb\"/&gt; &lt;%System.out.println(bb);// ip 정보 저장bb.setIp(request.getRemoteAddr());// BoardDAO 객체 생성 - reInsertBoard(객체)BoardDAO bdao = new BoardDAO();bdao.reInsertBoard(bb); // 페이지 이동(글 목록)response.sendRedirect(\"boardList.jsp\");%&gt; 4. BoardDAO.java에서 reInsertBoard(BoardBean bb)메서드 만들기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void reInsertBoard(BoardBean bb){ //1.지역변수생성 int num = 0; //2. 디비연결 try { getCon(); //sql(게시판의 글번호 중 최댓값 계산) &amp; pstmt //2-1. 답글번호 계산 sql = \"select max(bno) from itwill_board\"; pstmt = con.prepareStatement(sql); // 실행 rs = pstmt.executeQuery(); // 데이터 처리 if(rs.next()){ num = rs.getInt(1)+1; } System.out.println(\" 답글 번호 : \"+num); //2-2. 답글 순서 재배치 //re_ref(같은 그룹기준)으로 re_seq값이 기존의 값보다 큰 값이 있을경우 seq값을 1증가시킴 sql = \"update itwill_board set re_seq=re_seq+1 \" + \"where re_ref=? and re_seq&gt;?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bb.getRe_ref()); pstmt.setInt(2, bb.getRe_seq()); pstmt.executeUpdate(); //2-3. 답글 추가 동작 sql=\"insert into itwill_board \" + \"values(?,?,?,?,?\" + \",?,?,?,?,now()\" + \",?,?)\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, num);//bno는 가지고있는게 아니라 계산해서 만든것이므로 num사용 pstmt.setString(2, bb.getName()); pstmt.setString(3, bb.getPw()); pstmt.setString(4, bb.getSubject()); pstmt.setString(5, bb.getContent()); pstmt.setInt(6, bb.getReadcount()); pstmt.setInt(7, bb.getRe_ref()); //기존 원글의 그룹번호와 동일 pstmt.setInt(8, bb.getRe_lev()+1); // 기존의 값 + 1 pstmt.setInt(9, bb.getRe_seq()+1); // 기존의 값 + 1 pstmt.setString(10, bb.getFile()); pstmt.setString(11, bb.getIp()); //3. 실행 pstmt.executeUpdate(); System.out.println(\"답글쓰기 성공\"); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } } //reInsertBoard닫음 5. BoardList.jsp에서 답글 들여쓰기 추가 구현이미지와 조건문을 통해 구현 img src=”level.gif” width=”&lt;%=wid%&gt;” height=”15” img src=”re.gif” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;fieldset&gt;&lt;legend&gt;땡땡게시판&lt;/legend&gt; &lt;div id=\"contents\"&gt; 게시판 총 글의 수 : &lt;%=cnt%&gt; 개 &lt;% if(id == null){ %&gt; &lt;input class=\"btn\" type=\"button\" value=\"로그인\" onclick=\"location.href='../member/main.jsp'\"&gt; &lt;% }else if( id != null){ %&gt; &lt;input class=\"btn\" type=\"button\" value=\"로그아웃\" onclick=\"location.href='../member/logout.jsp'\"&gt; &lt;input class=\"btn\" type=\"button\" value=\"글쓰기\" onclick=\"location.href='writeForm.jsp'\"&gt; &lt;% } %&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;글번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;th&gt;작성일&lt;/th&gt; &lt;th&gt;IP&lt;/th&gt; &lt;/tr&gt; &lt;%//반복문 //ArrayList는 가변배열이므로 length가 없고 size가 존재한다. //size()메서드는 배열의 요소의 갯수를 리턴 for(int i=0;i&lt;boardList.size(); i++){ //ArrayList 한칸의 정보 -&gt;BoardBean 객체 하나로 이동 BoardBean bb = (BoardBean) boardList.get(i); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=bb.getBno()%&gt;&lt;/td&gt; &lt;td&gt; &lt;% //답글일때만 이미지넣기 //변수 wid를 이용하여 들여쓰기 처리 int wid = 0; if(bb.getRe_lev() &gt; 0){ wid= 10 * bb.getRe_lev(); //레벨값의 10을 곱한 값만큼 이미지 가로길이를 길게해줌 %&gt; &lt;img src=\"level.gif\" width=\"&lt;%=wid%&gt;\" height=\"15\"&gt; &lt;img src=\"re.gif\"&gt; &lt;% } %&gt; &lt;a href=\"content.jsp?bno=&lt;%=bb.getBno()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;\"&gt;&lt;%=bb.getSubject()%&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getName()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getReadcount()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getDate()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getIp()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;/table&gt; &lt;/div&gt;&lt;/fieldset&gt;","link":"/2020/07/22/200723jspi2/"},{"title":"[ITWILL : WEB]마진과 패딩, 인라인과 블록 차이","text":"ITWILL학원 : 10강 WEB(HTML, CSS) BY 김영희1. margin 마진 테두리기준 바깥여백 margin왼쪽값과 오른쪽값이 서로 같으면 요소는 항상 중앙에 온다. 따라서 margin의 좌우값을 auto를 지정 margin : 위 오른 아래 왼 2. padding 패딩 테두기리준 안쪽여백 padding : 위 오른 아래 왼 3. margin과 padding 차이 4. inline과 block 차이 참고링크 : HTML 정의태그 dl, dt, dd 태그, code 태그, block VS inline VS inline-block 인라인요소(한줄에 나란히 오는 요소, 줄바꿈이 없는 요소) : 상하 margin과 height와 width 아예 적용 안됨 좌우 margin가능 img태그와 input태그는 예외","link":"/2020/07/23/200724webi2/"},{"title":"[ITWILL : JAVA]로깅, 디버깅","text":"ITWILL학원 : 20강 JAVA BY 윤미영강사1. 로깅(Logging) 로깅 : 사용자의 요청사항을 출력하는 것 이외에 애플리케이션에서 발생하는 사건들을 기록하는 것. 참고링크 : java.util.Logging.Logger의 메서드 123456789101112131415161718192021222324public class SimpleLoggingFile { private final static Logger logger = Logger.getLogger(SimpleLoggingFile.class.getName()); public static void main(String[] args) throws SecurityException, IOException { FileHandler fHandler = new FileHandler(\"mylog_%g.log\"); logger.addHandler(fHandler); logger.log(Level.INFO, \"INTO LOG\"); logger.info(\"메서드 타입 인포 로그\"); logger.warning(\"메서드 타입 경고 로그\"); logger.severe(\"메서드 타입 시비어 로그\"); }}//출력값7월 23, 2020 11:11:40 오전 ch9.SimpleLoggingFile main정보: INTO LOG7월 23, 2020 11:11:40 오전 ch9.SimpleLoggingFile main정보: 메서드 타입 인포 로그7월 23, 2020 11:11:40 오전 ch9.SimpleLoggingFile main경고: 메서드 타입 경고 로그7월 23, 2020 11:11:40 오전 ch9.SimpleLoggingFile main심각: 메서드 타입 시비어 로그 더불어 mylog_0.log파일이 생성되었다. 출력된 로그는 콘솔과 함께 파일에도 기록된다. 실무에서는 logging패키지의 클래스보다 주로 logback과 같은 별도의 로깅 프레임워크들을 사용함. 2. 디버깅 리커시브방법 : 함수가 자기 자신을 계속 호출하는 구조 = 재귀함수 데이터처리 -&gt; for문과 동일한 결과이기에 실무에선 반복문을 많이 사용한다. 참고링크 : 데이터구조 - 재귀함수 break point : 프로그램 동작 중 디버깅을 위해서 동작을 멈추는 지점 중단점을 지정해 놓으면 그 전까지 프로그램이 동작하다가 브레이크포인트에서 사용자의 다음동작을 기다린다. step into를 하면 변수뷰창에서 valables가 어떻게 변화하는지 알수있다.","link":"/2020/07/22/200723javai/"},{"title":"[ITWILL : JSP]Javabean 12 : 게시판만들기(파일업로드), UTF-8과 EUC-KR차이","text":"ITWILL학원 : 31강 JSP기초 BY 정규태강사1. 새로운 프로젝트 fileUpload 생성 새로운 다이나믹 앱 프로젝트 생성 : 프로젝트명 fileUpload 라이브러리 추가 : cos.jar를 복사하여 D:\\fileUpload\\WebContent\\WEB-INF\\lib에 복붙하기 WebContent하위에 fileUP폴더 생성 후 그 안에 up.html페이지 생성(아래 단계) 2. up.html 작성 up.html의 meta charset=&quot;UTF-8&quot; 에서 meta charset=&quot;euc-kr&quot;로 변경 UTF-8과 euc-kr 둘 다 한글을 처리하는 메타태그임. UTF-8 : 한글 조합형의 유니코드 인코딩방식 EUC-KR : 한글 완성형의 유니코드 인코딩방식. 한글 2BYTE로 사용. 참고링크 : UTF-8과 EUC-KR의 차이점 12345678&lt;fieldset&gt;&lt;legend&gt;파일업로드&lt;/legend&gt;&lt;form action=\"up.jsp\" method=\"post\" enctype=\"multipart/form-data\"&gt; 이름 : &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt; 파일 : &lt;input type=\"file\" name=\"upfile\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"파일업로드\"&gt;&lt;/form&gt;&lt;/fieldset&gt; 3. up.jsp 작성 에러해결 : java build path &gt; library &gt; add library &gt; server runtime &gt; 톰캣 추가 UTF-8을 euc-kr로 싹 다 바꾸기 onclick에 function을 넣어도 되고 location.href넣어도 둘 다 동일한 결과 출력된다. input type=”button” value=”파일삭제” onclick=”delfile()” input type=”button” value=”파일삭제” onclick=”location.href=’./delup.jsp’” 참고링크1 : Enumeration 참고링크2 : Enumeration 참고링크3 : Enumeration 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;%//1. 전달되는 데이터 인코딩request.setCharacterEncoding(\"euc-kr\");//2. 업로드 폴더 지정(절대경로 = 파일을 직접적으로 접근하는 방식)String savePath = \"d:\\\\upfile\"; //3. 업로드 파일 크기 =&gt; 10MBint maxSize = 10 * 1024 * 1024;//4. 파일 이름 저장하는 변수 생성String fileName=\"\";String originalFileName=\"\";//5. 예외처리 포함한 파일업로드try{ MultipartRequest multi = new MultipartRequest(request, savePath, maxSize, \"euc-kr\", new DefaultFileRenamePolicy()); //여기까지 파일업로드완료 //6. 파일업로드 결과를 화면에 출력 //6-1. 폼의 이름 반환 Enumeration formNames = multi.getFileNames(); //업캐스팅 //6-2. 전달된 파일의 정보를 저장 String formname = (String) formNames.nextElement(); //위의 업캐스팅한 걸 다운캐스팅 //7. 서버에 저장된 파일의 이름저장 fileName = multi.getFilesystemName(formname); //8. 원래 파일의 이름 저장 originalFileName = multi.getOriginalFileName(formname); //9.파일업로드 성공시 해당 정보 출력 if(fileName == null){ out.println(\"파일업로드 실패!\"); }else{ out.print(\"업로드한 사람 : \"+multi.getParameter(\"name\") +\"&lt;br&gt;업로드 파일이름(서버저장) : \"+fileName+\"&lt;br&gt;업로드 파일이름(원본): \"+originalFileName +\"&lt;br&gt;file태그정보 : \"+formname); } }catch(Exception e){ out.println(\"파일업로드 중 예외상황발생\"); e.printStackTrace();}%&gt;&lt;fieldset&gt;&lt;form method=\"post\" name=\"myform\"&gt; &lt;input type=\"text\" name=\"filename\" value=\"&lt;%=fileName%&gt;\"&gt; //onclick에 function을 넣어도 되고 location.href넣어도 동일한 결과 출력 &lt;input type=\"button\" value=\"파일삭제\" onclick=\"delfile()\"&gt; &lt;input type=\"button\" value=\"파일삭제\" onclick=\"location.href='./delup.jsp'\"&gt; &lt;input type=\"button\" value=\"파일다운로드\"&gt;&lt;/form&gt; &lt;/fieldset&gt; 4. delup.jsp 생성한글파일빼고는 삭제가 잘 진행된다.인코딩방식의 문제이므로 나중에 처리하기로한다 12345678910111213141516&lt;%//1. 전달된 파일 이름 저장String filename = request.getParameter(\"filename\");//2. 파일 객체 생성 -&gt; 삭제//File f = new File(\"해당파일의 위치+파일명\");//객체를 만든 순간 = 해당 폴더로 이동해서 파일을 선택한 상황임.File f = new File(\"D:\\\\upfile/\"+filename);//3. 파일삭제f.delete();out.println(\"파일삭제완료\");//3-1. 한글파일빼고는 삭제가 잘 진행된다.out.println(filename);%&gt;","link":"/2020/07/26/200727jspi2/"},{"title":"[ITWILL : JSP]Javabean 13 : 게시판만들기(파일다운로드)","text":"ITWILL학원 : 31강 JSP기초 BY 정규태강사이 부분은 어렵다. 반복해서 보자. 1. up.jsp에 onclick이벤트 연결 onclick에 function을 넣어도 되고 location.href넣어도 둘 다 동일한 결과 출력된다. input type=”button” value=”파일삭제” onclick=”downfile()” input type=”button” value=”파일삭제” onclick=”location.href=’./down.jsp’” 12345678910111213141516171819&lt;fieldset&gt;&lt;form method=\"post\" name=\"myform\"&gt; &lt;input type=\"text\" name=\"filename\" value=\"&lt;%=fileName%&gt;\"&gt; &lt;input type=\"button\" value=\"파일삭제\" onclick=\"delfile()\"&gt; &lt;input type=\"button\" value=\"파일다운로드\" onclick=\"downfile()\"&gt;&lt;/form&gt; &lt;/fieldset&gt;&lt;script type=\"text/javascript\"&gt; function delfile(){ document.myform.action=\"./delup.jsp\"; //myform이름의 폼태그의 action값을 설정 document.myform.submit(); } function downfile(){ document.myform.action=\"./down.jsp\"; //myform이름의 폼태그의 action값을 설정 document.myform.submit(); }&lt;/script&gt; 2. down.jsp생성 인코딩 모든 UTF-8을 EUC-KR(euc-kr)로 변경해준다. 대소문자 둘 다 가능. string은 그냥 담아도 되고 객체에 담아도 된다. 즉 1번과 2번이 동일 WHY? String의 특징! 1번 : String filename=request.getParameter(“filename”) 2번 : String filename= new String(request.getParameter(“filename”)); java.io 아래에 있는 입출력 객체를 import한다 참고링크 : 스트림 개념 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;%@page import=\"java.io.FileNotFoundException\"%&gt;&lt;%@page import=\"java.io.FileInputStream\"%&gt;&lt;%@page import=\"java.io.File\"%&gt;&lt;%@page import=\"java.io.OutputStream\"%&gt;&lt;%@page import=\"java.io.InputStream\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=euc-kr\" pageEncoding=\"euc-kr\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=euc-kr\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;다운로드페이지&lt;/h2&gt;&lt;%//1. 인코딩//string은 그냥 담아도 (=String filename=request.getParameter(\"filename\"))되고 객체에 담아도된다//String filename= new String(request.getParameter(\"filename\"));//파라미터 데이터를 가져와서 8859_1 인코딩방식으로 바꾼 뒤 EUC-KR로 한번 더 바꾸는 것String filename = new String((request.getParameter(\"filename\")).getBytes(\"8859_1\"),\"euc-kr\");//2. 파일저장경로(절대경로)String filePath = \"D:/upfile\"; //3. 입출력시 필요한 객체 생성InputStream in = null;OutputStream os = null;File file = null;File viewFile = null;//3-1. 추가 레퍼런스생성boolean skip = false; //플래그만들기String client = \"\";// 4. 예외처리try{ //5. 변수생성 : 인코딩시 변경되는 string 따로 저장하려고 3개 변수 만듬 String fname1 = \"\"; String fname2 = \"\"; String fname = \"\"; fname = filename; fname1 = new String(fname.getBytes(\"8859_1\"), \"euc-kr\"); //9. try catch구문으로 묶기 try{ //6. 전달된 파일 경로,이름 사용해서 파일 객체 생성 file = new File(filePath, fname); viewFile = new File(filePath,fname1); //확인차 페이지에 출력 out.print(\"file : \"+file+\"&lt;br&gt;\"); out.print(\"viewfile : \"+viewFile); //8. 파일을 읽어오기 위해서 입력 통로를 생성 // 객체를 만든 순간 = 해당 폴더로 이동해서 파일을 선택한 상황임. // InputStream in = null; in = new FileInputStream(file); //업캐스팅 }catch(FileNotFoundException e){ skip = true; } //10. String변수만들어주기 fname2 = new String(fname1.getBytes(\"euc-kr\"), \"8859_1\"); //11. 응답객체초기화 for 다운로드 팝업창 생성된 것처럼 보이게끔하여 다운로드 진행중임을 표시 response.reset(); 2-1. down.jsp에 다운로드기능 구현 코드다운로드 기능을 구현하고자한다. 위의 코드에 이어서 작성해보자 MIME타입 : 웹에서 데이터를 표현하는 방법이다. 참고링크 : MIME 타입 참고링크 : 바이트스트림 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 //12. 다운로드처리 //12-1. 클라이언트가 다운로드 요청시 사용자 웹브라우저 정보필요 //why? 브라우저별로 설정해줘야하는 것들이 다르기 때문 client = request.getHeader(\"User-Agent\"); //System.out.println(\"client :\" + client); //12-2. 사용자브라우저에 따른 처리 //12-2-1. mine 타입이용하여 값세팅하기 response.setContentType(\"application/x-msdownload\"); response.setHeader(\"Content-Description\", \"JS Generated Data\"); //12-2-2. 브라우저마자 실행 제어 if(!skip){ //false항상실행 if(client.indexOf(\"MSIE 5.5\") != -1){ response.setHeader(\"Content-Type\", \"doesn/matter; charset=euc-kr\"); response.setHeader(\"Content-Disposition\", \"filename\"+ new String(fname.getBytes(\"euc-kr\"),\"8859_1\")); }else{ response.setHeader(\"Content-Type\", \"application/octet-stream; charset=euc-kr\"); response.setHeader(\"Content-Disposition\", \"attachment; filename=\"+new String(fname.getBytes(\"euc-kr\"),\"8859_1\")); } //12-2-3. 문자열만들기 response.setHeader(\"Content-Transfer-Encoding\", \"binary;\"); response.setHeader(\"Content-Length\", \"\"+file.length()); response.setHeader(\"Pragma\", \"no-cache;\"); response.setHeader(\"Expires\", \"-1;\"); //12-3. 데이터출력할 수 있는 통로 생성 os = response.getOutputStream(); //12-3-1. 바이트스트림 byte[] b = new byte[4096]; int leng = 0; //12-3-2. 파일을 읽어서 leng에 저장이 될 것이고 데이터가 있을 경우에만 진행 //leng은 데이터가 없으면 -1값을가진다 while((leng = in.read(b))&gt; 0){ //데이터출력(다운로드) os.write(b,0,leng); } }else{ out.print(\"파일다운로드 실패\"); return; } }catch(Exception e){ System.out.println(\"다운로드도중 에러발생\"); e.printStackTrace();}finally{ if(in != null) in.close(); if(os != null) os.close();}%&gt;","link":"/2020/07/26/200727jspi3/"},{"title":"[ITWILL : JSP]Javabean 11 : MultipartRequest클래스","text":"ITWILL학원 : 31강 JSP기초 BY 정규태강사 MultipartRequest클래스 (p305)MultipartRequest 클래스의 생성자와 메소드들을 사용하여 파일 업로드 기능 구현 1. 라이브러리 설치 servlets페이지 방문. 왼쪽 카테고리 COS File Upload Library 클릭 하여 com.oreilly.servlet로 이동. 맨 하단에 Download 에서 Version 밑에 zip압축파일 다운로드. lib폴더 안의 cos.jar복사하여 프로젝트의 WebContent\\WEB-INF\\lib에 붙여넣기. 2. fwriteForm.jsp 작성 cos.jar라이브러리설치 (위에 내용 참고) 폼태그속성 enctype=”multipart/form-data”, method=”post” get방식은 처리되지 않음. enctype속성때문에 참고링크 : 속성종류 3가지 D드라이브에 `upfile’ 폴더생성 D드라이브말고 원하는 경로 지정가능. 123456789101112131415161718192021222324252627282930&lt;%String id = (String) session.getAttribute(\"id\");if( id == null){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"로그인 후 이용가능합니다\"); location.href=\"../member/loginForm.jsp\" &lt;/script&gt; &lt;%}//1. cos.jar라이브러리설치 (위에 내용 참고)//2. 폼태그속성 enctype=\"multipart/form-data\", method=\"post\" get방식은 처리되지 않음.//3. D드라이브에 `upfile' 폴더생성- D드라이브말고 원하는 경로 지정가능.%&gt;&lt;fieldset&gt;&lt;legend&gt;게시판 글쓰기(p305~)&lt;/legend&gt; &lt;form action=\"fwritePro.jsp\" method=\"post\" enctype=\"multipart/form-data\"&gt; 글쓴이 : &lt;input type=\"text\" name=\"name\" required&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\" required&gt;&lt;br&gt; 제목 : &lt;input type=\"text\" name=\"subject\" maxlength=\"15\" required&gt;&lt;br&gt; 내용 : &lt;br&gt; &lt;textarea rows=\"10\" cols=\"35\" name=\"content\" placeholder=\"여기에 작성해주세요\" required&gt;&lt;/textarea&gt;&lt;br&gt; 파일 : &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\" value=\"글등록\" class=\"btn\"&gt; &lt;button type=\"reset\" class=\"btn\"&gt;초기화&lt;/button&gt; &lt;input type=\"button\" value=\"목록으로\" class=\"btn\" onclick=\"location.href='boardList.jsp'\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 3. fwritePro.jsp 작성파일업로드구현 파일 업로드 =&gt; cos.jar (MultipartRequest 클래스) 파일이 저장되는 위치 (D:/upfile) 파일 업로드 최대 크기 크기를 왜 지정해야할까? 그 전에 파일을 업로드하면 어디로 저장되는지 알아야한다 서버의 upfile폴더안으로 들어간다. 따라서 유한한 디스크이고 메모리라서 최대 크기 지정이 필수이다. 보통 20~250MB이다. 1MB = 1024바이트 * 1024바이트 계산 꼭 하기 MultipartRequest생성 : import하기 (다운받았던 cos.jar라이브러리) 아래 코드처럼 객채생성하면 에러메세지가 뜬다1MultipartRequest multi = new MultipartRequest(); The constructor MultipartRequest() is undefined 기본생성자가 없는 클래스이다 따라서 아래처럼 괄호안에 오버로딩되는 생성자를 작성해야한다. MultipartRequest(요청정보,파일 업로드할 폴더,파일 업로드 제한 크기,인코딩방식,파일 이름동일시 처리객체)1MultipartRequest multi = new MultipartRequest(request, savePath, maxSize, &quot;UTF-8&quot;, new DefaultFileRenamePolicy()); new DefaultFileRenamePolicy 객체의 역할 : 우리가 동일한 파일을 다운로드받는 경우 파일명에 파일명(1), 파일명(2)등등 자동으로 구분할 수 있도록 rename해주는 역할을 한다. 즉 중복처리하는 객체. 1234567891011121314&lt;%//파일 업로드 =&gt; cos.jar (MultipartRequest 클래스)//1. 파일이 저장되는 위치 (D:/upfile)String savePath = \"d:\\\\upfile\"; //2. 파일 업로드 최대 크기 =&gt; 5MBint maxSize = 5 * 1024 * 1024;//3. MultipartRequest 객체생성MultipartRequest multi = new MultipartRequest(request, savePath, maxSize,\"UTF-8\", new DefaultFileRenamePolicy());//4. 파일 업로드 완료 확인out.println(\"파일 업로드 완료!\");%&gt; 테스트하면 만들었던 upfile폴더안에 저장되어있다. 성!공!적! 하지만 이 방법은 보안상 매우 위험하다 누구나 주소를 입력하여 upfile폴더에 접근가능하기때문이다. 이제 디비와 연결해보자. 4. 디비연결위의 코드에서 아래 코드를 더 추가해야한다. multi객체 안에 request가 있으므로 request.getParameter()가 아닌 multi.getParameter()로 가지고 와야한다. 1234567891011121314151617181920212223242526//6. 파일의 정보 + 글 정보를 디비에 저장//6-1. 글정보저장하는 객체생성BoardBean bb = new BoardBean();//6-2. 전달되는 정보 저장// bb.setName(request.getParameter(\"name\")); enctype과 함께 쓸 수없다bb.setName(multi.getParameter(\"name\"));bb.setPw(multi.getParameter(\"pw\"));bb.setSubject(multi.getParameter(\"subject\"));bb.setContent(multi.getParameter(\"content\"));// bb.setFile(multi.getParameter(\"file\")); //DB에 파일저장 불가-&gt;아래코드로 진행bb.setFile(multi.getFilesystemName(\"file\"));System.out.println(\"upfile에 저장된 파일명 : \"+multi.getFilesystemName(\"file\"));System.out.println(\"사용자가 올린 원본 파일명 : \"+multi.getOriginalFileName(\"file\"));//6-3. 따로 저장한 정보 저장bb.setIp(request.getRemoteAddr());//7. boardDAO객체생성BoardDAO bdao = new BoardDAO();//8. 글쓰기 메서드 호출bdao.insertBoard(bb);//9. 목록페이지로 이동response.sendRedirect(\"boardList.jsp\"); DB에도 잘 들어가는 걸 확인할 수 있다.동일한 페이지 두번 작성하면 upfile에 저장된 파일명은 자동적으로 뒤에 숫자가 붙어 고유한 파일명으로 업로드가능하다.","link":"/2020/07/26/200727jspi/"},{"title":"SQL의 OBJECT종류 : 시퀀스(Sequence)","text":"SQL의 OBJECT 종류 Object 특징 사용방법 정의방법 테이블(Table) 행과 열의 조합으로 구성된 기본 저장단위 select, insert, update, delete create table, alter table, drop table, truncate table 뷰(View) 하나 또는 그 이상의 base테이블로부터 논리적으로 데이터를 추출한 부분집합으로 가상의 논리적인 테이블 select, insert, update, delete create [or replace] view, drop view 시퀀스(Sequence) 자동으로 고유한 숫자값을 생성해주며 주로 기본키 값을 생성하기 위해 사용 시퀀스명.nextval, 시퀀스명.currval create sequence, alter sequence, drop sequence 인덱스(Index) 쿼리(Query) 속도를 향상시키기 위해 사용 X create index, alter index, drop index 시노님(Synonym) object에 대한 또다른 이름의 alias역할 X create synonym, drop synonym 시퀀스 생성(create sequence) 자동으로 고유한 번호를 반환해 주는 번호생성기와 같은 오브젝트. 주로 PK제약조건과 함께 사용한다. 주로 insert와 update사용한다. 옵션여러개 기입시 콤마(,)필요없다! 절대 찍지말것! 시퀀시 생성시 사용가능한 옵션 increment by 숫자 : 시퀀스번호사이에 간격을 지정하는 옵션. default값은 1이다. 생략하면 1씩 증가하는 값을 반환해주는 시퀀스가 생성된다. 예시 : increment by 5 : 5씩 증가하는 값을 반환해주는 시퀀스를 만든다는 의미. 예시 : increment by -1 : 1씩 감소하는 값을 반환해주는 시퀀스를 만든다는 의미. start with 숫자 : 시퀀스번호의 시작값을 지정하는 옵션. default값은 1이다. 예시 : start with 100 : 100부터 시작하는 시퀀스를 만든다는 의미. maxvalue와 minvalue :시퀀스번호의 최댓값, 최소값을 지정하는 옵션. default값은 nomaxvalue와 nominvalue이다. 즉 시스템에 정의되어있는 최대값과 최소값을 쓰겠다는 의미. 시스템 최대값 : 10의 27승 시스템 최소값 : 10의 -26승 cycle 사용하고자하는 컬럼이 PK나 UQ제약조건이 있는 경우 cycle 옵션을 건 경우 중복값이 발생해 에러가 발생할 수 있다. 디폴트값은 nocycle이다. maxvalue나 minvalue를 끝으로 순환한다 즉 다시 처음부터 시작한다. 예시 : maxvalue가 100이면 100값이 지난뒤 다시 1부터 시작 cache 숫자 원하는 숫자만큼 미리 만들어 Shared Pool의 Library Cache에 상주시킴. 메모리에 시퀀스 값을 미리 할당 for 성능향상. 디폴트값은 cache 20이다. cache를 사용하고싶지않다면 nocache를 입력해야한다. CACHE는 시스템 번호를 생성하는 데 필요한 디스크 IO 수를 최소화하여 시퀀스 개체를 사용하는 응용 프로그램의 성능을 향상시킵니다. 전원 오류와 같은 예기치 않은 종료로 인해 캐시에 남아 있는 시퀀스 번호가 손실될 수 있습니다. 값을 1로 설정하는 경우 캐쉬가 없이 스퀀스가 실행되므로 디스크 IO가 매번 일어 납니다. 예시 : cache 5인경우, 시퀀스가 호출될때 미리 만들어진 캐시메모리를 빨리 전달해줌. 1234567891011121314151617//기본 =&gt; 모든 옵션생략시 6개의 옵션의 디폴트값으로 적용됨create sequence 시퀀스명//기본+옵션create sequence 시퀀스명 [increment by n] [start with n] [maxvalue n 또는 nomaxvalue] [minvalue n 또는 nominvalue] [cycle 또는 nocycle] [cache n 또는 nocache]; //예시 (옵션여러개 기입시 콤마필요없다! 절대 찍지말것)create sequence dept_id_seq increment by 10 start with 350 maxvalue 1000; 시퀀스 사용(nextval와 currval) 시퀀스사용하는 방법은 두가지이다 : nextval와 currval 컬럼과 데이터 삽입시 시퀀스 활용하면 용이하다. 여러 테이블에 사용가능하다. 테이블 바뀐다고해서 시퀀스가 처음값으로 반환되는 건 아니다. 시퀀스는 insert, update, select구문을 날릴때마다 시퀀스 값이 올라간다 따라서 의미없는 시퀀스 사용을 자제해야한다 그렇다면 시퀀스를 쓰지않고 마지막 시퀀스 사용값을 어떻게 확인 할 수 있을까? nextval대신 currval을 쓰면 된다 = &gt; select dept_id_seq.currval from dual; WHY? 데이터딕셔너리에 값이 남기때문에! 예시 : A테이블에서 기본 시퀀스를 쓰며 컬럼을 INSERT 5번(마지막 시퀀스 5)했다. 그리고 테이블을 바꿔서 B테이블에서 INSERT를 1번했다 그렇다면 B테이블의 첫번째컬럼 시퀀스는 몇번일까? 정답은 6이다. A테이블에서 마지막 시퀀스 5였으므로 B테이블의 첫번째컬럼은 시퀀스 6이다. 12345678910111213//기본 두가지시퀀스명.nextval시퀀스명.currval//예시 : nextvalinsert into departmentsvalues(dept_id_seq.nextval, 'XXX', 108, 1700);select * from departments;//예시 : currvalselect dept_id_seq.currvalfrom dual; 시퀀스사용시 갭발생하는 이유 주로 rollback때문에 발생한다. rollback때문에 gab이 발생할 수 있다. rollback은 테이블과 관련되어있는 DML을 취소시켜주는 것이지 시퀀스를 취소시켜주는 것은 아니다. 시퀀스를 돌이킬수는 없다. 따라서 갭이 발생했다면 수동으로 데이터를 처리(insert, update등)하면 된다. 예시 : A테이블에서 기본 시퀀스를 쓰며 컬럼을 INSERT 5번(마지막 시퀀스 5)한 뒤 commit을 했다. 그리고 테이블을 바꿔서 B테이블에서 INSERT를 1번했다가 B테이블의 첫번째컬럼 시퀀스는 몇번일까? 정답은 6이다. A테이블에서 마지막 시퀀스 5였으므로 B테이블의 첫번째컬럼은 시퀀스 6이다. 시퀀스 수정(alter) 변경가능 : 시퀀스간격, 최대값, 최소값, cycle옵션, cache옵션 변경불가능 : 시작값 (start with n) 시작값(start with n)을 변경하고 싶다면 시퀀스 삭제하고 새로 생성하면 된다. 1234567891011121314//기본alter sequence 시퀀스명 [increment by n] [maxvalue n 또는 nomaxvalue] [minvalue n 또는 nominvalue] [cycle 또는 nocycle] [cache n 또는 nocache];//예시alter sequence dept_deptid_seq increment by 20 maxvalue n 9999 nocycle nocache; 시퀀스 삭제(drop)12345//기본drop sequence 시퀀스명;//예시drop sequence dept_deptid_seq;","link":"/2020/07/28/200729dbi/"},{"title":"SQL의 OBJECT종류 : 뷰(View)","text":"코드블록상에 [] 대괄호는 생략가능하다는 의미이다. SQL의 OBJECT 종류 지금까지 테이블(table) object에 관한 것을 배웠다. 이제 다른 object들을 배워보자. Object 특징 사용방법 정의방법 테이블(Table) 행과 열의 조합으로 구성된 기본 저장단위 select, insert, update, delete create table, alter table, drop table, truncate table 뷰(View) 하나 또는 그 이상의 base테이블로부터 논리적으로 데이터를 추출한 부분집합으로 가상의 논리적인 테이블 select, insert, update, delete create [or replace] view, drop view 시퀀스(Sequence) 자동으로 고유한 숫자값을 생성해주며 주로 기본키 값을 생성하기 위해 사용 시퀀스명.nextval, 시퀀스명.currval create sequence, alter sequence, drop sequence 인덱스(Index) 쿼리(Query) 속도를 향상시키기 위해 사용 X create index, alter index, drop index 시노님(Synonym) object에 대한 또다른 이름의 alias역할 X create synonym, drop synonym View 하나 이상의 base table을 기반으로 생성은 되었으나 물리적으로 존재하지 않고 data dictionary에 select 구문 형태로 정의만 되어 있는 가상의 논리적인 테이블 테이블도 아무나 만들 수 없듯이 뷰도 뷰권한을 가진 유저만이 사용할 수 있다. create biew 권한을 가진 유저만이 뷰를 생성할 수 있다. 가상테이블도 테이블이므로 사용방법은 테이블과 동일하다. (insert, update, select, delete가능) 사용방법 : select, insert, update, delete 정의방법 : create [or replace] view, drop view DDL이라 오토커밋발생하기에 rollback안됨. 뷰 장점 : 보안성 좋음 보안성이 좋아서 table대신 table컬럼의 필요한 컬럼을 모아 view를 사용 공간적 효율성이 좋음 편의성이 높음 두 테이블을 join해서 자주 보는 경우 귀찮기때문에 아예 두 테이블에 자주 보는 정보를 join한 채로 view를 만들어서 편리하게 사용할 수 있다. 쿼리를 save하는 것과의 차이점은 save는 스크립트파일을 운영체제안에 저장. view는 DB안에 저장. 따라서 다른 개발자들과 함께 save쿼리를 사용하려면 스크립트파일을 서버컴퓨터에 저장하거나 USB로 공유해야하는 번거로움이 있다. 이럴때 VIEW를 사용하면 권한을 가진 모든 개발자들이 누군가가 만들어놓은 VIEW를 사용할 수 있다. 뷰 생성 옵션 [force|noforce] force : VIEW를 생성할 때 쿼리 컴파일하지 않고 생성. subquery 조건만족여부와 관계없이 무조건 만들어라는 명령. view가 만들어지지만 만들어진 뷰를 볼수는 없다. 사용도 안되는 옵션이 왜 필요할까? 사용예시1 : base테이블을 곧 만들 예정이고 일단 view먼저 만들어놓을때 사용. 사용예시2 : 설계를하는 사람과 테이블을 만드는 사람은 실제 분리되어있기 때문에 설계를 하는 쪽에서 미리 테이블 정의서를 확인하고 VIEW를 만들어 놓기 위해 FORCE 옵션을 사용해서 테이블이 구축되기 이전에 생성시 사용 noforce : VIEW를 생성할 때 쿼리 컴파일을 진행. (기본값) 참고링크 : oracle view 사용법 및 정리 12345678910111213//기본create view 뷰명 [(alias[, alias ...])] as subquery형태로_정의;//예시create view empvu80as select employee_id, last_name, salaryfrom employeeswhere department_id = 80;desc empvu80;select * from empvu80; 뷰 수정 뷰는 alter구문이 없다. 대신 or replace라는 옵션이 있다. 뷰명이 동일하면 수정해서 교체. 뷰명이 다르면 새롭게 생성. 12create or replace view 뷰명 [(alias[, alias ...])] as subquery형태로_정의; 뷰 삭제 뷰를 삭제하면? =&gt; base테이블의 데이터가 이전으로 돌아가지않는다. 이미 오토커밋했기때문에. 뷰를 rollback하는 방법은 없다. 뷰를 잘못삭제하면 돌릴 방법은 없다. 다시 만들어야한다. 1drop view 뷰명 만든 뷰 전체 목록 조회 가지고 있는 테이블 전체를 조회하는 명령어가 있는 것처럼 가지고 있는 뷰 목록을 조회하는 명령어가 있다. 뷰의 경우 컬럼이 많기때문에 desc로 먼저 원하는 컬럼을 설정한 뒤 목록을 조회하는 것을 추천한다. 12345678910//가지고 있는 테이블전체를 조회하는 명령어select * from tab;//가지고 있는 뷰전체를 조회하는 명령어select * from user_views;//뷰가 가지고 있는 컬럼이 많기때문에 원하는 컬럼만 골라서 뷰리스트보는 것을 추천//예시 : view_name으로 전체 뷰 목록 조회desc user_views;select view_name from user_views;","link":"/2020/07/27/200728dbi/"},{"title":"SQL의 OBJECT종류 : 인덱스(Index), 시노님(Synonym)","text":"SQL의 OBJECT 종류 Object 특징 사용방법 정의방법 테이블(Table) 행과 열의 조합으로 구성된 기본 저장단위 select, insert, update, delete create table, alter table, drop table, truncate table 뷰(View) 하나 또는 그 이상의 base테이블로부터 논리적으로 데이터를 추출한 부분집합으로 가상의 논리적인 테이블 select, insert, update, delete create [or replace] view, drop view 시퀀스(Sequence) 자동으로 고유한 숫자값을 생성해주며 주로 기본키 값을 생성하기 위해 사용 시퀀스명.nextval, 시퀀스명.currval create sequence, alter sequence, drop sequence 인덱스(Index) 쿼리(Query) 속도를 향상시키기 위해 사용 X create index, alter index, drop index 시노님(Synonym) object에 대한 또다른 이름의 alias역할 X create synonym, drop synonym 인덱스 개발자에게 table 다음으로 중요한 object! oracle 서버에서 포인터를 사용하여 행의 검색 속도를 높이기 위해 사용하는 object. 테이블이 작거나 자주 갱신이 되는 컬럼 또는 자주 사용하지 않는 컬럼에는 인덱스 생성 권장하지 않음. 자주 변경되는 컬럼인 경우, 오라클은 데이터가 변경될때마다 테이블과 인덱스까지 같이 변경해줘야해서 오히려 성능저하가 생길 수 있음. 자주 사용하지 않는 컬럼인 경우, 인덱스도 오브젝트를 생성하는 것이기때문에 생성할 추가 공간이 필요해서 오히려 성능저하가 나타날 수 있음. 구조 : B Tree (Balanced Tree)구조 참고링크 : B Tree (Balanced Tree) 인덱스 검색 절차 예시 : 인덱스가 없는 컬럼을 기준으로 작업을 요청 -&gt; full table scan작업방식 : 처리속도가 느리다. 인덱스가 있는 컬럼 -&gt; index scan작업방식 : 처리속도가 훨씬 빠르다. 인덱스생성(create index) 과 수정과 삭제. 자동생성 : PK 또는 UNIQUE 제약조건이 정의된 컬럼에 자동 생성됨. 수동생성 : 행에 엑세스하는 속도를 높이기 위해 인덱스 생성 가능. 12345678910//생성 기본create index 인덱스명on 테이블명(컬럼명);//수정 기본alter index 인덱스명on 테이블명(칼럼명);//삭제 기본drop index 인덱스명; 시노님(Synonym) = 동의어 객체에 다른 이름을 부여해 주는 object 엘리야스와 뭐가 다를까? 테이블 엘리야스는 쿼리구문안에서만 유효. 쿼리가 끝나면 사라진다. 시노님을 이용하면 DB가 켜져있는 내내 다양한 곳에서 사용가능 하나의 객체에 시노님이 여러개 부여할 수 있을까? 가능! 시노님사용법12345678910//생성 기본create synonym 시노님명for 원본object명;//생성 예시create synonym d_sumfor dept_sum_vu;//삭제 기본drop synonym d_sum;","link":"/2020/07/28/200729dbi2/"},{"title":"SQL 기억해야 할 쿼리","text":"제약조건 검색하는 쿼리 123select constraint_name, constraint_type, search_condition, r_constraint_namefrom user_constraintswhere lower(table_name) = lower( '&amp;table_name'); 제약조건의 컬럼까지 확인하는 쿼리제약조건을 조합값에 걸때는 1번쿼리로는 어떤 컬럼의 조합값이 들어가있는지 확인하기 어렵다.이때 사용할 수 있는 쿼리구문이다. 같은 제약조건명을 가진 컬럼명을 확인하면 된다. 1234//기본select constraint_name, column_name from user_cons_columnswhere lower(table_name) = lower( '&amp;table_name'); 제약조건 타입과 조합값까지 함께 검색하는 쿼리즉 1번과 2번을 join한 쿼리이고 개발자가 자주 사용하는 쿼리이다 1234567891011col column_name format a15col constraint_name format a15col r_constraint_name format a20select a.column_name, b.constraint_name, b.constraint_type, b.search_condition, b.r_constraint_name, c.table_name as parnet_table, a.column_name as parnet_columnfrom user_cons_columns a join user_constraints bon a.constraint_name = b.constraint_nameleft outer join user_cons_columns con b.r_constraint_name = c.constraint_namewhere lower(a.table_name) = lower('&amp;table_name'); SQL에서는 무조건 작은따옴표 ''를 사용한다. 큰따옴표를 사용하는 경우는 딱 두가지! 나머지는 다 작은 따옴표를 사용한다. 큰따옴표 사용 : 엘리야스, to_char구문안에서 사용자 형식 내 문자열 포함할때. 쿼리구문에 큰따옴표(“ “)가 사용되는 경우 예시","link":"/2020/07/28/200729dbi3/"},{"title":"[ITWILL : JAVA]람다식개념, 인터페이스 Comparator","text":"ITWILL학원 : 21강 JAVA BY 윤미영강사1. 람다식 자바 8에서 추가된 가장 큰 특징으로 함수형 프로그래밍 형태를 받아들인 결과 메서드 vs 함수 객체지향 프로그래밍개념에서 : 메서드와 함수는 동일하다 함수형 프로그래밍개념에서 : 메서드(특정객체가 수행하는 기능) vs 함수(특정 객체에 속하지않는 기능) 람다식을 쓰는 이유 : 코드가 간결해짐. 람다식 사용가능한 곳 : 함수형 인터페이스 중 익명클래스를 사용한 부분만 람다식으로 대체해서 사용가능. 함수형 인터페이스가 뭘까? 함수형 인터페이스 : 인터페이스 중에서 한 개의 abstract메서드를 가진 인터페이스 사용법 : 12345678910111213//기본 람다식(파라미터타입) -&gt; {실행문;}//예시 : 매개변수없음 + 리턴없는 경우() -&gt; System.out.println(\"Hi\");//예시 : 매개변수있음 + 리턴없는 경우(msg) -&gt; System.out.println(msg);//예시 : 매개변수있음 + 리턴있는 경우(msg) -&gt; { System.out.println(msg); return msg; } 이클립스 단축키 : new연산자의 대괄호{} 전체 선택 후 ctrl + 1 -&gt; convert to lambda expression 를 선택하면 자동으로 람다식을 생성해준다. 2. 인터페이스 Comparator 객체정렬방식 2가지 Comparable 인터페이스 : 정렬 대상 클래스를 자바에서 기본적으로 제공하고 있는 Comparable 인터페이스를 구현하도록 변경 만약 이미 존재하고 있는 정렬 기준과 다른 정렬 기준으로 정렬을 하고 싶을 때는 어떻게 해야할까? Comparator 인터페이스 : 정렬 기준을 누락된 클래스의 객체나 기존 정렬 기준을 무시하고 새로운 정렬 기준으로 객체를 정렬가능. 데이터타입별 비교방법 int 데이터타입은 부등호로 서로 비교가능 String은 부등호로 비교가 안됨 =&gt; compareTo()메서드사용해서 비교해야함 int compare(T o1, T o2) : Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. 리턴값이 -1이면 위치가 앞으로 , 0이면 가만히, 1이면 뒤로 o1 &gt; o2 : negative integer o1 = o2 : zero o1 &lt; o2 : positive integer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class Person { //1. 멤버변수생성 String name; int age; //3. 생성자만들기 public Person(int age, String name) { this.age = age; this.name = name; } //2. getter와 setter만들기 public String getName() { return name; } (생략) //5. toString생성 @Override public String toString() { return \"Person [name=\" + name + \", age=\" + age + \"]\"; } public static void main(String[] args) { //4. 배열만들기 Person[] people = new Person[3]; people[0] = new Person(22, \"홍\"); people[1] = new Person(20, \"길\"); people[2] = new Person(24, \"동\"); //4-1. 배열출력하기 - toString사용 System.out.println(\"배열의 인덱스출력 : \"+people[0]); System.out.println(\"toString이용 배열출력(입력순) : \"+Arrays.toString(people)); //6. sort하기 : //Arrays.sort(people); //에러발생 //왜 에러날까? sort하기위해서는 정렬의 기준이 필요하다. 멤버변수 두개중에 어떤걸 기준잡을지 말해야한다 = Comparator //7-2. comparator이용해서 나이순으로 sort하기 Arrays.sort(people, new Comp()); System.out.println(\"sort+외부클래스사용 배열출력(나이오름차순) : \"+Arrays.toString(people)); //7-3. 익명클래스를 사용해서 나이순으로 sort하기 Arrays.sort(people, new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { if(o1.age &gt; o2.age) return -1; else return 1; } }); System.out.println(\"sort+내부클래스사용+age(나이내림차순) 배열출력 : \"+Arrays.toString(people)); //7-4. 이름순으로 정렬하기 //String은 부등호로 비교가 안됨 =&gt; compareTo()메서드사용해서 비교해야함 Arrays.sort(people, new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { if(o1.name.compareTo(o2.name) &gt; 0) return 1; //가나다순 else return -1; } }); System.out.println(\"sort+내부클래스사용+name 배열출력(가나다순) : \"+Arrays.toString(people)); }//main매서드닫음 }//Person클래스닫음//7. comparaor생성(내부클래스말고 독립적인 클래스로 생성)class Comp implements Comparator&lt;Person&gt;{ //7-1. 추상메서드 오버라이딩 @Override public int compare(Person arg0, Person arg1) { if(arg0.age &lt; arg1.age){ return -1; //오름차순(arg0보다 arg1이 더 큰 경우) }else{ return 1; } }}//Comp클래스닫음 Comparator 객체는 메서드가 하나 뿐인 함수형 인터페이스를 구현하기 때문에 람다 함수로 대체가 가능. 기존에 있던 new Comparator&lt;Person&gt;() { @Override public int compare를 화살표로 대체해주면 람다식완성. 데이터 타입도 지울 수 있다 : (Person o1, Person o2) -&gt; (o1, o2)로 가능. 1234567//7-4. 이름순으로 정렬하기(람다식 사용)Arrays.sort(people, (o1, o2) -&gt; if(o1.name.compareTo(o2.name) &gt; 0) return 1; //가나다순 else return -1; });System.out.println(Arrays.toString(people)); 참고링크 : Comparable과 Comparator참고링크 : 객체 정렬하기 1부 - Comparable vs Comparator","link":"/2020/07/29/200730javai/"},{"title":"[ITWILL : JSP]홈페이지만들기3 : 로그인&#x2F;로그아웃 기능 구현","text":"ITWILL학원 : 34강 JSP기초 BY 정규태강사1. loginForm.jsp 생성 header include하기 : jsp:include page=&quot;../inc/top.jsp&quot; footer include하기 : jsp:include page=&quot;../inc/bottom.jsp&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt;&lt;div id=\"wrap\"&gt;&lt;!-- 헤더들어가는 곳 --&gt;&lt;jsp:include page=\"../inc/top.jsp\"&gt;&lt;/jsp:include&gt;&lt;!-- 헤더들어가는 곳 --&gt;&lt;!-- 본문들어가는 곳 --&gt;&lt;!-- 본문메인이미지 --&gt;&lt;div id=\"sub_img_member\"&gt;&lt;/div&gt;&lt;!-- 본문메인이미지 --&gt;&lt;!-- 왼쪽메뉴 --&gt;&lt;nav id=\"sub_menu\"&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=\"#\"&gt;Join us&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;Privacy policy&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;&lt;!-- 왼쪽메뉴 --&gt;&lt;!-- 본문내용 --&gt;&lt;article&gt;&lt;h1&gt;로그인&lt;/h1&gt;&lt;form action=\"loginPro.jsp\" id=\"join\" method=\"post\"&gt; &lt;fieldset&gt; &lt;legend&gt;로그인정보&lt;/legend&gt; &lt;label&gt;아이디&lt;/label&gt; &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt; &lt;label&gt;비밀번호&lt;/label&gt; &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; &lt;/fieldset&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;div id=\"buttons\"&gt; &lt;input type=\"submit\" value=\"Submit\" class=\"submit\"&gt; &lt;input type=\"reset\" value=\"Cancel\" class=\"cancel\"&gt; &lt;/div&gt;&lt;/form&gt;&lt;/article&gt;&lt;!-- 본문내용 --&gt;&lt;!-- 본문들어가는 곳 --&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;!-- 푸터들어가는 곳 --&gt;&lt;jsp:include page=\"../inc/bottom.jsp\"&gt;&lt;/jsp:include&gt;&lt;!-- 푸터들어가는 곳 --&gt;&lt;/div&gt;&lt;/body&gt; 2. loginPro.jsp생성 int데이터타입으로 변수받아서 데이터처리. 아이디와 비밀번호가 DB와 일치시 main.jsp페이지로 이동. 아이디와 비밀번호가 DB와 불일치시 뒤로가기. 123456789101112131415161718192021222324252627282930313233&lt;% //1. 한글처리 및 변수가져오기request.setCharacterEncoding(\"UTF-8\");String id = request.getParameter(\"id\");String pw = request.getParameter(\"pw\");//2. MemberDAO객체생성 -&gt; idcheck(id, pw) 메서드생성MemberDAO mdao = new MemberDAO();int result = mdao.idCheck(id, pw);//3.데이터처리if(result == 1){ //아이값을 세션객체에 저장 session.setAttribute(\"id\", id); //두번째파라미터에서 업캐스팅발생 object-&gt;String System.out.println(\"아디일치비번일치-&gt;로그인성공\"); response.sendRedirect(\"../main/main.jsp\");}else if(result == 0){ System.out.println(\"아디일치,비번불일치-&gt;로그인실패\"); %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"비밀번호가 일치하지 않습니다\"); history.back(); &lt;/script&gt; &lt;%}else{ System.out.println(\"아디불일치,비번불일치-&gt;로그인실패\"); %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"존재하지않는 아이디입니다\"); history.back(); &lt;/script&gt; &lt;%}%&gt; 3. memberDAO.java에 idCheck()메서드 생성1234567891011121314151617181920212223242526public int idCheck(String id, String pw){ int result = -1; try { //1.DB여결 con = getCon(); //2.SQL &amp; PSTMT sql = \"select pw from fun_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); //3.실행 -&gt; rs -&gt; 데이터처리 rs = pstmt.executeQuery(); if(rs.next()){ if(pw.equals(rs.getString(\"pw\"))){ result = 1; }else{ result = 0; } } } catch (Exception e) { e.printStackTrace(); } finally { //4.자원해제 closeDB(); } return result;}//idCheck메서드 닫음 4. top.jsp 추가 로그인한 경우 id님 환영합니다와 함께 로그인 버튼을 로그아웃으로 변경 123456789101112131415161718192021222324252627282930&lt;% //화면상단에 위치하는 메뉴바 처리페이지String id = (String)session.getAttribute(\"id\"); //다운캐스팅 Object -&gt; String%&gt;&lt;header&gt;&lt;div id=\"login\"&gt; &lt;%if(id == null){ %&gt; &lt;div id=\"login\"&gt;&lt;a href=\"../member/loginForm.jsp\"&gt;로그인&lt;/a&gt; | &lt;a href=\"../member/joinForm.jsp\"&gt;회원가입&lt;/a&gt;&lt;/div&gt; &lt;% }else if(id != null){ %&gt; &lt;div id=\"login\"&gt;&lt;%=id %&gt;님 환영합니다 | &lt;a href=\"../member/logout.jsp\"&gt;로그아웃&lt;/a&gt;&lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;!-- 로고들어가는 곳 --&gt;&lt;div id=\"logo\"&gt;&lt;img src=\"../images/logo.gif\" width=\"265\" height=\"62\" alt=\"Fun Web\"&gt;&lt;/div&gt;&lt;!-- 로고들어가는 곳 --&gt;&lt;nav id=\"top_menu\"&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"../index.jsp\"&gt;홈&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"../company/welcome.html\"&gt;회사소개&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;솔루션&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"../center/notice.jsp\"&gt;고객센터&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;무엇이든 물어보세요&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;&lt;/header&gt; 5. logout.jsp 생성12345678&lt;%session.invalidate();System.out.println(\"로그아웃성공\");%&gt;&lt;script type=\"text/javascript\"&gt; alert(\"정상적으로 로그아웃 되었습니다\"); location.href=\"../main/main.jsp\";&lt;/script&gt;","link":"/2020/07/29/200730jspi2/"},{"title":"[ITWILL : JSP]홈페이지만들기1 : 프로젝트 시작 설정 및 자바빈생성과 DB연결","text":"ITWILL학원 : 33강 JSP기초 BY 정규태강사html로 만들어진 홈페이지를 jsp로 변경해보자. 1. main.jsp 생성 path설정 / 와 ./는 현재폴더 ../는 상위폴더 페이지 인클루드 2가지방법 12345678&lt;!-- JSP 지시어 : 공통으로 사용되는 변수를 파일에 지정해서 추가 --&gt;&lt;%@ include ~ %&gt;&lt;!-- 액션태그 : 공통으로 사용되는 메뉴들을(페이지) 특정 공간에 추가 --&gt;&lt;jsp:include page=\"\"&gt;&lt;!-- 예시 --&gt;&lt;jsp:include page=\"../inc/top.jsp\"&gt;&lt;/jsp:include&gt; 코드블록 : 12345678910111213141516171819&lt;body&gt;&lt;div id=\"wrap\"&gt; &lt;!-- 헤더파일들어가는 곳 (page Include)--&gt; &lt;jsp:include page=\"../inc/top.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- 헤더파일들어가는 곳 (page Include)--&gt; &lt;!-- 메인이미지 들어가는곳 --&gt; &lt;!-- 메인이미지 들어가는곳 --&gt; &lt;!-- 메인 콘텐츠 들어가는 곳 --&gt; &lt;!-- 메인 콘텐츠 들어가는 곳 --&gt; &lt;!-- 푸터 들어가는 곳 --&gt; &lt;jsp:include page=\"../inc/bottom.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- 푸터 들어가는 곳 --&gt; &lt;/div&gt;&lt;/body&gt; 2. index.jsp생성1234&lt;%//프로젝트의 시작페이지 구현response.sendRedirect(\"./main/main.jsp\");%&gt; 3. top.jsp 생성화면상단에 위치하는 메뉴바 처리페이지 123456789101112131415161718192021&lt;!-- html코드가 필요없다 (html body태그안에 넣어도 되고 html태그 없어도 됨)--&gt;&lt;% //화면상단에 위치하는 메뉴바 처리페이지%&gt;&lt;header&gt;&lt;div id=\"login\"&gt;&lt;a href=\"../member/loginForm.jsp\"&gt;login&lt;/a&gt; | &lt;a href=\"../member/joinFrom.jsp\"&gt;join&lt;/a&gt;&lt;/div&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;!-- 로고들어가는 곳 --&gt;&lt;div id=\"logo\"&gt;&lt;img src=\"../images/logo.gif\" width=\"265\" height=\"62\"&gt;&lt;/div&gt;&lt;!-- 로고들어가는 곳 --&gt;&lt;nav id=\"top_menu\"&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"../index.jsp\"&gt;HOME&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"../company/welcome.html\"&gt;COMPANY&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;SOLUTIONS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"../center/notice.html\"&gt;CUSTOMER CENTER&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;CONTACT US&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;&lt;/header&gt; 4. bottom.jsp 생성화면하단에 위치하는 footer 처리페이지 12345678910111213141516&lt;!-- html코드가 필요없다 (html body태그안에 넣어도 되고 html태그 없어도 됨)--&gt;&lt;% //화면하단에 위치하는 footer 처리페이지%&gt;&lt;footer&gt;&lt;hr&gt;&lt;div id=\"copy\"&gt;All contents Copyright 2011 FunWeb 2011 FunWeb Inc. all rights reserved&lt;br&gt;Contact mail:funweb@funwebbiz.com Tel +82 64 123 4315Fax +82 64 123 4321&lt;/div&gt;&lt;div id=\"social\"&gt;&lt;img src=\"../images/Instagram.gif\" width=\"33\" height=\"33\" alt=\"Instagram\"&gt;&lt;img src=\"../images/twitter.gif\" width=\"34\" height=\"34\" alt=\"Twitter\"&gt;&lt;/div&gt;&lt;/footer&gt; 5. joinForm.jsp 생성원하는 회원가입 폼양식 생성하면 된다.코드블록은 생략하도록 한다. 6. joinPro.jsp 생성자바빈을 작성하려면 테이블이 생성되어있어야한다.joinPro.jsp의 남은 코드는 순서대로 아래에 추가해서 작성할 예정이다. 12345&lt;%// 한글처리 request.setCharacterEncoding(\"UTF-8\");// 전달되는 데이터 입력(저장) =&gt; 자바빈 이용%&gt; 7. MySQL에서 테이블생성 자바빈을 작성하려면 테이블이 생성되어있어야한다. 회원테이블 정보 : 제약조건 아이디(id) : pk 비밀번호(pw) : nn 이름(name) : nn 이메일(email) : nn, uq 생년월일(birth) : nn 성별(gender) : nn 주소(addr) 휴대폰번호(mobile) re_date : 가입일자 팁 전화번호 : 보통 실무에서 varchar를 이용하는 것이 편하다 생년월일 : int나 varchar를 쓰는데, 실무에선 varchar로 받아서 바로 이용하는 것이 편하다 8. MemberBean.java생성12345678910111213141516171819202122232425262728293031323334353637383940414243package com.itwillbs.member;import java.sql.Date;//1번규약 :public 클래스public class MemberBean {//자바빈은 항상 패키지를 포함해야한다.//데이터를 저장하는 객체(한번에 회원정보를 저장가능한 객체) =&gt; DB에 데이터전달 //2번 규약: private멤버변수 private String id; private String pw; private String name; private String email; private int birth; private String gender; private String addr; private String mobile; private Date re_date; //4번규약 : 디폴트생성자 //3번규약 : getter, setter public String getId() { return id; } public void setId(String id) { this.id = id; } (중략) //5번 선택: toString /* (non-Javadoc) * @see java.lang.Object#toString() */ @Override public String toString() { return \"MemberBean [id=\" + id + \", pw=\" + pw + \", name=\" + name + \", email=\" + email + \", birth=\" + birth + \", gender=\" + gender + \", addr=\" + addr + \", mobile=\" + mobile + \", re_date=\" + re_date + \"]\"; }} 9. MemberDAO.java 생성DB연결과 자원해제 메서드를 생성한다 자원해제는 사용한 객체 역순으로 진행하는 것이 안전하게 자원해제할 수 있다 1234567891011121314151617181920212223242526272829303132333435363738394041424344import javax.sql.DataSource;public class MemberDAO { Connection con = null; String sql = \"\"; PreparedStatement pstmt = null; ResultSet rs = null; //디비연결메서드 /*private void getCon() throws NamingException, SQLException { //Context 객체 생성 //Context인터페이스이기때문에 직접객체생성할 수 없어서 InitialContext클래스를 사용해서 객채생성 //예외처리 : throws사용하는 방법 Context init = new InitialContext(); //업캐스팅 //디비연결정보를 불러오기 -&gt;DataSource 타입으로 저장 // 고정문구\"java:comp/env/다른문구context파일의 name값입력\" DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/mysqlDB\"); //ds 사용해서 연결 //멤버변수는 static이 아니기때문에 new BoardDAO();객체생성 후에 멤버변수들이 생성된다. //그리고 getCon()메서드를 하면 멤버변수 con에 데이터(ds.getConnection();)가 담기게 된다. //따라서 이때 return하지 않고 써도된다. con = ds.getConnection(); System.out.println(\"디비연결성공 :\"+con); } */ private Connection getCon() throws Exception { Context init = new InitialContext(); DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/funwebDB\"); return con; } //자원해제메서드 public void close(){ try{ if(rs != null) rs.close(); if(pstmt != null) pstmt.close(); if(con != null) con.close(); } catch (SQLException e) { e.printStackTrace(); } }} 10. context.xml 생성주요 체크사항 - name : 사용할 이름으로 작성 - url : 테이블이 있는 DB경로 - username과 password 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 디비연결에 필요한 정보 저장 --&gt;&lt;Context&gt; &lt;Resource name=&quot;jdbc/fubwebDB&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/funwebdb&quot; username=&quot;root&quot; password=&quot;1234&quot; /&gt;&lt;/Context&gt;","link":"/2020/07/28/200729jspi/"},{"title":"오픈소스컨트리뷰톤 온라인미팅1 후기 : 모던 js 오픈소스 기여순서","text":"모던 js 오픈소스 기여순서 본저장소 fork하기 fork한 주소로 로컬에 clone받기 엑셀 대시보드에서 번역 원하는 작업 찜하기 본저장소에 진행할 작업 issue하기 issue제목 예시 : 2-js/04-Forms, controls/03-Events: change, input, cut, copy, paste 번역 로컬서버세팅 에디터에서 pull하기 작업 시작! git add. git commit 메세지 commit명 예시 : 다른사람 커밋명 확인할 것 [이벤트 루프와 매크로·마이크로태스크] 번역 [정적 메서드와 정적 프로퍼티] 1차 리뷰 [화살표 함수 다시 살펴보기] 보완 fork한 내저장소에 push. pr. PR시 체크박스에 체크 [x] 필수. CLA(Contributor License Agreement)동의 필수 : 제작물에 나의 저작권을 요구하지 않겠다는 동의. 원격저장소 최신버전으로 업데이트하는 방법 연결고리만들기 git remote add upstream git fetch 또는 rebase 리뷰시 주의사항 여러개 리뷰할꺼면 : start a review 한문장만 리뷰할꺼면 : add single comment 번역시 주의사항 모범사례 정독하기 대명사는 명확하게 예시 : it works incorrectly면 그냥 작동하지않는다로 번역하는 것이 아니라 대명사 it이 뭔지 제대로 번역할 것. 인칭대명사는 생략가능 보라님 번역스타일로 하는 것이 문서 통일성을 높여서 좋다. 번역된거 많이 읽어보기 번역은 소제목단위로 커밋날리고 한 챕터가 다 되면 pr 남기기","link":"/2020/07/31/200801opensource/"},{"title":"[ITWILL : JAVA] 람다식을 이용한 함수형 프로그래밍1 : 계열","text":"ITWILL학원 : 22강 JAVA BY 윤미영강사 자바 8에서는 빈번히 사용되는 함수형 인터페이스들을 java.util.function패키지를 통해 제공한다. 1. Consumer 계열 소비자계열은 무엇을 소비할까? 바로 파라미터이다. 전달받은 파라미터를 받아서 소비하는 소비자이며 리턴값은 없다 Consumer 계열의 인터페이스 : biConsumer는 bi가 두 개라는 의미로 두 개의 파라미터를 받는다. 객체를 처리하지않고 기본형을 처리하는 경우 double, long, int 값을 처리할 수 있다. 2. Supplier 계열 공급자계열은 무엇을 공급할까? 바로 리턴값이다. 파라미터를 받지 않고 자체적으로 리턴할 값을 생성한다 파라미터가 없기때문에 bi가 붙는 형태는 없다. 인터페이스명 메서드 설명 Supplier T get() T타입 객체 리턴 pSupplier p getAsp() p타입의 값 리턴 참고 p는 boolean, int, long, double를 의미한다 3. Function 계열 파라미터도 받고, 리턴도 존재한다. 4. Operator 계열 function계열과 유사하게 파라미터와 리턴 타입을 모두 갖는다. 차이점 : function계열 : 파라미터와 리턴 타입이 무관 operator계열 : 파라미터를 이용해 어떤 연산을 수행한 후 파라미터와 같은 타입이 리턴된다. 5. Predicate 계열 파라미터와 리턴타입을 갖는데 리턴타입이 boolean으로 고정.","link":"/2020/07/30/200731javai/"},{"title":"람다식을 이용한 함수형 프로그래밍2 : 메서드","text":"표준 함수형 인터페이스 메서드 java.util.function패키지의 인터페이스들은 모두 하나 이상의 default 또는 static 메서드를 포함하고 있는데 이들 메서드를 이용해서 동일한 계열의 여러 동작을 연결해서 사용할 수 있다. andThen()와 compose() andThen()와 compose() : Consumer, Function, Operator계열에 서언된 dafault메서드. 두 개의 함수형 인터페이스를 순차적으로 연결함. 첫번째 함수의 연산의 결과를 두번째 함수의 파라미터로 제공해서 최종 결과 값을 도출함. 최종 값의 타입은 두번째 함수의 리턴 타입임. 두 메서드의 차이점 : 적용순서. A 인터페이스에 선언되 andThen()을 사용해서 B인터페이스를 연결할 때 = A.andThen(B) A의 결과가 B의 파라미터로 활용되고 B의 리턴값이 AB리턴한 값과 동일함. A 인터페이스에 선언된 compose()를 사용해서 B인터페이스를 연결할 때 = A.compose(B) B의 리턴이 A의 파라미터로 사용되고 A의 리턴값은 AB리턴값과 동일함. Consumer 계열에서의 연결 Consumer계열은 리턴값이 존재하지 않기때문에 최초의 파라미터가 그대로 두번째 인터페이스의 파라미터가 됨. 첫번째 인터페이스의 동작은 두번째 인터페이스의 동작에 영향을 주지 않음. 12345678DoubleConsumer con1 = num -&gt; System.out.println(Math.pow(num, 2));DoubleConsumer con2 = num -&gt; System.out.println(num+num);DoubleConsumer andThen = con1.andThen(con2);andThen.accept(10);//출력값100.020.0 Function 계열의 연결 Function계열 : andThen()과 compose()를 모두 사용가능. 순서차이 확인 1234567891011Function&lt;String, String&gt; func1 = name -&gt; \"Hi, \"+name;Function&lt;String, String&gt; func2 = data -&gt; \"리턴값 : \"+data;Function&lt;String, String&gt; func3 = func1.andThen(func2);System.out.println(func3.apply(\"수박\"));Function&lt;String, String&gt; func4 = func1.compose(func2);System.out.println(func4.apply(\"수박\"));//출력값리턴값 : Hi, 수박Hi, 리턴값 : 수박 Predicate계열의 연결 디폴트 메서드 : and(), or(), negate() and() : 두 개의 predicate를 연결하며 &amp;&amp;연산자와 동일하게 동작 or() : 두 개의 predicate를 연결하며 ||연산자와 동일하게 동작 negate() : 두 개의 predicate를 연결하며 !연산자(부정)와 동일하게 동작 클래스 메서드 : isEqual() : 대상 객체와 기준 객체를 비교. 위의 메서드들 서로 다른 두개의 predicate를 연결하거나 새로운 predicate반환한다. 메서드와 생성자 참조 더블콜론(::)연산자 : 단순히 기존에 사용된 코드를 재사용하는 경우 더블콜론연산자를 이용해 기존 메서드 참조가능. 123클래스 :: 인스턴스_메서드클래스 :: 클래스_메서드객체 :: 인스턴스_메서드 클래스 :: 인스턴스_메서드 람다식에 전달된 o1의 타입인 String 클래스가 가지는 compareTo()메서드에 두번째 파라미터인 o2가 전달된다. 12345678910String[] langs = {\"py\", \"js\", \"java\", \"db\"};//1. 기본적인 람다식Arrays.sort(langs, (o1,o2) -&gt; { return o1.compareTo(o2);})//2. 더블콜론 연산자를 사용한 람다식Arrays.sort(langs, String::compareTo); 클래스 :: 클래스_메서드 f0 : 기본적인 람다식 f1 : 최대한 축약한 람다식. 파라미터가 하나이므로 괄호()생략가능. 구현부가 return한 문장이므로 대괄호화 return키워드 생략가능 f2 : 더클론론::연산자를 활용한 람다식 12345678910111213Function&lt;String, Integer&gt; f0 = (str) -&gt; {return Integer.parseInt(str);};System.out.println(f0.apply(\"100\"));Function&lt;String, Integer&gt; f1 = str -&gt; Integer.parseInt(str);System.out.println(f1.apply(\"200\"));Function&lt;String, Integer&gt; f2 = Integer::parseInt;System.out.println(f2.apply(\"300\"));//출력값100200300 객체 :: 인스턴스_메서드 주어진 객체의 메서드가 호출되며 람다식에 전달된 파라미터는 메서드에 그대로 전달됨. 12345678910111213String base =\"람다\";//1. 기본적인 람다식Function&lt;String, Boolean&gt; f11 = str -&gt; base.equals(str);System.out.println(f11.apply(\"람다\"));//2. 더블콜론사용한 람다식Function&lt;String, Boolean&gt; f22 = base::equals;System.out.println(f22.apply(\"람다\"));//3. Consumer&lt;T&gt;에서 메서드 참조를 사용한 예시Consumer&lt;String&gt; f33 = System.out::println;f33.accept(\"람다\"); 클래스 :: new 생성자 참조함. 배열을 만들때 사용 가능 -&gt; 이때, 파라미터 = 배열의 길이. 클래스 타입의 새로운 객체를 생성함. 호출되는 생성자는 전달되는 파라미터의 타입과 개수에 근거하여 결정됨.","link":"/2020/08/02/200803javai/"},{"title":"java.lang패키지1 : Object클래스의 메서드(equals(), hashcode(), clone(), getClass())","text":"java.lang패키지의 가장 큰 특징 : import할 필요 없다. Object클래스 가장 최상위 클래스로 모든 크래스의 조상 클래스. equals() 메서드 두 객체의 주소값이 같은지 비교 : ==연산자사용. 두객체의 내용이 같은지 비교 : equals()사용. 이때 equals()메서드 오버라이딩을 사용한다. hashCode()메서드 equals()만 재정의해서는 안되고 반드시 equals()와 hashCode()를 함께 재정의해야만 부작용이 없다. 어떤 부작용? hashCode : 클래스의 주소값을 변환하여 생성한 객체의 고유한 정수값(실제주소값은 아님) HashSet이나 HashMap등에서 객체를 구별하기 위한 일종의 키값으로 사용함. equals()와 hashcode()는 항상 함께 쓰기 set계열 라이브러리를 쓰지않으면 사실 hashcode를 안 써도 된다. 하지만 내가 아닌 다른 개발자가 set계열을 사용할 수 있으므로 DTO타입인 경우 equals()와 hashcode()를 모두 오버라이딩해주는 것이 좋다 주석은 hashcode를 오버라이딩한 부분이다. hashcode overriding전에는 내가 만든 두 개의 동일한 클래스인 Product를 같은 객체인지 인식하지 못한다. hashcode overriding후에는 Product를 동일한 객체로 인식한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Product{ String sn; public Product(String sn){ this.sn = sn; } @Override public String toString() { return \"Product [sn=\" + sn + \"]\"; }/* @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((sn == null) ? 0 : sn.hashCode()); return result; }*/ @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Product other = (Product) obj; if (sn == null) { if (other.sn != null) return false; } else if (!sn.equals(other.sn)) return false; return true; } }public class HashCodeTest { public static void testString(){ Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(new String(\"Hello\")); set.add(new String(\"Hello\")); System.out.println(set); } public static void testProduct(){ Set&lt;Product&gt; st = new HashSet&lt;&gt;(); st.add(new Product(\"9877\")); st.add(new Product(\"9877\")); System.out.println(st); } public static void main(String[] args) { testString(); testProduct(); }}//hashcode 주석해재 전[Hello][Product [sn=9877], Product [sn=9877]]//hashcode 주석해재 후[Hello][Product [sn=9877]] clone()메서드 자신을 복제해서 새로운 객체를 생성하는 메서드 사용처 : 배열 같은 객체를 clone()하여 원본 훼손 X -&gt; 다양한 테스트 가능. 규칙 : clone()메서드는 protected 접근제한자를 사용하기 때문에 오버라이딩하지 않고는 외부에서 호출할 수 없다. 외부 호출을 위해 오버라이딩시 public 접근 제한자로 변경하기. throws CloneNotSupportedException 처리하기. 얕은 복사(shallow copy)와 깊은 복사(deep copy) 기본적으로 clone에서 사용하는 복사 방식은 얕은 복사. 얕은 복사 : 단순히 객채가 가지는 기본형의 값과 객체의 참조값만 복사해서 복제본 생성. 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다. 기본형데이터 : 그대로 복제되어 원본데이터 중 기본형데이터의 값이 바뀐다고해서 clone한 객체의 값이 바뀌지않는다. 연결되어있지않다. 참조형데이터 : 단순히 원본 객체에 대한 레퍼런스값을 복사했기때문에 원본데이터 중 참조형데이터의 값이 변경되면 clone한 객체의 값도 변경된다. 반대로 clone한 참조형데이터를 변경하면 원본 참조형데이터의 값도 변경된다. 깊은 복사 : 얕은 복사 + 참조의 내용을 공유하지 않음 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식. 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Person implements Cloneable{ String name; int age; int[] score; public Person(String name, int age, int[] score){ this.name = name; this.age = age; this.score = score; } @Override public String toString() { return \"person [name=\" + name + \", age=\" + age + \", score=\" + Arrays.toString(score) + \"]\"; } @Override protected Object clone() throws CloneNotSupportedException { // TODO Auto-generated method stub return super.clone(); } }public class CustomCloneTest { public static void main(String[] args) throws CloneNotSupportedException { Person or = new Person(\"홍길동\", 20, new int[]{100,30}); Object cloned = or.clone(); System.out.println(\"원본과 복제품1 &gt;&gt; \"+or+\" : \"+cloned); System.out.println(\"원본과 복제품1의 해쉬코드비교 &gt;&gt; \"+System.identityHashCode(or) +\" : \"+System.identityHashCode(cloned)); //원본의 기본형데이터 변경 or.age = 77; System.out.println(\"원본의 age변경 &gt;&gt; \"+or+\" : \"+cloned); //원본의 참조형데이터변경 or.score[0] = 3; System.out.println(\"원본의 score변경 &gt;&gt; \"+or+\" : \"+cloned); //클론의 기본형데이터 변경 p1.name = \"재재\"; System.out.println(\"클론의 name변경 &gt;&gt; \"+or+\" : \"+p1); //클론의 참조형데이터변경 Person p1 = (Person) cloned; //다운캐스팅 p1.score[0] = 12; System.out.println(\"클론의 score변경 &gt;&gt; \"+or+\" : \"+p1); }}//출력값원본과 복제품1 &gt;&gt; [name=홍길동, age=20, score=[100, 30]] : [name=홍길동, age=20, score=[100, 30]]원본과 복제품1의 해쉬코드비교 &gt;&gt; 366712642 : 1829164700원본의 age변경 &gt;&gt; [name=홍길동, age=77, score=[100, 30]] : [name=홍길동, age=20, score=[100, 30]]원본의 score변경 &gt;&gt; [name=홍길동, age=77, score=[3, 30]] : [name=홍길동, age=20, score=[3, 30]]클론의 name변경 &gt;&gt; [name=홍길동, age=77, score=[12, 30]] : [name=재재, age=20, score=[12, 30]]클론의 score변경 &gt;&gt; [name=홍길동, age=77, score=[12, 30]] : [name=홍길동, age=20, score=[12, 30]] getClass()메서드 JVM은 .class파일을 메모리에 읽어 들인 후 class 타입의 객체로 관리한다. getClass() : 객체가 속한 class의 정보를 알아내는 메서드이다.","link":"/2020/08/02/200803javai2/"},{"title":"java.lang패키지2 : System클래스의 메서드","text":"java.lang패키지의 가장 큰 특징 : import할 필요 없다. System클래스 JVM이 실행되고 있는 운영체제(OS)와 소통을 위한 클래스 다양한 정적 메서드 제공 System 클래스를 이용하면 운영체제의 프로그램 종료, 키보드로부터 입력, 모니터로 출력, 메모리 정리, 현재 시간 읽기, 시스템 프로피티 읽기, 환경 변수 읽기등의 일부 기능을 사용가능. 프로그램의 종료와 G.C권고 System.gc() : 가비지컬렉터를 실행. System.exit(0) : 강제적으로 JVM을 종료시킴. System.exit(0); 정상종료 System.exit(n); 0이외의 다른 숫자는 비정상종료 Positive =&gt; 잘못된 것으로 예상되는 부분이 잘못됨 (잘못된 명령 줄, 파일을 찾을 수 없음, 서버에 연결할 수 없음) Negative =&gt; 전혀 예상하지 못한 것 (시스템 오류 - 예기치 않은 예외 - 외부 강제 종료, 예 : kill -9)123System.exit(0) or EXIT_SUCCESS; ---&gt; SuccessSystem.exit(1) or EXIT_FAILURE; ---&gt; ExceptionSystem.exit(-1) or EXIT_ERROR; ---&gt; Error 12345678910111213141516171819202122232425262728293031323334353637383940414243class Dummy{ public Dummy(){ System.out.println(\"더미 객체 생성됨\"); } @Override protected void finalize() throws Throwable { System.out.println(\"더미 객체 소멸\"); super.finalize(); } }public class BasicIO { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ System.out.println(\"명령을 입력하세요 C,G,X\"); String readLine = sc.nextLine(); if(readLine.equals(\"C\")){ new Dummy(); }else if(readLine.equals(\"G\")){ System.gc(); }else if(readLine.equals(\"X\")){ System.exit(0); } } }//main닫힘}//출력값명령을 입력하세요 C,G,XC더미 객체 생성됨명령을 입력하세요 C,G,XG명령을 입력하세요 C,G,X더미 객체 소멸X 현재 시각 정보 획득 작성한 애플리케이션의 성능을 체크하기 위해 소요 시간을 계산할 필요가 있다. currentTimeMillis() : 현재 시각을 밀리세커드(1/1000초)단위의 long 타입으로 리턴. System.nanoTime() : 현재 시각을 나노세컨드(1/10^9초)단위의 long 타입으로 리턴. 1234567891011121314151617181920public class SystemClockTest { public static void main(String[] args) { long start = System.nanoTime(); int num = 20; long result = getFactorial(num); System.out.println(num+\"의 팩토리얼 : \"+result); long end = System.nanoTime(); System.out.println(\"총 소요시간(나노초): \"+(end-start)); } public static long getFactorial(long num){ if(num == 1){ return num; }else{ return num * getFactorial(num -1); } }} 시스템 속성 및 환경변수 참조 시스템 속성 : JVM이 시작할 때 OS로부터 얻어오는 값. 값 종류 : OS종류, JDK설치경로, 사용자계정, 사용자 임시디렉토리경로등 시스템 속성이 중요한 이유 : OS의 종류를 가리지 않는 플랫폼 독립적인 프로그램을 작성하기 위해서! getProperties() : 모든 시스템 속성들을 키-값의 쌍으로 데이터를 저장하는 java.util.Properties형태로 반환. 123456789101112public class Test { public static void main(String[] args) { System.out.println(\"운영체제 종류: \" + System.getProperty(\"os.name\") ); System.out.println(\"자바 가상머신 버전: \" + System.getProperty(\"java.vm.version\") ); System.out.println(\"클래스 버전: \" + System.getProperty(\"java.class.version\") ); } }//출력값운영체제 종류: Windows 10자바 가상머신 버전: 25.151-b12클래스 버전: 52.0","link":"/2020/08/02/200803javai3/"},{"title":"Data Dictionary","text":"Data Dictionary DB관리에 필요한 모든 정보가 저장되어있다. Data Dictionary 구성 Base Tables : DB의 모든 정보를 oracle이 oracle 스스로 보기 쉬운 형태로 기록해 놓은 테이블. oracle이 스스로를 위한 이진정보를 저장. 시스템정보는 건들면 위험하기때문에 보통 뷰를 통해서 조회만 가능. Data Dictionary Views(딕셔너리 뷰) : Base Table을 사용자가 보기 쉬운 형태로 만들어 놓은 뷰. 딕셔너리에서 사용하는 뷰를 딕셔너리 뷰라고 함. 시스템뷰에 속함. DB생성시 오라클시스템에 의해 자동 생성됨. 읽기전용(select만 가능) 주요 딕셔너리뷰 4가지 : ALL, USER, DBA, V$ V$XXX 예시 Dynamic Performance View의 약어 주로 DBA에게만 액세스가 허용. 모든 DB의 접근 및 조회가능. 실시간 반영 O 주로 DBA의 모니터링 작업용 정보를 제공. ex) v$session, v$datafile 주요 딕셔너리뷰 4가지 : USER, ALL, DBA, V$ 개발자들은 주로 USER, ALL 딕셔너리뷰를 사용하고 DB관리자들은 DBA를 사용한다. 종류 접근가능자 조회가능한 정보 실시간 반영 예시 USER_XXX SQL접속중인 사용자 접속중인 사용자가 소유한 객체 X uesr_tables, user_views, uesr_users, user_constraints, user_indexes ALL_XXX SQL접속중인 사용자 접속중인 사용자가 소유하거나 접근 권한이 있는 모든 객체 X all_tables, all_view, all_indexes DBA_XXX DBA (보통 sys유저) 모든 DB의 객체 X dba_users, dba_data_files, dba_tables V$XXX DBA (보통 sys유저) 모든 DB의 객체 O v$session, v$datafile 개발자가 자주 사용하는 딕셔너리 뷰 예시dictionary 뷰 테이블에 대한 설명을 볼 수 있다. 사용빈도수가 높음 =&gt; 따라서 동의어가 존재함 : dict(딕트) 12345678910//사용방법$ desc dictionary;$ select * from dictionary;//천개가 넘는 컬럼이 출력된다. 비효율적 따라서 아래와 같이 사용한다.//예시1 : 테이블명이 user_users인 딕셔너리 뷰의 모든 컬럼 출력$ select * from dictionary where lower(table_name) = 'user_users';//예시2 : 테이블단어가 들어간 딕셔너리 뷰의 모든 컬럼 출력$ select * from dict where lower(table_name) like '%tables%'; USER_views 예시1234567891011121314151617181920//예시//보통 DB사이즈가 매우 크기때문에 *를 쓰면 데이터처리 시간이 오래걸려서 비추$ select * from user_views;//따라서 desc먼저 날린 뒤 원하는 컬럼을 선택하여 select쿼리를 날리면 된다.$ desc user_views;$ select view_name, text$ from user_views;//출력값VIEW_NAME TEXT-------------------- ----------------------------------------EMPVU80 select employee_id, first_name || ' ' || last_name, salary, department_id from eDEPT_SUM_VU select d.department_name, min(e.salary), max(e.salary), avg(e.salary) from emplo user_sequences 예시12345678910select sequence_name, min_value, max_value, increment_by, last_numberfrom user_sequences//출력값SEQUENCE_NAME MIN_VALUE MAX_VALUE INCREMENT_BY LAST_NUMBER-------------------- ---------- ---------- ------------ -----------DEPARTMENTS_SEQ 1 9990 10 280DEPT_ID_SEQ 1 1000 10 750EMPLOYEES_SEQ 1 1.0000E+28 1 207LOCATIONS_SEQ 1 9900 100 3300","link":"/2020/08/03/200804dbi/"},{"title":"홈페이지만들기5 : 게시판에 글목록표시구현","text":"작성한 게시글을 표시해주는 게시판 글 전체목록을 표시하는 기능 구현 notice.jsp 수정 html테이블작성 BoardDAO객체생성 테이블에 저장된 글의 개수 계산 메서드 getBoardCount()메서드 생성 글이 있는 경우 모든 글의 정보를 가져오는 getBoardList() 메서드 생성 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 게시판 --&gt;&lt;% //1. BoardDAO객체생성BoardDAO bdao = new BoardDAO();//2. 테이블에 저장된 글의 개수 계산 메서드 getBoardCount()메서드 생성int count = bdao.getBoardCount();//3. 글이 있는 경우 모든 글의 정보를 가져오는 메서드List boardList = null;if(count != 0){ boardList = bdao.getBoardList();}%&gt;&lt;article&gt;&lt;h1&gt;게시판 [총 글 : &lt;%=count %&gt;개]&lt;/h1&gt;&lt;table id=\"notice\"&gt;&lt;tr&gt;&lt;th class=\"tno\"&gt;No.&lt;/th&gt; &lt;th class=\"ttitle\"&gt;Title&lt;/th&gt; &lt;th class=\"twrite\"&gt;Writer&lt;/th&gt; &lt;th class=\"tdate\"&gt;Date&lt;/th&gt; &lt;th class=\"tread\"&gt;Read&lt;/th&gt;&lt;/tr&gt;&lt;%//반복문for(int i=0; i&lt;boardList.size(); i++){ BoardBean bb = (BoardBean) boardList.get(i); %&gt;&lt;tr&gt;&lt;td&gt;&lt;%=bb.getBno() %&gt;&lt;/td&gt; &lt;td class=\"left\"&gt;&lt;%=bb.getSubject() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getDate() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getReadcount() %&gt;&lt;/td&gt;&lt;/tr&gt; &lt;%}%&gt;&lt;/table&gt;&lt;div id=\"table_search\"&gt;&lt;input type=\"text\" name=\"search\" class=\"input_box\"&gt;&lt;input type=\"button\" value=\"search\" class=\"btn\"&gt;&lt;/div&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;div id=\"page_control\"&gt; &lt;a href=\"#\"&gt;Prev&lt;/a&gt; &lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt; &lt;a href=\"#\"&gt;4&lt;/a&gt;&lt;a href=\"#\"&gt;5&lt;/a&gt;&lt;a href=\"#\"&gt;6&lt;/a&gt; &lt;a href=\"#\"&gt;7&lt;/a&gt;&lt;a href=\"#\"&gt;8&lt;/a&gt;&lt;a href=\"#\"&gt;9&lt;/a&gt; &lt;a href=\"#\"&gt;10&lt;/a&gt; &lt;a href=\"#\"&gt;Next&lt;/a&gt;&lt;/div&gt;&lt;/article&gt;&lt;!-- 게시판 --&gt; BoardDAO.java에서 getBoardCount()메서드 생성글 개수 계산하는 메서드 작성 12345678910111213141516171819202122232425public int getBoardCount(){ int count = 0; try { //1.DB연결 con = getCon(); //2. sql &amp; pstmt //전체또는 not null 컬럼을 가져오는데 count함수를 사용해서 개수를 세서 가져오는 것 sql = \"select count(*) from fun_board\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); //3. 데이터처리 //왜 while이 아니고 if일까? count함수가 적용되었기때문에 if(rs.next()){ count = rs.getInt(1); System.out.println(\"게시판 총 글 개수 : \"+count); } } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return count;}//getBoardCount닫음 BoardDAO.java에서 getBoardList()메서드 생성글이 있는 경우 모든 글의 정보를 가져오는 메서드 작성 123456789101112131415161718192021222324252627282930313233343536373839404142public List getBoardList(){ //리스트객채 배열 생성 List boardList = new ArrayList(); //2.DB연결 try { con = getCon(); //3.sql &amp; pstmt //최신글이 위로 가도록 정렬 sql = \"select * from fun_board order by re_ref desc\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); //4.데이터처리 while(rs.next()){ BoardBean bb = new BoardBean(); bb.setBno(rs.getInt(\"bno\")); bb.setName(rs.getString(\"name\")); bb.setPw(rs.getString(\"pw\")); bb.setSubject(rs.getString(\"subject\")); bb.setContent(rs.getString(\"content\")); bb.setReadcount(rs.getInt(\"readcount\")); bb.setRe_ref(rs.getInt(\"re_ref\")); bb.setRe_seq(rs.getInt(\"re_seq\")); bb.setRe_lev(rs.getInt(\"re_lev\")); bb.setDate(rs.getDate(\"date\")); bb.setIp(rs.getString(\"ip\")); bb.setFile(rs.getString(\"file\")); //여기까지 한 행의 데이터를 저장한 것임. //5. 리스트 한칸에 행의 정보 하나를 저장 boardList.add(bb); } System.out.println(\"글 정보 저장 완료 : \"+boardList); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return boardList; }//getBoardList닫음","link":"/2020/08/03/200804jspi/"},{"title":"java.lang패키지4 : Math클래스,  Wapper클래스","text":"Math클래스 특징 final클래스 -&gt; 상속X, 메서드오버라이딩X 모든 멤버가 static 선언되어있음 -&gt; 객체생성필요X Math클래스의오버플로우 방지를 위한 연산 +연산자를 쓰는 경우 예외가 나야할 상황임에도 예외가 나지않고 쓰레기값이 출력된다 이때 +연산자대신 addExact()를 사용하여 안전한 연산을 가능하게 해야한다. 12345678910111213int i = Integer.MAX_VALUE;int i2 = i+1;System.out.println(i2); //쓰레기값발생try{ int i3 = Math.addExact(i, 1); System.out.println(i3);} catch(ArithmeticException e) { System.out.println(\"예외발생 : \"+e.getMessage());}//출력값-2147483648예외발생 : integer overflow Wapper클래스 자바에서는 모든 것을 담을 수 있는 Object가 있다. Object로 배열을 만들면 다양한 종류의 객체들을 담을 수 있게된다. 단 기본형은 제외된다. WHY? 기본형데이터타입은 Object를 상속받지 않기때문! 이때 기본형 데이터를 wap해서 객체로 만들어 주는 것이 Wapper클래스이다. 참고링크 : Wrapper클래스","link":"/2020/08/04/200805javai2/"},{"title":"[jQuery] attr(), html()와 text(), append()와 prepend()","text":"attr() 함수 attr(‘속성’,’값’) : 선택한 요소의 속성을 생성,수정 하는 동작 css와 차이점 attr사용 : border color, border style적용안됨. css사용 : border color, border style 적용됨. 12345678910111213141516171819202122232425262728293031323334353637383940414243$(function(){ $('img').attr('width', '200') //1. 선택한 요소의 속성을 생성,수정 하는 동작 =&gt; attr('속성','값') let src = $('img').attr('src'); alert(\"이미지파일 속성 : \"+src); //출력값 //여러 이미지 태그중 첫번재 이미지태그명만 확인가능 //2. 이미지태그 파일의 경로를 변경(그림변경) //$('img').attr('src', '3.jpg') //출력값 : 모든 이미지태그의 링크가 4.jpg로 변경됨 //3. 이미지태그의 테두리지정 : border를 크기10로 지정 //$('img').attr('border', '10') //3. 이미지별로 테두리 5,10,15지정 //내코드 : 배열이용 let border = ['5', '10', '15'] $('img').attr('border', function(idx){ return border[idx]; }) //강사님코드 : 연산이용 let border = ['5', '10', '15'] $('img').attr('border',function(index){ return (index+1)*5; }) //4. 여러 속성적용 //4-1. attr사용(border color, border style적용안됨) $('img').css({ border : '5px solid red', width : '300', height : '150' }) //4-2. css사용(border color, border style 적용됨) $('img').attr({ border : '5px dotted blue', width : '300', height : '150' }) }) html()함수와 text()함수 글자읽기는 text()와 html() 동일한 결과값 출력함. html() : 선택한 요소의 값을 리턴하거나 속성을 변경함. 해당하는 가장 첫 요소의 값만 리턴. 태그요소를 해당 태그가 적용되어 출력. text() : 선택한 요소의 텍스트값을 리턴하거나 텍스트값을 변경함. 해당하는 모든 요소의 텍스트값을 리턴. 태그요소를 있는 문자 그대로 출력. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;head&gt;&lt;!-- 제이쿼리 라이브러리연결 --&gt;&lt;script type=\"text/javascript\" src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt; head - 0&lt;/h2&gt;&lt;h2&gt; head - 1&lt;/h2&gt;&lt;h2&gt; head - 2&lt;/h2&gt;&lt;script type=\"text/javascript\"&gt; $(function(){ //1. html() 사용해서 h2 태그의 정보를 출력 let h = $('h2').html(); alert(\"html()값 : \"+h); //출력값 //html()값 : head - 0 //2. text() 사용해서 h2 태그의 정보를 출력 let t = $('h2').text(); alert(\"text()값 : \"+t) //출력값 //text()값 : head - 0 head - 1 head - 2 //3.text() 사용해서 div태그에 값을 변경 $('div').text('안녕'); $('div').text('&lt;h3&gt;텍스트함수 사용&lt;/h3&gt;'); //4.html() 사용해서 div태그에 값을 변경 $('div').html('안녕'); $('div').html('&lt;h3&gt;텍스트함수 사용&lt;/h3&gt;'); //5.h1태그를 a태그의 링크로 변경 //5-1.내코드 //$('h1').html(\"&lt;a href='Test5.jsp'&gt;&lt;h1&gt;Test5.jsp&lt;/h1&gt;&lt;/a&gt;\"); //5-2.강사님코드 : 제목을 읽어와서 저장 -&gt; 태그요소로 입력 let addr = $('h1').text() $('h1').html(\"&lt;a href=\"+addr+\"&gt;&lt;h1&gt;Test5.jsp&lt;/h1&gt;&lt;/a&gt;\") })&lt;/script&gt;&lt;/body&gt; append()와 prepend()함수태그선택자에 append()와 prepend()함수 적용 See the Pen oNxNZGG by sowon-dev (@gracehopperdev) on CodePen. 배열에 append()와 prepend()함수 적용 활용도가 높다. html테이블에 arr을 담아보자. 배열의 값을 각각 접근해서 테이블행에 추가 =&gt; each(function(){}) 테이블태그에 배열의 값을 추가 =&gt; append() $( ??? ).each(function(){}) =&gt; 선택자로 전달이 모호한 경우에는 인자로 전달한다= $.each(arr, function(idx, item){} 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;head&gt;&lt;!-- 제이쿼리 라이브러리연결 --&gt;&lt;script type=\"text/javascript\" src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;//5-1. 배열생성 let arr =[ {name:\"유저1\", region:\"부산\"}, {name:\"유저2\", region:\"수원\"}, {name:\"유저3\", region:\"서울\"}, ]; //5-2. 테이블에 추가 //$( ??? ).each(function(){}) =&gt; 선택자로 전달이 모호한 경우에는 인자로 전달한다= $.each(arr, function(idx, item){} $.each(arr, function(idx, item){ //alert(\"index : \"+idx+\" item : \"+item) $('table').append('&lt;tr&gt;&lt;td&gt;'+item.name+'&lt;/td&gt;&lt;td&gt;'+item.region+'&lt;/td&gt;&lt;/tr&gt;') }); //5-3. div태그의 배열의 값에 하나씩 저장 //div태그는 배열이 아니기때문에 바로 접근이 가능해서 each를 쓸 필요가 없다 $('div').html(function(idx){ let item = arr[idx]; return item.name +\" \"+ item.region; }); });&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 내용 &lt;/div&gt;&lt;div&gt; 내용 &lt;/div&gt;&lt;div&gt; 내용 &lt;/div&gt;&lt;hr&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;이름&lt;/td&gt;&lt;td&gt;지역&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;","link":"/2020/08/04/200805jspi/"},{"title":"[jQuery] setInterval()와 clearInteval(), CDATA VS PCDATA","text":"setInterval()와 clearInteval()의 차이와 CDATA와 PCDATA의 차이를 알아보자. setInterval() 와 clearInteval() 함수 setInterval(“스크립트 실행문”,시간(밀리초)) : 일정 시간마다 코드를 실행 가능 clearInteval(실행중인객체정보) : 인터벌 작업종료 참고링크 : 가위바위보게임만들기 CDATA VS PCDATA CDATA (UnParsed Character DATA) : 코드가 태그를 포함하거나, 연산(부등호)를 포함할때 일반 문자로 인식하도록 처리(주로 &gt;사용시 html닫는태그가 아니라 부등호연산이라는 걸 알려줌) PCDATA (Parsed Character DATA) : 코드가 태그를 포함하거나, 연산(부등호)를 포함할때 코드 그대로 인식하도록 처리(주로 &gt;사용시 html 닫는 태그임) 참고링크 : CDATA란? 예제코드 1234567891011121314&lt;head&gt;//1. setInterval(\"스크립트 실행문\",시간(밀리초)) : 일정 시간마다 코드를 실행 가능//2. clearInteval(실행중인 객체 정보) : 인터벌작업 종료//3. CDATA : (UnParsed Character DATA) VS PCDATA (Parsed Character DATA) //&lt;![CDATA[let i=0;let s = setInterval(\"console.log(i++)\",1000);//]]&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"인터벌정지\" onclick=\"clearInterval(s);\"&gt;&lt;/body&gt; setInterval() 활용한 이미지 순서 변경 See the Pen eYZYWgE by sowon-dev (@gracehopperdev) on CodePen.","link":"/2020/08/04/200805jspi2/"},{"title":"java.lang패키지3 : String 클래스, StringBuffer와 StringBuilder 클래스의 메서드","text":"String 클래스의 특징과 객체 생성 가장 많이 사용되는 클래스 1위! 기본특징 final 클래스 -&gt; 상속을 받아서 수정불가 내부적으로 char[]배열을 만들어서 데이터를 저장함. 생성자를 사용하지 않고 바로 “”로 둘러싼 문자열을 할당가능. -&gt; String Pool사용. 불변성(Immutable)클래스 : 무심코 +로 연결한 문자열이 메모리를 심각하게 낭비할 수 있음. 이 불변성때문에 equals()와 ==연산자차이가 생긴다. 객체생성방법 2가지 new 키워드 : heap메모리공간에 새로운 문자열을 저장 “”문자열할당 : 상수저장공간(Constant Pool)에 새로운 문자열을 저장. 중복된 값 무시. 메모리절약에 유리(아래 이미지 참조). 참고링크 : equals()와 ==연산자차이점, String Pool String 주요 메서드 선언부 설명 public int length() 주어진 문자열의 길이를 리턴 public char charAt(int index) index에 해당하는 문자를 리턴. 없는경우 IndexOutOfBoundsException public int indexOf(int ch) 문자열내에서 ch의 index를 리턴. 없을경우 -1 public boolean equals(Object o) o의 문자열의 내용을 비교해서 결과를 boolean타입으로 리턴 public boolean equalsIgnoreCase(String s) 대소문자 구별없이 s의 문자열의 내용이 같은지 boolean타입으로 리턴 public String replace(char oldChar, char newChar) 문자열에서 oldChar를 찾아서 newChar로 변경된 새로운 문자열을 리턴 public String substring(int beginIdx, int endIdx) 문자열의 beginIdx에서 endIdx앞까지 잘라서 리턴 public String trim() 문자열 좌우 공백을 없앤 결과를 리턴 public boolean matches(String regex) 문자열이 정규표현식 regex에 부합되는지 여부를 boolean타입으로 리턴 public String[] split(String regex) 문자열을 주어진 정규표현식으로 나눈 후 배열에 담아서 리턴 charAt() 예시1234567891011121314String ssn = \"000101-4111111\";char gender = ssn.charAt(7);if(gender == '4'){ System.out.println(\"여\");}else if(gender == '3'){ System.out.println(\"남\");}else{ System.out.println(\"주민번호형식오류\");}System.out.println(gender);//출력값여4 equalsIgnoreCase()예시123456String s = \"HI\";System.out.println(\"hi\".equals(s));System.out.println(\"hi\".equalsIgnoreCase(s));//출력값falsetrue replace() 예시 전화번호의 뒷자리를 별표표시하는 방법 1234567String hp = \"010-1234-5678\";String last4 = hp.substring(9, hp.length());System.out.println(\"추출된 문자열 : \"+last4);System.out.println(\"마킹된 폰번 : \"+hp.replace(last4, \"****\"));//출력값추출된 문자열 : 5678마킹 폰번 : 010-1234-**** 전화번호의 하이픈을 없애는 방법 123System.out.println(\"하이픈제거 폰번호 :\"+hp.replace(\"-\", \"\"));//출력값하이픈제거 폰번호 :01012345678 split()과 matches() 예시 정규표현식을 파라미터로 받는다. 참고링크 : 정규표현식 split()예시 : 1234567String str = \"Hi java world\";String[] result = str.split(\" \");for(String s : result){ System.out.println(s); }//출력값Hijavaworld split()과 matches()예시1234567891011public static void main(String[] args) { String str = \"Hi java world\"; String[] sResult = str.split(\"[a ]\"); for(int i=0; i&lt;sResult.length;i++){ System.out.println(i+\" : \"+sResult[i]); } String nameRule = \"[a-zA-Z가-힣]{2,5}\"; System.out.println(str.matches(nameRule)); System.out.println(\"Hi\".matches(nameRule)); System.out.println(\"Hijavaworld2\".matches(nameRule));} StringBuffer와 StringBuilder 클래스의 메서드 String클래스는 불변성 클래스이기때문에 문자열 연산에 제약이 많음 12345678910sql = \"abc\"; //\"abc\"sql.toUpperCase(); //\"ABC\"sql; //\"abc\"//대문자 ABC가 sql에 저장되지 않는다. String은 불변성 클래스이다.//따라서 새로운 변수에 담아쓰는 수 밖에 없다.str = sql.toUpperCase(); //\"ABC\"str //\"ABC\"sql //\"abc\" 따라서 문자열 연산에 적합한 StringBuffer와 StringBuilder 클래스 사용가능. Buffer(버퍼) : 배열형태. 데이터를 임시로 저장하는 공간. StringBuffer와 String의 차이점 여러 차이점 중에 불변성유무가 있다. 12345678910111213141516//Stringsql = \"abc\"; //\"abc\"sql.toUpperCase(); //\"ABC\"sql; //\"abc\"//대문자 ABC가 sql에 저장되지 않는다. String은 불변성 클래스이다.//따라서 새로운 변수에 담아쓰는 수 밖에 없다.str = sql.toUpperCase(); //\"ABC\"str //\"ABC\"sql //\"abc\"//StringBuffersql2 = \"abc\"; //\"abc\"sql2.substring(1); //\"bc\"sql2 = \"bc\" //\"bc\" 따라서 문자열 연산에 적합한 StringBuffer와 StringBuilder 클래스 사용가능. 주요 메서드 여기서 P는 Object, String, StringBuffer, charSequence, Char[], Boolean, char, int, long, float, double이 올 수 있다. 선언부 설명 public StringBuilder append(P param) 현재 버퍼의 맨 뒤에 param을 추가한 후 StringBuilder타입으로 리턴 public String toString() 버터의 내용을 문자열로 리턴 append()와 toString()예시123456789101112131415StringBuilder b = new StringBuilder(\"서면-대연-광안-수영\");b.append(\"-장산\");System.out.println(b);b.insert(0, \"부암-\");System.out.println(b);b.delete(5, 8); //대연-삭제System.out.println(b);b.replace(0, 1, \"푸\"); //부 -&gt; 푸System.out.println(b);//출력값서면-대연-광안-수영-장산부암-서면-대연-광안-수영-장산부암-서면-광안-수영-장산푸암-서면-광안-수영-장산","link":"/2020/08/04/200805javai/"},{"title":"Date와 LocalDate차이점, 날짜 및 시간 처리하는 클래스의 변천사","text":"시간순으로 클래스변천사를 나열해보았다.바쁘니까 결론부터 보자 ☝️결론 LocalDate와 LocalDateTime을 쓰자! Java8부터는 LocalDate와 LocalDateTime이 등장했다.그전에는 자바 기본 날짜타입인 Date클래스, Calenar클래스를 사용했는데 문제점이 꽤나 많아서 오픈소스인 JodaTime을 통해 문제점들을 피하곤했다.하지만 Java8에서부터는 더이상 피할 필요가 없도록 LocalDate와 LocalDateTime이 추가되었다. Date클래스, Calenar클래스 문제점 변하지 않는 객체가 아님 Calenar.OCTOBER 숫자값이 9로 헷갈리게 설정되어있어 문제를 야기함 java.util.Date 클래스 deprecated처리되었지만 이미 작성된 많은 API가 파라미터나 리턴타입으로 Date를 여전히 사용. java.util.Calendar 클래스 정말 자주 사용하는 클래스. switch문은 if조건문으로 변경해도 됨. 예시112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static String getDateString(Calendar c){ int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH)+1; int date = c.get(Calendar.DATE); int dayOfWeek = c.get(Calendar.DAY_OF_WEEK); String day = null; switch(dayOfWeek){ case Calendar.SUNDAY : day = \"일\"; break; case Calendar.MONDAY : day = \"월\"; break; case Calendar.TUESDAY : day = \"화\"; break; case Calendar.WEDNESDAY : day = \"수\"; break; case Calendar.THURSDAY : day = \"목\"; break; case Calendar.FRIDAY : day = \"금\"; break; case Calendar.SATURDAY: day = \"토\"; break; default : System.out.println(\"다시입력해주세요\"); } return String.format(\"%d년 %d월 %d일(%s)\", year, month, date, day); }public static String getTimeString(Calendar c){ int hour = c.get(Calendar.HOUR); int minute = c.get(Calendar.MINUTE); int second = c.get(Calendar.SECOND); int amPm = c.get(Calendar.AM_PM); String smPmString = (amPm == Calendar.AM ? \"오전\":\"오후\"); return String.format(\"%d시 %d분 %d초(%s)\", hour, minute, second, smPmString);}public static void main(String[] args) { Calendar cal = Calendar.getInstance(); System.out.println(\"오늘은 : \"+getDateString(cal)); System.out.println(\"지금 시각은 : \"+getTimeString(cal)); int futureY = 2030; cal.set(Calendar.YEAR, futureY); System.out.println(futureY+\"년 오늘은 : \"+getDateString(cal));}//출력값오늘은 : 2020년 8월 6일(목)지금 시각은 : 9시 42분 29초(오전)2030년 오늘의 요일은 : 2030년 8월 6일(화) 예시2 Calendar.getInstance().set()을 통해서 연산의 첫 시작일을 셋팅할 수 있다. 12345678910111213141516171819202122232425public static String printSimpleCalendar(Calendar c){ int month = c.get(Calendar.MONDAY)+1; int date = c.get(Calendar.DATE); return String.format(\"%d월 %d일\", month, date);}public static void main(String[] args){ Calendar cal = Calendar.getInstance(); //cal.set(Calendar.DATE, 23); System.out.println(\"최초 : \"+printSimpleCalendar(cal)); cal.add(Calendar.DATE, 20); System.out.println(\"20일 add 후 : \"+printSimpleCalendar(cal)); cal.roll(Calendar.DATE, -20); System.out.println(\"-20일 roll 후 : \"+printSimpleCalendar(cal));}//주석해제 전 출력값최초 : 8월 6일20일 add 후 : 8월 26일-20일 roll 후 : 8월 6일//주석해제 후 출력값최초 : 8월 23일20일 add 후 : 9월 12일-20일 roll 후 : 9월 22일 java.time 패키지 java.util패키지 안에 date와 calendar 클래스만 있다가 여러 번거로움때문에 아예 패키지가 생겼다. 그것이 바로 time패키지이다. 날짜/시간 정보의 조회와 변경 LocalDate, LocalTime, LocalDateTime : 현재 소속된 로컬의 시간과 날짜정보를 다루는 클래스. ZoneDateTime : 특정 타임존의 날짜와 시간을 다루는 클래스.(LocalDate, LocalTime, TimeZone이 합쳐진 형태이다) 위 클래스들의 공통 정적 메서드 2가지: now() : 현재 시각을 기준으로 날짜 또는 시간 정보를 갖는 객체를 리턴. of() : 각 객체가 가지는 요소들(LocalDate는 년/월/일정보, LocalTime은 시/분/초)을 파라미터로 받아서 객체를 생성. 참고링크 : java.time패키지 모든 클래스 및 메서드 1234567891011121314public static void main(String[] args) { LocalDateTime datetime = LocalDateTime.of(1991, 12,25,12,30,1); LocalDateTime curdatetime = LocalDateTime.now(); System.out.println(\"기준일 : \" + datetime + \"-\" + datetime.getDayOfWeek()); LocalDateTime lastday = datetime.with(TemporalAdjusters.lastDayOfYear()); LocalDateTime curdatetimelast = curdatetime.with(TemporalAdjusters.lastDayOfMonth()); System.out.println(\"지정한 한 해의 마지막일 : \" + lastday + \"-\" + lastday.getDayOfWeek()); System.out.println(\"올해 이번달 마지막일 : \" + curdatetimelast + \"-\" + curdatetimelast.getDayOfWeek());}//출력값기준일 : 1991-12-25T12:30:01-WEDNESDAY지정한 한 해의 마지막일 : 1991-12-31T12:30:01-TUESDAY올해 이번달 마지막일 : 2020-08-31T11:34:23.765-MONDAY 날짜와 시간 비교 Period.between() : 년/월/일 차이 계산(각 단위별로 연산) Duration.between() : 초/나노 초 계산(총 시간을 기준으로 연산) ChronoUnit.XXX.between() : 모든 단위 계산(총 시간을 기준으로 연산) 참고링크 : 날짜와 시간 비교하기 표 1234567891011121314151617181920212223242526272829public static void main(String[] args) { LocalDate date1 = LocalDate.of(1953, 8, 15); LocalDate date2 = LocalDate.now(); Period p = Period.between(date1, date2); System.out.println(p); System.out.println(\"몇 년 차이 ? \"+ p.getYears()); System.out.println(\"몇 월 차이 ? \"+ p.getMonths()); System.out.println(\"몇 일 차이 ? \"+ p.getDays()); long monDiff = ChronoUnit.MONTHS.between(date1, date2); System.out.println(\"총 몇 개월 차이 ? \"+monDiff); LocalDateTime dt1 = LocalDateTime.of(2011, 3, 01, 1,1,1); LocalDateTime dt2 = LocalDateTime.of(2020, 3, 01, 1,1,1); Duration d = Duration.between(dt1, dt2); System.out.println(d); System.out.println(\"getSeconds사용한 몇 초 차이? \"+d.getSeconds()); long secDiff = ChronoUnit.SECONDS.between(dt1, dt2); System.out.println(\"chronounit사용한 몇 초 차이? \"+ secDiff);}//출력값P66Y11M22D몇 년 차이 ? 66몇 월 차이 ? 11몇 일 차이 ? 22총 몇 개월 차이 ? 803PT78912HgetSeconds사용한 몇 초 차이? 284083200chronounit사용한 몇 초 차이? 284083200 날짜와 시간 표현 포맷팅 : 객체를 원하는 형태의 문자열로 변환하는 과정. 파싱의 반대. 파싱 : 문자열을 객체로 변경하는 과정. 포맷팅의 반대. 123456789101112131415161718public static void main(String[] args) { LocalDateTime date = LocalDateTime.of(2011, 2,5,1,11,0); System.out.printf(\"기본 날짜 출력 : %s%n\", date); System.out.println(date.format(DateTimeFormatter.BASIC_ISO_DATE)); System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE)); //추천 System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_TIME)); System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)); System.out.println(date.format(DateTimeFormatter.ISO_ORDINAL_DATE)); System.out.println(date.format(DateTimeFormatter.ISO_WEEK_DATE));}//출력값기본 날짜 출력 : 2011-02-05T01:11201102052011-02-0501:11:002011-02-05T01:11:002011-0362011-W05-6 DateTimeFormatter는 다양한 포맷의 출력을 지원하지만 개발자가 원하는 형태의 출력이 아닐 수 있다. 이때는 ofPattern()을 이용하면 됨! 참고링크 : String을 파싱하여 LocalDate로 변환하는 예시","link":"/2020/08/05/200806javai/"},{"title":"[jQuery] click(), bind(), event.preventDefault(), unbind(), keyup()","text":"클릭이벤트 : click(), bind(), on() 참고링크 : click()이벤트 bind(“이벤트종류”, 실행코드) : 해당요소에 이벤트를 등록시키는 함수 click(function(){}) : 클릭이벤트 함수 on(“이벤트종류”, 실행코드) : 이벤트처리함수 체이닝기법 : 점을 통해서 함수를 이어주는 기법이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 제이쿼리 라이브러리연결 --&gt;&lt;script type=\"text/javascript\" src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function(){ //이벤트처리하는 방법 1안 : bind(\"이벤트종류\", 기능)사용 //바인드는 이벤트 여러개 연결가능 $('input').bind(\"click mouseover\",function(){ alert(\"제이쿼리 클릭!\"); }); //이벤트처리하는 방법 2안 : click(기능)사용 $('input').click(function(){ alert(\"클릭함수\"); }); //h2태그 클릭시 alert창 출력 -&gt; h2태크 클릭시 해당 요소에만 '+'문자추가 $('h2').click(function(){ //this : 클릭 이벤트가 발생한 개별 h2태그 $(this).html(function(index, text){ //alert(text) return text+\"+\" }) }); //마우스오버시 그림변경. 마우스떼면 원래그림으로 //img태그보다는 this 선택자가 더 정확하다. $('img').mouseover(function(){ //$('img').attr('src', '../jq/3.jpg'); $(this).attr('src', '../jq/3.jpg'); }); $('img').mouseout(function(){ //$('img').attr('src', '../jq/1.jpg'); $(this).attr('src', '../jq/1.jpg'); }); //위의 두 동작을 한번에 처리 = &gt;체이닝기법 $('img').mouseover(function(){ $(this).attr('src', '../jq/3.jpg'); }).mouseout(function(){ $(this).attr('src', '../jq/1.jpg'); }); });&lt;/script&gt;&lt;body&gt;&lt;input type=\"button\" value=\"js버튼\" onclick=\"alert('자바스크립트 클릭')\"&gt;&lt;img src=\"../jq/1.jpg\"&gt;&lt;img src=\"../jq/4.jpg\"&gt;&lt;/body&gt; 이벤트실행 방지하기 : event.preventDefault(), unbind() event.preventDefault() : 태그의 기본이벤트 실행을 방지하는 함수 event.stopPropagation() : unbind(); : 한번만 실행하고 이벤트종료 123456789101112131415161718192021222324252627282930&lt;!-- 제이쿼리 라이브러리연결 --&gt;&lt;script type=\"text/javascript\" src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$(function(){//a 링크 클릭시 배경색을 파랑으로 변경 $('a').click(function(event){ $(this).css('background-color','blue'); //이벤트 기본기능 실행 방지 //event.preventDefault();// a링크 기본기능-하이퍼링크를 막음.(페이지 이동 x) //event.stopPropagation(); //return false; //모든이벤트 실행안됨 return true; //return; //모든이벤트 항상실행 }); //h2 클릭했을시 +기호 추가 $('h2').click(function(){ $(this).html(function(index, text){ return text+\"+\" }) $(this).unbind(); //이벤트 한번만 실행하고 이벤트종료 });})//제이쿼리닫음&lt;/script&gt;&lt;body&gt;&lt;h2&gt;이벤트실행을 막는 방법&lt;/h2&gt;&lt;a href=\"https://www.daum.net\"&gt;다음&lt;/a&gt;&lt;/body&gt; 글자수카운트하기 : keyup() 사람인 글자수계산기처럼 글자수를 역으로 카운트해서 200자 내외로 쓸 수 있는 기능을 구현해보자. 내코드내가 구현한 코드는 문제점이 있다 글자를 지울때 글자수가 늘어나지 않는다. 즉 글자의 길이를 구해야만한다. 강사님 코드를 보자. 글자수를 측정하는 것이 아니라 키를 누른만큼을 측정하기때문에 한글은 자음모음으로 구성되기때문에 2카운트씩 기본으로 감소되어버린다 12345678910111213141516171819202122&lt;!-- 제이쿼리 라이브러리연결 --&gt;&lt;script type=\"text/javascript\" src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$(function(){ //textarea 글자 입력시 숫자가 1씩 감사 let count =0; $(\"textarea\").keyup(function(){ count++; console.log(count); return $('#count').text(200 - count); });})&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;h2&gt;&lt;span id=\"count\"&gt;200&lt;/span&gt;&lt;span&gt;자 내외로 입력하세요&lt;/span&gt;&lt;/h2&gt;&lt;br&gt; &lt;textarea rows=\"5\" cols=\"50\"&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;/body&gt; 강사님 제이쿼리코드12345678910111213$(document).ready(function(){ $('textarea').keyup(function(){ $('#count').html(200- $(this).val().length); //입력된 글자수가 200이상이면 red, 200미만이면 black 글자색상변경기능구현 let v = 200 - $(this).val().length; if(v &gt;= 0){ $('#count').css('color', 'black'); }else{ $('#count').css('color', 'red'); } });});","link":"/2020/08/05/200806jspi/"},{"title":"[jQuery] 유효성체크(자바스크립트 vs 제이쿼리), 제이쿼리 기본효과","text":"유효성체크 : 자바스크립트 vs 제이쿼리 처리속도 : 자바스크립트 &gt; 제이쿼리 유동성 : 자바스크립트 &lt; 제이쿼리 필요 상황에 맞게 쓰면 됨 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 제이쿼리 라이브러리연결 --&gt;&lt;script type=\"text/javascript\" src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;//js로 유효성 체크function check(){ //let v = document.fr.txt.value; //name속성값으로 변수설정 let v= document.getElementById(\"data\").value; //id속성값으로 변수설정 console.log(v) if(v == \"\"){ alert(\" 데이터를 입력하시오 \"); document.fr.txt.focus(); return false; }}//제이쿼리를 이용한 유효성 체크$(function(){ $('#fr2').submit(function(){ //alert(\"제이쿼리 사용 폼태그 제어\") let data = $('#data2').val(); //alert(data); if(data == \"\"){ $('#data2').focus(); return false } });});&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"a.jsp\" method=\"get\" id=\"fr\" name=\"fr\" onsubmit=\"return check()\"&gt; 데이터1 : &lt;input type=\"text\" name=\"txt\" id=\"data\"&gt; &lt;input type=\"submit\" value=\"전송\"&gt; &lt;/form&gt; &lt;form action=\"b.jsp\" method=\"get\" id=\"fr2\" &gt; 데이터2 : &lt;input type=\"text\" name=\"txt2\" id=\"data2\"&gt; &lt;input type=\"submit\" value=\"전송2\"&gt; &lt;/form&gt; &lt;/body&gt; 제이쿼리 기본효과 효과 설명 hide() 선택된 요소 사라지게하기 show() 선택된 요소 보여지게하기 toggle() 선택된 요소의 이전 상태에 따라 현재 상태를 반대로 바꿔주기 fadeIn/fadeOut/fadetoggle() fade형태로 업/다운/토글 구현 SlideUp/SlideDown/SlideToggle() 슬라이드형태로 업/다운/토글 구현 fadeTo() 투명도조절(0부터 1까지 값. 0으로갈수록 옅어짐) 주로 쇼핑몰 매진상품에 사용 속도 값 총 4개 입력가능 fast normal slow 1/1000(밀리초)단위 콜백함수 : 적용하려고 하는 효과가 모두 실행된 후 그 다음에 실행되는 함수를 일컬음. 예시 See the Pen ExKxzeR by sowon-dev (@gracehopperdev) on CodePen.","link":"/2020/08/05/200806jspi2/"},{"title":"오픈소스컨트리뷰톤 온라인미팅2 후기","text":"후기오늘도 보라님을 랜선으로 만나게 되어 좋았다.배우는 게 참 많다.컨트리뷰톤 기간동안 모던 튜토리얼을 1회독을 하려고 매일 아침마다 컨트리뷰톤팀과 아침스터디를 하고 있다. 추후 번역작업도 할 예정이기에 영어원문튜토리얼과 한글튜토리얼을 같이 읽고 있었는데 영어원문에 추가된 부분이 있었다! 강한 느낌이 왔다.이것이 내 첫 오픈소스PR이 될거란 강력한 느낌이 ㅋㅋㅋㅋㅋㅋ간단한 것이기때문에 첫PR로 굉장히 좋아보였다.오늘 온라인미팅동안 어떻게 하면 좋을 지 물어보았고 여러 규칙이 잘 정의되어있는 레퍼런스를 보여주셨다.레퍼런스들의 이슈와 PR보면서 많이 배워야지. 레퍼런스1 : eslint/eslint 레퍼런스2 : facebook/jest 첫 오픈소스PR 팁커밋메세지 : 2줄로작성[제목]번역 #이슈번호8월6일기준 영어 원문 반영 프론트앤드를 하면 하는일프론트앤드 jquery - 변한작업 -&gt; vue jsonp, cors : 면접때 프론트앤드개발자에게 무조건 물어봄. 보안이슈이기때문에. 모던js튜토리얼 2회독이상하기 도움이 엄청 되었다. github stats함께 참여하시느 분이 stats 방법을 슬랙으로 공유해주셨다.언젠가 파도타면서 본 적 있었는데 나도 하고싶어졌다!모르는 부분을 도와주신다고하니 든든하다! 브랜치 3개이상 만들기깃 브랜치를 세개이상 만들며 활용해보기가 다음주 과제이다.깃 브랜치에 대해 깊게 공부해야지!","link":"/2020/08/05/200806opensource/"},{"title":"[jQuery] innerfade 라이브러리, animate(속성, 속도, 콜백함수)","text":"jquery.innerfade 라이브러리 화면전환효과를 나타내는 라이브러리이다. 어떠한 효과들이 있는지는 참고링크 : jquery.innerfade에서 확인가능. 라이브러리 사용방법 라이브러리 다운로드사이트의 하단에 있는 zip파일 클릭 라이브러리 다운로드 후 압축해제 후 jquery.innerfade.js파일 복사 프로젝트의 라이브러리 모음 폴더에 jquery.innerfade.js붙여넣기 script태그로 jsp페이지에 연결하기 예시 : li가 0.75초마다 다음 li로 바뀌는 화면전화 효과123456789101112131415161718192021222324&lt;script&gt;&lt;!-- 컴퓨터에 있는 제이쿼리 라이브러리 추가 --&gt;&lt;script src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;!-- innerfade 라이브러리(플러그인 추가) --&gt;&lt;script src=\"../js/jquery.innerfade.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function(){ $(\"#news\").innerfade({ animationtype: \"fade\", speed:750 }); });&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=\"news\"&gt; &lt;li&gt;content 1&lt;/li&gt; &lt;li&gt;content 2&lt;/li&gt; &lt;li&gt;content 3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; animate(속성, 속도, 콜백함수) 함수예시 1번 : div태그 클리시마다 속성값(가로,세로)을 변경 코드 구현 css로 변경하고자하는 속성값 변수에 저장 css로 속성값 변화주기 (이때 parseInt로 형변환) animate() 함수 적용 예시 2번 : 페이지 실행시 h태그가 왼쪽으로 이동하는 코드 구현 animate()로 왼쪽 margin값 증가시키면 됨 예시 3번 : h태그가 왼쪽으로 갔다고 원래 자리로 다시 돌아오는 코드 구현 animate()로 왼쪽 margin값 증가시켰다가 감소시키면 됨 이때 marginRight는 사용하지 않고 marginLeft만 사용함 내코드 : 콜백함수에 원래 위치로 돌아오는 animate()함수적용 강사님코드 : 체이닝기법을 사용해서 animat()함수적용. 체이닝기법사용시 왔다리갔다리도 표현 가능. 예시 4번 : 에니메이션 정지 코드 구현 stop()은 animate한 개를 멈추게 한다 아래 예시의 h4의 경우 animate가 4번 걸려있으므로 4번 stop을 눌러야 멈춘다 clearQueue()는 큐자료구조의 큐와 동일. 에니메이션 큐에 있는 모든 동작 제거. finish()는 효과를 모두 처리하지않고 가장 마지막 결과만 보여줌 예시 5번 : 딜레이시켰다가 animate()실행 delay()사용 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!-- 컴퓨터에 있는 제이쿼리 라이브러리 추가 --&gt;&lt;script src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;//div태그 클리시마다 속성값(가로,세로)을 변경시키기$(document).ready(function(){ $('div').click(function(){ //1-1.가로세로크기를 알아야 변경가능. 가로세로길이 출력 let w = $(this).css('width'); let h = $(this).css('height'); //alert(\" w : \" + w+\", h : \"+h); //1-2.기존의 크기보다 20px 증가 //변수값이 number타입이 아니라서 덧셈연산이 원하는대로 되지않는다 //parseInt로 형변환하면 원하는 기능 구현 //$('div').css('width', parseInt(w)+20); //$('div').css('height', parseInt(w)+20); //1-3.animate(속성, 속도, 콜백함수) //클릭시마다 20px씩 늘어나긴 하는데 뚝뚝 끊긴다 -&gt; 부드럽게 처리하는 걸 animate라고한다 $(this).animate({ width: parseInt(w)+20, height: parseInt(h)+20, },'slow') //2.페이지 실행시 태그 이동(왼쪽 margin값 증가) $('h2').animate({marginLeft: \"200px\"}, 2000, //function(){ alert(\"이동 완료\");} ); $('h3').animate({ marginLeft:\"200px\", width : \"100px\" }, 2000); //3.h4 요소가 오른쪽으로 이동했다가 왼쪽으로 이동 구현 //내코드 $('h4').animate({marginLeft:\"300px\"},2000, function(){ $('h4').animate({marginLeft:\"0px\"},2000) }); //강사님코드 : 체이닝기법사용 $('h4').animate({marginLeft: \"200px\" },2000) .animate({marginLeft: \"0px\" },1000) .animate({marginLeft: \"100px\" },1000) .animate({marginLeft: \"0px\" },1000); //4. 정지버튼 클릭시 애니메이션 정지 //stop() vs clearQueue() vs finish() $('#btn').click(function(){ $('h2').stop(); $('h3').stop(); $('h4').stop(); $('h4').clearQueue(); $('h4').finish(); }); //5.h3태그 왼쪽여백 150px 지정,가로길이 100px,5초 // + 1초 기다렸다가 실행 $('h3').delay(1000).animate({ marginLeft: \"150px\", width: \"100px\" },4000); })//click()닫음});&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;시작&lt;/div&gt;&lt;h2&gt;내용1&lt;/h2&gt;&lt;h3&gt;내용2&lt;/h3&gt;&lt;h4&gt;내용3&lt;/h4&gt;&lt;input type=\"button\" value=\"정지\" id=\"btn\"&gt;&lt;/body&gt;","link":"/2020/08/06/200807jspi/"},{"title":"오픈소스컨트리뷰톤 온라인미팅3 후기","text":"현직 꿀팁 서버 : node, spring 주로 사용 백앤드는 스프링배워서 컨트롤러짜는 기능까지 요구 사이드플젝 : 아래 동아리들이 팀원을 구해서 프로젝트랑 연결해줌 비사이드 얍 메이커스 깃헙툴 : 비트박스(?)쓰는 좋은 회사이다 깃은 브랜치기반이 아니라 커밋기반이다. 그냥 이름표이다. 깃헙쉐어 5천명 -&gt; API횟수초과 power apps 기술 : women who code에서 마이크로소프트랑합작으로 만든 회사. 프론트앤드 웹스킬 한방에 정리한 사이트 면접, 취업꿀팁 프론트앤드 신입/경력과제 todoapp 배포(줄글로) zeplin.io 로 디자인 시안을 해서 화면을 주면 그걸 보고 구현 면접질문 클로저 번역하면서 이런 내용은 보충되었으면 하는 내용을 정리해보았습니다.스코프의 정의: 이름(변수)의 유효범위렉시컬 스코프: 정적 스코프라고도 불리운다. 동적 스코프의 단점 때문에 등장한 개념으로, 관련 내용은 ‘코딩을 지탱하는 기술’ 제 7장 ‘이름과 스코프’에서 확인할 수 있다. 배열과 메서드 학습팁! 배열을 조작하는지, 아니면 기존 배열은 건드리지 않고 조건을 적용한 새로운 배열을 반환하는지에 주의하며 메서드를 살펴보시기 바랍니다. pure function에 대한 자료들도 읽어보시면 좋을 것 같습니다. 현업에서 자주사용하는 언어 프론트개발자 : vue, ts(타입스크립트)로 진행함 프론트앤드 삼대장 : 뷰, 리액트, 앵귤러(카카오톡이 밀고있음) 순수js를 쓰는 회사는 거의없다 앱만들때는 : ios코틀린, 리액트(iso,안드), 네이티브 QA자동화 : 카탈론(자바랑 리액트) Q. 브랜치명 작성은 보통 어떻게 하는 지? 브랜치명 : 이슈나 티켓기반으로 작업 &gt; 브랜치명을 이슈번호나 티켓번호가 자동으로 셋팅됨. 브랜치명이 다른 팀원과 겹쳐도 됨. 실무 Feature/{issue number}/기능설명 기능개발: feature 버그: bugfix 오픈소스에 PR 하기전에 필수. 서버에 돌려보기 git fetch하기 commit명 잘 작성하기 pr하기 pr제목옆에 커밋명작성 퀴즈 아이디어 : 한줄 틀리게 적어놓고 틀린부분 찾으세요","link":"/2020/08/07/200808opensource/"},{"title":"포맷팅클래스 : StringTokenizer 클래스, DecimalFormat 클래스, SimpleDateFormat 클래스, MessageFormat클래스","text":"StringTokenizer 클래스 구분자를 이용해서 문자열을 분리 및 관리함 쌍따옴표안에 두개의 인자를 공백을 주고 넣을 수 있음 아래 예시에서 토큰은 :와,로 구분됨 (이름 제와피 나이 77 주소 서울 총6개) 1234567public static void main(String[] args) { String s = \"이름:제와피, 나이:77, 주소:서울\"; StringTokenizer tokens = new StringTokenizer(s, \": ,\"); System.out.println(\"총 토큰의 개수 : \"+tokens.countTokens());}//출력값총 토큰의 개수 : 6 형식화클래스 Object객체의 toString()으로 형식화하기 어려운 두가지가 존재한다. 기본형데이터타입 중 숫자 Date클래스 이들을 읽기 쉬운 문자열로 바꾸는데 사용되는 클래스 = 형식화클래스. 형식화클래스 종류 DecimalFormat SimpleDateFormat MessageFormat DecimalFormat 클래스 사용방법 위의 표를 참고하여 사용할 패턴을 정하기 객체생성 : 생성자에 패턴문자 전달하기 만든 객체 사용하기 예시 : double 1234.5를 원화로 형식화하기 1234567891011double orgNum = 1234.5;//원화기호표시를 `\\`대신 `￦`으로 나타내주는 변수 symbolString symbol = Currency.getInstance(Locale.KOREA).getSymbol();//객체생성DecimalFormat df = new DecimalFormat(symbol+\"#,###.#\");System.out.println(df.format(orgNum));//출력값￦1,234.5 SimpleDateFormat 클래스 DateFormatter와의 차이점 : SimpleDateFormat클래스는 date객체에서 사용됨. 나머지는 동일. 사용방법 위의 표를 참고하여 사용할 패턴을 정하기 객체생성 : 생성자에 패턴문자 전달하기 만든 객체 사용하기 예시 : 12345678910111213141516//date 객체사용Date now = new Date();SimpleDateFormat sdf = new SimpleDateFormat(\"yy-MM-dd\");System.out.println(sdf.format(now));sdf = new SimpleDateFormat(\"yy년 MM월 dd일\");System.out.println(sdf.format(now));sdf = new SimpleDateFormat(\"yyyy년의 D번째 날\");System.out.println(sdf.format(now));//출력값20-08-1020년 08월 10일2020년의 223번째 날 MessageFormat 클래스 +를 대신 :,{}를 사용하여 간단하게 표현가능하다. 예시 12345678910111213public static void main(String[] args) throws ParseException { String pattern = \"이름:{0}, Java:{1}, HTML:{2}, Script:{3}\"; String src = \"영희:100:90:85,철수:90:80:70\"; String[] studentInfo = src.split(\",\"); for(String student : studentInfo){ System.out.println(MessageFormat.format(pattern, student.split(\":\"))); }}//출력값이름:영희, Java:100, HTML:90, Script:85이름:철수, Java:90, HTML:80, Script:70","link":"/2020/08/09/200810javai/"},{"title":"Ajax : DB데이터를 불러와서 json형태로 변경하여 출력하기","text":"필요한 라이브러리 추가필요한 라이브러리는 2가지 json-simple 라이브러리 추가 가장 최신버전을 다운르도하면 된다 json-simple-1.1.1.jar connector라이브러리 추가 mysql-connector-java-5.1.38-bin.jar Json3.html생성DB(Mysql)에 저장된 정보를 JSON으로 변경해서 출력 123456789101112131415161718192021222324252627282930313233&lt;script src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" &gt;$(function(){ $.getJSON('Json3.jsp', function(data){ $.each(data, function(index, item){ $('table').append(\"&lt;tr&gt;&lt;td&gt;\"+item.name+\"&lt;/td&gt;\"+\"&lt;td&gt;\"+item.subject+\"&lt;/td&gt;\"+\"&lt;td&gt;\"+item.content+\"&lt;/td&gt;&lt;/tr&gt;\") }) })})&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; DB(Mysql)에 저장된 정보를 JSON으로 변경해서 출력 &lt;/h1&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;작성자&lt;/td&gt; &lt;td&gt;글 제목&lt;/td&gt; &lt;td&gt;글 내용&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;//출력값DB(Mysql)에 저장된 정보를 JSON으로 변경해서 출력작성자 글 제목 글 내용a a aaahoho 아프지말고~ 자이언티~b b bc c cd d de e e점심 오늘 점심메뉴 오늘 점심메뉴는 쌀국수이다. Json3.jsp생성DB데이터를 불러와서 JSON형태로 변경해서 출력 html 태그 삭제 contentType=”application/json; charset=UTF-8” 로 변경 드라이버로드 &gt; DB연결 &gt; sql &amp; pstmt &gt; 실행 &gt; 데이터처리 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@page import=\"org.json.simple.JSONObject\"%&gt;&lt;%@page import=\"java.sql.ResultSet\"%&gt;&lt;%@page import=\"java.sql.PreparedStatement\"%&gt;&lt;%@page import=\"java.sql.Connection\"%&gt;&lt;%@page import=\"java.sql.DriverManager\"%&gt;&lt;%@page import=\"java.sql.SQLException\"%&gt;&lt;%@ page language=\"java\" contentType=\"application/json; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;% //&lt;h1&gt; DB데이터를 불러와서 JSON형태로 변경 출력 &lt;/h1&gt; // 1. 드라이버로드 String DRIVER = \"com.mysql.jdbc.Driver\"; String DBURL = \"jdbc:mysql://localhost:3306/jspdb\"; //사용할DB이름 String DBID = \"root\"; String DBPW = \"1234\"; //2. DB연결 Class.forName(DRIVER); System.out.println(\"드라이버 로드 성공!\"); Connection con = DriverManager.getConnection(DBURL, DBID, DBPW); System.out.println(\"DB 연결 성공!\"+con); //3.sql &amp; pstmt String sql = \"select * from itwill_board\"; PreparedStatement pstmt = con.prepareStatement(sql); //4.실행 ResultSet rs = pstmt.executeQuery(); //5. //기존방식: 행 1줄을 자바빈객체에 저장해서 ArrayList 한 칸에 저장 //json이용한 방식: 행 1줄을 jsonObject객체에 저장해서 JsonArray 한 칸에 저장 //5-2.JSONArray 생성 JSONArray arr = new JSONArray(); //5-1.while문 while(rs.next()){ //json object 생성 (import json-simple패키지해야함) JSONObject obj = new JSONObject(); obj.put(\"name\", rs.getString(\"name\")); obj.put(\"subject\", rs.getString(\"subject\")); obj.put(\"content\", rs.getString(\"content\")); //obj.put(\"date\", rs.getDate(\"date\")); //5-3.배열한칸에 객체 하나를 저장 arr.add(obj); } %&gt; &lt;%=arr%&gt; JSON 활용법 중의 하나인 RSS사용법RSS 기상청이나 뉴스등에서 정보를 실시간으로 받아서 내 페이지에 자동으로 출력시켜줄 수 있다. RSS JTBC 참고링크 : 주요 RSS 위의 RSS파일을 클릭하여 주소창의 주소를 복사 주소를 바로 붙여넣어서 될 수도 있고 그게 안되면 구글 RSS API를 통하여 RSS데이터를 출력할 수 있다. 구글 API","link":"/2020/08/09/200810jspi2/"},{"title":"단일행함수 : 조건부 표현식","text":"조건부 표현식 SQL 문에서 IF-THEN-ELSE 논리 사용 가능 방법 2가지 : CASE 식 검색된 CASE 표현식 DECODE 함수 CASE식 CASE로 시작해서 END로 끝난다 = 사용 예시 : EMPLOYEES테이블에서 JOB_ID가 IT인 사람은 연봉에서 10%인상, ST인 사람은 30%연봉인상 그 외는 급여인상이 없다는 테이블을 만들어보자. “수정된_연봉” : 엘리야스이다. 1234567891011121314//기본형CASE 표현1 WHEN 비교표현1 THEN 리턴표현1 WHEN 비교표현2 THEN 리턴표현2 ... ELSE 엘스표현END//예시 select job_id, salary, case job_id when 'IT' then 1.1*salary when 'ST' THEN 1.3*salary ELSE salary END &quot;수정된_연봉&quot;FROM EMPLOYEES; 검색된 CASE 표현식 CASE로 시작해서 END로 끝난다 = 이외 연산자 사용. 예시 : EMPLOYEES테이블에서 고과점수가 500점 미만인 사람은 low, 1000점미만인 사람은 Medium, 2000점미만인 사람은 Good, 그외는 great이라는 테이블을 만들어보자. label : 엘리야스이다. 12345678//예시 select last_name, score,case when score&lt;500 then 'Low'when score&lt;1000 then 'Medium'when score&lt;2000 then 'Good'else 'Great'end labelfrom employees; DECODE 함수 = 사용 예시 : EMPLOYEES테이블에서 JOB_ID가 IT인 사람은 연봉에서 10%인상, ST인 사람은 30%연봉인상 그 외는 급여인상이 없다는 테이블을 만들어보자. “수정된_연봉” : 엘리야스이다. 123456789//기본형DECODE(컬럼명, 비교표현1, 리턴표현1, 비교표현2, 리턴표현1, ..., default) &quot;엘리야스&quot;//예시select job_id, salary, decode job_id, 'IT', 1.1*salary 'ST', 1.3*salary salary) &quot;수정된_연봉&quot;FROM EMPLOYEES;","link":"/2020/08/10/200811dbi/"},{"title":"JSTL과 EL : JSTL과 EL개념, CORE 라이브러리(out)","text":"JSTL (JSP Standard Tag Library)(p510~) 커스텀태그 : 개발자가 직접 정의할 수 있는 태그를 의미. 자카르트회사에서 제공 –인수–&gt; 아파치에서 제공 자주 사용되는 필요한 기능들을 모아놓은 커스텀 태그 라이브러리. 실무에서 사용빈도가 매우 높음. 종류 CORE 라이브러리 변수선언, 조건문, 반복문 처리 가능 페이지 이동처리 가능 Formmating 라이브러리 국제화 : 다국어처리 기능 형식화 : 숫자, 날짜 처리 기능 DataBase 라이브러리 CRUD 처리 기능 XML 라이브러리 xml 처리 기능 JSTL 설정 아파치 톰캣 페이지에서 Impl, Spec, EL 3가지 다운로드. new 다이나믹 웹 프로젝트를 생성해서 위의 3가지 라이브러리 추가. EL (Expression Language)(p512~) JSTL과 EL은 거의 같이 사용함. JSP 스트립트 태그(&lt;%=%&gt;)를 대신하여 JSP값들을 좀더 편리하게 출력하기 위해 제공되는 언어. 123456//JSP표현식&lt;%=HELLO%&gt;//EL${hello}//제이쿼리랑 비슷하게 생겼지만 다름 EL 내장객체 EL 특징 EL태그안에서는 연산가능 값이 null일 경우 NullPointerException이 아니라 빈 공백으로 출력됨 빈 공백은 default 속성을 사용해서 원하는 문자 출력 가능. 배포 후 서비스운영시 에러가 나서 서버가 다운되는 것보다 빈 공백으로 표시되는게 훨씬 좋음 빈 공백은 default 속성을 사용해서 원하는 문자 출력 가능. 태그를 body에 나타내고 싶을때 방법 2가지 유니코드사용 jstl사용 : 유니코드보다 훨씬 간편 12345678910111213141516171819&lt;!-- 특징 --&gt;&lt;!-- 1.EL태그안에서는 연산가능 --&gt;&lt;c:out value=\"10+20\"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value=\"${10+20}\"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;!-- 2.값이 null일 경우 nullpointexection이 아니라 빈공백으로 출력됨 --&gt;&lt;c:out value=\"${itwill.name}\"/&gt;&lt;br&gt;&lt;c:out value=\"${null}\"/&gt;&lt;br&gt;&lt;!-- 3.빈 공백은 default 속성을 사용해서 원하는 문자 출력 가능. --&gt;&lt;c:out value=\"${null}\" default=\"NULL대신해서 출력\"/&gt;&lt;br&gt;&lt;c:out value=\"${null}\" default=\"${'NULL대신해서 출력 EL태그'}\"/&gt;&lt;br&gt;&lt;!-- 4. 태그를 body에 나타내고 싶을때 방법 2가지--&gt;&lt;itwill&gt;태그명이 itwill입니다&lt;br&gt;&lt;!-- 4-1. 유니코드사용 --&gt;&amp;lt;itwill&gt;태그명이 itwill입니다&lt;br&gt;&lt;!-- 4-2. jstl사용 --&gt;&lt;c:out value=\"&lt;itwill&gt;태그명이 itwill입니다\"/&gt;&lt;br&gt; 화면에 데이터를 출력하는 7가지 방법 html코드 사용해서 출력 out.print() JAVA코드 사용해서 출력 JSP표현식 사용해서 출력 Jquery 사용 출력 EL 표현식 사용해서 출력 JSTL 사용 화면 출력 : 반드시 taglib import해줘야한다. JSTL안에서 EL사용해서 출력 주로 실무에서 5번이나 7번방법을 많이 사용함. c:out 화면에 value값을 출력하는 기능의 태그라이브러리 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!-- 6.jstl을 사용하기위해 taglib import함 prefix를 c로 지정 ex)a를 써도되고 b를 써도되는데 일반적으로 core lib를 뜻하는 c를 쓴다. *반드시 태그라이브러리 추가를 해야지만 사용가능 --&gt; &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%&gt; &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;!-- 컴퓨터에 있는 제이쿼리 라이브러리 추가 --&gt;&lt;script src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function(){ $('body').append(\"4. Jquery 사용 출력&lt;br&gt;\"); });&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;화면에 데이터를 출력하는 7가지 방법&lt;/h2&gt;1. html코드 사용해서 출력&lt;br&gt;&lt;%out.print(\"2. out.print() JAVA코드 사용해서 출력&lt;br&gt;\");%&gt;&lt;%=\"3. JSP표현식 사용해서 출력&lt;br&gt;\"%&gt;${\"5. EL 표현식 사용해서 출력&lt;br&gt;\" }&lt;!-- c:out 화면에 value값을 출력하는 기능의 태그라이브러리 --&gt;&lt;c:out value=\"6. JSTL 사용 화면 출력\"&gt;&lt;/c:out&gt;&lt;br&gt;&lt;c:out value=\"${'7. JSTL안에서 EL사용해서 출력'}}\"&gt;&lt;/c:out&gt;&lt;br&gt;//출력값화면에 데이터를 출력하는 7가지 방법1. html코드 사용해서 출력2. out.print() JAVA코드 사용해서 출력3. JSP표현식 사용해서 출력5. EL 표현식 사용해서 출력6. JSTL 사용 화면 출력7. JSTL안에서 EL사용해서 출력}4. Jquery 사용 출력","link":"/2020/08/10/200811jspi/"},{"title":"오픈소스 Git 기여순서(취소포함)","text":"GitHub에서 기여할 소스의 레포를 fork하여 내 레포에 생성하기 클라우드상에서 이루어지는 부분 git clone 내fork레포주소 .git파일이 자동 생성되며 커밋정보나 이력이 저장됨. 아래 3가지의 차이는? fork : 클라우드upstream repo와 서버your fork사이에서 이루어짐. 즉 클라우드상에서만 이루어짐 clone: 서버에서 내 로컬로 받아오는 것 copy: clone과 동일하다고 생각하면 됨 1git clone 내fork레포주소 code . 주력 에디터로 열기 열코~ : 작업하기git status bash에서 git status 명령어를 입력하면 내가 수정한 부분이 modified 표시와 함께 빨간색으로 표시됨 modified 취소하고싶으면?1git checkout unmodified하고싶은_파일명 git add의 의미 워드나 한글등의 일반 파일들은 저장이라는 기능으로 한꺼번에 저장을 한다. 하지만 프로그래머는 소스코드 기능개발중 버그를 유발하는 코드를 수정해야한다. git add의 의미 : 내가 원하는 것만 커밋하기 위해 add를 한다 git add를 취소하고싶으면?1git reset add취소하고싶은_파일명 git commit -m '의미있는 커밋명' commit의 단위 : 논리적 변경이 있을 때 1개를 만든다. commit을 잘 나누는 개발자가 능력있는 개발자이다. commit을 잘못 쳐서 지우고 싶다면?1234567//git reset을 쓰면되는데 옵션이 3가지임.--soft : commit후의 Unmodified에서 commit전의 staged상태로 되돌아가는 옵션--mixed : 기본옵션. commit후의 Unmodified에서 commit전의 modified상태로 되돌아가는 옵션--hard : commit후의 Unmodified에서 commit 전의 Unmodified로 되돌아가는 옵션//잘못된 가장 최근의 커밋 한개를 지우고 싶을때 예시git reset HEAD~1 불필요한 커밋을 합치려면 또는 큰 커밋을 작은 커밋단위로 쪼개려면? rebase git push 저장소명 브랜치명 어느 저장소의 어떤 브랜치에 push할지를 잘 체크해야한다. git remote -v 에서 origin 하나만 있을 경우 git push하면 git push origin master와 동일한 결과가 된다.12//예시git push origin master 깃헙에서 내fork레포의 Pull request버튼 클릭 실제 현업에선 절대 master로 PR보내는 것이 금지. 대부분 develop등 개발전용 브랜치에 PR보내도록 한다. PR 제목도 회사규칙에 따라 잘 남겨야한다. 예시 : [주제제목] 작업내용 PR 메세지 남길 때 체크박스 체크하기 원하려면 [X] : 공백없어야 함. PR을 보내면 공식레포메니저에게 알림이메일이 감 공식레포메니저는 Jenkins서버 github에 변경내역을 webhook으로 감지가 되면 jenkis서버가 실행되고 build server가 연동되어 변경내역이 서버에 올라간다","link":"/2020/08/10/200811opensource/"},{"title":"컬렉션 프레임워크1: Set과 List계열 예시위주","text":"Collections 프레임워크 컬렉션 프레임워크: java.util에 있는 클래스들로 자료구조를 담당한다. 자료구조: 대량의 데이터를 효율적으로 이용할 수 있도록 컴퓨터에서 데이터를 추가,조회,수정,삭제(CRUD)하는 방식. 자료구조 개념1 : Collections Framwork(Set계열, List계열) 자료구조 개념2 : Stack클래스, Queue인터페이스, Map인터페이스 개념은 위의 링크로 대체하고 이 글에서는 응용이나 예시위주로 확인해보려고한다. Collections 인터페이스의 메서드 Collections 인터페이스는 List와 Set계열의 공통 조상으로 아래 메서드 사용가능 아래 메서드들 중 index사용하는 메서드는 set계열에서 사용할 수 없다. WHY? set은 index가 없기때문에! List와 Set 특징비교 계열 특징 방법 List 중복가능 데이터가 중복되어도 index로 구분함 각 요소접근 index사용하면 됨 데이터조회 indexOf()로 위치찾기가능, contains()로 데이터유무(boolean) 확인가능 데이터수정 set() 정렬 sort() set 중복불가능 중복데이터제거를 위해 @Override hashcode()와 equals() 재정의필수 각 요소접근 index 정렬불가능-&gt; iterator객체의 hasNext(), next()사용 데이터조회 contains()로 데이터유무(boolean) 확인가능, for(Object obj : hashset명 ){ System.out.println(obj)} 데이터수정 인덱스가 없어서 데이터수정없음불가능 -&gt; 걍 삭제(remove) 후 추가(add) 정렬 index없어서 sort()사용불가 -&gt; TreeSet&lt;&gt;이용 List계열 : ArrayList와 LinkedList 성능차이 ArrayList 단점 : 비순차적인 데이터의 추가, 삭제에 많은 시간이 걸림 이를 해결하기 위해 LinkedList가 있음 LinkedList 특징 : 각 요소를 Node(노드)로 정의. Node는 다음요소의 참조값과 데이터로 구성됨. 각 노드는 링크정보를 가지므로 ㅔ이터를 연속으로 구성할 필요가 없음. 따라서 ArrayList가 전체전익 요소를 움직였던 것에 비해 훨씬 가볍게 작동함. 그렇다면 ArrayList와 LinkedList 데이터처리과정별 성능차이는 어떨까? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 private static void addTest(String testcase, List&lt;Object&gt; list){ long start = System.nanoTime(); for(int i=0; i&lt;1000000; i++){ list.add(new String(\"Hello\")); } long end = System.nanoTime(); System.out.println(testcase+\" 소요시간: \"+(end-start)); } private static void addTest2(String testcase, List&lt;Object&gt; list){ long start = System.nanoTime(); for(int i=0; i&lt;100000; i++){ list.add(0, new String(\"Hi\")); } long end = System.nanoTime(); System.out.println(testcase+\" 소요시간: \"+(end-start)); } private static void accessTest(String testcase, List&lt;Object&gt; list){ long start = System.nanoTime(); for(int i=0; i&lt;100000; i++){ list.get(i); } long end = System.nanoTime(); System.out.println(testcase+\" 소요시간: \"+(end-start)); } public static void main(String[] args) { ArrayList&lt;Object&gt; alist = new ArrayList&lt;Object&gt;(); LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;(); addTest(\"순차적 추가: ArrayList\", alist); addTest(\"순차적 추가: LinkedList\", list); addTest2(\"중간에 추가: ArrayList\", alist); addTest2(\"증간에 추가: LinkedList\", list); accessTest(\"데이터접근: ArrayList\", alist); accessTest(\"데이터접근: LinkedList\", list); }//출력값순차적 추가: ArrayList 소요시간: 37748800순차적 추가: LinkedList 소요시간: 85107500중간에 추가: ArrayList 소요시간: 15683133500증간에 추가: LinkedList 소요시간: 3635400데이터접근: ArrayList 소요시간: 2516900데이터접근: LinkedList 소요시간: 7363336600 List계열 : ArrayList&lt;&gt; 로또게임 예시 로또는 1부터 45까지의 숫자가 적힌 공 중에서 당첨공 6개와 보너스공 1개를 랜덤으로 뽑는다. 이 공들은 중복을 허용하지않는다. List는 중복을 허용하는 계열인데 어떻게하면 로또를 만들 수 있을까? contains()로 중복확인가능 1234567891011121314151617181920212223242526272829303132333435class ListLotto{ Integer bonus; List&lt;Integer&gt; lotto = new ArrayList&lt;&gt;(); public void setup(){ Random rd = new Random(); while(bonus == null){ int num = rd.nextInt(45)+1; if(!lotto.contains(num)){ if(lotto.size() &lt; 6){ lotto.add(num); }else{ bonus = num; } } Collections.sort(lotto); } } @Override public String toString() { return &quot;당첨번호: &quot;+lotto+&quot;, 보너스: &quot;+bonus; }}public class ListLottoTest { public static void main(String[] args) { ListLotto lotto = new ListLotto(); lotto.setup(); System.out.println(lotto); }} Set계열 : TreeSet&lt;&gt; 정렬 set계열을 정렬하기만 원한다면 TreeSet&lt;&gt;안에 넣기만 하면 됨. TreeSet&lt;&gt;은 add()가 안됨 -&gt; 내부적으로 알파벳오름차순인데 객체가 add되면 비교가 불가능함. Treeset&lt;&gt;()에서 괄호안에 정렬기준을 추가할 수 있다. Treeset&lt;&gt;(new StringLengthComparator()) : StringLength를 기준으로 짧은 String이 앞쪽으로 정렬된다. 12345678910111213141516public static void main(String[] args) { TreeSet&lt;Object&gt; set = new TreeSet&lt;&gt;(); set.addAll(Arrays.asList(\"w\",\"a\",\"t\",\"e\",\"r\")); //set.add(3); //exception: cannot be cast to java.lang.Integer Object타입이 들어올 수 있지만 add할때는 동일한 데이터들을 넣어줘야 TreeSet이 비교할 수 있다 //set.add(Arrays.asList(\"삼\",\"다\",\"수\")); //exception : cannot be cast to java.lang.Comparable System.out.println(\"자동으로 오름차순: \"+set); System.out.println(\"처음 요소: \"+set.first()); System.out.println(\"마지막 요소: \"+set.last()); System.out.println(\"a 아래 요소: \"+set.lower(\"a\")); //최하위계증.알파벳순으로 a는 가장먼저이기때문에 최하위계층 System.out.println(\"z 다음 요소: \"+set.higher(\"z\")); //최상위계층.알페벳순으로 z는 가장마지막이기때문에 최상위계층 System.out.println(\"e 다음 요소: \"+set.higher(\"e\")); NavigableSet&lt;Object&gt; naviSet = set.descendingSet(); System.out.println(\"내림차순 : \"+naviSet);} Set계열 : TreeSet&lt;&gt; 로또게임 예시12345678910111213141516171819202122232425262728293031class TreesetLotto{ Integer bonus; Set&lt;Integer&gt; lotto = new TreeSet&lt;&gt;(); public void setup(){ Random rd = new Random(); while(bonus == null){ int num = rd.nextInt(45)+1; if(lotto.size() &lt; 6){ lotto.add(num); }else{ bonus = num; } } } @Override public String toString() { return \"당첨번호: \"+lotto+\", 보너스: \"+bonus; }}public class TreeSetLottoTest { public static void main(String[] args) { TreesetLotto lotto = new TreesetLotto(); lotto.setup(); System.out.println(lotto); }}//출력값당첨번호: [5, 14, 23, 29, 33, 38], 보너스: 31","link":"/2020/08/11/200812javai/"},{"title":"내 로컬저장소를 원격저장소를 반영하여 최신 베이스만들기","text":"내 로컬저장소를 원격저장소를 반영하여 최신 베이스만들기세가지 방법이 있다. 명령어 결과 특징 Git pull 내 로컬머신이 remote저장소베이스 그대로 갱신(브랜치까지 싹 다) 로컬과 remote변경사항 확인불가 Git merge after git fetch fetch후 충돌/차이점 확인 후 내 로컬머신에 갱신, 머지커밋생성됨 로컬과 remote변경사항 확인가능 Git rebase after git fetch 내 커밋아래에 remote의 커밋이 쌓이고 그 위에 내 커밋이 얹음 master브랜치에 사용하지말것 공통 설정 두가지git remote -v origin 저장소만 있다면 최신레포를 가져올 upstream저장소를 연결해줘야한다. origin과 upstream 두개가 있어야하며 origin: 내 아이디가 있는 내fork한 레포주소. upstream: 최신레포를 가져 올 공식레포주소. origin 저장소 주소 변경하고싶다면? 12gir remote -vgit remote set-url origin 변경할주소 git remote add 최신반영하고싶은_저장소이름 최신반영하고싶은_레포주소1git remote add upstream 공식레포주소 최신베이스만들기 첫번째 방법 : pull fetch + merge = pull 1git pull upstream master 최신베이스만들기 두번째 방법 : fetch + rebase git fetch 최신반영하고싶은_저장소이름 가져올브랜치명 fetch는 임시 저장해놓은 것이라서 fetch했다고 내 로컬의 브랜치에 반영되지 않는다 -&gt; fetch분과 내 로컬 브랜치를 merge해줘야한다. 보통 upstream을 많이 사용함. upstream말고 다른 저장소명써도 상관없음. fetch를 쓰는 이유 : 내 로컬저장소와 원격저장소르 비교하여 차이점을 볼 수 있기때문 git rebase upstream/master : 임시저장분(fetch)을 내 로컬머신의 커밋 아래로 저장해야한다. git log : 머지커밋이 생성안됨. 신규 커밋 없음을 확인할 수 있다. git push origin 브랜치명 : 최신베이스가 반영된 내 로컬의 데이터를 깃헙 내fork한레포에 반영하고싶다면 git push하면된다 12345678910111213141516//상황//현재 체크아웃한 브랜치는 fix-blah이고 updatream저장소의 master는 최신베이스이다. //fix-blah의 베이스를 master의 베이스로 만들고 싶다git checkout fix-blah//1. upstream의 master브랜치에 있는 최신 변경분을 가져오다는 의미git fetch upstream master//2. 현재 체크아웃된 fix-blah의 베이스를 upstream의 master베이스로 바꾸겠다는 의미git rebase upstream/master//3. 로그에 rebase 커밋이 남지않음.git log//4. 최신베이스가 반영된 내 로컬의 데이터를 깃헙 내fork한레포에 반영하고싶을때git push origin fix-blah 최신베이스만들기 세번째 방법 : fetch + merge git fetch 최신반영하고싶은_저장소이름 가져올브랜치명 fetch는 임시 저장해놓은 것이라서 fetch했다고 내 로컬의 master브랜치에 반영되지 않는다 -&gt; fetch분과 내 로컬 master브랜치를 merge해줘야한다. 보통 upstream을 많이 사용함. upstream말고 다른 저장소명써도 상관없음. git merge upstream master 임시저장분(fetch)을 내 로컬머신으로 저장하기위해서는 master브랜치로 가야한다 임시저장분(fetch)이 내 로컬머신의 브랜치로 저장된다. git log : 머지커밋이 생성된걸 확인 할 수 있음 git push origin 브랜치명 : 최신베이스가 반영된 내 로컬의 데이터를 깃헙 내fork한레포에 반영하고싶다면 git push하면된다 123456789101112//1. upstream의 master브랜치에 있는 최신 변경분을 가져오다는 의미git fetch upstream master//2. 임시저장분(fetch)이 내 로컬머신의 브랜치로 저장git checkout mastergit merge upstream/master//3. log에 merge커밋이 남음git log//4. 최신베이스가 반영된 내 로컬의 데이터를 깃헙 내fork한레포에 반영하고싶을때git push origin master 최신베이스 유지를 위해 pull이 아닌 fetch &gt; rebase를 해야하는 이유 깃헙저장소 master를 로컬 master로 pull받아온다. 로컬에서 작업 하는 동안 깃헙 저장소에 새로운 커밋이 추가되었다. 여기서 내 로컬과 원격 저장소의 싱크를 맞추고싶다면 즉, 원격의 새로운 커밋을 내 로컬에 반영시키고싶다면 무조건 리베이스해야한다 git pull하면 나중에 커밋한 내용을 합칠 수 없다. git fetch upstream master -&gt; git rebase upstream/master 하면 싱크를 맞출 수 있다. 리베이스는 혼자만 하는 브랜치에서만 작업하는 것이 좋다. 커밋을 하나로 합칠때 interactive rebase 사용해야한다.","link":"/2020/08/10/200811opensource2/"},{"title":"JSTL과 EL : fmt 라이브러리(formatDate, formatNumber)","text":"formatting 라이브러리 형식화 = formatting jstl core 라이브러리처럼 사용가능한 formatting라이브러리 시작 전 항상 라이브러리부터 추가 12&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt; &lt;fmt:formatDate value=”${}”&gt; fmt에서 가장 많이 사용하는 형태임 (formatDate). 현재 시간정보 출력 12&lt;c:set var=\"date\" value=\"&lt;%=new Date() %&gt;\" /&gt; ${date}&lt;br&gt; 기본 포맷으로 현재 시간정보 출력(default:년월일) 1&lt;fmt:formatDate value=\"${date }\"/&gt;&lt;br&gt; 현재 시간정보에서 시간만 출력 1&lt;fmt:formatDate value=\"${date }\" type=\"time\" /&gt;&lt;br&gt; 날짜와 시간정보 같이 출력 1&lt;fmt:formatDate value=\"${date }\" type=\"both\" /&gt;&lt;br&gt; 날짜 스타일별 출력 1234&lt;fmt:formatDate value=\"${date }\" dateStyle=\"full\"/&gt; &lt;br&gt;&lt;fmt:formatDate value=\"${date }\" dateStyle=\"long\"/&gt; &lt;br&gt;&lt;fmt:formatDate value=\"${date }\" dateStyle=\"medium\"/&gt; &lt;br&gt;&lt;fmt:formatDate value=\"${date }\" dateStyle=\"short\"/&gt; &lt;br&gt; 시간 스타일별 출력12345&lt;fmt:formatDate value=\"${date }\" type=\"time\"/&gt; &lt;br&gt;&lt;fmt:formatDate value=\"${date }\" timeStyle=\"full\" type=\"time\"/&gt; &lt;br&gt;&lt;fmt:formatDate value=\"${date }\" timeStyle=\"long\" type=\"time\"/&gt; &lt;br&gt;&lt;fmt:formatDate value=\"${date }\" timeStyle=\"medium\" type=\"time\"/&gt; &lt;br&gt;&lt;fmt:formatDate value=\"${date }\" timeStyle=\"short\" type=\"time\"/&gt; &lt;br&gt; 가장 많이 사용하는 날짜 시간 포맷으로 출력- 소문자 mm : 시간의 분을 나타남. 헷갈리지 말것.1234567891011121314151617&lt;fmt:formatDate value=\"${date }\" type=\"both\" dateStyle=\"long\" timeStyle=\"long\" /&gt;&lt;br&gt;//2. 날짜 정보를 yyyy/MM/dd(E) 패턴으로 출력 : //소문자 mm : 시간의 분을 나타남. 헷갈리지말것&lt;fmt:formatDate value=\"${date }\" pattern=\"yyyy/MM/dd/(E)\"/&gt;&lt;br&gt;//3. yy-MM-dd(E) 패턴으로 출력 :&lt;fmt:formatDate value=\"${date }\" pattern=\"yy-MM-dd(E)\"/&gt; &lt;br&gt;//4. 시간정보를 오전오후로 출력&lt;fmt:formatDate value=\"${date }\" pattern=\"(a)hh:mm:ss\"/&gt; &lt;br&gt;//출력값2020년 8월 12일 (수) 오후 5시 03분 59초2020/08/12/(수)20-08-12(수)(오후)05:03:59 나라별 로컬시간대와 로컬화폐단위를 출력 예시 날짜정보를 포맷팅해서 사용하기 위한 변수생성 core라이브러리와 formatting 라이브러리 추가 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- core 라이브러리 추가 --&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!--3. formatting 라이브러리 추가 --&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 형식화(formatting)1. jstl core 라이브러리처럼 사용가능2. 날짜정보를 포맷팅해서 사용하기 위한 변수생성 --&gt; &lt;c:set var=\"date\" value=\"&lt;%=new Date() %&gt;\"/&gt;&lt;c:out value=\"${date }\"/&gt;&lt;hr&gt;&lt;fmt:formatDate value=\"${date }\"/&gt;&lt;hr&gt;&lt;h2&gt;우리나라&lt;/h2&gt;&lt;fmt:setLocale value=\"ko_kr\"/&gt; 금액 : &lt;fmt:formatNumber value=\"100000000000\" type=\"currency\"/&gt;&lt;br&gt; 날짜 : &lt;fmt:formatDate value=\"${date }\" dateStyle=\"full\"/&gt; &lt;h2&gt;미국&lt;/h2&gt;&lt;fmt:setLocale value=\"en_us\"/&gt; 금액 : &lt;fmt:formatNumber value=\"100000000000\" type=\"currency\"/&gt;&lt;br&gt; 날짜 : &lt;fmt:formatDate value=\"${date }\" dateStyle=\"full\"/&gt;&lt;h2&gt;일본&lt;/h2&gt;&lt;fmt:setLocale value=\"ja_jp\"/&gt; 금액 : &lt;fmt:formatNumber value=\"100000000000\" type=\"currency\"/&gt;&lt;br&gt; 날짜 : &lt;fmt:formatDate value=\"${date }\" dateStyle=\"full\"/&gt;//출력값Wed Aug 12 16:09:42 KST 20202020. 8. 12우리나라금액 : ￦100,000,000,000날짜 : 2020년 8월 12일 수요일미국금액 : $100,000,000,000.00날짜 : Wednesday, August 12, 2020일본금액 : ￥100,000,000,000날짜 : 2020年8月12日 &lt;fmt:formatNumber value=””&gt; 숫자데이터를 원하는 형태로 출력가능하게 하는 formatting라이브러리 시작 전 항상 라이브러리부터 추가12&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt; 숫자를 3자리마다 콤마를 찍고싶다면 fmt:formatNumber groupingUsed=”true”가 default이다 12345678 &lt;fmt:formatNumber value=\"100000000\" /&gt;&lt;br&gt; &lt;fmt:formatNumber value=\"100000000\" groupingUsed=\"true\"/&gt;&lt;br&gt; &lt;fmt:formatNumber value=\"100000000\" groupingUsed=\"false\"/&gt;&lt;br&gt; //출력값100,000,000100,000,000100000000 소수점자리 표현 &lt;fmt:formatNumber value=”” pattern=””&gt; pattern속성 : 숫자는 #으로, 자리수는 .으로 표시 12345678910111213&lt;h2&gt; 3.1234643 소수점 두번째 자리 까지만 표현 &lt;/h2&gt;소수점 처리 : &lt;fmt:formatNumber value=\"3.1234643\" /&gt; (기본값) &lt;br&gt;소수점 처리 : &lt;fmt:formatNumber value=\"3.1234643\" pattern=\"#.##\" /&gt;&lt;br&gt;소수점 처리 : &lt;fmt:formatNumber value=\"3.1234643\" pattern=\"#.#######\" /&gt;&lt;br&gt;소수점 처리 : &lt;fmt:formatNumber value=\"3.1234643\" pattern=\"#.##########\" /&gt;&lt;br&gt;소수점 처리 : &lt;fmt:formatNumber value=\"3.1234643\" pattern=\"####.#\" /&gt;&lt;br&gt;//출력값소수점 처리 : 3.123 (기본값)소수점 처리 : 3.12소수점 처리 : 3.1234643소수점 처리 : 3.1234643소수점 처리 : 3.1 빈자리수는 0을 채워서 표현 &lt;fmt:formatNumber value=”” pattern=”##.00”&gt; 123456789101112&lt;fmt:formatNumber value=\"30.1\" pattern=\"##.##\"/&gt;&lt;br&gt;&lt;fmt:formatNumber value=\"30.1\" pattern=\"##.00\"/&gt;&lt;br&gt;&lt;fmt:formatNumber value=\"30.1\" pattern=\"00.00\"/&gt;&lt;br&gt;&lt;fmt:formatNumber value=\"30.1\" pattern=\"00.77\"/&gt;&lt;br&gt;&lt;fmt:formatNumber value=\"30.1\" pattern=\"#00.00\"/&gt;&lt;br&gt;//출력값30.130.1030.1030.7730.10 퍼센트123456백분율 : &lt;fmt:formatNumber value=\"0.55\" /&gt;&lt;br&gt;백분율 : &lt;fmt:formatNumber value=\"0.55\" type=\"percent\" /&gt;&lt;br&gt;//출력값백분율 : 0.55백분율 : 55% 통화량 currencySymbol속성 : 원하는 문자를 넣어서 통화표현도 할 수 있음 12345678910통화량 : &lt;fmt:formatNumber value=\"2000000000\" /&gt;&lt;br&gt;통화량 : &lt;fmt:formatNumber value=\"2000000000\" type=\"currency\" /&gt;&lt;br&gt;통화량 : &lt;fmt:formatNumber value=\"2000000000\" type=\"currency\" currencySymbol=\"$\" /&gt;&lt;br&gt;통화량 : &lt;fmt:formatNumber value=\"2000000000\" type=\"currency\" currencySymbol=\"*\" /&gt;&lt;br&gt; //출력값통화량 : 2,000,000,000통화량 : ￦2,000,000,000통화량 : $2,000,000,000통화량 : *2,000,000,000","link":"/2020/08/11/200812jspi2/"},{"title":"JSTL과 EL : CORE 라이브러리(if, forEach, forTokens, choose)","text":"&lt;c:if test=”${조건문}”&gt; 기본형태1234//기본형태&lt;c:if test=\"${조건문}\"&gt; 실행문장&lt;/c:if&gt; 파라미터 데이터형태의 차이 jstl의 param.변수명 : 있는 그대로의 타입을 가지고온다. 숫자면 숫자, 문자열이면 문자열 -&gt; 사칙연산가능 반면 js의 request.getParameter(“변수명”)는 무조건 문자열이다. -&gt; 사칙연산불가 순서 core 라이브러리연결 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 변수값을 출력하고싶으면 EL태그사용 그냥 i찍으면 변수명이 출력됨. 변수값을 출력하고싶으면 EL태그사용123456789//기본값&lt;c:out value=&quot;${변수명}&quot; /&gt;//예시&lt;c:out value=&quot;i&quot; /&gt; &lt;c:out value=&quot;${i}&quot; /&gt;//출력값i변수명 if else는 없다 if만 있음 1234//기본형태&lt;c:if test=&quot;${i=='itwill' }&quot;&gt; 아이티윌 입니다.&lt;/c:if&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 1.core 라이브러리연결 --&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 2.jstl을 사용해서 변수 생성 --&gt;&lt;c:set var=\"i\" value=\"itwill\"/&gt;&lt;!-- 3. 변수출력 : 그냥 i찍으면 변수명이 출력됨. 변수값을 출력하고싶으면 EL태그사용--&gt;&lt;c:out value=\"i\" /&gt; &lt;c:out value=\"${i}\" /&gt;&lt;hr&gt;&lt;!-- 4. if조건문 --&gt;&lt;c:if test=\"${i=='itwill' }\"&gt; 아이티윌 입니다.&lt;/c:if&gt;&lt;hr&gt;&lt;!-- 5. form 태그 사용해서 숫자 2개를 입력 -&gt; if.jsp페이지에 전달5-1. 전달된 2개의 숫자중에서 더큰수를 구분해서 출력--&gt;&lt;fieldset&gt; &lt;legend&gt;큰수 찾기&lt;/legend&gt; &lt;form action=\"if.jsp\"&gt; 숫자 1 : &lt;input type=\"text\" name=\"num1\"&gt;&lt;br&gt; 숫자 2 : &lt;input type=\"text\" name=\"num2\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"큰수 찾기\"&gt; &lt;/form&gt; &lt;/fieldset&gt;&lt;!-- param.num1은 있는 그대로의 타입을 가지고온다. 숫자면 숫자, 문자열이면 문자열 -&gt; 연산가능반면 js의 request.getParameter(\"num1\")는 무조건 문자열이다 --&gt;&lt;c:if test=\"${ (param.num1) &gt; (param.num2) }\"&gt; 큰값 : ${ param.num1 }&lt;/c:if&gt;&lt;c:if test=\"${ param.num2 &gt; param.num1 }\"&gt; 큰값 : ${ param.num2 }&lt;/c:if&gt;&lt;!-- 5-2. num1이 null이 아니면서 num1과 num2가 같은 경우 동일한 값을 출력 (p517 el연산자 --&gt;&lt;%-- &lt;c:if test=\"${ (param.num1 == param.num2) &amp;&amp; (param.num1 != null)}\"&gt; --%&gt;&lt;c:if test=\"${ (param.num1 == param.num2) and (param.num1 ne null)}\"&gt; 동일한 값&lt;/c:if&gt; &lt;c:forEach begin=”” end=”” step=”” var=””&gt;와 &lt;c:forTokens items=”” delims=”” var=””&gt; 자주 사용함. 필수 속성: items=”” delims=”” var=”” jsp표현식은 사용할 수 없다 WHY? jstl실행전에 java가 먼저 실행되는데 jstl의 변수가 먼저 생성되지 않았기때문에 java는 변수를 몰라서 에러가 남. 123456//기본값&lt;c:forTokens items=&quot;문자데이터객체&quot; delims=&quot;구분자&quot; begin=&quot;시작값&quot; end=&quot;끝값&quot; step=&quot;단계&quot; var=&quot;결과값을 저장할 변수&quot; varStatus=&quot;상태&quot;&gt;&lt;/c:forTokens&gt;- 이 많은 속성 중 필수 속성은 items=&quot;&quot; delims=&quot;&quot; var=&quot;&quot;이다. 사용법 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;% for(int i=0;i&lt;5;i++){ out.print(i+\"안녕하세요&lt;br&gt;\"); } %&gt;&lt;hr&gt;&lt;!--1. JSTL 사용해서 반복문 처리 --&gt;&lt;c:forEach begin=\"1\" end=\"5\" step=\"2\" var=\"i\"&gt; &lt;h2&gt; ${i } JSTL : 안녕하세요 &lt;/h2&gt;&lt;/c:forEach&gt;&lt;hr&gt;&lt;!--2. 1~10 까지 수 중에서 홀수 --&gt;&lt;c:forEach begin=\"1\" end=\"10\" step=\"2\" var=\"odd\"&gt; 홀수 : ${odd }&lt;br&gt;&lt;/c:forEach&gt;&lt;hr&gt;&lt;!--3. 1~10 까지 수 중에서 짝수--&gt;&lt;c:forEach begin=\"1\" end=\"10\" step=\"2\" var=\"even\"&gt; 짝수 : ${even }&lt;br&gt;&lt;/c:forEach&gt;&lt;hr&gt;&lt;!--4. 1~5까지의 숫자 출력 --&gt;&lt;c:forEach begin=\"1\" end=\"5\" step=\"1\" var=\"num\"&gt; 숫자: ${num }&lt;br&gt;&lt;/c:forEach&gt;&lt;!-- 4-1.jsp표현식 사용가능할까? YES가능함 -&gt;이것보다 forTokens를 더 많이 사용함--&gt;&lt;c:forEach begin=\"1\" end=\"&lt;%=5 %&gt;\" step=\"1\" var=\"num\"&gt; 숫자: ${num }&lt;br&gt;&lt;/c:forEach&gt;&lt;!-- 4-2.c:forTokens = for반복문 + StringTokenizer클래스 --&gt;&lt;c:forTokens items=\"a.s.df.as.qwesd.fg.qwe3q\" delims=\".\" var=\"result\"&gt; 결과 : ${result}&lt;br&gt;&lt;/c:forTokens&gt;&lt;hr&gt;&lt;c:forTokens items=\"안녕하세요 JSTL 문법입니다.\" delims=\" \" var=\"result2\"&gt; 결과2 : ${result2}&lt;br&gt;&lt;/c:forTokens&gt; &lt;c:choose&gt;&lt;c:when test=”${조건식}”&gt;&lt;c:otherwise&gt; choose태그를 사용하여 switch case구문을 나타낼수있다. 123456789101112131415&lt;c:set var=\"num1\" value=\"0\" /&gt;&lt;c:set var=\"num2\" value=\"20\" /&gt;&lt;!-- 변수의 값이 양수일때, 음수일때, 둘다 아닐때sms 0으로 데이터 처리 --&gt;&lt;c:choose&gt; &lt;c:when test=\"${num1 &gt; 0}\"&gt; 양수&lt;br&gt; &lt;/c:when&gt; &lt;c:when test=\"${num1 &lt; 0}\"&gt; 음수&lt;br&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; 0&lt;br&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt;","link":"/2020/08/11/200812jspi/"},{"title":"JSTL과 EL : EL태그 연산자","text":"EL태그로 연산하기 특징 : EL 표현식은 연산자가 있으면 전달받은 데이터 자동으로 숫자형으로 캐스팅함. operator1.jsp의 숫자 정보를 입력받아서 다음 페이지operator2.jsp로 넘기고 다음페이지operator2.jsp에서 해당 연산을 구현해보자. 공통코드 : operator1.jsp 와 operator2.jsp 생성 operator1.jsp 코드 1234567&lt;fieldset&gt;&lt;form action=\"operator2.jsp\"&gt; 숫자1 : &lt;input type=\"text\" name=\"num1\"&gt;&lt;br&gt; 숫자2 : &lt;input type=\"text\" name=\"num2\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"전송\"&gt;&lt;/form&gt; &lt;/fieldset&gt; operator2.jsp코드 core 라이브러리 추가1&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; EL 표현식 사용해서 전달받은 정보 출력12숫자1 : ${param.num1}&lt;br&gt;숫자2 : ${param.num2}&lt;br&gt; EL 표현식을 사용해서 전달받은 2개의 값 합 출력 파라미터는 String타입인데 어떻게 EL태그에서 바로 연산이 될까? EL 표현식은 전달받은 데이터 자동 캐스팅때문! 1숫자1 + 숫자2 = ${param.num1+param.num2}&lt;br&gt; EL 표현식을 사용해서 전달받은 2개의 값이 모두 양수인가?123&lt;c:if test=\"${(param.num1 &gt; 0) &amp;&amp; (param.num2 &gt; 0)}\"&gt; 모두 양수입니다&lt;br&gt;&lt;/c:if&gt; EL 표현식 사용해서 삼항조건연산 처리 전달한 두 개의 데이터가 같으면 “같다”출력, 다르면 “다르다”출력 1${(param.num1 == param.num2) ? \"같다\" : \"다르다\" } EL 표현식 사용해서 아이디값이 있는지 확인하기 값이 null이거나 컬렉션의 크기가 0인지 체크 =&gt; empty(리턴타입boolean)사용 operator1.jsp페이지에서 ID값 전달, ID가 없을 경우 게스트님, 환영합니다 ID가 있는 경우, 해당id님 환영합니다 1${empty param.id ? \"게스트\" :param.id }님 환영합니다","link":"/2020/08/13/200814jspi/"},{"title":"JSTL과 EL : EL태그로 동일한 name의 파라미터를 EL태그로 쉽게 가져오기","text":"EL태그로 페이지 이동시 정보가져오기 동일한 name의 파라미터인 경우 어떻게 정보를 가져올 수 있을까? 순서 : paramTest.html생성. 동일한 name을 가진 파라미터를 만든다. 그다음 paramTest.jsp생성. 동일한 name의 파라미터를 어떻게 가져올수있을까? 첫번째 방법 : String array와 request.getParameterValues()사용 두번째 방법 : EL태그사용 공통코드 : paramTest.html 생성123456789101112&lt;fieldset&gt; &lt;form action=\"paramTest.jsp\" method=\"get\"&gt; ID : &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt; PW : &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; MSG1 : &lt;input type=\"text\" name=\"msg\"&gt;&lt;br&gt; MSG2 : &lt;input type=\"text\" name=\"msg\"&gt;&lt;br&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"수영\"&gt;수영 &lt;input type=\"checkbox\" name=\"hobby\" value=\"등산\"&gt;등산 &lt;input type=\"checkbox\" name=\"hobby\" value=\"댄스\"&gt;댄스 &lt;input type=\"submit\" value=\"전송하기\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 첫번째방법 : String array와 request.getParameterValues()사용paramTest.jsp 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;%//1.한글처리request.setCharacterEncoding(\"UTF-8\");//2.각각의 정보를 저장 후 출력 =&gt; 동일한 name의 파라미터를 인식하지 못하고 제일 첫번째의 파라미터값만 가져옴String id = request.getParameter(\"id\");String pw = request.getParameter(\"pw\");String msg1 = request.getParameter(\"msg\"); String msg2 = request.getParameter(\"msg\");%&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디 &lt;/td&gt; &lt;td&gt;&lt;%=id %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;비번 &lt;/td&gt; &lt;td&gt;&lt;%=pw %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;메세지1 &lt;/td&gt; &lt;td&gt;&lt;%=msg1%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;메세지2 &lt;/td&gt; &lt;td&gt;&lt;%=msg2%&gt;&lt;/td&gt; //2-1.메세지1과 동일한 파라미터값이 출력된다-&gt;어떻게하면 메세지2를출력할수있을까? &lt;/tr&gt;&lt;/table&gt;&lt;hr&gt;&lt;%//3.동일한 name의 데이터를 어떻게 가져올수있을까? =&gt;String array와 request.getParameterValues() String[] str = request.getParameterValues(\"msg\");%&gt;&lt;%=str[0] %&gt;&lt;%=str[1] %&gt;&lt;hr&gt;&lt;h2&gt;체크박스1 : 일반출력&lt;/h2&gt;&lt;%//4.체크박스 =&gt; request.getParameterValues() String[] optStr = request.getParameterValues(\"hobby\");//체크박스 3개중 2개만 틱한 상태에서 페이지를 넘기면 nullpoint예외라는 심각한 문제가 발생한다.%&gt;&lt;%=optStr[0] %&gt;&lt;%=optStr[1] %&gt;&lt;%=optStr[2] %&gt;&lt;%//4-1.첫번째방법 : 배열의 길이만큼만 출력//3개 모두 틱하지않더라도 출력이 잘된다. //하지만 하나도 틱하지않은 상태인 경우 또 nullpoint에러가 발생한다 =&gt; 해결if문for(int i=0; i&lt;optStr.length; i++){ %&gt; &lt;%=optStr[i] %&gt; &lt;%}//그래서 if문이 필수 =&gt; 챙겨야할것이 많으므로 두번째방법인 el태그 추천if(optStr != null){ for(int i=0;i&lt;optStr.length;i++){ %&gt; &lt;%=optStr[i] %&gt; &lt;% } }%&gt; 두번째방법 : EL태그 사용taglib 추가1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; paramTest.jsp 생성- 위의 `paramTest.html`을 바탕으로 아래 코드 구현.1234567891011121314151617181920&lt;h2&gt;체크박스1 : EL 표현식 사용 출력&lt;/h2&gt; &lt;!-- EL표현식은 nullpoint예외가 발생되면 화면은 빈화면으로 출력한다 param 객체 : request.getParameter(\"이름\") paramValues 객체 : request.getParameterValues(\"이름\") --&gt; &lt;!-- param 객체 --&gt;아이디 : ${ param.id }&lt;br&gt;비밀번호 : ${ param.pw }&lt;br&gt;&lt;!-- paramValues 객체 --&gt;옵션1 : ${ paramValues.hobby[0] }&lt;br&gt;옵션2 : ${ paramValues.hobby[1] }&lt;br&gt;옵션3 : ${ paramValues.hobby[3] }&lt;br&gt;&lt;hr&gt;&lt;!-- 5. foreach --&gt;&lt;c:forEach var=\"tmp\" items=\"${paramValues.hobby }\"&gt; ${tmp }&lt;br&gt; &lt;/c:forEach&gt;","link":"/2020/08/12/200813jspi/"},{"title":"I&#x2F;O1: 스트림개념, 노드스트림(파일기반 입&#x2F;출력처리)","text":"개념 및 용어정리 I/O : INPUT과 OUTPUT을 함께 일컫는 용어. 자바의 I/O : 스트림(Stream)을 이용해서 데이터를 주고받는 구조. 스트림(Stream) : 데이터의 소스에서 목적지까지 데이터를 이동시키는 일종의 통로. 종류 : 노드스트림 파일기반 입/출력처리 보조스트림 노드(Node) : 데이터의 소스나 목적지. 종류 : 키보드, 모니터, 파일, 메모리, DB등등 노드스트림(Node Stream) : 노드에 연결된 스트림 종류는 매우 다양한데 아래 3가지 조건의 조합으로 구분됨. 첫번째 기준 : 전송할 데이터타입이 BYTE인가? CHAR인가? byte(8비트)인 경우 XXStream char 인 경우 XXer byte데이터 전송인 경우 비트단위때문에 문자열이 깨지는 문제발생할수있으므로 텍스트를 전송할때는 char기반의 스트림을 사용하는 것이 좋다. 두번째 기준 : 데이터 이동방향 데이터 읽는 경우 InputStream 또는 Reader 데이터출력하는 경우 OutputStream 또는 write 세번째 기준 : 노드타입 단방향 중 키보드 : InputStream 또는 Reader 단방향 중 모니터 : OutputStream 또는 write 양방향 중 파일과 연결할때 : file 양방향 중 다른 스레드와 연결 : Piped 양방향 중 메모리와 연결 : Array(ByteArray, CharArray) I/O클래스의 구조 InputStream / OutputStream (바이트 입출력) Reader / Writer (문자 입출력) 노드스트림 모든 스트림은 노드 스트림에서 시작. 노드 스트림의 최상위 인터페이스 : InputStream과 Reader, OutputStream과 write 키보드를 이용한 InputStream과 Reader read()메서드는 스트림에서 데이터를 읽음. return byte의 개수. return -1이면 더이상 읽을 데이터가 없음을 의미. 전송될 데이터가 숫자인 경우 byte단위의 InputStream사용 추천 전송될 데이터가 문자인 경우(특히 한글) char단위의 Reader사용 추천 키보드를 이용한 InputStream 예시 buffer : 데이터를 한 번에 읽을 수 있기위해 생성한 배열. read(byte[]), read(byte[], int, int) : 버퍼단위로 데이터를 읽음. 한계 : InputStream은 byte단위의 전송때문에 한글자가 2byte이상인 한글은 깨짐 =&gt; Reader사용 12345678910111213141516System.out.println(\"입력하세요\");byte[] buffer = new byte[10];try(InputStream input = System.in){ int read = -1; while((read = input.read(buffer)) &gt; 0){ System.out.println(\"읽은 값: \"+read+\", 문자열로: \"+ new String(buffer, 0, read)); }}catch(IOException e){ e.printStackTrace();}//입력값자바는 객체지향 언어입니다//출력값읽은 값: 10, 문자열로: 자바는 객?읽은 값: 10, 문자열로: 셉置? 언어읽은 값: 8, 문자열로: 입니다 키보드를 이용한 Reader 예시1234567891011121314char[] buffer = new char[10];try(Reader rd = new InputStreamReader(System.in)){ int read =-1; while((read = rd.read(buffer)) &gt; 0){ System.out.println(\"읽은 값: \"+read+\", 문자열로: \"+ new String(buffer, 0, read)); }}catch(IOException e){ e.printStackTrace();}//입력값자바는 객체지향 언어입니다//출력값읽은 값: 10, 문자열로: 자바는 객체지향 언읽은 값: 6, 문자열로: 어입니다 모니터를 이용한 OutputStream과 Writer Write는 OutputStream의 byte가 char로 대체된다. OutputStream사용 getBytes()를 이용하여 byte[]로 바꾼 뒤 write()로 출력하면 된다.12345678try(OutputStream os = System.out){ String msg = \"안녕 월요일\"; os.write(msg.getBytes());}catch(IOException e){ e.printStackTrace();}//출력값안녕 월요일 Writer사용 byte를 char단위로 바꾸기 위해 OutputStreamWriter를 사용하여 Writer생성한다.123456789try(Writer wr = new OutputStreamWriter(System.out)){ String msg = \"안녕\"; wr.write(msg); wr.append(\"피곤한\").append(\"월요일\");}catch(IOException e){ e.printStackTrace();}//출력값안녕피곤한월요일 메모리기반 입/출력처리 CharArrayReader가 변수 memory를 buffer만큼 읽고 CharArrayWriter에 출력한다. CharArrayWriter에 출려된 내용을 모니터에 출력(System.out.println)한다.1234567891011121314char[] memory = \"안녕 또다시 월요일\".toCharArray();char[] buffer = new char[5];int read=0;try(CharArrayReader car = new CharArrayReader(memory); CharArrayWriter caw = new CharArrayWriter();){ while((read=car.read(buffer)) &gt; 0){ caw.write(buffer, 0, read); } System.out.println(Arrays.toString(caw.toCharArray()));}catch(IOException e){ e.printStackTrace();}//출력값[안, 녕, , 또, 다, 시, , 월, 요, 일] 파일기반 입/출력처리 가장 빈번히 사용하며 너무나도 중요해서 아래 게시글에 별도로 포스팅을 했다. 링크 : 노드스트림 - 파일기반 입/출력처리 다른 스레드와의 통신을 위한 스트림 스레드간의 통신을 위해서는 PipedInputStream/PipedOutputStream 이나 PipedReader/PipedWriter가 사용됨. 다른 스트림과 공통점 : 데이터 읽고 쓰는 과정. 다른 스트림과 차이점 : 사용 전 connect()메서드를 사용하여 연결 필수!","link":"/2020/08/16/200817javai/"},{"title":"다형성의 java.lang.ClassCastException: cannot be cast to 에러, instanceof의 Incompatible conditional operand types에러 해결법","text":"다형을 이용한 예제 s의 데이터 타입이 Sub1이면 ‘Sub1’출력하고 아니면 ‘Sub2’를 출력하는 코드예시이다. 다형성을 이용한 형변환으로 변수s을 다운캐스팅(Super -&gt; Sub1)했다 원하는 결과값이 잘 출력되었다. 12345678910111213141516171819class Super{}class Sub1 extends Super {}class Sub2 extends Super {}public class question24 { public static void main(String[] args) { Super sup = new Sub1(); Sub1 s = (Sub1) sup; if( s instanceof Sub1){ System.out.println(\"Sub1\"); }else{ System.out.println(\"Sub2\"); } }}//출력값Sub1 Incompatible conditional operand types 에러 발생 Sub2도 만들어보고싶어서 아래와 같이 코드를 추가했는데 Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem 컴파일 에러가 났다. 직역하면 호환되지 않는 조건부 피연산자 유형에러이다. 123456789101112131415161718192021class Super{}class Sub1 extends Super {}class Sub2 extends Super {}public class question24 { public static void main(String[] args) { Super sup = new Sub1(); Sub1 s = (Sub1) sup; Sub2 s2 = (Sub2) sup; //추가한 코드 if( s2 instanceof Sub1){ System.out.println(\"Sub1\"); }else{ System.out.println(\"Sub2\"); } }}//출력값 : 에러Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: Incompatible conditional operand types Sub2 and Sub1 Incompatible conditional operand types 에러 원인과 해결법 해결을 위해서는 instanceof 연산자를 알아야한다. instanceof 연산자는 A(Object) instanceof B(Class, Interface) 형태로 사용하고 return은 boolean이다. 오브젝트 A를 클래스 B나 인터페이스 B로 casting가능유무(Boolean)를 확인한다. 따라서 B가 클래스일 경우에는 A가 반드시 B 클래스와 상속관계에 있어야 true가 된다. 만약 A와 B가 전혀 상호 상속관계가 없을 경우 캐스팅이 불가능 -&gt; 컴파일 에러 발생. 위의 예시에서 s2 instanceof Sub1에서 변수s(소속 : Sub2)와 Sub1(소속 : Sub1)은 상속관계 없기에 컴파일 에러가 발생했다. 그래서 s2 instanceof Sub1에서 s2 instanceof Sub2로 바꾸어보았다. java.lang.ClassCastException 에러 발생 s2 instanceof Sub1에서 s2 instanceof Sub2로 바꾸었더니 이번엔java.lang.ClassCastException에러가 발생했다. 123456789101112131415161718192021class Super{}class Sub1 extends Super {}class Sub2 extends Super {}public class question24 { public static void main(String[] args) { Super sup = new Sub1(); Sub1 s = (Sub1) sup; Sub2 s2 = (Sub2) sup; //추가한 코드 if( s2 instanceof Sub2){ System.out.println(\"Sub2\"); }else{ System.out.println(\"Sub1\"); } }}//출력값(예외에러)Exception in thread \"main\" java.lang.ClassCastException: test1.Sub1 cannot be cast to test1.Sub2 java.lang.ClassCastException 에러 원인과 해결법 다운캐스팅은 업캐스팅이 일어난 값에 한해서만 다운캐스팅이 가능하다. 업캐스팅이 선행되지 않으면 다운캐스팅을 할 수 없다. 참고링크 : DownCasting(다운캐스팅 = 명시적 형변환) 따라서 Super sup2 = new Sub2();로 업캐스팅해준뒤 Sub2 s2 = (Sub2) sup2;로 다운캐스팅을 하면 원하는 출력값을 볼 수 있다. 123456789101112131415161718192021class Super{}class Sub1 extends Super {}class Sub2 extends Super {}public class question24 { public static void main(String[] args) { Super sup = new Sub1(); //업캐스팅 Sub1 s = (Sub1) sup; //다운캐스팅 Super sup2 = new Sub2(); //새로 추가한 코드(업캐스팅) Sub2 s2 = (Sub2) sup2; //추가한 코드(다운캐스팅) if( s2 instanceof Sub2){ System.out.println(\"Sub2\"); }else{ System.out.println(\"Sub1\"); } }}//출력값Sub2","link":"/2020/08/14/200815javai/"},{"title":"Ajax : xml처리, json처리","text":"Ajax 요청에 따른 응답 처리할 수 있는 데이터 형태 : XML, HTML, TXT, JSONHTML : 웹페이지 일부를 업데이트 특징 응답처리가 간결. 브라우저별로 별도의 처리가 필요없음 (바로 사용가능). 한계 서버가 사용가능한 페이지를 리턴해야만 함. = 데이터 이식성이 좋지 않음. 요청이 반드시 같은 도메인으로 처리되어야 함. 예를 들어 www.ecodeda.com에 요청했으면 www.ecodeda.com에서 응답해야만한다. XML : HTML과 유사하게 사용하지만 태그의 이름이 다르다. 특징 태그의 데이터를 지정해서 사용가능 =&gt; 거의 모든 플랫폼에서 사용. 다양한 데이터타입의 구조를 표현가능 HTML태그와 유사하게 처리 가능. 한계 데이터 처리시 많은 리소스가 필요하기때문에 많은 양의 코드가 필요함. 요청이 반드시 같은 도메인으로 처리되어야 함. 예를 들어 www.ecodeda.com에 요청했으면 www.ecodeda.com에서 응답해야만한다. JSON : js객체표현식(=JavaSscript Object Natation) 특징 html/xml보다 간결한 데이터처리 가능 (이름 : 값-쌍) 위의 한계였던 다른 도메인 요청에서도 사용가능. 한계 문법이 예민함 &gt; 콤마, 따옴표, 콜론 등등 문법처리 중요 &gt; 잘못하면 파일 전체 사용불가 악의적인 목적의 객체를 사용가능 &gt; 신뢰된 페이지에서만 사용가능하게 처리해야 함. Ajax xml처리xml.jsp 파일생성 contentType=”text/xml”로 설정하기 임의의 xml데이터작성하기 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/xml; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;!-- 임의로 xml데이터 만들어보기 --&gt;&lt;people&gt; &lt;person&gt; &lt;name&gt;유저1&lt;/name&gt; &lt;gender&gt;여&lt;/gender&gt; &lt;hobby&gt;독서&lt;/hobby&gt; &lt;/person&gt; &lt;person&gt; &lt;name&gt;유저2&lt;/name&gt; &lt;gender&gt;여&lt;/gender&gt; &lt;hobby&gt;여행&lt;/hobby&gt; &lt;/person&gt; &lt;person&gt; &lt;name&gt;유저3&lt;/name&gt; &lt;gender&gt;여&lt;/gender&gt; &lt;hobby&gt;운전&lt;/hobby&gt; &lt;/person&gt;&lt;/people&gt; xml.html 파일생성xml.jsp파일을 xml데이터를 볼러와서 xml.html에서 출력하기. 제이쿼리 준비 ajax사용 출력값이 object이므로 접근을 each로 해야함 object와 배열은 주로 each로 접근한다. body에 출력 1234567891011121314151617181920212223242526272829303132333435&lt;script src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" &gt;$(function(){ //xml.jsp페이지에서 xml데이터를 읽어와서 출력하기 //비동기방식 $.ajax({ url:\"xml.jsp\", success: function(data){ //1. alert창으로 잘 처리되는지 확인 //alert('xml데이터를 읽어오기 성공'); //alert(data); //출력값 [object XMLDocument] //2. data안에서 person태그를 찾아서 그안의 데이터 출력 &gt; object라서 접근을 each로 해야함 let tmp = $(data).find('person'); //alert(tmp) //출력값 [object Object] //2-1. each로 반복문을 돌린 후 body에 출력 //people에 접근할 필요없이 원하는 태그인 person에 바로 접근 가능 $(data).find('person').each(function(){ let name = $(this).find('name').text(); let gender = $(this).find('gender').text(); let hobby = $(this).find('hobby').text(); //3. body에 출력시키기 $('body').append(name+\"/\"+gender+\"/\"+hobby+\"&lt;br&gt;\"); }); }, error:function(){ alert('xml데이터를 읽어오기 실패'); } });});&lt;/script&gt; Ajax json처리 항상 속성(key)-값(value)쌍으로 구성. 속성구분시 콤마(,)로 구분함. {} = json객체를 의미 [] = json배열을 의미 우리가 사용하는 거의 모든 브라우저에는 json타입을 처리하는 json파서가 포함되어있다. 그래서 브라우저에서 파일이 자동으로 열림 지원하는 자료형 정수형(10진수) (2,816진수X) 실수형(고정 소수점 , 부동 소수점) 고정소수점 : 1.123 부동소수점 : 1e4, 2.4E-5 boolean형 Null 문자형(문자열) ex “” 이스케이프문법지원(ex \\n, \\t) 배열 : 타입에 상관업싱 모두 저장 가능 배열안에 객체 저장 가능, 배열안에 배열저장 가능1234567891011[ { &quot;name&quot;:&quot;지영&quot;, &quot;age&quot;:77, [&quot;abc&quot;,123,321] }, { &quot;name&quot;:&quot;영희&quot;, &quot;age&quot;:88 }] Json1.jsp생성 + Json1.html생성 : Ajax사용 contentType=”application/json; charset=UTF-8” 로 마임타입(MIME타입) 바꾸기 임의의 json데이터 입력 1234567&lt;%@ page language=\"java\" contentType=\"application/json; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; { \"name\":\"하지\", \"gender\":\"여\", \"hobby\":\"게임\" }, Json1.html생성 : Ajax사용 12345678910111213141516171819202122232425&lt;script src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" &gt;$(function(){ //json데이터 가져와서 html 문서에 출력하기 $.ajax({ //1. dataType:json으로 작성 url: \"Json1.jsp\", dataType: \"json\", success: function(data){ //2. 출력잘되는 지 확인 //alert(data);//출력값 [object Object] //3. each로 접근해서 body에 출력. $.each(data, function(item, data){ alert(item+\"/\"+data); $('body').append(item+\"/\"+data+\"&lt;br&gt;\") }); },error: function(){ alert(\"json데이터가져오기 실패\"); } });});&lt;/script&gt; Json1.jsp생성 +Json1_1.html생성 : getJSON사용 contentType=”application/json; charset=UTF-8” 로 마임타입(MIME타입) 바꾸기 임의의 json데이터 입력 1234567&lt;%@ page language=\"java\" contentType=\"application/json; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; { \"name\":\"하지\", \"gender\":\"여\", \"hobby\":\"게임\" }, Json1.html생성 : getJSON사용 12345678910111213&lt;script src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" &gt;$(function(){ //json데이터 ajax가 아닌 getJson으로 가져와서 html 문서에 출력하기 $.getJSON('Json1.jsp', function(data){ //해당 json파일을 읽어서 가져오기 $.each(data, function(item, data){ $('body').append(item+\"/\"+data+\"&lt;br&gt;\") }) });});&lt;/script&gt; Json2.json생성 +Json2.html생성 : 배열데이터를 getJSON사용 json데이터가 한개가 아니라 여러개일때 즉 json데이터가 배열일때 body에 출력하는 예시이다. 가장 많이 사용한다. Json2.json생성 임의의 json데이터 입력 1234567891011121314151617[ { \"name\":\"하지\", \"age\":77, \"addr\":\"일산\" }, { \"name\":\"메지\", \"age\":66, \"addr\":\"대구\" }, { \"name\":\"한사장\", \"age\":55, \"addr\":\"부천\" }] Json2.html생성 12345678910111213141516171819202122232425262728293031323334353637&lt;script src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" &gt;$(function(){ $.getJSON('Json2.json', function(data){ //첫번째, data에 JSON데이터를 배열형태로 파라미터로 가지고 오기 $.each(data, function(index, item){ $('body').append(\"사용자\"+(index+1)+\" : \"+item.name+\" / \"+item.age+\" / \"+item.addr+\"&lt;br&gt;\") }) //두번째, json배열데이터를 html테이블에 데이터 넣기 $.each(data, function(index, item){ $('table').append(\"&lt;tr&gt;&lt;td&gt;\"+item.name+\"&lt;/td&gt;\"+\"&lt;td&gt;\"+item.age+\"&lt;/td&gt;\"+\"&lt;td&gt;\"+item.addr+\"&lt;/td&gt;&lt;/tr&gt;\") }) })})&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\" style=\"text-align:center\"&gt; &lt;tr&gt; &lt;th&gt; 이름 &lt;/th&gt; &lt;th&gt; 나이 &lt;/th&gt; &lt;th&gt; 주소 &lt;/th&gt; &lt;/tr&gt;&lt;/table&gt;//첫번째 출력값사용자1 : 하지 / 77 / 일산사용자2 : 메지 / 66 / 대구사용자3 : 한사장 / 55 / 부천//두번째 출력값이름 나이 주소하지 77 일산메지 66 대구한사장 55 부천","link":"/2020/08/09/200810jspi/"},{"title":"숫자처리클래스 : java.util.Random, java.math.BigInteger, java.math.BigDecimal","text":"java.util.Random 클래스예시1 : 주사위를 무작위로 던져 그 만큼 전진하기 1234567891011public class RandomTest { public static void playDice(Random random){ int step = random.nextInt(6); System.out.println((step+1)+\"만큼 전진\"); } public static void main(String[] args) { Random r = new Random(); playDice(r); }} 예시2 : 주사위를 무작위로 한 번 더 던질 수 있는 보너스 기회를 얻어서 전진하기12345678910111213141516171819public class RandomTest { public static void playDice(Random random){ int step = random.nextInt(6); System.out.println((step+1)+\"만큼 전진\"); } public static void main(String[] args) { Random r = new Random(); playDice(r); if(r.nextBoolean()){ System.out.println(\"보너스 스테이지\"); playDice(r); } }}//출력값 : 랜덤값이라서 계속 변한다5만큼 전진보너스 스테이지2만큼 전진 java.math.BigInteger 클래스와 java.math.BigDecimal클래스 long도 큰 범위의 정수를 표현하지만 한계가 있다 -&gt; 아무리 큰 수도 저장할 수 있는 BigInteger클래스를 사용할 수 있다. HOW? 클래스가 내부적으로 int[]에 값을 저장하기 때문! 사용법 : 생성자에 꼭 string타입으로 정수를 적어줘야한다. BigInteger b = new BigInteger(&quot;12345678901234567890&quot;); BigDecimal d = new BigDecimal(&quot;2.0&quot;); 사용처 : 정수를 안정적으로 표현할 때 사용. 그럼 실수는? java.math.BigDecimal클래스를 이용한다. 1234567891011121314151617181920212223public static void main(String[] args) { //1.long보다 큰 정수 out of range에러출력된다. //long l1 = 12345678901234567890L; //System.out.println(l1); //출력값 The literal 12345678901234567890L of type long is out of range //2.BigInteger에 담아봤지만 값이 잘렸다. BigInteger bi = new BigInteger(\"12345678901234567890\"); System.out.println(bi.longValue()); //출력값 값이잘림 -6101065172474983726 //3.try catch문을 이용하여 안정적으로 사용가능하다 try{ System.out.println(bi.longValueExact()); }catch (Exception e){ System.out.println(\"범위를 벗어남\"); } System.out.println(bi.doubleValue());}//출력값-6101065172474983726범위를 벗어남1.2345678901234567E19","link":"/2020/08/09/200810javai3/"},{"title":"I&#x2F;O2: 노드스트림 - 파일기반 입&#x2F;출력처리","text":"I/O클래스의 구조와 스트림(Stream) I/O클래스의 구조 스트림 : 데이터의 소스에서 목적지까지 데이터를 이동시키는 일종의 통로. 스트림 종류 : 노드스트림 파일기반 입/출력처리 보조스트림 파일기반 입/출력처리 개념 가장 빈번히 사용함. 프로그래밍과정에서 발생하는 데이터를 파일에 저장하거나 파일의 내용을 읽기/복사/이동등은 모두 파일기반 입/출력처리를 사용함. File라이브러리의 File() : 파일의 크기, 속성. 이름, 경로에 대한 정보얻기, 파일 생성, 파일 삭제가능. 하지만 파일에서 데이터를 읽고 쓰는 것은 스트림을 통해서만 가능. 파일경로 구분자 : 리눅스 /만 사용 , 윈도우 / 또는 \\사용. =&gt; 문제가 발생할 수 있으므로 File라이브러리가 제공하는 구분자인 File.separator사용하는 것이 좋다. 예시예시1 : 파일 생성과 삭제 URI : 통합 자원 식별자(Uniform Resource Identifier, URI)는 인터넷에 있는 자원을 나타내는 유일한 주소. 형식 : 데이터타입:///경로 예시 : phone:///경로, file:///경로, http:///경로 등등 123456789101112131415161718public static void main(String[] args) throws IOException, URISyntaxException{ //구분자 File.separator로 사용 String dirName = \"C:\"+File.separator+\"Temp\"+File.separator+\"mydir\"; File f1 = new File(dirName); //f1.mkdir()는 새로운디렉토리 생성 f1.mkdirs(); //경로상에 없는 모든 디렉토리 생성 File f2 = new File(dirName, \"자바북15장test2.txt\"); f2.createNewFile(); File f3 = new File(dirName, \"자바북15장test3.txt\"); f3.createNewFile(); File f4 = new File(new URI(\"file:///c:/Temp/자바북15장test4.txt\")); f4.createNewFile(); f4.deleteOnExit(); // 애플리케이션이 종료될때 자동으로 만들었던 걸 삭제함.}//end of main 예시2 : File클래스를 이용해 현재 경로의 파일 정보 출력1234567891011121314151617181920212223public static void main(String[] args) { File currentDir = new File(\".\"); if(currentDir.exists()){ File[] childs = currentDir.listFiles(); for(File child : childs){ Date time = new Date(child.lastModified()); String name = child.getName(); long length = child.length(); if(child.isDirectory()){ name = \"[\"+child.getName()+\"]\"; } System.out.printf(\"%-20s\\t%tF%&lt;tT\\t%s%n\", name, time, length); } }}//출력값.classpath 2020-06-1012:32:21 301.project 2020-06-1012:32:21 384[.settings] 2020-06-1012:32:21 0[bin] 2020-08-1711:15:56 4096config.properties 2020-08-1312:24:25 96mylog_0.log 2020-07-2311:12:50 1313[src] 2020-08-1711:15:55 4096 FileInputStream과 FileOutputStream을 이용한 복사 가장 기본적이고 중요한 코드. 바탕화면에 있는 자바파일스트림테스트.txt 파일을 C:/Temp디렉토리로 복사하는 예시. 해당 파일이 존재하지 않으면 FileNotFoundException이 발생함. 12345678910111213141516171819public class CopyTest { //C:\\Users\\ITWILL\\Desktop public static void main(String[] args) { File src = new File(\"C:\"+File.separator+\"Users\"+File.separator+\"ITWILL\"+File.separator+\"Desktop\"+File.separator+\"자바파일스트림테스트.txt\"); File target = new File(\"C:\"+File.separator+\"Temp\"+File.separator+\"자바파일스트림테스트.txt\"); try(FileInputStream input = new FileInputStream(src); FileOutputStream output = new FileOutputStream(target)){ byte[] buffer = new byte[100]; int read = 0; while((read = input.read(buffer))&gt;0){ output.write(buffer, 0, read); } }catch(IOException e){ e.printStackTrace(); } }//end of main} FileInputStream과 FileOutputStream을 이용한 웹상의 이미지 다운로드하기 주로 사용한다. 1234567891011121314151617public static void main(String[] args) { try{ URL url = new URL(\"https://sowon-dev.github.io/img/avatar.png\"); InputStream input = url.openStream(); FileOutputStream output = new FileOutputStream(\"./googleImg.png\"); byte[] b = new byte[1000]; int read = 0; while((read = input.read(b))&gt; 0){ output.write(b, 0, read); } input.close(); output.close(); }catch (Exception e) { e.printStackTrace(); }}//end of main FileReader와 FileWriter를 이용한 문서 작성 FileReader와 FileWriter는 문자 단위의 데이터를 파일에서 읽고 쓰는 스트림. 처리과정 : System.in(키보드) FileWriter 파일 생성 후 작성 완료 FileReader System.out(모니터) 123456789101112131415161718192021222324252627public static void main(String[] args) { File target = new File(\"C:\"+File.separator+\"Temp\"+File.separator+\"diary.txt\"); try(Scanner sc = new Scanner(System.in); FileWriter w = new FileWriter(target, true); FileReader r = new FileReader(target);){ System.out.println(\"일기를 입력하세요\"); w.write(\"\\n시작 - \"+new Date()+\"\\n\"); String str = null; while(true){ str = sc.nextLine(); if(str.equals(\"x\")){ //일기를끝낼땐 x를 입력 break; }else{ w.write(str+\"\\n\"); } } w.flush(); //퍼버의 내용을 출력한 뒤 비움 char[] buffer = new char[10]; int read = -1; while((read=r.read(buffer))&gt;0){ System.out.print(String.valueOf(buffer, 0, read)); } }catch(IOException e){ e.printStackTrace(); }}","link":"/2020/08/16/200817javai2/"},{"title":"Servlet : Servlet용어정리, model1과 model2(MVC구조) 개발방식 비교","text":"Servlet기초 JavaEE : JSP/Servlet등등의 정보를 포함하는 JavaSE JSP(Java Server Page) : 클라이언트의 요청을 처리하기위해서 동적 콘텐츠를 생성하기 위한 기술 동적 콘텐츠를 생성하기 위해서는 jsp 버전이 중요하다 세트 JSP2.2/Servlet3.0 세트 JSP2.3/Servlet3.1 =&gt; tomcat8.x JSP실행순서 : .jsp -&gt; .java(Servlet) -&gt; .class JSP파일이 Servlet파일로 변하는 방법 클라이언트 요청시 jsp파일은 서블릿으로 변환. jsp스크립틀릿 &lt;%%&gt; 코드가 변경됨 -&gt; Servlet클래스 아래의 service()메서드에 들어감. jSP표현식 &lt;%= %&gt; -&gt; Servlet클래스 아래의 service()메서드안에 out.println()로 표시됨. jsp선언문 &lt;%! %&gt; -&gt; Servlet 멤버 메서드로 변환. html태그 -&gt; Servlet클래스 아래의 service()메서드안에 out.write()로 표시됨 jsp page디렉티브 –서블릿변환–&gt; 서블릿변환시 참고용으로 사용 확인 할수있는 위치 : D:\\workspace_jsp7\\.metadata\\.plugins\\org.eclipse.wst.server.core\\tmp0\\work\\Catalina\\localhost Servlet : 자바에서 웹 개발을 하기 위한 작은 기술 작은 서버 프로그램 ex) Contoller 사용자의 요청을 멀티 쓰레딩 방식으로 처리가능. 동적 데이터 처리가능. Servlet 사용방법 javax.servlet.Servlet 인터페이스를 구현. 1번을 따로 구현할 필요가 없거나 구현이 힘들 경우 javax.servlet.http.HttpServlet을 구현. 실무에서는 1번은 거의 사용하지않고 2번부터 바로 시작함. doGet()/doPost()메서드를 구현(오버라이딩) -&gt; 파라미터로 javax.servlet.http.HttpServletRequest와 javax.servlet.http.HttpServletResponse를 순서대로 사용. 예외처리: IOException, ServletException 두 개 처리. web.xml파일에 매핑처리 but 서블릿 3.0이후부터는 대체해서 @WebServlet을 사용가능. 해당 파일을 지정위치에 놓고 실행. 서블릿 Life Cycle init() : 최초 한 번만 실행 = 서블릿 로딩 protected void service(HttpServletRequest arg0, HttpServletResponse arg1){} 생성. 여기서 doGet() 또는 doPost()를 호출헤야한다. doGet() 또는 doPost(HttpServletRequest req, HttpServletResponse resp){} 호출. 재호출(새로고침) &gt;service()와 doGet() 또는 doPost()만 반복된다. 내용 변경 후 페이지 리로딩시 destroy()호출 destroy() : 파일이 수정되면 자동으로 destroy함 &gt; 새로 시작시 init() 재실행. 다시 1번으로 돌아가서 시작. = 라입 Servlet 사용방법 기초예시 MyServlet.java생성 메서드 오버라이딩 : init(), service()와 doGet() 또는 doPost(), destroy() 오버라이딩 1234567891011121314151617181920212223242526272829303132333435363738public class MyServlet extends HttpServlet{ @Override public void init() throws ServletException { System.out.println(\"서블릿 초기화\"); } @Override protected void service(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException { System.out.println(\"서비스(Http)\"); //doGet(arg0, arg1); }/* @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { System.out.println(\"서비스(Servlet)\"); //doGet(arg0, arg1); 에러 service(arg0, arg1); }*/ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"서블릿 doGet()\"); //doGet에서 doPost로 변경 doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"서블릿 doPost()\"); } //.java파일이 수정되면 자동으로 삭제하고 init()초기화 실행 @Override public void destroy() { System.out.println(\"서블릿 destroy\"); } }//end of class web.xml코드 추가 12345678&lt;servlet&gt; &lt;servlet-name&gt;myservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itwillbs.servlet.MyServlet&lt;/servlet-class&gt; //실제 파일 위치&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;myservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/MyServlet.com&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; model1과 model2 개발방식 비교model1 개발방식: XXXForm.jsp, XXXPro.jsp jsp페이지에서 모든 동작을 처리(html, css, db, 로직). 장점: 개발속도가 빠름. 단점: 유지보수가 힘듬. php페이지 model2 개발방식 (MVC구조/패턴): MVC 패턴 : Model: 비즈니스 로직처리(DB처리). 보통 .java로 만들어짐. View: 화면 처리 로직(화면). 보통 .jsp로 만들어짐. Controller: Model과 View를 연결. 이게 Servlet임. 요청이 들어오면 Controller가 Model로 갈지 View로 갈지 판단 후 실행. 장점: 유지보수에 특화된 개발방식 디자인파트와 개발(비즈니스로직)파트를 분리해서 동시 개발이 가능. 단점 : 구조가 복잡, 코드양이 많음, 시간이 오래걸림. Model2 개발 페이지 이동 구조 일반적으로 많이 사용되는 4가지조합 (절대적인 페이지이동방식은 아님) 정보가 없어서 정보를 입력하는 페이지 요청. 예시 : 회원가입창 열기 가상 주소(.me) -&gt; 실제페이지(.jsp)로 페이지이동 이때 사용하는 방법 컨트롤러 : 주소 처리 ActionForward사용해서 false-forward방식으로 이동 정보를 받아서 처리한 뒤 페이지를 이동. 예시 : 회원가입을 처리하고 로그인폼페이지로 이동 실제페이지(.jsp) -&gt; Action -&gt; DAO -&gt; DB -&gt; Action -&gt; 가상 주소(.me)로 이동. 따라서 Action 인터페이스를 구현한 객체를 사용해서 각각의 동작을 처리해야함. 처리 후 페이지 이동은 ActionForward사용해서 true-forward방식(sendRedirect)으로 이동 정보를 처리한 뒤 자바스크립트를 사용하여 페이지를 이동. 예시 : 로그인 아이디 비번일치 여부. response객체 사용(contentType, PrintWriter 상용함) -&gt; 출력스트림객체를 사용하여 화면에 js코드를 출력 주의사항 : js이용한 이동은 컨트롤러로 전달되는 forward객체의 정보가 null이어야한다. 안그러면 충돌남. DB에서 정보 가져와서 페이지 출력 예시 : 회원정보보기 가상주소(.me) -&gt; Action -&gt; DAO -&gt; DB -&gt; Action -&gt; 실제주소(.jsp) 따라서 Action 인터페이스를 구현한 객체를 사용해서 각각의 동작을 처리해야함. 처리 후 페이지 이동은 ActionForward사용해서 false-forward방식(sendRedirect)으로 이동 Model2 구조 ./Main.me(가상주소) =&gt; ./현재프로젝트명(http://localhost:8088/model2JSP7) ./member/main.jsp(실제주소) =&gt; ./WebContent~ Controller.java에서 주소처리할때 DB를 사용하려면 action.java생성 -&gt; forward(보이는 화면은 .jsp 주소는 .me)로 페이지처리 DB필요없으면 바로 forward(보이는 화면은 .jsp 주소는 .me)로 페이지처리 DB정보가 필요없기때문에 바로 view페이지로 전환","link":"/2020/08/16/200817jspi/"},{"title":"Servlet쇼핑몰1: 기본설정 및 가상주소생성","text":"index.jsp 서블릿을 사용할때 주소가 .jsp로 끝나는 경우 다 잘못된 코드이다. 그건 모델2의 방식이 아니다. 모델2를 출력하는 방식은 직접url타이핑 index.jsp를 시작페이지로 지정 -&gt; 여기서 실행 1234&lt;%//프로젝트의 시작페이지response.sendRedirect(\"./MemberJoin.me\");%&gt; MemberFrontController.java 생성 가장 기본적인 코드. 순서 class를 서블릿으로 변경해줘야함 =&gt; extends HttpServlet 상속받기 get/post 방식에 대한 처리 가능하도록 준비 =&gt; 오버라이딩 doGet(), doPost() doProcess()생성 : get방식이든 post방식이든 doProcess()에서 한번에 처리가능할 수 있게끔 만드는 메서드 가상주소가져오기 URI와 URL차이 리퀘스트uri: /Model2JSP7/*.me 리퀘스트url: http://localhost:8088/Model2JSP7/*.me 어차피 똑같은 프로토콜 부분을 항상 들고다닐 필요가 없으므로 URI사용함. 변수 command: 가상경로라고 칭함. 12345678910111213141516171819202122232425262728293031323334353637//1. 상속public class MemberFrontController extends HttpServlet { //3. doProcess()생성 protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doProcess메서드 호출\"); //4. 가상주소 가져오기 : 가지고 다닐 주소는 /*.me 앞부분의 주소는 필요가 없다. String requestURI = req.getRequestURI(); StringBuffer requestURL = req.getRequestURL(); //uri와 url차이 -&gt; uri에서 내 프로젝트명을 뺀 /*.me만 들고다니면됨 System.out.println(\"리퀘스트uri: \"+requestURI); ///Model2JSP7/*.me System.out.println(\"리퀘스트url: \"+requestURL); //http://localhost:8088/Model2JSP7/*.me //contextPath는 프로젝트명을 호출함 String contextPath = req.getContextPath(); System.out.println(\"contextPath: \"+contextPath); ///Model2JSP7 //가상주소: 필요한 주소인 /*.me만 가져다니기 위해 substring()사용 String command = requestURI.substring(contextPath.length()); System.out.println(\"잘 짤렸는지 가상주소 command: \"+command); } //2.오버라이딩: doGet(), doPost() @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet메서드 호출\"); doProcess(req, resp); //get방식이든 post방식이든 doProcess()에서 한번에 처리가능 } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost메서드 호출\"); doProcess(req, resp); //get방식이든 post방식이든 doProcess()에서 한번에 처리가능 }} web.xml 코드 추가 me는 member의 앞 두글자를 따옴. *.me : 주소 중 me로 끝나는 모든 페이지는 servlet-name이 MemberFrontController인 .java페이지에서 처리하겠다는 의미. 123456789&lt;!-- model2 구조 --&gt;&lt;servlet-name&gt;MemberFrontController&lt;/servlet-name&gt;&lt;servlet-class&gt;com.itwillbs.member.action.MemberFrontController&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;MemberFrontController&lt;/servlet-name&gt;&lt;url-pattern&gt;*.me&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ActionForward.java 생성 이동정보를 저장하는 객체 이동할 페이지, 이동할 방식을 이동정보에 저장함. 이동방식은 어떻게 선택할까? true면 sendRedirect방식으로 이동 언제 사용?: 주소와 화면의 전환이 동시에 일어날때 (가상주소 -&gt; 가상주소로 ) false면 forward방식으로 이동 언제 사용?: 주소는 그대로인데 화면이 바뀔때 (가상주소에서 jsp보여줌) 절대적인 방식은 아니지만 보통 실무에서 위처럼 많이 사용한다 12345678910111213141516171819202122232425262728public class ActionForward { //1.외부접근 못하도록 이동할 페이지와 이동할 방식 멤버변수 생성 private String path; private boolean isRedirect; // true면 sendRedirect방식으로 이동 // false면 forward방식으로 이동 //2. getter setter생성 public String getPath() { return path; } public void setPath(String path) { this.path = path; } public boolean isRedirect() { return isRedirect; } public void setRedirect(boolean isRedirect) { this.isRedirect = isRedirect; } //3.toString @Override public String toString() { return \"ActionForward [path=\" + path + \", isRedirect=\" + isRedirect + \"]\"; }} MemberFrontController.java 추가 코드작성 모델2에서 페이지 이동은 무조건 ActionForward사용 1234567891011121314151617181920212223242526272829//3. doProcess()생성protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doProcess메서드 호출\"); //4. 가상주소 가져오기 : 가지고 다닐 주소는 /*.me 앞부분의 주소는 필요가 없다. String requestURI = req.getRequestURI(); StringBuffer requestURL = req.getRequestURL(); //uri와 url차이 -&gt; uri에서 내 프로젝트명을 뺀 /*.me만 들고다니면됨 System.out.println(\"리퀘스트uri: \"+requestURI); ///Model2JSP7/*.me System.out.println(\"리퀘스트url: \"+requestURL); //http://localhost:8088/Model2JSP7/*.me //contextPath는 프로젝트명을 호출함 String contextPath = req.getContextPath(); System.out.println(\"contextPath: \"+contextPath); ///Model2JSP7 //가상주소 command : 필요한 주소인 /*.me만 가져다니기 위해 substring()사용 String command = requestURI.substring(contextPath.length()); System.out.println(\"잘 짤렸는지 가상주소 command: \"+command); //5. 툭정 주소에 대한 처리 if(command.equals(\"/MemberJoin.me\")){ System.out.println(\"/MemberJoin.me 호출\"); }}//출력값doGet메서드 호출doProcess메서드 호출리퀘스트uri: /Model2JSP7/*.me리퀘스트url: http://localhost:8088/Model2JSP7/*.mecontextPath: /Model2JSP7잘 짤렸는지 가상주소 command: /*.me","link":"/2020/08/16/200817jspi2/"},{"title":"정규표현식, 자주 사용하는 정규식","text":"정규표현식 정규표현식은 언어와 상관없이 표준화가 거의 되어있다. 따라서 정규표현식을 공부하면 언어를 초월해서 해당 언어(java,c,c++,js,python등)에 금방 적응할수있다. 주의 : 자바에서는 역슬래시()를 단독으로 쓸수가 없음 -&gt; 따라서 역슬래시 두번(\\) 써줘야 다른 언어의 역슬래시 하나와 동일하다. 기본형1/패턴/[플래그] 자주 사용하는 정규식 예시12345678//한글이름(2~5글자)^[가-힣]{2,5}$//휴대전화번호^(010|011)[-\\s]?\\d{3,4}[-\\s]?\\d{4}$//이메일주소표현^[\\w\\.-]{1,64}@[\\w\\.-]{1,125}\\.\\w{2,4}$ 예시1 예시 : 정규식을 이용한 전화번호 형식변환 예시 : 정규표현식으로 문자열변환 예시2 : 정규표현식을 이용해 비밀번호 생성 규칙을 테스트하는 예시1234567891011121314151617181920212223242526272829303132333435363738String[] pw = { \"adcdsda한글\", \"AS!112342\", \"asasafdsfa\", \"123456789\", \"asd12345-=\",};for(String p : pw){ String lenReg = \"[a-zA-Z0-9!@#$%^&amp;*]{8,}\"; //사용자가 어떤 부분에서 비밀번호 규칙을 어겼는지 알기위해 아래 변수 생성 String engReg = \"[a-zA-Z]\"; String numReg = \"[0-9]\"; String specReg = \"[!@#$%^&amp;*]\"; System.out.print(p+\"은(는) \"); int has = 0; if(Pattern.matches(lenReg, p)){ has+=Pattern.compile(engReg).matcher(p).find() ? 1:0; has+=Pattern.compile(numReg).matcher(p).find() ? 1:0; has+=Pattern.compile(specReg).matcher(p).find() ? 1:0; if(has &lt; 2){ System.out.println(\"영문,숫자,특수문자(!@#$%^&amp;*) 중 두 가지 이상이 조합하여 입력하세요\"); }else{ System.out.println(\"적합한 비번입니다\"); } }else{ System.out.println(\"영문,숫자,특수문자(!@#$%^&amp;*)로 8자 이상 입력하세요\"); }}//출력값adcdsda한글은(는) 영문,숫자,특수문자로 8자 이상 입력하세요AS!112342은(는) 적합한 비번입니다asasafdsfa은(는) 영문,숫자,특수문자 중 두 가지 이상이 조합하여 입력하세요123456789은(는) 영문,숫자,특수문자 중 두 가지 이상이 조합하여 입력하세요asd12345-=은(는) 영문,숫자,특수문자로 8자 이상 입력하세요 예시3 : 메뉴에서 부추가 들어간 메뉴만 출력하기1234567891011121314151617181920212223//메뉴 중에 부추가 들어간 메뉴 모두를 출력해보자String menu = \"오리매운탕 짜장면,부추잡채 메밀전,매운부추전 불고기, 부추\";//1.split으로 나눠서 변수에 담기String[] menuArr = menu.split(\"[, ]\");System.out.println(Arrays.toString(menuArr));//2.패턴만들기String pattern = \"부추\";Pattern pat = Pattern.compile(pattern);//3. 반복문을 통해 출력for(String s : menuArr){ Matcher mat = pat.matcher(s); if(mat.find())System.out.println(\"부추가 들어간 모든 메뉴 : \"+s); if(mat.matches()) System.out.println(\"부추만 들어간 메뉴 : \"+s);}//출력값부추가 들어간 모든 메뉴 : 부추잡채부추가 들어간 모든 메뉴 : 매운부추전부추가 들어간 모든 메뉴 : 부추부추만 : 부추 참고 nextree 정규식 레일로드 다이어그램 정규식 튜토리얼 정규 표현식 MDN","link":"/2020/08/09/200810javai2/"},{"title":"I&#x2F;O3: 보조스트림","text":"I/O클래스의 구조와 스트림(Stream) I/O클래스의 구조 스트림 : 데이터의 소스에서 목적지까지 데이터를 이동시키는 일종의 통로. 스트림 종류 : 노드스트림 파일기반 입/출력처리 보조스트림 개념 노드 스트림과 달리 노드에 직접 연결되지않고 다른 스트림과 연결되는 스트림. 보조스트림 = 필터스트림 = 프로세싱스트림. 상황에 따라 다르지만 일반적으로 노드스트림보다 500배 빠름 readLine() : 데이터를 한 줄씩 읽어서 리턴. DataInputStream/DataOutputStream : 기본형과 문자열을 입출력하는 스트림(byte기반 노드 스트림) ObjectInputStream/ObjectOutputStream : 객체를 입출력하는 스트림(byte기반 노드 스트림) 객체저장을 위한 스트림직렬화와 역직렬화 객체 전송시 필요한 것은 객체가 가진 데이터 즉 멤버변수. 직렬화 : 객체이 멤버변수들을 전송위해 연속적인 데이터 형태로 변환화는 과정 객체 –ObjectInputStream 직렬화–&gt; 노드 역직렬화 : 직렬화된 멤버변수 –ObjectOutputStream 역직렬화–&gt; 객체 직렬화되기 위한 클래스는 반드시 Serializable 인터페이스 구현. 키워드 transient : 객체의 멤버변수 중 외부로 유출되지 말아야 할 멤버변수은 걍우 키워드 transient사용으로 직렬화에서 제외. serialVersionUID : 직렬화 가능한 클래스에는 static final long타입의 serialVersionUID멤버 변수를 추가하는 것이 좋다.","link":"/2020/08/17/200818javai/"},{"title":"I&#x2F;O4: NIO","text":"NIO(New Input Output) 자바7버전부터 이용가능. 기존 I/O를 대체하는 개념이 아닌 다른 특성을 가진 I/O이다. 지금 file클래스보다는 Path와 files 라이브러리를 사용. 장점 : 다수의 클라이언트환경, 짧은 입출력 작업에 적합. I/O가 더 유리한 경우 : 대용량 처리, 소수의 클라이언트 환경 Java IO vs NIO Path와 FilesI/O가 File 하나로 파일 관련 요소들을 관리하던 것을 NIO에서는 Path, Files로 분리해서 관리한다. java.nio.file.Path 인터페이스 : java.io.File과 거의 동일하다. java.nio.files.Files 클래스 : java.io.File과 유사하지만 객체생성 필요없이 메서드로 바로 사용할 수 있어 더 편리하다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public static void main(String[] args) throws IOException { FilesTest ft = new FilesTest(); ft.copyTest(); ft.dirInfo(); ft.readTextFile(); ft.deleteTest();}//end of mainpublic void copyTest() throws IOException{ Path src = Paths.get(\"c:/windows/explorer.exe\"); Path target = Paths.get(\"C:/Temp/files_copy_explorer.exe\"); if(Files.isReadable(src)){ Files.copy(src, target, StandardCopyOption.REPLACE_EXISTING); System.out.println(\"복사완료\"); }}//end of copyTestpublic void dirInfo() throws IOException{ Path target = Paths.get(\".\"); DirectoryStream&lt;Path&gt; dirStream = Files.newDirectoryStream(target); for(Path p : dirStream){ Date time = new Date(Files.getLastModifiedTime(p).toMillis()); String name = p.getFileName().toString(); long length = Files.size(p); if(Files.isDirectory(p)){ name = \"[\"+name+\"]\"; } System.out.printf(\"%-20s\\t%tF %&lt;tT\\t%s%n\", name, time, length); }}//end od dirInfopublic void readTextFile() throws IOException{ Path target = Paths.get(\"./form.xml\"); BufferedReader reader = Files.newBufferedReader(target); String line = null; while ((line = reader.readLine()) != null){ System.out.println(line); } List&lt;String&gt; lines = Files.readAllLines(target); for(String line2 : lines) System.out.println(line2);}public void deleteTest() throws IOException { Path target = Paths.get(\"C:/Temp/files_copy_explorer.exe\"); boolean result = Files.deleteIfExists(target); String resultStr = result ? \"삭제성공\" : \"삭제실패\"; System.out.println(resultStr);}//출력값복사완료.classpath 2020-06-10 12:32:21 301.project 2020-06-10 12:32:21 384[.settings] 2020-08-18 10:42:17 0[bin] 2020-08-17 11:15:56 4096config.properties 2020-08-13 12:24:25 96form.xml 2020-08-18 11:16:11 85googleImg.png 2020-08-18 09:45:40 4273mylog_0.log 2020-07-23 11:12:50 1313[src] 2020-08-17 11:15:55 4096&lt;사람&gt;&lt;/사람&gt;&lt;이름&gt;김하지&lt;/이름&gt;&lt;나이&gt;77&lt;/나이&gt;&lt;총점&gt;&lt;/총점&gt;삭제완료 Buffer read/write가 가능한 메모리상의 배열. NIO에서 모든 입출력이 버퍼를 통해서 이루어짐. 장점 : I/O 성능 향상. 데이터타입에 따른 종류 다양한 타입의 버퍼가 있지만 실제로 채널은 ByteBuffer를 통해서만 데이터를 읽고 쓸 수 있다. 메모리 위치에 따른 종류 다이렉트버퍼 : OS메모리에 위치. 넌다이렉트버퍼 : JVM 힙메모리에 위치. java.nio.channel.FileChannel 파일을 읽고 쓰는데 사용되는 채널. 동기화되어있어 멀티스레드 환경에 안전. open()과 close()로 FileChannel을 열고 닫음. 읽기전용 : FileChannel readChannel = FileChannel.open(srcPath, StandardOpenOption.READ 파일생성하고 쓰기 : FileChannel readChannel = FileChannel.open(srcPath, StandardOpenOption.READ 사용한 후에는 close()로 꼭 닫아야함. read()할때 읽은 데이터수가 리턴. 더이상 읽을 데이터가 없을땐 -1리턴","link":"/2020/08/17/200818javai2/"},{"title":"Servlet쇼핑몰4: 메인페이지와 로그아웃","text":"main.jsp 생성 123456789101112131415161718&lt;%//1.한글처리, 파라미터 request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅String name = request.getParameter(\"name\");//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동. 가상주소로 이동if(id == null){ response.sendRedirect(\"./MemberLogin.me\");}%&gt;&lt;h3&gt;아이디: &lt;%=id %&gt;&lt;/h3&gt;&lt;h3&gt;아이디(session-EL표현식) : ${ sessionScope.id } &lt;/h3&gt;&lt;input type=\"button\" value=\"ITWILL게시판가기\" class=\"btn\" onclick=\"location.href='../board/boardList.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보조회\" class=\"btn\" onclick=\"location.href=''\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" class=\"btn\" onclick=\"location.href=''\"&gt;&lt;input type=\"button\" value=\"로그아웃\" class=\"btn\" onclick=\"location.href='./MemberLogout.me'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" class=\"btn\" onclick=\"location.href=''\"&gt; MemberFrontController.java의 doProcess()메서드 추가 코드작성 main.jsp와 연결 =&gt; 11.메인페이지 연결 MemberLogout.java와 연결 =&gt; 12. 로그아웃연결 :view페이지 필요없고 Action페이지가 필요함 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//3. doProcess()생성protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doProcess메서드 호출\"); //4. 가상주소 가져오기 : 가지고 다닐 주소는 /*.me 앞부분의 주소는 필요가 없다. String requestURI = req.getRequestURI(); StringBuffer requestURL = req.getRequestURL(); String contextPath = req.getContextPath(); System.out.println(\"contextPath: \"+contextPath); ///Model2JSP7 String command = requestURI.substring(contextPath.length()); System.out.println(\"잘 짤렸는지 가상주소 command: \"+command); //9-1. 일회성이 아닌 다회용 여러번 쓸수있게 처리 Action action = null; //6-3.ActionForward 객체사용 ActionForward forward = null; //5. 특정 주소에 대한 처리 if(command.equals(\"/MemberJoin.me\")){ System.out.println(\"/MemberJoin.me 호출\"); //6. 회원가입처리 -&gt; 회원정보 입력창(view의 개념이 필요) //모델2에서 페이지 이동은 무조건 ActionForward사용 //6-4. 특정주소에 대한 처리 후 페이지이동 =&gt;먼저 특정주소에 대한 처리는 ActionForward 객체 사용 //ActionForward 객체 생성되기 전에는 null (값이 없다)이다가 객체생성후 이동정보가 생긴다 forward = new ActionForward(); // 이동할 주소 forward.setPath(\"./member/insertForm.jsp\"); // 이동할 방법 forward.setRedirect(false); //8.MemberJoinAction일때도 주소 출력 }else if(command.equals(\"/MemberJoinAction.me\")){ //주소에 `.`붙이면 안됨 System.out.println(\"/MemberJoinAction.me 주소 호출\"); //9-2.`MemberJoinAction action = new MemberJoinAction()`을 `action = new MemberJoinAction();`으로 변경 action = new MemberJoinAction(); try { System.out.println(\"@@@@ Controller : MemberJoinAction 객체생성완료 후 excute()호출완료\"); forward = action.execute(req, resp); System.out.println(\"@@@@ Controller : 회원가입 처리완료 후 페이지 이동\"+forward); } catch (Exception e) { e.printStackTrace(); } //10. 로그인페이지연결 }else if(command.equals(\"/MemberLogin.me\")){ System.out.println(\"가상주소: /MemberLogin.me 주소 호출, 실제주소: ./member/loginForm.jsp\"); forward = new ActionForward(); forward.setPath(\"./member/loginForm.jsp\"); forward.setRedirect(false); //10-1. 로그인처리 }else if(command.equals(\"/MemberLoginAction.me\")){ //10-2. MemberLoginAction.java 생성 action = new MemberLoginAction(); try { System.out.println(\"@@@@ Controller : MembeLoginAction 객체생성완료 후 excute()호출완료\"); forward = action.execute(req, resp); System.out.println(\"@@@@ Controller : 로그인 처리완료 후 페이지 이동\"+forward); } catch (Exception e) { e.printStackTrace(); } //11.메인페이지 연결 }else if(command.equals(\"/Main.me\")){ System.out.println(\"@@@@ Controller : 가상주소: /Main.me 실제주소:./member/main.jsp\"); forward = new ActionForward(); forward.setPath(\"./member/main.jsp\"); forward.setRedirect(false); try { forward = action.execute(req, resp); } catch (Exception e) { e.printStackTrace(); } //12. 로그아웃연결 -&gt;view가 필요없고 Action페이지가 필요함 }else if(command.equals(\"/MemberLogout.me\")){ System.out.println(\"@@@@ Controller : 가상주소 /MemberLogout.me 실제주소: ./member/MemberLogoutAction.java\"); action = new MemberLogoutAction(); try { forward = action.execute(req, resp); } catch (Exception e) { e.printStackTrace(); } } //7.페이지이동 : 두가지방식 if(forward != null){ System.out.println(\"@@@페이지이동@@@\"); if(forward.isRedirect()){//1 - response.sendRedirect(주소)사용 //정보는 ActionForward객체 안에 있다 System.out.println(\"sendRedirect방식의 이동\"+forward.getPath()); resp.sendRedirect(forward.getPath()); }else{ //0 - forward사용 System.out.println(\"RequestDispatcher방식의 이동\"+forward.getPath()); RequestDispatcher dis = req.getRequestDispatcher(forward.getPath()); dis.forward(req, resp); } }}//end of doProcess MemberLogoutAction.java 생성1234567891011121314151617181920212223242526public class MemberLogoutAction implements Action{ @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"@@@@ Action: MemberLogoutAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2.세션초기화 HttpSession session = req.getSession(); session.invalidate(); //3. 메인페이지이동 : 결과에 따른 페이지이동처리, 무조건 Controller로 이동 System.out.println(\"@@@@ Action : 로그아웃성공 후 페이지이동 \"); //자바스크립트사용하여 alert()창띄우기 resp.setContentType(\"text/html; charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.print(\"&lt;script&gt;\"); out.print(\"alert('정상적으로 로그아웃 되었습니다');\"); out.print(\"location.href='./Main.me';\"); out.print(\"&lt;/script&gt;\"); //자원해제 out.close(); return null; }}","link":"/2020/08/18/200819jspi3/"},{"title":"Top-N분석","text":"개념 Subquery에서 확장된 문법. 컬럼에서 가장 큰 n개의 값 또는 가장 작은 n개의 값을 요청함. ROWNUM : 서브퀴리에서 반환되는 결과집합에 순차적인 번호를 할당. 진짜 컬럼이 아닌데 컬럼처럼 행동하는 요소. 행번호 의사컬럼(현재행의 순서를 반환 의사컬럼). 오라클 전용. ROWNUM은 쿼리의 결과를 하나의 ROW씩 가져오면서 숫자를 지정함. rownum 조건을 첫번째 숫자가 아니라 중간부터 지정하면 결과를 얻을수 없다. 이때 서브쿼리를 사용하면 숫자를 먼저 지정한 테이블을 사용하기 때문에 조건을 중간부터(BETWEEN문 사용가능) 사용할 수있음. 인라인뷰 : FROM절에 있는 서브퀴리. 예를 들어 가장 적게 팔린 제품 10가지는? 회사의 최상위 소득자 3명은? 예시예시1 : 급여 가장 적게 받는 직원, 가장 오래 일한 직원 급여를 가장 적게 받는 직원 3명을 구하려면 부등호 방향이 바뀌는 것이 아니라 정렬이 바뀐다. =&gt; desc생략. where rownum &lt;= 3; 그대로 근속일수가 가장 오래된 직원 5명을 구하려면 부등호 방향이 바뀌는 것이 아니라 정렬이 바뀐다. =&gt; desc생략. where rownum &lt;= 5; 그대로 예시2 : employees테이블에서 최하위 소득자 5명의 last_name, salary를 출력하는 구문. 최상위 소득자를 작성할때, 부등호 방향이 바뀌는 것이 아니라 정렬이 바뀐다. =&gt; desc추가. where rownum &lt;= 5; 그대로 123select rownum as rank, last_name, salaryfrom (select last_name, salary from employees order by salary)where rownum &lt;= 5; 예시3 : employees테이블에서 가장 예전에 입사한 사원 10명의 employee_id, last_name, hire_date를 출력하는 구문 예시문제를 보고 처음에 작성한 코드는 아래와 같았다. 서브쿼리에서 employee_id 컬럼은 필요없으니까 빼고 작성했는데 오류가 발생했다. 123select rownum as rank, employee_id, last_name, hire_datefrom (select last_name, hire_date from employees order by hire_date)where rownum &lt;= 10; select에서 출력될 컬럼은 from절안의 서브쿼리 select 컬럼에 무조건 있어야한다. -&gt; 서브쿼리 출력값을 하나의 인라인뷰를 만드는데 인라인뷰 컬럼에 없다면 메인 select는 해당 컬럼을 찾지못한다. 123select rownum as rank, employee_id, last_name, hire_datefrom (select employee_id, last_name, hire_date from employees order by hire_date)where rownum &lt;= 10; 퀴즈 : 최상위 소득자 순으로 10위에서 20위 구하기 EMPLOYEES 테이블과 DEPARTMENTS 테이블을 사용하여 최상위 소득자 순으로 10위에서 20위에 해당하는 사원들의 정보를 출력하는 쿼리를 작성하시오. 퀴즈를 보고 처음 든 생각은 일단 상위 20위까지 구하는 쿼리를 작성하는 것이었다. 12345678910//1. 범위좁히기select ROWNUM as rank, employee_id, last_name, salary, department_id, department_namefrom (select e.employee_id, e.last_name, e.salary, e.department_id, d.department_name from departments d join employees e on (d.department_id = e.department_id) ORDER BY e.salary desc)where ROWNUM &lt;= 20;//출력값오류없이 잘 출력됨 첫 시도(내코드) : between조건 이용하기. 12345678910//2. 첫시도 : between이용하기select rownum as rank, employee_id, last_name, salary, department_id, department_namefrom (select rownum as rank, employee_id, last_name, salary, department_id, department_name from departments d join employees e on (d.department_id = e.department_id) ORDER BY e.salary desc) where rank between 10 and 20; //출력값 오류 : 열의 정의가 애매합니다 하지만 rownum은 한 행이 조건에 맞는지 확인한 뒤 rownum 순차적으로 붙인다. 따라서 첫번째 rownum이 없다면 그 이후의 결과는 출력되지않는다. 두번째 시도(내코드) : 중첩서브쿼리를 이용하기.위의 rownum특성을 생각하여 먼저 rownum을 포함한 테이블을 만든 뒤 그 테이블의 rownum 10부터 20번까지 가져오고자하였다. 123456789101112//3. 두번째 시도 : 중첩서브쿼리이용하기select rank, employee_id, last_name, salary, department_id, department_namefrom (select rownum as rank, employee_id, last_name, salary, department_id, department_name from (select e.employee_id, e.last_name, e.salary, e.department_id, d.department_name from employees e join departments d on (d.department_id = e.department_id) ORDER BY e.salary desc)) where rank between 10 and 20 order by rank; //출력값 원하는 값이 잘 출력됨. 세번째 시도(쿼리 리팩토링) : join을 서브퀴리 끝난뒤 마지막에 해보기.강사님께 내가 작성한 쿼리보다 나은 쿼리가 있는 지 물어보니 join을 서브쿼리끝난뒤에 하면 데이터처리속도가 향상된다고 하셨다. 12345678910//강사님 코드select e.rank, e.employee_id, e.last_name, e.salary, e.department_id, d.department_namefrom (select rownum as rank, employee_id, last_name, salary, department_id from (select employee_id, last_name, salary, department_id from employees ORDER BY salary desc)) ejoin departments don (d.department_id = e.department_id)where e.rank between 10 and 20order by rank;","link":"/2020/08/19/200820dbi/"},{"title":"Servlet쇼핑몰5: 회원정보조회","text":"main.jsp 생성 123456789101112131415161718192021222324252627&lt;%//1.한글처리, 파라미터 request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅String name = request.getParameter(\"name\");//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동. 가상주소로 이동if(id == null){ response.sendRedirect(\"./MemberLogin.me\");}%&gt;&lt;h3&gt;아이디: &lt;%=id %&gt;&lt;/h3&gt;&lt;h3&gt;아이디(session-EL표현식) : ${ sessionScope.id } &lt;/h3&gt;&lt;input type=\"button\" value=\"ITWILL게시판가기\" class=\"btn\" onclick=\"location.href='../board/boardList.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보조회\" class=\"btn\" onclick=\"location.href='./MemberInfo.me'\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" class=\"btn\" onclick=\"location.href=''\"&gt;&lt;input type=\"button\" value=\"로그아웃\" class=\"btn\" onclick=\"location.href='./MemberLogout.me'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" class=\"btn\" onclick=\"location.href=''\"&gt;&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id != null){ if(id.equals(\"admin\")){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" class=\"btn\" onclick=\"location.href=''\"&gt;&lt;% }}%&gt; MemberFrontController.java의 doProcess()메서드 추가 코드작성 회원정보조회페이지 가상경로 설정 12345678910111213141516171819202122232425 //13. 회원정보조회 }else if(command.equals(\"/MemberInfo.me\")){ System.out.println(\"@@@@ Controller : 가상주소 /MemberInfo.me 실제주소: ./member/memberInfo.jsp\"); action = new MemberInfoAction(); try { forward = action.execute(req, resp); } catch (Exception e) { e.printStackTrace(); } } //7.페이지이동 : 두가지방식 if(forward != null){ System.out.println(\"@@@페이지이동@@@\"); if(forward.isRedirect()){//1 - response.sendRedirect(주소)사용 //정보는 ActionForward객체 안에 있다 System.out.println(\"sendRedirect방식의 이동\"+forward.getPath()); resp.sendRedirect(forward.getPath()); }else{ //0 - forward사용 System.out.println(\"RequestDispatcher방식의 이동\"+forward.getPath()); RequestDispatcher dis = req.getRequestDispatcher(forward.getPath()); dis.forward(req, resp); } }}//end of doProcess MemberInfoAction.java 생성 회원정보조회 페이지 생성우선순위 DB에서 정보가져오기 DB정보를 가지고 .jsp페이지로 이동 순서1. 세션값을 가져오기 2. DAO객체 생성하여 DB정보가져오기 (MemberBean) 3. `.java` --request객체로 데이터를 전달--&gt; `.jsp` - session에 담아써도 괜찮지만 데이터가 필요없는 순간에도 session 이 살아있는 한 데이터를 가지고 다녀야할수있다. - 따라서 request객체를 사용하는 것이 더 올바르다123456789101112131415161718192021222324252627282930313233public class MemberInfoAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"@@@@ Action: MemberInfoAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2.세션값을 가져오기 HttpSession session = req.getSession(); String id = (String) session.getAttribute(\"id\"); //2-1.id값이 없으면 로그인페이지로 이동 ActionForward forward = new ActionForward(); if(id == null){ //resp.sendRedirect(\"./MemberLogin.me\"); forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); //주소가 바뀌니까 false가 아니라 true임 return forward; //아이디가 없으면 retrun을 통해서 아래 코드는 실행되지않는다. } //3.DAO객체 생성하여 DB정보가져오기 (MemberBean) MemberDAO mdao = new MemberDAO(); MemberBean mb = mdao.getMember(id); //4. .java --request객체로 데이터를 전달--&gt; .jsp //session에 담아써도 괜찮지만 데이터가 필요없는 순간에도 session 이 살아있는 한 데이터를 가지고 다녀야할수있다. //따라서 request객체를 사용하는 것이 더 올바르다 req.setAttribute(\"memberBean\", mb); forward.setPath(\"./member/memberinfo.jsp\"); forward.setRedirect(false); return forward; }} MemberInfo.jsp 생성 jsp표현식을 사용해도되고 EL표현식으로 사용해서 가져와도 됨. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%//회원정보를 DB에서 가져와서 페이지에 출력//1. 한글설정 &amp; 변수생성String id = (String) session.getAttribute(\"id\");//object이기에 형변환필수//1-1.id값확인 -없으면 로그인페이지로 이동if(id == null){ response.sendRedirect(\"./MemberLogin.me\");} //2. 멤버DAO객체 생성 -&gt; 회원정보 가져오는 메서드생성MemberBean mb = (MemberBean) request.getAttribute(\"memberBean\");//3. 데이터처리 : 테이블로 표현if(mb != null){%&gt;&lt;h2&gt;마이페이지&lt;/h2&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;${memberBean.id }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;${memberBean.pw }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;${memberBean.name }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;나이&lt;/td&gt; &lt;td&gt;${memberBean.age }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;성별&lt;/td&gt; &lt;td&gt;${memberBean.gender }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;이메일&lt;/td&gt; &lt;td&gt;${ requestScope.memberBean.email }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;회원가입일&lt;/td&gt; &lt;td&gt;${memberBean.reg_date }&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;% } %&gt;&lt;hr&gt;&lt;input type=\"button\" value=\"뒤로가기\" onclick=\"location.href='./Main.me'\"&gt; MemberDAO.java의 getMember()메서드 추가 코드 작성1234567891011121314151617181920212223242526272829303132333435//5. 회원정보 가져오는 메서드 getMember:회원정보 전부 리턴 -&gt; 테이블에 추가public MemberBean getMember(String id){ MemberBean mb = null; //객체 레퍼런스 생성 //왜 null인가? 정보가 생성되는 시점은 rs에 있을때이다. //따라서 rs가 없을땐 굳이 만들필요가 없다. try{ //5-1. 드라이브로드 디비연결 con = getCon(); //5-2. SQL &amp; pstmt 생성 sql = \"select * from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); //5-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //5-4. 데이터처리 : DB에 있는 회원정보 저장 후 memberinfo페이지로 전달 //DB의컬럼명을 입력할 것 if(rs.next()){ mb = new MemberBean(); mb.setId(rs.getString(\"id\")); mb.setPw(rs.getString(\"pw\")); mb.setName(rs.getString(\"name\")); mb.setAge(rs.getInt(\"age\")); mb.setEmail(rs.getString(\"email\")); mb.setGender(rs.getString(\"gender\")); mb.setReg_date(rs.getTimestamp(\"reg_date\")); } System.out.println(\"@@@@ DAO : 회원정보저장완료\"+mb); }catch (Exception e) { e.printStackTrace(); } finally { //5-5. 자원해제 closeDB(); } return mb;}//getMember닫힘","link":"/2020/08/18/200819jspi4/"},{"title":"오픈소스컨트리뷰톤 온라인미팅5 후기 : GIT 케이스 스터디","text":"두번째 브랜치 생성하고 커밋했는데 첫번째 브랜치의 커밋이 함께 들어가 있을때 두개의 PR을 날렸는데 첫번째는 마스터, 두번째는 새로운 브랜치에서 했었는데요. 두번째에 새로운 브랜치에서 날린 커밋이 첫번째 마스터 아래로 들어갔더라구요 원인 : master브랜치에서 커밋 -&gt; PR -&gt; 다시 master브랜치에서 새로운 브랜치 생성했기 때문! master에서 이미 PR 날린 상태에서 branch를 만들면 새로만든 branch에도 PR보낸게 적용 됨. 해결 방법 2가지 HEAD를 뒤로 돌린 뒤 새로운 브랜치 생성. 커밋을 체크아웃한 뒤 새로운 브랜치 생성. rebase를 사용해 브랜치를 최신화 해주세요. 머지 커밋을 없애주시기 바랍니다에 대한 해결https://github.com/javascript-tutorial/ko.javascript.info/pull/694 기존 작업중인 브랜치를 임시저장하고 빠져나옴 : git status &gt; git stash git 머지커밋 삭제하기 : git log &gt; q &gt; git reset HEAD^ (git reset HEAD~1) &gt; git push 오류남 &gt; git push -f &gt; upstream깃헙 &gt; 머지커밋 사라지고 원하는 커밋만 남음 &gt; 해결! 팁 : CSS 변경 후 실시간으로 반영이 안될때 원인 : CSS 캐쉬때문에 안나옴 empty cache and hard reload 진행 개발자도구 열고 (f12) 새로고침 버튼에서 마우스 오른쪽 클릭하면 3개 버튼 -&gt; 강력 새로고침 또는 캐시비우고 강력 새로고침 단축키 : ctrl + shift + r","link":"/2020/08/21/200822opensource/"},{"title":"Git flow 전략","text":"Git flow 전략 master : 제품으로 출시될 수 있는 브랜치 develop : 다음 출시 버전을 개발하는 브랜치 다음 출시 버전과 관련된 개발자분들은 develop브랜치에 병합하는 전략을 사용. 상시로 버그를 수정한 커밋들이 추가 feature : 기능을 개발하는 브랜치 / 새로운 기능 개발하는 브랜치 release : 이번 출시 버전을 준비하는 브랜치 hotfix : 출시 버전에서 발생한 버그를 수정 하는 브랜치 일반 사용자에게 프로토타입을 공개하지 않는다면? 브랜치 master, develop, feature브랜치 이 세 브랜치 정도만 사용해도 충분. 팁 : master와 develop은 ci서버를 따로 구성하여 계속 빌드가 될 수있게끔 + develop브랜치에 자주 병합 필수. 가장 유명한 git-flow전략이미지와 설명 항상 유지되는 브랜치 : master, develop 일정 기간 동안만 유지되는 보조 브랜치들 : feature, release, hotfix master브랜치르 생성한다 master브랜치에서 develop브랜치를 생성한다. 여기에는 상시로 버그 수정한 커밋을 추가 혹시 새로운 기능 추가 작업이 있다면 develop브랜치에서 feature브랜치를 생성 -&gt; 기능 추가 작업이 완료되었다면 feature브랜치는 develop브랜치로 머지 QA(Quality Assurance)를 위해 develop브랜치에서 relase브랜치 생성 -&gt; QA를 진행하면서 발생한 버그를 relase브랜치에서 수정. QA란 제품개발단계에서 품질보증. 결함을 예방. QA의 모적 : 고품질 제품확보 QA를 무사히 통화 -&gt; relase브랜치를 master와 develop브랜치에 머지 master브랜치에서 버전 태그를 추가. 참고링크 : 우아한형제들의 git flow전략","link":"/2020/08/21/200822opensource2/"},{"title":"Merge시 create a merge commit과 rebase and merge 차이","text":"머지시 create a merge commit과 rebase and merge 차이 create a merge commit : 머지시 머지커밋이 생성됨. 배포가 자주 일어나는 저장소에서 주로 사용 아래 사진처럼 HEAD~1과 HEAD~2가 뭔지 한 번에 알 수 없다. develop브랜치생성 &gt; 커밋 3개 생성 master브랜치에서 커밋3개 생성 master브랜치체크아웃상태에서 develop브랜치를 머지 git merge develop rebase and merge : 머지커밋이 생성안됨. 많은 사람이 기여하면 리베이스앤머지전략을 사용함 ex) 모던자바스크립트 한국어저장소 ko저장소 아래 사진처럼 한 줄로 깔끔하게 커밋내역을 관리할 수 있고 순서가 정확히 나타나기 때문에 HEAD~1과 HEAD~2가 뭔지 한 번에 알 수 있다. develop브랜치생성 &gt; 커밋 3개 생성 master브랜치에서 커밋3개 생성 master브랜치에체크아웃상태에서 develop브랜치를 리베이스 git rebase develop 머지커밋에서 head~1과 head2가 뭘 가르킬까? 위의 사진에서 아래 3단계가 진행된 상태이다. 여기서 HEAD~1과 HEAD~2는 어떤 커밋을 가르킬까? develop브랜치생성 &gt; 커밋 3개 생성 master브랜치에서 커밋3개 생성 master브랜치에서 develop브랜치 merge 체크아웃된 브랜치에 따라 가르키는 값이 다르다. master브랜치에서 HEAD~2했을떼 develop브랜치에서 HEAD~2헸을때 master브랜치의 커밋내역은 변경되지않는다.","link":"/2020/08/21/200822opensource3/"},{"title":"삭제한 옛날 branch 살리기","text":"모르고 삭제해버린 옛날 브랜치 되살리기issue 작업을 끝내고 PR날리고 dev브랜치와 issue737브랜치를 master로 병합 후 깔끔하게 삭제했다. 그 뒤로 수많은 커밋을 master로 날리고 새로운 issue641브랜치 생성하여 커밋을 날렸다. 날렸는데앞으로 일어날 일에 대해서는 전혀 알지못한채… 깔끔 IS THE BEST라고 생각하며… 하지만 PR날린게 conflicts 나면서 다시 그 브랜치가 필요해졌다!!!망함. 심장부여잡고 폭풍검색한 끝에 reflog란 명령어가 있다는 사실을 알았다. 현재 내 상황 master브랜치에서 dev브랜치를 생성 dev브랜치 커밋날리고 master브랜치로 병합 dev브랜치 삭제 master브랜치에서 issue737브랜치 생성 issue737브랜치 커밋날리고 master브랜치로 병합 issue737브랜치 삭제 master브랜치에서 issue641브랜치 생성 issue641브랜치 커밋날림. (병합안함) 이 상황에서 나는 dev브랜치와 issue737브랜치를 살려야 한다.그것도 각 브랜치의 커밋과 함께!!할 수 있을까? reflog란?브랜치나 태그의 모든 변경사항을 기록한다.참고링크 : reflog기초 내 상황을 reflog를 통해 들여다보자. 1234567891011121314$ git reflog14e5ed2 (HEAD -&gt; issue641) HEAD@{0}: commit: 이슈641commit0251dd3 (master) HEAD@{1}: checkout: moving from master to issue6410251dd3 (master) HEAD@{2}: merge issue737: Fast-forwardf04a0fc HEAD@{3}: checkout: moving from issue737 to master0251dd3 (master) HEAD@{4}: commit: 이슈737 commitf04a0fc HEAD@{5}: checkout: moving from master to issue737f04a0fc HEAD@{6}: merge dev: Fast-forwardfee6895 (origin/master, origin/HEAD) HEAD@{7}: checkout: moving from dev to masterf04a0fc HEAD@{8}: commit: dev commitfee6895 (origin/master, origin/HEAD) HEAD@{9}: checkout: moving from master to devfee6895 (origin/master, origin/HEAD) HEAD@{10}: reset: moving to HEAD~1405f8cd HEAD@{11}: commit: dev 첫번째커밋fee6895 (origin/master, origin/HEAD) HEAD@{12}: clone: from https://github.com/sowon-dev/conflict-resolve.git HEAD@{12} : 레포 클론해옴 HEAD@{10}과 HEAD@{11}은 그냥 무시해도 됨.dev에서 커밋해야하는데 master에서 커밋해버려서 커밋삭제한 로그임ㅋㅋㅋ HEAD@{9} : dev브랜치생성후 dev브랜치로 체크아웃 HEAD@{8} : dev브랜치에서 커밋날림 HEAD@{7} : dev브랜치에서 master브랜치로 체크아웃 HEAD@{6} : master브랜치로 dev브랜치 병합 후 삭제 HEAD@{5} : master브랜치에서 issue737브랜치 생성 후 체크아웃 HEAD@{4} : issue737브랜치에서 커밋날림 HEAD@{3} : master브랜치로 체크아웃 HEAD@{2} : master브랜치로 issue737브랜치 병합 후 삭제 HEAD@{1} : master브랜치에서 issue641브랜치 생성 후 체크아웃 HEAD@{0} : issue641브랜치에서 커밋날림 여기서 dev와 issue737을 각각 커밋과 함께 살려야한다. 해결순서 git branch : 현재 내가 가지고 있는 브랜치 확인하기 git reflog : HEAD가 가리키는 커밋이 바뀔 때마다 Git은 자동으로 그 커밋이 무엇인지 기록한다. 새로 커밋하거나 브랜치를 바꾸면 Reflog도 늘어난다. 참고링크 삭제한 브랜치 찾기 git checkout -b [deleted-branchName] HEAD@{number} : 삭제한 브랜치 커밋 되돌리기 그런데 삭제한 브랜치에 대해 수많은 로그가 있는데 그 중 어떤 로그를 되돌려야할까?? 실험결과 ** merge 브랜치명: Fast-forward ** 로그를 되돌려야 해당 브랜치의 커밋까지 살아난다!! 12345678910111213141516171819202122232425//기본값$ git branch # 내가 가지고 있는 브랜치 확인하기$ git reflog $ git checkout -b [deleted-branchName] HEAD@{number}//예시$ git branch* issue641 master $ git checkout master0251dd3 (HEAD -&gt; master) HEAD@{0}: checkout: moving from issue641 to master14e5ed2 (issue641) HEAD@{1}: commit: 이슈641commit0251dd3 (HEAD -&gt; master) HEAD@{2}: checkout: moving from master to issue6410251dd3 (HEAD -&gt; master) HEAD@{3}: merge issue737: Fast-forwardf04a0fc HEAD@{4}: checkout: moving from issue737 to master0251dd3 (HEAD -&gt; master) HEAD@{5}: commit: 이슈737 commitf04a0fc HEAD@{6}: checkout: moving from master to issue737f04a0fc HEAD@{7}: merge dev: Fast-forwardfee6895 (origin/master, origin/HEAD) HEAD@{8}: checkout: moving from dev to masterf04a0fc HEAD@{9}: commit: dev commitfee6895 (origin/master, origin/HEAD) HEAD@{10}: checkout: moving from master to devfee6895 (origin/master, origin/HEAD) HEAD@{11}: reset: moving to HEAD~1405f8cd HEAD@{12}: commit: dev 첫번째커밋fee6895 (origin/master, origin/HEAD) HEAD@{13}: clone: from https://github.com/sowon-dev/conflict-resolve.git 실험 : 수많은 로그중에 어떤 로그를 써야 내가 원하는대로 각 브랜치의 커밋까지 그대로 살아날까? 첫번째 시도 : HEAD@{8}: checkout: moving from dev to master 12345678$ git checkout -b dev HEAD@{8}$ git branch* dev issue641 master$ code . 첫번째 시도 결과 : dev브랜치에서 code .로 열였을때 내가 작성한 커밋이 반영되어있지않았다. master브랜치 code .로 열였을때 내가 작성한 issue737까지 포함된 커밋이 그대로 보존되어있었다. 결론 : master브랜치의 상태에 변화를 주지않고 dev브랜치만 살아나는 데 dev에서 커밋한 내용은 없음. 두번째 시도 : HEAD@{3}: merge issue737: Fast-forward 12345678$ git checkout -b issue737 HEAD@{3}$ git branch dev issue641 issue7* issue737 master$ code . 두번째 시도 결과 : issue737브랜치에서 code .로 열였을때 내가 작성한 커밋이 그대로 보존되어있었다. master브랜치 code .로 열였을때 내가 작성한 issue737까지 포함된 커밋이 그대로 보존되어있었다. 결론 : master브랜치의 상태에 변화를 주지않고 issue737브랜치만 살아난다! 되살리기 성공! 실험 결론 : ** merge 브랜치명: Fast-forward **를 되돌려야 해당 브랜치의 커밋까지 살아난다!! 실무에선 추가로 생성한 branch는 보통 언제 삭제할까?깔끔한게 좋다며 괜히 브랜치 삭제해서 진짜 큰일 날뻔했다.도대체 새로 생성한 브랜치는 언제 삭제하는 지 궁금해져서 보라님께 물어봤다.아래 두가지 경우에서 삭제한다고 한다. PR날려서 머지되면 삭제함. 어차피 회사가면 jenkins라는 툴로 브랜치관리함.","link":"/2020/08/22/200823git/"},{"title":"git reflog 기초","text":"reflog란?브랜치나 태그의 모든 변경사항을 기록한다. The ‘reflog’ command keeps a Reference logs such as the commit snapshot of when the branch was created or cloned, checked-out, renamed, or any commits made on the branch are maintained by track of every single change made in the references (branches or tags) of a repository and keeps a log history of the branches and tags that were either created locally or checked out. Git and listed by the ‘reflog’ command. 참고링크 : Git Reflog — How To Recover A Deleted Branch That Was Not Merged 브랜치를 새로 만들면 git reflog에는 어떻게 기록될까?현재 master에 체크아웃되어있는 상태에서 아래 명령어를 차례대로 입력했다. 123456789git branch issue#654$ git reflog8bbfbb1b (HEAD -&gt; master, origin/master, origin/HEAD, issue#654) HEAD@{0}: checkout: moving from issue#641 to master(생략)$ git branch issue#641 issue#654* master 위 출력값에서도 알 수 있듯이 아무런 기록이 되지 않는다. 새로 만든 브랜치에 체크아웃한다면 reflog에는 어떻게 기록될까?현재 master브랜치에서 위에서 새로만든 issue#654로 체크아웃했다. 12345git checkout issue#654$ git reflog8bbfbb1b (HEAD -&gt; issue#654, origin/master, origin/HEAD, master) HEAD@{0}: checkout: moving from master to issue#6548bbfbb1b (HEAD -&gt; issue#654, origin/master, origin/HEAD, master) HEAD@{1}: checkout: moving from issue#641 to master(중략) 체크아웃을 하자마자 체크아웃이 reflog에 기록되었다. 브랜치를 삭제하면 reflog에는 어떻게 기록될까?기껏 만든 issue#654 브랜치를 삭제해보자issue#654브랜치를 삭제하기위해서는 다른 브랜치에 head가 있어야한다.master브랜치로 체크아웃한 뒤 진행해보자. 12345678910git checkout master$ git branch -d issue#654$ git reflog8bbfbb1b (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@{0}: checkout: moving from issue#654 to master8bbfbb1b (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@{1}: checkout: moving from master to issue#6548bbfbb1b (HEAD -&gt; master, origin/master, origin/HEAD) HEAD@{2}: checkout: moving from issue#641 to master$ git branch issue#641* master 브랜치 삭제하는 것은 로그가 찍히지 않는다. 브랜치를 되살려보자삭제한 issue#654 브랜치를 되살려보자HEAD@{0} 과 HEAD@{1}은 체크아웃상태밖에 없는데 어떤 걸로 체크아웃해야할까?궁금해서 둘다 해봤다. HEAD@{0}: checkout: moving from issue#654 to master 을 되살리기 123456git checkout -b issue#654 HEAD@{0}$ git branch issue#641* issue#654 master HEAD@{1}: checkout: moving from issue#654 to master 을 되살리기 123456git checkout -b issue#654 HEAD@{0}$ git branch issue#641* issue#654 master 둘 다 브랜치를 살리는 동일한 결과를 가져왔고 head도 issue#654로 동일했다. 요약 브랜치 새로 생성은 로그가 찍히지않는다. HEAD@{1}은 issue#654브랜치를 새로만들고 체크아웃한 로그이다. HEAD@{0}은 issue#654브랜치에서 master브랜치로 체크아웃한 로그이다. 브랜치 삭제도 로그가 찍히지않는다.","link":"/2020/08/22/200823git2/"},{"title":"git bash내 특정 상황에서 빠져나가기 명령어","text":"server 종료하기 명령어 : Ctrl + c 추천 검색어 : how to exit server git bash git log, nano 편집기 나가기 q vi편집기 나가기 :wq : write and quit(저장하고 나가기의 줄임말) SQL에서 리눅스로 나가기 i : sql -&gt; 리눅스 exit : 리눅스 -&gt; sql","link":"/2020/08/22/200823git3/"},{"title":"Subquery2: Inlineview, Scalar Subquery, Correlated Subquery","text":"위치에 따라 다르게 불리는 서브쿼리 WHERE 중첩 서브쿼리 FROM 인라인 뷰 SELECT 스칼라 서브쿼리 inlineviewfrom절에 sub쿼리가 사용된 경우 쓴다.직급이 사원인 사람들의 이름과 급여를 구하시오. 1234SELECT emp.last_name, emp.salaryFROM ( SELECT * FROM employee AS e WHERE e.office_worker='사원') emp Scalar Subquery 스칼라서브쿼리 SELECT 문에 나타나는 서브쿼리 규모가 제일 작은 중첩서브쿼리유형 한 행에서 정확히 한 행에서 정확히 열 값을 반환. 단일행 서브쿼리 + 단일컬럼 서브쿼리 사용처 decode및 case조건 및 표현식 부분 group by제외한 모든 select절 update문의 set절 123456//departments테이블에서 department_id, department_name, 각부서별 사원수를 출력하는 쿼리select department_id, department_name, (select count(*) from employees e where e.department_id = d.department_id) as emp_cfrom departments dorder by department_id; Correlated Subquery 상호관련서브쿼리 내부 Subquery에서 외부테이블의 값을 참조할 때 사용. 일반 서브쿼리와 달리 서브쿼리만 따로 돌릴 수 없음. 실행순서 : 메인쿼리에서 만들어진 테이블의 행의 수만큼 후보 행을 하나씩 가져옴 -&gt; 후보행 하나를 사용해서 inner쿼리를 실행 -&gt; 메인 쿼리의 후보행을 다 돌때까지 반복실행 후 결과 출력. 단점 : 성능적으로 유리한 문법이 아님. 따라서 상호관련서브쿼리말고 다른 문법으로 쓸 수 있다면 그걸 쓰면 됨. 예제1 : 자신의 부서의 평균 급여보다 많은 급여를 받는 사원을 모두 찾을때.- 인라인뷰로도 출력가능12345678910111213141516171819202122232425//상호관련서브쿼리사용select last_name, salary, department_idfrom employees outerwhere salary &gt; (select avg(salary) from employees inner where inner.department_id = outer.department_id);//내코드 : 왜 계속 에러가 뜰까했는데 메인쿼리의 select부분이 e1테이블인지 e2테이블인지 모호해서 에러가 났다. 따라서 아래 강사님코드처럼 어디서 가져올지 테이블을 확실히 정해줘야한다.select last_name, salary, department_idfrom (select avg(salary), department_id from employees group by department_id) e1join employees e2on(e1.department_id = e2.department_id)where e2.salary &gt;e1.avg;//강사님코드 (인라인뷰사용)select e1.last_name, e1.salary, e1.department_idfrom employees e1join (select department_id, avg(salary) avgsal from employees group by department_id) e2on (e1.department_id = e2.department_id)where e1.salary &gt; e2.avgsal; 예제2 : 각 부서별 최대 연봉을 받는 사원의 employee_id를 출력하는 쿼리스스로 궁금해서 다른 쿼리구문으로 작성가능 한지 확인해보았다상호관련서브쿼리를 바꾸기 위해서 첫번째로 서브쿼리를 먼저 만들어야한다. 1234567891011121314151617181920212223242526//상호관련서브쿼리사용select department_id, employee_id, salaryfrom employees ewhere 1 = (select count(distinct salary) from employees where e.department_id = department_id and e.salary &lt;= salary)order by department_id;//내코드 : 인라인뷰사용//1. 부서별 최대 연봉 출력select department_id, max(salary)from employees group by department_idorder by department_id;//2. 부서별 최대 연봉을 받는 직원의 employee_id출력select e1.department_id, e1.employee_id, e1.salaryfrom employees e1join (select department_id, max(salary) maxsal from employees group by department_id) e2on e1.salary = e2.maxsal where e1.department_id = e2.department_idorder by department_id;","link":"/2020/08/23/200824dbi/"},{"title":"Subquery3: exists연산자, not exists연산자","text":"exists연산자 서브쿼리의 결과 집합에 행이 존재하는 지 확인하는 연산자. 서브쿼리로부터 결과값이 존재(exist)하면 true를 반환. 서브쿼리로부터 결과값이 존재하지않으면 false를 반환. 상호관련서브쿼리임 123456789//exists연산자 기본형select 컬럼명, 컬럼명, 컬럼명from 테이블명where exists ( 서브쿼리 );//not exists연산자 기본형select 컬럼명, 컬럼명, 컬럼명from 테이블명where not exists ( 서브쿼리 ); exists연산자 예시 : employees테이블로 부터 자기 자신이 매니저인 사원의 employee_id, last_name, department_id 출력하는 쿼리1234567891011121314//exist사용select employee_id, last_name, department_idfrom employees outerwhere exists (select 'x' from employees where manager_id = outer.employee_id);//구상select employee_id, last_name, department_idfrom employees where employee_id in (매니저아이디 리스트);//서브쿼리사용select employee_id, last_name, department_idfrom employees where employee_id in (select manager_id from employees); not exists연산자 예시 : 사원이 없는 부서 찾는 쿼리1234567891011121314151617181920212223242526272829303132333435//not exists사용select department_id, department_namefrom departments dwhere not exists( select 'dept in no one' from employees where department_id = d.department_id)order by department_id;//구상select d.department_id, d.department_namefrom departments dwhere (d.department_id not in (사원들이 있는 부서리스트));//첫번째시도select d.department_id, d.department_namefrom departments dwhere d.department_id not in (select e.department_id from employees e);//계속 no row인 경우는? null값때문!!! //근데 에러가 아닌 no row가 나오는 이유는? where는 조건절이기때문에 조건이 없다고해서 select구문이 에러가 나진않는다.//null값 해결법 =&gt; nvl사용//두번째시도 : 서브쿼리 + not in을 이용해서 풀기 =&gt; 성공select d.department_id, d.department_namefrom departments dwhere d.department_id not in (select nvl(e.department_id, 0) from employees e);//강사님코드select department_id, department_namefrom departmentswhere department_id not in (select department_id from employees where department_id is not null)order by department_id; no row인 경우는? null값때문!!! 근데 에러가 아닌 no row가 나오는 이유는? where는 조건절이기때문에 조건이 없다고해서 select구문이 에러가 나진않는다. null값 해결법 =&gt; nvl()함수사용 또는 not null 연산자 사용 테이블 규모가 클때(500행이상)는 함수(nvl)보다 연산자(not null)이 성능이 더 좋다","link":"/2020/08/24/200825dbi/"},{"title":"Subquery4: with절","text":"with절 복합 query내에서 동일한 쿼리블록이 두 번 이상 발생하면 그 블록을 select문에 사용가능 임시테이블을 만든다고 생각하면 됨. 성능개선 WITH절은 오라클9 이후 버전부터 사용이 가능하며 이름이 부여된 서브쿼리라고 생각하시면 됩니다. 임시테이블을 만든다는 관점에서본다면 VIEW와 쓰임새가 비슷한데 차이점이 있다면 VIEW는 한번 만들어놓으면 DROP할때까지 없어지지 않지만 WITH절의 같은경우 한번 실행할 쿼리문내에 정의되어 있을경우, 그 쿼리문안에서만 실행된다는 차이점이 있습니다.출처 : https://coding-factory.tistory.com/445 WITH절을 사용하는 이유WITH절은 복잡한 SQL에서 동일 블록에 대해 반복적으로 SQL문을 사용하는 경우 그 블록에 이름을 부여하여 재사용 할 수 있게 함으로서 쿼리 성능을 높일 수 있는데 WITH절을 이용하여 미리 이름을 부여해서 Query Block을 만들 수 있습니다. 자주 실행되는 경우 한번만 Parsing되고 Plan 계획이 수립되므로 쿼리의 성능향상에 도움이 됩니다.출처 : https://coding-factory.tistory.com/445","link":"/2020/08/24/200825dbi2/"},{"title":"vscode extension 추천 : code runner","text":"코드러너vscode에서 크롬개발자도구처럼 간단한 출력값을 바로 보고 싶을때가 있다.이때 사용하면 좋을 익스텐션이 바로 코드러너 (공식사이트) 이다. 예시는 파이썬이지만 js등 다른 언어도 충분히 가능하다. 다운로드 : vscode extension에서 code runner 검색 후 다운로드 사용법 : ctrl + alt + N output에 바로 출력결과를 확인 가능.","link":"/2020/08/22/200823journal/"},{"title":"멀티스레드프로그래밍2 : 풍선게임","text":"클릭하면 풍선이 나타나고 위로 올라가는 풍선게임을 만들어보자. MouseEvent -&gt; y축을 이동 sleep : 반응시간 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import javax.swing.ImageIcon;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;public class BaloonThreadEx extends JFrame{ JPanel p; BaloonThreadEx(){ setTitle(\"Baloon\"); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); p = new JPanel(); p.setLayout(null); p.addMouseListener(new MouseAdapter(){ @Override public void mousePressed(MouseEvent e) { BaloonThread t= new BaloonThread(e.getX(), e.getY()); t.start(); } }); setContentPane(p); setSize(500,500); setVisible(true); } class BaloonThread extends Thread { int x,y; BaloonThread(int x, int y){ this.x=x; this.y=y; } @Override public void run() { ImageIcon icon = new ImageIcon(\"images/balloon.jpg\"); JLabel baloon = new JLabel(icon); baloon.setSize(60,60); baloon.setLocation(x, y); p.add(baloon); while(y&gt;0){ y-=20; //0.2초마다 얼마만큼 위로 올라가는지 숫자가 클수록 빨리 올라가는 느낌 but부자연스러움 try{ Thread.sleep(200); //0.2초마다 }catch(Exception e){ e.toString(); } baloon.setLocation(x, y); //p.repaint(); } p.remove(baloon); } } public static void main(String[] args) { new BaloonThreadEx(); }}","link":"/2020/08/25/200826javai/"},{"title":"멀티스레드프로그래밍3 : 멀티스레드의 문제점과 해결","text":"데이터 공유와 동기화 문제 멀티 스레드의 장점 중 하나는 공유 데이터를 여러 스레드에서 사용할 수 있다는 점이지만 공유데이터에 여러 스레드가 동시 접근하여 수정하면 문제가 발생한다. =&gt; 이를 데이터 신뢰성이 깨졌다고 표현한다. 예를 들어 공유데이터 계좌가 있다고 생각해보자. 잔액이 5000원 남았는데 a스레드에서 3000원을 b스레드에서 4000원을 동시에 출금하려고한다면 순서가 없으므로 3000원과 4000원이 동시에 출력되어 이 계좌는 마이너스통장도 아닌데 -2000원이 되어버리는 문제가 발생한다. 데이터 신뢰성이 깨져버렸다 해결하기 위해서는 세마포어(Semaphore)개념으로 lock개념과 synchronized키워드 사용 synchronized는 메서드 등 블록에 사용하며 해당 영역","link":"/2020/08/25/200826javai2/"},{"title":"걸스인텍 서울 : Git? GitHub? 웨비나후기","text":"🍀 웨비나 후기1시간반동안 진행되었는데 너무 아쉬웠다. 2시간해도 될듯.라면비법이라든지 Azure 개발도구와 Azure 앱 시연이 정말 유익했다.Azure 개발도구는 정말 팀플에는 필수적이라는 생각이 들었다. 지금 개인 프로젝트중이지만 적응하고자 사용해봤는데 너무 편했다.이전까지 todo list들을 구글 task에 저장하고 사용했었는데 앞으로느 Azure devOps 적극 사용해야겠다!깃초보뿐만 아니라 깃중급사용자를 위해 1시간반이라는 짧은 시간동안 다양한 꿀팁을 전수해주셔서 매우 유익했다.나뿐만 아니라 다른 참여자들도 취업에 대한 두려움이 가득했는데 뻔하다면 뻔한 질문에 응원가득한 답변을 해주셔서 정말 감사했다.할 수 있다. 할 수 있다고 믿자! 개발자라면 협업에 반드시 필요한 GitHub! 깃허브 직원들이 쉽고 재밌게 알려주는 깃허브에 대해서 알아봐요 👩🏻‍💻💞 무료 행사신청: https://www.wanted.co.kr/events/git_github #걸스인텍 #깃허브 #github #코딩 #여성개발자게시: Girls in Tech - Korea&nbsp;2020년 8월 18일 화요일 🍀 깃이 왜 필요하죠? 작업을 할때 버전 관리가 필요하다. 문서는 save as로 저장하면서 관리할수있다지만 그게 코드면? 점 하나만 달라져도 프로그램의 동작 여부가 달라진다. 어떤 부분을 어떻게 작성했는지 깃을 이용하여 추적을 해야한다. 🍀 깃 vs 깃허브 깃 : 분산 버전 관리 시스템 깃허브 : 분산버전 관리 툴인 깃을 사용하는 프로젝트를 지원하는 웹 호스팅 서비스 리누스 토르발스 : 리눅스운영체제 개발, 깃 개발한 천재개발자 🍀 깃 주요 개념 개념 어떨 때 사용할까 commit 어느 단위로 변경된 사항을 저장 conflict 같은 부분을 협업자들과 동시에 변경하게되면 발생. 어떻게 처리할 것인지가 관건 branch 개별적인 버전관리 merge 개별적인 버전의 최종본들을 합치기 🍀 빌드개발자들이 쓴 코드를 실행되는 파일로 변환하는 것을 빌드라고 한다 🍀 프로젝트 협업도구 Azure DevOps : 깃헙이랑 연동가능 깃헙계정이랑 연동하면 됨 + 커밋메세지 AB#번호+ development에 자동으로 트리거됨 🍀 draft pull request 깃헙에서 제공하는 기능 작업량이 많은 경우 완성된 pr은 아니지만 중간지점에서 리뷰해줬으면 좋겠을때 사용하는 기능 🍀 코드 스페이스 https://github.com/features/codespaces 올해 ms빌드 개발자빌드에서 굉장히 핫했다. pc에 개발환경이 없어도 개발가능 다른 사람의 브랜치를 vs코드로 볼수있음 디버깅 가능 배타버전이라 정식출시는 2020년 하반기 명령어 npm test 🍀 깃헙 actions ci/cd (지속적인 빌드/지속적인배포) 자동화 가능하게 함. node.js파일을 azure web app으로 바꿈 on: 언제 실행하나요? 마스터브랜치일때 job:뭘실행하나요? 셋팅즈 -&gt; 시크릿 -&gt; repostiory secrets 에서 중요정보를 보호할수있음 🍀추천무료학습사이트 GitHub Learning lab Microsoft Learn : 컴퓨팅사고 Microsoft Learn : 다양한 무료교육 Microsoft Learn : Azure Web App 소개 🍀 브랜치는 몇개 생성하면 좋은가요? 브랜치 관리 팁 알려주세요! branch 개수는 상관이 없습니다. branch는 merge된 후에 삭제되기도 합니다.branch 관리팁은 git flow개념이 도움됩니다.간단히 말씀드리면 기능별(feature), 버그별(hotfix), 릴리즈별(release)등 다양하게 만들 수 있습니다. 🍀 실무에서 리뷰어가 따로 있는지? 보통은 개발문화가 좋은 회사의 경우 CTO, 팀장님, 동료들이 서로의 코드를 리뷰해줍니다.","link":"/2020/08/25/200826girlsInTech/"},{"title":"스트림 API 개념","text":"스트림 API 스트림 API란 자바 8부터 추가된 java.util.stream패키지 I/O 스트림과는 전혀 무관하다. 목적 : 배열을 포함한 컬렉션의 저장 요소를 하나씩 참조해서 람다식으로 처리가능하도록 만듦 장점 코드 간결 컬렉션과 배열 등 데이터 소스를 공통된 방식으로 접근 가능 중간처리와 최종 처리를 조합해서 처리 가능 중간처리 : 매핑, 필터링, 정렬 등 데이터 가공 담당 최종처리 : 반복, 카운팅, 평균, 총합 등 집계처리 담당, 최종처리는 한 개만 사용한다. 병렬처리 작업이 용이 연산의 결과를 원본에 반영하지않음 -&gt; 결과를 새로운 컬렉션이나 배열에 담아서 반환가능 스트림 생성 예시 : List에 담긴 요소 중 3글자 이상인 요소를 순차적으로 출력하기 위한 코드12345678910111213141516171819202122232425262728293031323334353637383940//스트림 API사용 전List&lt;String&gt; ppl = Arrays.asList(\"하지\",\"강조지\",\"휘슬\",\"그레이스호퍼\",\"브라이언\"); List&lt;String&gt; sub = new ArrayList&lt;&gt;(); for(String p : ppl){ if(p.length() &gt;= 3){ sub.add(p); } } for (String p : sub){ System.out.print(p+\"\\t\"); } //출력값강조지 그레이스호퍼 브라이언 //스트림 API사용 후List&lt;String&gt; ppl2 = Arrays.asList(\"하지\",\"강조지\",\"휘슬\",\"그레이스호퍼\",\"브라이언\");Stream&lt;String&gt; stream = ppl2.stream(); //스트림생성stream.filter(p2 -&gt;{ return p2.length() &gt;= 3;}).forEach(System.out::println);//출력값강조지그레이스호퍼브라이언//스트림 API사용String[] ppl3 = {\"하지\",\"강조지\",\"휘슬\",\"그레이스호퍼\",\"브라이언\"};Stream&lt;String&gt; fromArray = Arrays.stream(ppl3); //스트림생성List&lt;String&gt; pplList = Arrays.asList(ppl3);Stream&lt;String&gt; fromList = pplList.stream();fromList.forEach(a-&gt; { if(a.length() &gt;=3) System.out.print(\"[\"+a+\"]\"); });//출력값[강조지][그레이스호퍼][브라이언] 중간처리 예시 map()메서드를 이용해 char[]로 구성된 스트림로 변경 후 각 요소의 length속성값을 출력 return타입인 경우에는 return 예약어와 대괄호{}를 생략 가능. .map((item) -&gt; {return item.toCharArray();}) = .map(item-&gt; item.toCharArray()) return타입인 아니경우 대괄호{} 생략불가. int 스트림을 mapToObj()로 문자열스트림으로 변경한 뒤 각 요소를 출력 123456789101112131415List&lt;String&gt; list = Arrays.asList(\"안녕\",\"자바월드\");//return타입인 경우에는 return예약어를 생략.//리턴타입이 없는 건 생략안됨 `forEach(data -&gt; {System.out.println(data.length);}`//list.stream().map((item) -&gt; {return item.toCharArray();}).forEach(data -&gt; {System.out.println(data.length);});list.stream().map(item-&gt; item.toCharArray()).forEach(data -&gt; {System.out.println(data.length);});IntStream is = IntStream.range(3, 5);is.mapToObj(num -&gt; { return \"제곱: \"+num+num;}).forEach(System.out::println);//출력값24제곱: 33제곱: 44 최종처리 매칭과 집계 예시 : 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) { Locale[] locales = Locale.getAvailableLocales(); Map&lt;String, List&lt;Locale&gt;&gt; langNames2 = Arrays.stream(locales).filter(locale -&gt;{ return locale.getDisplayCountry().trim().length() &gt; 0; }).collect(Collectors.groupingBy(locale -&gt; { return locale.getLanguage(); })); System.out.print(\"한국어를 사용하는 locale은? \"); langNames2.get(\"ko\").stream().forEach(locale-&gt;{ System.out.println(\"[\"+locale.getDisplayCountry()+\"]\"); }); System.out.print(\"영어를 사용하는 locale은? \"); langNames2.get(\"en\").stream().forEach(locale-&gt;{ System.out.print(\"[\"+locale.getDisplayCountry()+\"] \"); }); Map&lt;Boolean, List&lt;Locale&gt;&gt; langName3 = Arrays.stream(locales).filter(locale -&gt; { return locale.getDisplayCountry().trim().length() &gt;0; }).collect(Collectors.partitioningBy(locale -&gt; { return locale.getLanguage().equals(\"ko\"); })); System.out.print(\"\\n한국어를 사용하지않는 locale의 수는? \"); System.out.println(langName3.get(false).stream().count() + \"개\"); langName3 = Arrays.stream(locales).filter(locale -&gt; { return locale.getDisplayCountry().trim().length() &gt;0; }).collect(Collectors.partitioningBy(locale -&gt; { return locale.getLanguage().equals(\"en\"); })); System.out.print(\"\\n영어를 사용하지않는 locale의 수는? \"); System.out.println(langName3.get(false).stream().count() + \"개\");}//출력값한국어를 사용하는 locale은? [대한민국]영어를 사용하는 locale은? [미국] [싱가포르] [몰타] [필리핀] [뉴질랜드] [남아프리카] [오스트레일리아] [아일랜드] [캐나다] [인도] [영국] 한국어를 사용하지않는 locale의 수는? 113개영어를 사용하지않는 locale의 수는? 103개 orElse와 orElseGet의 차이 orElse 메소드는 해당 값이 null 이든 아니든 관계없이 항상 호출 orElseGet 메소드는 해당 값이 null 일 때만 호출","link":"/2020/08/26/200827javai2/"},{"title":"멀티스레드 프로그래밍4 : 스레드 풀을 활용한 구구단","text":"코드 Executors.newFixedThreadPool(processCnt); 스레드풀생성 구구단 결과가 리턴값이므로 Callable타입으로 작업 -&gt; 람다식으로 call()메서드 오버라이딩함 Runnable타입 : 인터페이스, 스레드 동작 후 리턴할 값이 없음 Callable타입 : 인터페이스, 스레드 동작 후 리턴할 값이 있음, 사옹하려면 call()메서드 오버라이딩 필수 1234567891011121314151617181920212223242526272829303132333435363738private static int[][] gugudan = new int[9][9];private static int dans = 0;public static void main(String[] args) throws InterruptedException, ExecutionException { int processCnt = Runtime.getRuntime().availableProcessors(); System.out.println(\"VM에서 운용가능한 프로세서 개수: \"+processCnt); ExecutorService es = Executors.newFixedThreadPool(processCnt); //스레드풀생성 System.out.println(\"작업 시작 전: \"+es); Callable&lt;String&gt; callable = () -&gt; { //람다식으로 call()메서드 오버라이딩 int dan = ++dans; for(int i=1; i&lt;10; i++){ gugudan[dan-1][i-1] = dan * i; } return dan+\"작업완료, \"+Thread.currentThread().getName(); }; for(int i=0; i&lt;9; i++){ Future&lt;String&gt; guguFuture = es.submit(callable); new Thread(() -&gt; { try{ System.out.println(guguFuture.get()); }catch(Exception e){ e.printStackTrace(); } }).start(); } Thread.sleep(1000*5); //5초를 sleep하는 이유는 위의 코드들과 섞여서 출력될까봐 System.out.println(\"작업 종료 후: \"+es); for(int[] dans : gugudan){ for(int num : dans){ System.out.print(num+\"\\t\"); }System.out.println(); } es.shutdown();}//end of main","link":"/2020/08/26/200827javai/"},{"title":"Servlet쇼핑몰6: 회원탈퇴","text":"main.jsp 생성 &lt;input type=&quot;button&quot; value=&quot;회원탈퇴&quot; class=&quot;btn&quot; onclick=&quot;location.href='./MemberDelete.me'&quot;&gt;로 href속성 변경하기 123456789101112131415161718192021222324252627&lt;%//1.한글처리, 파라미터 request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅String name = request.getParameter(\"name\");//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동. 가상주소로 이동if(id == null){ response.sendRedirect(\"./MemberLogin.me\");}%&gt;&lt;h3&gt;아이디: &lt;%=id %&gt;&lt;/h3&gt;&lt;h3&gt;아이디(session-EL표현식) : ${ sessionScope.id } &lt;/h3&gt;&lt;input type=\"button\" value=\"ITWILL게시판가기\" class=\"btn\" onclick=\"location.href='../board/boardList.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보조회\" class=\"btn\" onclick=\"location.href='./MemberInfo.me'\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" class=\"btn\" onclick=\"location.href=''\"&gt;&lt;input type=\"button\" value=\"로그아웃\" class=\"btn\" onclick=\"location.href='./MemberLogout.me'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" class=\"btn\" onclick=\"location.href='./MemberDelete.me'\"&gt;&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id != null){ if(id.equals(\"admin\")){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" class=\"btn\" onclick=\"location.href=''\"&gt;&lt;% }}%&gt; MemberFrontController.java의 doProcess()메서드 추가 코드작성 회원삭제 가상경로 설정 1234567891011121314151617 //15.회원탈퇴}else if(command.equals(\"/MemberDelete.me\")){ System.out.println(\"@@@@ Controller : 가상주소 /MemberDelete.me 실제주소: ./member/deleteForm.jsp\"); //DB정보가 필요없기때문에 바로 view페이지로 전환 //페이지 이동하기 위한 객체 ActionForward()객체 생성 forward = new ActionForward(); forward.setPath(\"./member/deleteForm.jsp\"); forward.setRedirect(false);//주소전환없이 jsp페이지가 보여야함 forwarding방식}else if(command.equals(\"/MemberDeleteAction.me\")){ // new MemberDeleteAction() 객체 생성 action = new MemberDeleteAction(); try{ forward = action.execute(req, resp); //어차피 null에서 foward에 넣지 않아도 됨 } catch (Exception e){ e.printStackTrace(); }} deleteForm.jsp 생성12345678910111213141516171819202122&lt;%// 로그인 처리 -&gt; 로그인 x (로그인페이지 이동)String id = (String) session.getAttribute(\"id\");if( id == null ){ response.sendRedirect(\"./MemberLogin.me\");}// 회원 비밀번호만 입력받아서 deletePro.jsp페이지 이동후 삭제// 비밀번호와 db 비밀번호 일치 -&gt; 삭제하면안됨 비번이 같은 회원이 있을 수 있음// 따라서 %&gt; &lt;fieldset&gt; &lt;legend&gt;회원탈퇴&lt;/legend&gt; &lt;form action=\"./MemberDeleteAction.me\" method=\"post\"&gt; &lt;!-- input타입중 hidden은 화면에 있는 해당 input태그를 숨겨서 정보 전달 --&gt; 아이디 : &lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=id %&gt;\" readonly&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"btn\" value=\"탈퇴하기\"&gt; &lt;input type=\"button\" class=\"btn\" value=\"뒤로가기\" onclick=\"location.href='./Main.me'\"&gt; &lt;/form&gt;&lt;/fieldset&gt;&lt;/body&gt;&lt;/html&gt; MemberDeleteAction.java 생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MemberDeleteAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"@@@@ Action: MemberDeleteAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2.세션, 파라미터 정보 가져오기 HttpSession session = req.getSession(); String id = (String) session.getAttribute(\"id\"); String pw = req.getParameter(\"pw\"); ActionForward forward = new ActionForward(); if(id == null){ //model2방식이므로 req.sendRedirect()가 아닌 ActionForward방식으로 이동 forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } MemberBean mb = new MemberBean(); MemberDAO mdao = new MemberDAO(); int result = mdao.deleteMember(id, pw); //자바스크립트사용하여 alert()창띄우기 resp.setContentType(\"text/html; charset=UTF-8\"); PrintWriter out = resp.getWriter(); if(result == 0){ //로그인 비번오류 out.print(\"&lt;script&gt;\"); out.print(\"alert('비밀번호오류');\"); out.print(\"history.back();\"); out.print(\"&lt;/script&gt;\"); //자원해제(필수! 까먹지마!) out.close(); return null; //null이란 Controller에서 페이지 이동하지않겠다는 의미 }else if(result == -1){ out.print(\"&lt;script&gt;\"); out.print(\"alert('존재하지 않는 아이디입니다');\"); out.print(\"history.back();\"); out.print(\"&lt;/script&gt;\"); //자원해제(필수! 까먹지마!) out.close(); return null; //null이란 Controller에서 페이지 이동하지않겠다는 의미 } //if(result == 1) session.invalidate(); System.out.println(\"@@@@ Action : 회원탈퇴성공 후 페이지이동 \"); out.print(\"&lt;script&gt;\"); out.print(\"alert('정상적으로 회원탈퇴되었습니다');\"); out.print(\"location.href='./Main.me';\"); out.print(\"&lt;/script&gt;\"); //자원해제 out.close(); return null; }} MemberDAO.java의 deleteMember()메서드 추가 코드 작성1234567891011121314151617181920212223242526272829303132333435363738//7.delete구현public int deleteMember(String id, String pw){ int result = -1; try { //7-1. DB연결메서드 불러오기 con = getCon(); //7-2. SQL &amp; pstmt 생성 sql = \"select pw from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); //7-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //7-4. 데이터처리 : DB에 있는 회원인 경우 삭제, 아닌 경우 에러 if(rs.next()){ if(pw.equals(rs.getString(\"pw\"))){ //7-5. 비번일치하면 정보삭제 작업 //7-5-1. SQL 구문작성 &amp; pstmt 생성 sql = \"delete from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); pstmt.executeUpdate(); result = 1; System.out.println(\"회원삭제성공-아디일치,비번일치\"); }else{ result = 0; System.out.println(\"회원삭제실패-아디일치,비번불일치\"); } }else{ result = -1; System.out.println(\"회원삭제실패-아이디불일치\"); } } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return result; }//delete닫힘","link":"/2020/08/26/200827jspi2/"},{"title":"Position 포지션","text":"position position:static; 기본값 position:relative; 기준점: 현재위치 position:absolute; 기준점 : 부모를 기준으로 이동. 기준이 될 부모태그에는 무조건 position:relative;해줘야함 position:fixed; 네비게이션 만들어보기 position:sticky; See the Pen WNwjmYO by sowon-dev (@gracehopperdev) on CodePen.","link":"/2020/08/27/200828cssPosition/"},{"title":"Oracle DB구조3 : Instance의 Background process","text":"오라클 데이터베이스 구조 오라클DB는 크게 인스턴스(SGA 메모리구조와 백그라운드 프로세스와 데이터베이스로 나뉜다. Background process Parameterfile에 optional background process를 키고 끄는 걸 명령한다 block종류 clean block : 디스크(= DB)에서 가져 온 block중에 안의 내용이 하나도 안 바뀐 것 안의 내용이 바뀌지 않았으므로 다시 디스크(= DB)에 저장할 필요가 없다. dirty block : 디스크(= DB)에서 가져 온 block중에 안의 내용을 덮어써서 변경된 것 PMON 프로세스 모니터 역할 : User process를 주시함 User proc fail시(비정상적인 접속종료) 진행하던 트랜잭션 롤백 및 선점하고 있던 자원과 lock을 해제함 SMON 시스템 모니터 역할 : Instance를 주시함 Instance fail(= DB 비정삭적인 종료) 후 DB 재시작될 때 DB동기화를 시켜줌 DBWR DB buffer cache의 Dirty block을 datafile로 기록함 Dirty block : 변경된 block 체크포인트 발생시 기록함, 오라클이 내부적으로 알아서 체크포인트를 발생시킴. LGWR commit이 발생될 때 redo log buffer의 로그정보(= redo data)를 redo log file로 기록함 DB buffer cache에는 dirty block이 그대로 남아있음 -&gt; dirty block을 모아서 한 꺼번에 체크포인트 발생시 datafiles로 기록됨. 그전까지는 계속 db buffer cache에 dirty block이 존재함. CKPT 체크포인트 발생시 DBWR에게 알려줌 DBWR기록 후 datafiles 헤더와 controlfile에 마지막 체크포인트 번호를 갱신함 ARC(option) Archive log mode인 경우 활성화 Rodelogfile에 로그 스위치(logswitch)발생 시 offline 복사본( Archived log file)을 생성함.","link":"/2020/08/30/200831dbi/"},{"title":"Servlet게시판1: 기초","text":"web.xml코드 추가 123456789&lt;!-- Model2 게시판 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;BoardFrontController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itwillbs.board.action.BoardFrontController&lt;/servlet-class&gt; &lt;!-- 컨트롤로 주소와 동일하게 --&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;BoardFrontController&lt;/servlet-name&gt; &lt;url-pattern&gt;*.bo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; src폴더아래에 새로운 패키지와 BoardFrontController.java생성 extends HttpServlet상속을 해야 컨트롤러의 역할이 가능하다. 상속하지않으면 클래스명만 controller일 뿐 그냥 일반 클래스임. doGet(), doPost() 오버라이딩 주소 매핑 주소비교 후 처리 페이이지이동 : True면 sendRedirect이동방식, False면 forward이동 방식 true면 sendRedirect방식으로 이동 사용처: 주소와 화면의 전환이 동시에 일어날때 (가상주소 .bo -&gt; 가상주소로 .bo) false면 forward방식으로 이동 사용처: 주소는 그대로인데 화면이 바뀔때 (가상주소 .bo에서 request객체정보를 가지고 이동하면서 .jsp를 보여줌) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class BoardFrontController extends HttpServlet{ // 일반 클래스를 서블릿을 상속해서 컨트롤러 역활 할수있도록 설정 protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"doProcess() 호출 (페이지 GET/POST방식 모두 사용호출)\"); //1. 주소 매핑 System.out.println(\"--------------@ 주소 매핑 @-------------\"); // requestURI : /Model2JSP7/test.me // 프로젝트명 + 주소 String requestURI = request.getRequestURI(); System.out.println(\" requestURI : \" + requestURI); // contextPath : /Model2JSP7 // 프로젝트명 String contextPath = request.getContextPath(); System.out.println(\" contextPath : \" + contextPath); // 가상주소 // /test.me String command = requestURI.substring(contextPath.length()); System.out.println(\" command(가상주소) : \" + command); //2. 주소비교 후 처리 System.out.println(\"--------------@ 주소 비교 후 처리 @-------------\"); Action action = null; ActionForward forward = null; }//end of 주소비교후처리(command) //3. 페이이지이동 System.out.println(\"-----------------@ 페이지 이동 @--------------\"); if(forward != null){ // 이동할 정보(setPath과setRedirect)가 있는 경우 if(forward.isRedirect()){ //True면 sendRedirect이동방식, False면 forward이동 방식 //true면 sendRedirect방식으로 이동 //사용처: 주소와 화면의 전환이 동시에 일어날때 (가상주소 `.bo` -&gt; 가상주소로 `.bo`) System.out.println(\"컨트롤러: \"+forward.getPath()+\"로 이동(sendRedirect이동방식)\"); response.sendRedirect(forward.getPath()); }else{ //false면 forward방식으로 이동 //사용처: 주소는 그대로인데 화면이 바뀔때 (가상주소 `.bo`에서 request객체정보를 가지고 이동하면서 `.jsp`를 보여줌) //RequestDispatcher dis = new RequestDispatcher(forward.getPath()); 인터페이스이므로 new연산자를 이용한 객체생성 불가 System.out.println(\"컨트롤러: \"+forward.getPath()+\"로 이동(forward이동방식)\"); RequestDispatcher dis = request.getRequestDispatcher(forward.getPath()); dis.forward(request, response); } } }//end of doProcess @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet호출\"); doProcess(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost호출\"); doProcess(req, resp); }} ActionForward.java 생성 sendRedirect 이동방식 : 주소와 화면의 전환이 동시에 일어날때 (가상주소 -&gt; 가상주소로 ) forward 이동방식 : 주소는 그대로인데 화면이 바뀔때 (가상주소에서 jsp보여줌) 1234567891011121314151617181920212223242526272829public class ActionForward { //1.외부접근 못하도록 이동할 페이지와 이동할 방식 멤버변수 생성 private String path; private boolean isRedirect; // true면 sendRedirect방식으로 이동 //사용처: 주소와 화면의 전환이 동시에 일어날때 (가상주소 -&gt; 가상주소로 ) // false면 forward방식으로 이동 //사용처: 주소는 그대로인데 화면이 바뀔때 (가상주소에서 jsp보여줌) //2. getter setter생성 public String getPath() { return path; } public void setPath(String path) { this.path = path; } public boolean isRedirect() { return isRedirect; } public void setRedirect(boolean isRedirect) { this.isRedirect = isRedirect; } //3.toString @Override public String toString() { return \"ActionForward [path=\" + path + \", isRedirect=\" + isRedirect + \"]\"; }} Action.java생성1234567public interface Action { //상수, 추상메서드 사용가능 //1. 추상 메서드 작성 public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception; }//end of interface BoardDTO.java 생성 BoardBean.java 생성 대신 BoardBean.java 생성 DTO(Data Transfer Object) 데이터 전송 객체 DTO = bean = VO 동일한 역할 JavaBeans 규칙을 따름 DB에 정보를 가진 객체 1234567891011121314151617181920212223242526272829303132//1번규칙만족 : 클래스는 publicpublic class BoardDTO { //2번규칙만족 : 멤버변수선언 private private int bno; private String name; private String pw; private String subject; private String content; private int readcount; private int re_ref; private int re_lev; private int re_seq; private Date date; private String file; private String ip; //4번규칙만족 : 기본생성자존재하지만 생략됨 //public BoardBean(){} //3번규칙만족 : 멤버변수마다 별도의 get/set메소드가 존재해야한다. public int getBno() { return bno; } (중략) //5. toString() @Override public String toString() { return \"BoardBean [bno=\" + bno + \", name=\" + name + \", pw=\" + pw + \", subject=\" + subject + \", content=\" + content + \", readcount=\" + readcount + \", re_ref=\" + re_ref + \", re_lev=\" + re_lev + \", re_seq=\" + re_seq + \", date=\" + date + \", file=\" + file + \", ip=\" + ip + \"]\"; }} BoardDAO.java 생성 DB연결 메서드 생성 자원해제 메서드 생성 1234567891011121314151617181920212223242526public class BoardDAO { Connection con = null; String sql = \"\"; PreparedStatement pstmt = null; ResultSet rs = null; //디비연결 private void getCon() throws Exception{ Context init = new InitialContext(); //업캐스팅 // 고정문구\"java:comp/env/다른문구context파일의 name값입력\" DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/mysqlDB\"); con = ds.getConnection(); System.out.println(\"DAO: 디비연결성공\"+con); }//getCon닫음 //자원해제 메서드 구현 public void closeDB(){ try{ if(rs != null) rs.close(); if(pstmt != null) pstmt.close(); if(con != null) con.close(); } catch (SQLException e) { e.printStackTrace(); } }//closeDB닫음}","link":"/2020/08/30/200831jspi2/"},{"title":"Servlet쇼핑몰7: 회원전체목록조회(관리자기능)","text":"main.jsp 생성 location.href='memberList.jsp' 에서 location.href='./MemberList.me'로 변경 123456789101112131415161718192021222324252627&lt;%//1.한글처리, 파라미터 request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅String name = request.getParameter(\"name\");//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동. 가상주소로 이동if(id == null){ response.sendRedirect(\"./MemberLogin.me\");}%&gt;&lt;h3&gt;아이디: &lt;%=id %&gt;&lt;/h3&gt;&lt;h3&gt;아이디(session-EL표현식) : ${ sessionScope.id } &lt;/h3&gt;&lt;input type=\"button\" value=\"ITWILL게시판가기\" class=\"btn\" onclick=\"location.href='../board/boardList.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보조회\" class=\"btn\" onclick=\"location.href='./MemberInfo.me'\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" class=\"btn\" onclick=\"location.href='./MemberUpdate.me'\"&gt;&lt;input type=\"button\" value=\"로그아웃\" class=\"btn\" onclick=\"location.href='./MemberLogout.me'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" class=\"btn\" onclick=\"location.href='./MemberDelete.me'\"&gt;&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id != null){ if(id.equals(\"admin\")){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" class=\"btn\" onclick=\"location.href='./MemberList.me'\"&gt;&lt;% }}%&gt; MemberFrontController.java의 doProcess()메서드 추가 코드 작성1234567891011 //16. 회원전체목록 조회 //trim() - 문자열데이터의 앞뒤공백제거}else if(command.trim().equals(\"/MemberList.me\")){ System.out.println(\"@@@@ Controller : 가상주소 /MemberList.me 실제주소: ./member/MemberList.jsp\"); action = new MemberListAction(); try{ forward = action.execute(req, resp); } catch(Exception e){ e.printStackTrace(); }} memberList.jsp 생성1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%//1. 로그인세션제어(관리자는 제외)String id = (String) session.getAttribute(\"id\");//다운캐스팅if(id == null || !id.equals(\"admin\")){ //순서바뀌면 에러발생하므로 항상 null 먼저 비교할 것 response.sendRedirect(\"./LoginForm.me\");}//2. 회원정보를 저장//request.setAttribute(\"memberList\", memberList);List&lt;MemberBean&gt; memberList = (List&lt;MemberBean&gt;)request.getAttribute(\"memberList\");//다운캐스팅%&gt;&lt;h2&gt;마이페이지&lt;/h2&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;나이&lt;/td&gt; &lt;td&gt;성별&lt;/td&gt; &lt;td&gt;이메일&lt;/td&gt; &lt;td&gt;회원가입일&lt;/td&gt; &lt;/tr&gt; &lt;%//반복문 //ArrayList는 가변배열이므로 length가 없고 size가 존재한다. //size()메서드는 배열의 요소의 갯수를 리턴 for(int i=0;i&lt;memberList.size(); i++){ MemberBean mb = (MemberBean) memberList.get(i); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=mb.getId() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getPw() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getAge() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getGender() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getEmail() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=mb.getReg_date() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt;&lt;/table&gt;&lt;input type=\"button\" value=\"메인으로\" class=\"btn\" onclick=\"location.href='./Main.me'\"&gt; el표현식으로 위의 출력값을 나타내보자. 자바코드는 컴파일이 필요하지만 el태그가 훨씬 코드가 간결해진다 123&lt;c:forEach items=\"${memberList}\" var=\"mb\"&gt; &lt;c:out value=\"${mb.email}\"&gt;&lt;/c:out&gt;&lt;/c:forEach&gt; --%&gt; 위의 자바코드를 el태그로 변경. 1234567891011121314151617181920212223242526272829303132333435363738&lt;%//1. 로그인세션제어(관리자는 제외)String id = (String) session.getAttribute(\"id\");//다운캐스팅if(id == null || !id.equals(\"admin\")){ //순서바뀌면 에러발생하므로 항상 null 먼저 비교할 것 response.sendRedirect(\"./LoginForm.me\");}//2. 회원정보를 저장//request.setAttribute(\"memberList\", memberList);List&lt;MemberBean&gt; memberList = (List&lt;MemberBean&gt;)request.getAttribute(\"memberList\"); //다운캐스팅%&gt;&lt;h2 style=\"text-align: center;\"&gt;회원목록&lt;/h2&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;나이&lt;/td&gt; &lt;td&gt;성별&lt;/td&gt; &lt;td&gt;이메일&lt;/td&gt; &lt;td&gt;회원가입일&lt;/td&gt; &lt;/tr&gt;&lt;c:forEach items=\"${memberList}\" var=\"mb\"&gt; &lt;tr&gt; &lt;td&gt;&lt;c:out value=\"${mb.email}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.pw}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.name}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.age}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.gender}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.email}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.reg_date}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;input type=\"button\" value=\"메인으로\" class=\"btn\" onclick=\"location.href='./Main.me'\"&gt; MemberListAction.java 생성 trim() : 가져 온 문자열 데이터의 앞뒤 공백을 제거 -&gt; 정확도 향상 123456789101112131415161718192021222324252627282930public class MemberListAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"@@@@ Action: MemberListAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2. 세션제어 ( 로그인 여부, 관리자인지 판단 ) HttpSession session = req.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null || id.equals(\"admin\")){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } //3. DB객체처리 -&gt; getMemberList()메서드 구현 MemberDAO mdao = new MemberDAO(); List&lt;MemberBean&gt; memberList = mdao.getMemberList(); //4. 회원정보를 저장 req.setAttribute(\"memberList\", memberList); //5. jsp(view) 페이지로 이동 forward.setPath(\"./member/memberList.jsp\"); forward.setRedirect(false); //forwarding방식 -false return forward; }} MemberDAO.java에 getMemberList()메서드 추가 코드 작성123456789101112131415161718192021222324252627282930//8.회원목록//가능하면 list사용할때 데이터타입 명시하는 것이 좋다public List&lt;MemberBean&gt; getMemberList(){ List&lt;MemberBean&gt; memberList = new ArrayList&lt;MemberBean&gt;(); //업캐스팅 try{ con = getCon(); sql = \"select * from itwill_member\"; pstmt = con.prepareStatement(sql); //8-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); while(rs.next()){ MemberBean mb = new MemberBean(); mb.setAge(rs.getInt(\"age\")); mb.setEmail(rs.getString(\"email\")); mb.setId(rs.getString(\"id\")); mb.setName(rs.getString(\"name\")); mb.setPw(rs.getString(\"pw\")); mb.setGender(rs.getString(\"gender\")); mb.setReg_date(rs.getTimestamp(\"reg_date\")); //리스트 한 칸에 회원 1명의 정보 저장 memberList.add(mb); } System.out.println(\"memberList검색완료\"); }catch(Exception e){ e.printStackTrace(); } return memberList;}//end of getMemberList method","link":"/2020/08/30/200831jspi/"},{"title":"Oracle DB구조4 : 구조 완벽정리, 상황별 오라클 DB 순서","text":"오라클 데이터베이스 구조 정리 오라클DB는 크게 인스턴스(SGA 메모리구조와 백그라운드 프로세스와 데이터베이스로 나뉜다. 상황별 오라클 DB 순서 select구문 : 핑크색 user가 select구문 입력 library cache 로 감 data dictionary cache DB buffer cache 출력값 user에게 출력 update등 DML구문 : 주황색 user가 select구문 입력 library cache 로 감 data dictionary cache DB buffer cache redo log buffer 출력값 user에게 출력 commit명령어 : 파란색 user가 commit명령어를 입력 Redo log buffer의 로그정보를 LGWR가 Redologfiles에 기록 user에게 commit 완료되었다고 알려줌. At the moment, DB buffer cache에는 dirty block이 그대로 남아있음. 어느정도 DB buffer cache에 dirty block이 차면 오라클이 내부적으로 체크포인트 실행 CKPT가 DBWR에게 알려주고 DBWR에 기록 후 datafiles 헤더와 controlfile에 마지막 체크포인트 번호를 갱신함 DBWR을 통해 datafiles에 실제 data기록 redologfiles중 하나가 다 찬 경우 : 연두색 redologfiles은 순환형으로 관리된다. 한 개가 꽉 찬 경우 어떻게 될까? 로그스위치 발생시 ARC에 Redo log file의 오프라인 복사본을 생성하여 Archived log files에 저장","link":"/2020/08/31/200901dbi2/"},{"title":"Servlet게시판2: 게시판 글쓰기","text":"BoardFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 글 저장구조 : .jsp(뷰) -&gt; servlet(컨트롤러) -&gt; .java(모델) -&gt; DB로 이동 .jsp(뷰) -&gt; DB 바로 갈수 없으므로 .java(모델)가 필요하다. .jsp(뷰) -&gt; .java(모델) 바로 갈 수 없으므로 servlet이 필요하다. 1234567891011121314151617181920212223242526272829//2. 주소비교 후 처리System.out.println(\"--------------@ 주소 비교 후 처리 @-------------\");Action action = null;ActionForward forward = null;//2-1. 글쓰기 동작 : 글 입력 + DB저장if(command.equals(\"/BoardWrite.bo\")){ System.out.println(\"컨트롤러: BoardWrite.bo주소요청\"); //ActionForward 객체생성되면 2가지 정보를 저장할 수 있음 =&gt;setPath(), setRedirect() //ActionForward 객체를 생성한다고 해서 바로 페이지이동이 가능하지않다. 이 객체는 이동할 정보만 가지고 있다. forward = new ActionForward(); forward.setPath(\"./board/writeForm.jsp\"); forward.setRedirect(false); //주소는 `*.bo` 화면은 `.jsp` System.out.println(\"컨트롤러:./board/writeForm.jsp로 이동준비완료\");}else if(command.equals(\"/BoardWriteAction.bo\")){ //글 하려면 : .jsp(뷰) -&gt; servlet(컨트롤러) -&gt; .java(모델) -&gt; DB로 이동 해야한다 //BoardWriteAction 생성 아래 두가지 방식 try{ //1.forward = new BoardWriteAction().execute(req, resp); //가바지라서 메모리에서 사라지기때문에 필요할때마다 삭제되어버려서 사용하려면다시 만들기를 반복해야한다 //따라서 아래 2번째방법 주로 사용 //2. action = new BoardWriteAction(); forward = action.execute(request, response); } catch(Exception e){ e.printStackTrace(); }} writeForm.jsp 생성1234567891011121314151617&lt;%System.out.println(\"뷰: .jsp페이지로 이동완료\");String id = (String) session.getAttribute(\"id\");%&gt;&lt;fieldset&gt;&lt;legend&gt;게시판 글쓰기&lt;/legend&gt; &lt;form action=\"./BoardWriteAction.bo\" method=\"post\" name=\"fr\"&gt; 글쓴이 : &lt;input type=\"text\" name=\"name\" required&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\" required&gt;&lt;br&gt; 제목 : &lt;input type=\"text\" name=\"subject\" maxlength=\"15\" required&gt;&lt;br&gt; 내용 : &lt;br&gt; &lt;textarea rows=\"10\" cols=\"35\" name=\"content\" placeholder=\"여기에 작성해주세요\" required&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"글등록\" class=\"btn\"&gt; &lt;button type=\"reset\" class=\"btn\"&gt;초기화&lt;/button&gt; &lt;input type=\"button\" value=\"목록으로\" class=\"btn\" onclick=\"location.href='.//BoardList.bo'\"&gt; &lt;/form&gt;&lt;/fieldset&gt; BoardWriteAction.java 생성1234567891011121314151617181920212223242526272829303132333435public class BoardWriteAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"모델: BoardWriteAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2.전달되는 파라미터 정보저장 -&gt;MemberDTO생성 BoardDTO bdto = new BoardDTO(); bdto.setName(req.getParameter(\"name\")); bdto.setPw(req.getParameter(\"pw\")); bdto.setSubject(req.getParameter(\"subject\")); bdto.setContent(req.getParameter(\"content\")); //추가로 ip정보 가져오기 bdto.setIp(req.getRemoteAddr()); //3.BoardDAO객체생성 BoardDAO bdao = new BoardDAO(); int result = bdao.insertBoard(bdto); //4페이지 이동 ActionForward forward = new ActionForward(); if(result == 1){ // 글하나 작성완료 forward.setPath(\"./BoardList.bo\"); forward.setRedirect(true); }else{ //에러 상황( 자바스크립트 / 페이지 이동 ) forward.setPath(\"./Main.me\"); forward.setRedirect(true); } return forward; }} BoardDAO.java에 insertBoard()메서드 추가 코드 작성12345678910111213141516171819202122232425262728293031323334353637383940414243//글쓰기public int insertBoard(BoardDTO bdto){ int result = 0; int bno = 0; try { getCon(); // con 인스턴스 변수에 저장완료 // 글번호 계산 sql = \"select max(bno) from itwill_board\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); if(rs.next()){ bno = rs.getInt(1)+1; //인덱스 사용 호출 //rs.getInt(\"max(bno)\"); // 컬럼명 사용 호출 } System.out.println(\"DAO : 글번호 \"+bno); sql =\"insert into itwill_board(bno,name,passwd,subject,content,\" + \"readcount,re_ref,re_lev,re_seq,date,file,ip) \" + \"values(?,?,?,?,?,\" + \"?,?,?,?,now(),\" + \"?,?)\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); pstmt.setString(2, bdto.getName()); pstmt.setString(3, bdto.getPw()); pstmt.setString(4, bdto.getSubject()); pstmt.setString(5, bdto.getContent()); pstmt.setInt(6, 0); //조회수 0 pstmt.setInt(7, bno); // 일반글 == re_ref pstmt.setInt(8, 0); // 일반글 lev = 0 pstmt.setInt(9, 0); // 일반글 seq = 0 pstmt.setString(10, bdto.getIp()); pstmt.setString(11, bdto.getFile()); // 실행 result = pstmt.executeUpdate(); System.out.println(\"DAO : 글쓰기 완료! \"); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return result;}//end of insertBoard","link":"/2020/08/31/200901jspi/"},{"title":"Servlet게시판4: 글 내용보기","text":"content.jsp 코드 변경 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;%//전달받은 정보를 저장BoardDTO bdto = (BoardDTO) request.getAttribute(\"bdto\"); //object -다운캐스팅-&gt; BoardDTOString pageNum = (String) request.getAttribute(\"pageNum\"); //object -다운캐스팅-&gt; String%&gt;&lt;fieldset&gt;&lt;legend&gt;글 내용 보기&lt;/legend&gt; &lt;table border=\"solid,1px\"&gt; &lt;tr&gt; &lt;th&gt;글번호&lt;/th&gt; &lt;td&gt;&lt;%=bdto.getBno()%&gt;&lt;/td&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;td&gt;&lt;%=bdto.getReadcount()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;td&gt;&lt;%=bdto.getName()%&gt;&lt;/td&gt; &lt;th&gt;작성일&lt;/th&gt; &lt;td&gt;&lt;%=bdto.getDate()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;제목&lt;/th&gt; &lt;td colspan=\"3\"&gt;&lt;%=bdto.getSubject()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;첨부파일&lt;/th&gt; &lt;td colspan=\"3\"&gt;&lt;a href=\"D:\\upfile\\&lt;%=bdto.getFile()%&gt;\"&gt;&lt;%=bdto.getFile() %&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;내용&lt;/th&gt; &lt;td colspan=\"3\" height=\"300px\"&gt;&lt;%=bdto.getContent()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"4\" style=\"text-align:center\"&gt; &lt;% //현재페이지에 로그인 정보가 없거나 글쓴이 이름과 아이디가 다를 경우 수정,삭제버튼을 숨긴다 //1.세션값 가져오기 //String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅 //2. 아이디가 존재하면서 이름과 아이디가 같은 경우 //if( id != null &amp;&amp; id.equals(bdto.getName())){ %&gt; &lt;input type=\"button\" value=\"글수정\" class=\"btn\" onclick=\"location.href='./BoardUpdate.bo?bno=&lt;%=bdto.getBno()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;'\"&gt; &lt;input type=\"button\" value=\"글삭제\" class=\"btn\" onclick=\"location.href='./BoardDelete.bo?bno=&lt;%=bdto.getBno()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;'\"&gt; &lt;input type=\"button\" value=\"답글쓰기\" class=\"btn\" onclick=\"location.href='./BoardReWrite.bo?bno=&lt;%=bdto.getBno()%&gt;&amp;re_ref=&lt;%=bdto.getRe_ref() %&gt;&amp;re_lev=&lt;%=bdto.getRe_lev()%&gt;&amp;re_seq=&lt;%=bdto.getRe_seq()%&gt;'\"&gt; &lt;% //} %&gt; &lt;input type=\"button\" value=\"목록으로\" class=\"btn\" onclick=\"location.href='./BoardList.bo?pageNum=&lt;%=pageNum%&gt;'\"&gt; &lt;!-- location.href='boardList.jsp만 하면 5페이지보고있다가 다시 1페이지로 돌아가버린다 이때 historyback하면 조회수가 올라가지않는다. 따라서 pageNum을 가져와서 사용하면된다 --&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/fieldset&gt; BoardFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가12345678910 //content보기}else if(command.equals(\"./BoardContent.bo\")){ System.out.println(\"컨트롤러 : BoardContent객체 생성 execute() 호출\"); action = new BoardContentAction(); try{ forward = action.execute(request, response); }catch(Exception e){ e.printStackTrace(); }} BoardContentAction.java 생성1234567891011121314151617181920212223242526272829303132public class BoardContentAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"모델: BoardContentAction안의 execute() 실행됨\"); // 한글처리(post방식 전달일때 꼭 처리해줘야한다. get방식일때는 한글이 깨지지않는다) // 여기는 a태그를 타고 들어왔기때문에 get방식이다. 한글처리 안해도 됨 req.setCharacterEncoding(\"UTF-8\"); // 1. 전달받은 데이터 저장(bno, pageNum) int bno = Integer.parseInt(req.getParameter(\"bno\")); String pageNum = req.getParameter(\"pageNum\"); //2. BoardDAO 객체 생성 BoardDAO bdao = new BoardDAO(); //3.조회수 1증가 bdao.updateReadCount(bno); //4.특정 번호에 해당하는 글 정보 가져오기 BoardDTO bdto = bdao.getBoard(bno); //5.리퀘스트영역에 정보저장 req.setAttribute(\"bdto\", bdto); //pageNum도 함께 전달해야한다 req.setAttribute(\"pageNum\", pageNum); //6. 화면출력하는 뷰페이지(.jsp)로 전달 ActionForward forward = new ActionForward(); forward.setPath(\"./baord/content.jsp\"); forward.setRedirect(false); return forward; }} BoardDAO.java에 updateReadCount()메서드 작성123456789101112131415//특정글만 조회수 1 증가public void updateReadCount(int bno){ try { getCon(); sql=\"update itwill_board set readcount=readcount+1 where bno=?\"; pstmt.setInt(1, bno); pstmt = con.prepareStatement(sql); pstmt.executeUpdate(); System.out.println(\"조회수1증가\"); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); }} BoardDAO.java에 getBoard()메서드 작성12345678910111213141516171819202122232425262728293031323334//글내용보기public BoardDTO getBoard(int bno) { BoardDTO bdto = null; try { getCon(); sql =\"select * from itwill_board where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); rs = pstmt.executeQuery(); if(rs.next()){ bdto = new BoardDTO(); bdto.setBno(rs.getInt(\"bno\")); bdto.setContent(rs.getString(\"content\")); bdto.setDate(rs.getDate(\"date\")); bdto.setFile(rs.getString(\"file\")); bdto.setIp(rs.getString(\"ip\")); bdto.setName(rs.getString(\"name\")); bdto.setPw(rs.getString(\"pw\")); bdto.setRe_lev(rs.getInt(\"re_lev\")); bdto.setRe_ref(rs.getInt(\"re_ref\")); bdto.setRe_seq(rs.getInt(\"re_seq\")); bdto.setReadcount(rs.getInt(\"readcount\")); bdto.setSubject(rs.getString(\"subject\")); } System.out.println(\"DAO: 글정보저장완료\"); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return bdto;}","link":"/2020/09/02/200903jspi/"},{"title":"Servlet게시판5: 글 수정하기","text":"BoardFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 12345678910111213141516171819 //게시글 수정}else if(command.equals(\"/BoardUpdate.bo\")){ System.out.println(\"컨트롤러 : BoardUpdate객체 생성 execute() 호출\"); action = new BoardUpdateAction(); try{ forward = action.execute(request, response); }catch(Exception e){ e.printStackTrace(); }}else if(command.equals(\"/BoardUpdateProAction.bo\")){ System.out.println(\"C : /BoardUpdateProAction.bo 호출\"); System.out.println(\"C : .jsp -&gt; .bo\"); // BoardUpdateProAction 객체 생성 action = new BoardUpdateProAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); } BoardUpdateAction.java 생성12345678910111213141516171819202122232425262728public class BoardUpdateAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"모델: BoardUpdateAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2.전달되는 파라미터 정보저장 int bno = Integer.parseInt(req.getParameter(\"bno\")); String pageNum = (String) req.getAttribute(\"pageNum\"); //3.DAO객체생성 -&gt; bno 해당되는 정보 가져오기 BoardDAO bdao = new BoardDAO(); BoardDTO bdto = bdao.getBoard(bno); //5.리퀘스트영역에 정보저장 req.setAttribute(\"bdto\", bdto); //6. 화면출력하는 뷰페이지(.jsp)로 전달 (get방식) ActionForward forward = new ActionForward(); forward.setPath(\"./board/updateForm.jsp?pageNum=\"+pageNum); forward.setRedirect(false); return forward; }} BoardUpdateProAction.java생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class BoardUpdateProAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : BoardUpdateProAction_execute 호출\"); // 한글처리 request.setCharacterEncoding(\"UTF-8\"); // 전달되는값들 저장 (이름,비밀번호,제목, 내용, bno,pageNum) String pageNum = request.getParameter(\"pageNum\"); // BoardDTO 객체 생성 BoardDTO bdto = new BoardDTO(); bdto.setBno(Integer.parseInt(request.getParameter(\"bno\"))); bdto.setName(request.getParameter(\"name\")); bdto.setPw(request.getParameter(\"pw\")); bdto.setSubject(request.getParameter(\"subject\")); bdto.setContent(request.getParameter(\"content\")); // BoardDAO 객체 생성 -&gt; 정보 수정 메서드 updateBoard(dto) BoardDAO bdao = new BoardDAO(); int result = bdao.updateBoard(bdto); System.out.println(\"M : DB 처리 완료후 결과 -&gt; \"+result); // 결과를 리턴받아서 처리 (1, 0 ,-1) // 페이지이동 (js) // 페이지 출력준비 response.setContentType(\"text/html; charset=UTF-8\"); PrintWriter out = response.getWriter(); if(result == 0){ out.print(\"&lt;script&gt;\"); out.print(\" alert('비밀번호 오류');\"); out.print(\" history.back();\"); out.print(\"&lt;/script&gt;\"); out.close(); return null; }else if(result == -1){ out.print(\"&lt;script&gt;\"); out.print(\" alert('해당 글 없음!');\"); out.print(\" history.back();\"); out.print(\"&lt;/script&gt;\"); out.close(); return null; } out.print(\"&lt;script&gt;\"); out.print(\" alert('글 수정완료!');\"); out.print(\" location.href='./BoardList.bo?pageNum=\"+pageNum+\"';\"); out.print(\"&lt;/script&gt;\"); out.close(); return null; }} BoardDAO.java에 updateReadCount()메서드 작성123456789101112131415//특정글만 조회수 1 증가public void updateReadCount(int bno){ try { getCon(); sql=\"update itwill_board set readcount=readcount+1 where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); pstmt.executeUpdate(); System.out.println(\"DAO: 조회수1증가\"); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); }} BoardDAO.java에 getBoard()메서드 작성12345678910111213141516171819202122232425262728293031323334353637383940// getBoard(bno)public BoardDTO getBoard(int bno){ BoardDTO bdto = null; try { getCon(); sql = \"select * from itwill_board where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); rs = pstmt.executeQuery(); if(rs.next()){ bdto = new BoardDTO(); bdto.setBno(rs.getInt(\"bno\")); bdto.setContent(rs.getString(\"content\")); bdto.setDate(rs.getDate(\"date\")); bdto.setFile(rs.getString(\"file\")); bdto.setIp(rs.getString(\"ip\")); bdto.setName(rs.getString(\"name\")); bdto.setPw(rs.getString(\"pw\")); bdto.setRe_lev(rs.getInt(\"re_lev\")); bdto.setRe_ref(rs.getInt(\"re_ref\")); bdto.setRe_seq(rs.getInt(\"re_seq\")); bdto.setReadcount(rs.getInt(\"readcount\")); bdto.setSubject(rs.getString(\"subject\")); } System.out.println(\"DAO : 글정보 저장완료!!\"); } catch (Exception e) { e.printStackTrace(); }finally { closeDB(); } return bdto;}// getBoard(bno) updateForm.jsp 생성 hidden타입 : 화면에는 보이지않지만 데이터 저장 및 전달이 가능해서 데이터 이동용으로 주로 사용 1234567891011121314151617&lt;%String pageNum = (String) request.getParameter(\"pageNum\");BoardDTO bdto = (BoardDTO) request.getAttribute(\"bdto\");%&gt;&lt;fieldset&gt;&lt;legend&gt;게시판 글쓰기&lt;/legend&gt; &lt;form action=\"./BoardUpdateProAction.bo?pageNum=&lt;%=pageNum %&gt;\" method=\"post\" name=\"fr\"&gt; &lt;input type=\"hidden\" name=\"bno\" value=\"&lt;%=bdto.getBno() %&gt;\"&gt; 글쓴이 : &lt;input type=\"text\" name=\"name\" required value=\"&lt;%=bdto.getName() %&gt;\"&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\" required &gt;&lt;br&gt; 제목 : &lt;input type=\"text\" name=\"subject\" required value=\"&lt;%=bdto.getSubject() %&gt;\"&gt;&lt;br&gt; 내용 : &lt;br&gt; &lt;textarea rows=\"10\" cols=\"35\" name=\"content\" required&gt;&lt;%=bdto.getContent() %&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"글 수정하기\" class=\"btn\"&gt; &lt;input type=\"button\" value=\"수정취소\" class=\"btn\" onclick=\"location.href='./BoardList.bo'\"&gt; &lt;/form&gt;&lt;/fieldset&gt;","link":"/2020/09/02/200903jspi2/"},{"title":"Servlet게시판6: 글 삭제하기","text":"BoardFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 1234567891011121314 //글삭제}else if(command.equals(\"/BoardDelete.bo\")){ System.out.println(\"C : /BoardDelete.bo 호출\"); System.out.println(\"C : .jsp -&gt; .bo\"); //페이지이동 forward = new ActionForward(); forward.setPath(\"./board/deleteForm.jsp\"); forward.setRedirect(false);}else if(command.equals(\"/BoardDeleteAction.bo\")){ System.out.println(\"C : /BoardDeleteAction.bo 호출\"); action = new BoardDeleteAction(); try{ forward = action.execute(request, response); }catch(Exception e){e.printStackTrace(); }} BoardDeleteAction.java 생성1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BoardDeleteAction implements Action{ @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : BoardListAction_execute() 호출\"); //전달정보 저장 int bno = Integer.parseInt(request.getParameter(\"bno\")); String pageNum = request.getParameter(\"pageNum\"); String pw = request.getParameter(\"pw\"); //BoardDAO객체생성 deleteBoard BoardDAO bdao = new BoardDAO(); int result = bdao.deleteBoard(bno, pw); System.out.println(\"M: DB처리완료 -&gt;\"+result); //처리결과를 js사용하여 페이지 이동 //인코딩 response.setContentType(\"text/html; charset=UTF-8\"); //출력통로생성 PrintWriter out = response.getWriter(); if(result == 0){ out.print(\"&lt;script&gt;\"); out.print(\" alert('비밀번호 오류');\"); out.print(\" history.back();\"); out.print(\"&lt;/script&gt;\"); out.close(); return null; }else if(result == -1){ out.print(\"&lt;script&gt;\"); out.print(\" alert('해당 글 없음');\"); out.print(\" history.back();\"); out.print(\"&lt;/script&gt;\"); out.close(); return null; } //result == 1인경우 out.print(\"&lt;script&gt;\"); out.print(\" alert('글 삭제완료');\"); out.print(\" location.href='./BoardList.bo?pageNum=\"+pageNum+\"';\"); out.print(\"&lt;/script&gt;\"); out.close(); return null; } } BoardDAO.java에 deleteBoard()메서드 작성123456789101112131415161718192021222324252627282930313233//글삭제구현public int deleteBoard(int bno, String pw) { int result = -1; try{ getCon(); // sql (select) sql = \"select pw from itwill_board where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); rs = pstmt.executeQuery(); if(rs.next()){ if(pw.equals(rs.getString(\"pw\"))){ sql = \"delete from itwill_board where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); pstmt.executeUpdate(); result = 1; System.out.println(\"글삭제 성공: \"+result); }else{ result = 0; System.out.println(\"글삭제 중 비번불일치: \"+result); } }else{ result = -1; System.out.println(\"글삭제 중 select오류\"+result); } }catch(Exception e){ e.printStackTrace(); }finally{ closeDB(); } return result;}//end of deleteBoard() deleteForm.jsp 생성123456789101112131415161718&lt;%//1. 한글처리request.setCharacterEncoding(\"UTF-8\");//2. 파라미터저장int bno = Integer.parseInt(request.getParameter(\"bno\"));String pageNum = request.getParameter(\"pageNum\");%&gt;&lt;fieldset&gt; &lt;legend&gt;게시글 삭제&lt;/legend&gt; &lt;form action=\"./BoardDeleteAction.bo?pageNum=&lt;%=pageNum %&gt;\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"bno\" value=\"&lt;%=bno%&gt;\"&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"글삭제하기\" class=\"btn\"&gt; &lt;input type=\"button\" value=\"뒤로가기\" class=\"btn\" onclick=\"history.back()\"&gt; &lt;/form&gt;&lt;/fieldset&gt;","link":"/2020/09/06/200907jspi/"},{"title":"Servlet게시판7: 답글하기","text":"BoardFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 12345678910111213 //답글쓰기}else if(command.equals(\"/BoardReWrite.bo\")){ System.out.println(\"C : /BoardReWrite.bo 호출\"); //DB이동 X -&gt; 페이지이동 forward = new ActionForward(); forward.setPath(\"./board/reWriteForm.jsp\"); forward.setRedirect(false); }else if(command.equals(\"/BoardReWriteAction.bo\")){ System.out.println(\"C : /BoardReWriteAction.bo 호출\"); action = new BoardReWriteAction(); try{ forward = action.execute(request, response); }catch(Exception e){e.printStackTrace(); }} BoardReWriteAction.java 생성12345678910111213141516171819202122232425262728293031public class BoardReWriteAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"모델: BoardReWriteAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2.전달되는 파라미터 정보저장 -&gt;MemberDTO생성 BoardDTO bdto = new BoardDTO(); //hidden으로 가져온 거 저장 bdto.setBno(Integer.parseInt(req.getParameter(\"bno\"))); bdto.setRe_ref(Integer.parseInt(req.getParameter(\"re_ref\"))); bdto.setRe_lev(Integer.parseInt(req.getParameter(\"re_lev\"))); bdto.setRe_seq(Integer.parseInt(req.getParameter(\"re_seq\"))); //입력값 저장 bdto.setName(req.getParameter(\"name\")); bdto.setPw(req.getParameter(\"pw\")); bdto.setSubject(req.getParameter(\"subject\")); bdto.setContent(req.getParameter(\"content\")); //3.BoardDAO객체생성 BoardDAO bdao = new BoardDAO(); bdao.reInsertBoard(bdto); //4.페이지 이동 ActionForward forward = new ActionForward(); forward.setPath(\"./BoardList.bo\"); forward.setRedirect(true); return forward; }} BoardDAO.java에 reInsertBoard()메서드 작성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//답글쓰기public void reInsertBoard(BoardDTO bdto) { int result =-1; //1.지역변수생성 int num = 0; //2. 디비연결 try { getCon(); //sql(게시판의 글번호 중 최댓값 계산) &amp; pstmt //3. 답글번호 계산 sql = \"select max(bno) from itwill_board\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); if(rs.next()){ num = rs.getInt(1)+1; } System.out.println(\"답글 번호 : \"+num); //4. 답글 순서 재배치 //re_ref(같은 그룹기준)으로 re_seq값이 기존의 값보다 큰 값이 있을경우 re_seq값을 1증가시켜서 순서재배치 sql = \"update itwill_board set re_seq=re_seq+1 \" + \"where re_ref=? and re_seq&gt;?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bdto.getRe_ref()); pstmt.setInt(2, bdto.getRe_seq()); pstmt.executeUpdate(); //5. 답글 정보 저장 sql=\"insert into itwill_board \" + \"values(?,?,?,?,?\" + \",?,?,?,?,now()\" + \",?,?)\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, num);//bno는 가지고있는게 아니라 계산해서 만든것이므로 num사용 pstmt.setString(2, bdto.getName()); pstmt.setString(3, bdto.getPw()); pstmt.setString(4, bdto.getSubject()); pstmt.setString(5, bdto.getContent()); pstmt.setInt(6, bdto.getReadcount()); pstmt.setInt(7, bdto.getRe_ref()); //기존 원글의 그룹번호와 동일 pstmt.setInt(8, bdto.getRe_lev()+1); // 기존의 값 + 1 pstmt.setInt(9, bdto.getRe_seq()+1); // 기존의 값 + 1 pstmt.setString(10, bdto.getFile()); pstmt.setString(11, bdto.getIp()); pstmt.executeUpdate(); System.out.println(\"답글쓰기 성공\"); result = 1; } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } }//end of reInsertBoard() reWriteForm.jsp 생성 get방식으로 전달받은 파라미터들을 hidden타입 input태그를 이용하여 Action페이지에 post방식으로 전달해야한다. 123456789101112131415161718192021222324252627&lt;%System.out.println(\"뷰: .jsp페이지로 이동완료\");String id = (String) session.getAttribute(\"id\");//전달된 파라미터 저장int bno = Integer.parseInt(request.getParameter(\"bno\"));int re_ref = Integer.parseInt(request.getParameter(\"re_ref\"));int re_lev = Integer.parseInt(request.getParameter(\"re_lev\"));int re_seq = Integer.parseInt(request.getParameter(\"re_seq\"));%&gt;&lt;fieldset&gt;&lt;legend&gt;게시판 답글쓰기&lt;/legend&gt; &lt;form action=\"./BoardReWriteAction.bo\" method=\"post\" name=\"fr\"&gt; &lt;input type=\"hidden\" name=\"bno\" value=\"&lt;%=bno %&gt;\"&gt; &lt;input type=\"hidden\" name=\"re_ref\" value=\"&lt;%=re_ref %&gt;\"&gt; &lt;input type=\"hidden\" name=\"re_lev\" value=\"&lt;%=re_lev %&gt;\"&gt; &lt;input type=\"hidden\" name=\"re_seq\" value=\"&lt;%=re_seq %&gt;\"&gt; 글쓴이 : &lt;input type=\"text\" name=\"name\" required&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\" required&gt;&lt;br&gt; 제목 : &lt;input type=\"text\" name=\"subject\" maxlength=\"15\" value=\"[답글]\" &gt;&lt;br&gt; 내용 : &lt;br&gt; &lt;textarea rows=\"10\" cols=\"35\" name=\"content\" placeholder=\"여기에 작성해주세요\" &gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"답글등록\" class=\"btn\"&gt; &lt;button type=\"reset\" class=\"btn\"&gt;초기화&lt;/button&gt; &lt;input type=\"button\" value=\"목록으로\" class=\"btn\" onclick=\"location.href='./BoardList.bo'\"&gt; &lt;/form&gt;&lt;/fieldset&gt;","link":"/2020/09/06/200907jspi2/"},{"title":"Servlet게시판8: 파일업로드·파일보기","text":"BoardFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 12345678910111213 //파일업로드}else if(command.equals(\"/FileBoardWrite.bo\")){ System.out.println(\"C : /FileBoardWrite.bo 호출\"); //DB이동 X -&gt; 화면 먼저 보여줌.bo에서 .jsp로 페이지이동 forward = new ActionForward(); forward.setPath(\"./board/fwriteForm.jsp\"); forward.setRedirect(false); }else if(command.equals(\"/FileBoardWriteAction.bo\")){ System.out.println(\"C : /FileBoardWriteAction.bo 호출\"); action = new FileBoardWriteAction(); try{ forward = action.execute(request, response); }catch(Exception e){e.printStackTrace(); }} FileBoardWriteAction.java 생성 파일 업도르시 request.getRealPath(&quot;/upload&quot;)는 이제 deprecated -&gt; 실무에선 context에 있는 realpath를 사용함 request를 MultipartRequest로 바뀌었으니 MultipartRequest에 정보를 저장해야한다. BoardDAO객체생성 -&gt; insertBoard() 재사용 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class FileBoardWriteAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : FileBoardWriteAction의 execute()실행\"); //1. 파일업로드 (서버 : HDD) String realpath = request.getRealPath(\"/upload\"); //deprecated -&gt; 실무에선 context에 있는 realpath를 사용함 System.out.println(\"realpath: \"+realpath); int maxSize = 10 * 1024 * 1024; //10MB MultipartRequest multi = new MultipartRequest( request, realpath, maxSize, \"UTF-8\", new DefaultFileRenamePolicy() ); System.out.println(\"파일업로드성공\"); //2. 글정보 저장 (DB) //request로 받은 정보 -&gt; multipartrequest로 바뀌었으니 multipartrequest에 정보저장해야함 BoardDTO bdto = new BoardDTO(); //bdto.setName(request.getParameter(\"name\")); 이제 request가 아니라 multirequest를 써야한다 bdto.setName(multi.getParameter(\"name\")); bdto.setPw(multi.getParameter(\"pw\")); bdto.setSubject(multi.getParameter(\"subject\")); bdto.setContent(multi.getParameter(\"content\")); //bdto.setFile(multi.getParameter(\"file\")); //파라미터로 file을 제대로 가져올 수 없음getFilesystemName()를 사용해야한다 bdto.setFile(multi.getFilesystemName(\"file\")); bdto.setIp(request.getRemoteAddr()); //ip는 파라미터로 가져온게 아니니까 getRemoteAddr로 받으면됨 System.out.println(\"업로드 할 객체 정보: \"+bdto); //3. BoardDAO객체생성 -&gt; insertBoard() 재사용 BoardDAO bdao = new BoardDAO(); bdao.insertBoard(bdto); //파일업로드 끝******************************** //4. 페이지이동 ActionForward forward = new ActionForward(); forward.setPath(\"./BoardList.bo\"); forward.setRedirect(true); return forward; }} reWriteForm.jsp 생성 cos.jar라이브러리설치 폼태그속성 enctype=”multipart/form-data”, method=”post” get방식은 처리되지 않음. post로 해야함 가상경로를 가진 `upfile’ 폴더생성 1234567891011121314&lt;fieldset&gt;&lt;legend&gt;파일업로드(p305~)&lt;/legend&gt; &lt;form action=\"./FileBoardWriteAction.bo\" method=\"post\" enctype=\"multipart/form-data\"&gt; 글쓴이 : &lt;input type=\"text\" name=\"name\" required&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\" required&gt;&lt;br&gt; 제목 : &lt;input type=\"text\" name=\"subject\" maxlength=\"15\" required&gt;&lt;br&gt; 내용 : &lt;br&gt; &lt;textarea rows=\"10\" cols=\"35\" name=\"content\" placeholder=\"여기에 작성해주세요\" required&gt;&lt;/textarea&gt;&lt;br&gt; 파일 : &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\" value=\"글등록\" class=\"btn\"&gt; &lt;button type=\"reset\" class=\"btn\"&gt;초기화&lt;/button&gt; &lt;input type=\"button\" value=\"목록으로\" class=\"btn\" onclick=\"location.href='./BoardList.bo'\"&gt; &lt;/form&gt;&lt;/fieldset&gt; content.jsp 첨부파일 코드 수정 a태그의 href를 ./upload/&lt;%=bdto.getFile()%&gt;로 변경하면 이름을 클릭하는 순간 바로 볼 수 있다. 브라우저가 지원해주는 파일확장자인 경우 바로 파일 보기 가능 ex)이미지, 텍스트 둥둥 브라우저가 지원해주는 파일확장자가 아닌 경우 다운로드 됨 ex) 압축파일 등등 1234&lt;tr&gt; &lt;th&gt;첨부파일&lt;/th&gt; &lt;td colspan=\"3\"&gt;&lt;a href=\"./upload/&lt;%=bdto.getFile()%&gt;\"&gt;&lt;%=bdto.getFile() %&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;","link":"/2020/09/06/200907jspi3/"},{"title":"Servlet관리자용상품1 : 기초","text":"쇼핑몰기능을 만들려면 무슨 기능이 필요할까? 실무에서 필요한 모든 기능은 요구명세서에 작성된다. 그거 보고 처리하면 된다. 대략적으로 뭐가 필요할까? 상품, 구매자, 판매자, 주문(결제, 장바구니 등등), 재고관리 등등 관리자기눙 추가 : 상품등록 index.jsp 코드 변경1234&lt;%//관리자-상품등록response.sendRedirect(\"./GoodsAdd.ag\");%&gt; `web.xml’에 코드 추가123456789&lt;!-- Model2 상품등록 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;AdminGoodsFrontController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itwillbs.admin.goods.action.AdminGoodsFrontController&lt;/servlet-class&gt; &lt;!-- 컨트롤로 주소와 동일하게 --&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;AdminGoodsFrontController&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ag&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; src폴더아래에 새로운 패키지와 AdminGoodsFrontController.java생성 일반 클래스는 controller역할을 할 수 없다. 일반 클래스를 서블릿을 상속해서 컨트롤러 역활 할수있도록 설정해야한다 따라서 HttpServlet 상속한 뒤 doGet(), doPost() 오버라이딩해야한다. 그리고 get방식이든 post방식이든 한 번에 처리할 수 있는 doProcess()를 생성한다. doProcess()에서 처리하는 기능 주소 계산 command사용해서 주소 비교 후 처리 ActionForward를 가지고 페이지 이동 변수명 짓기 어려울때 변수명짓기 사이트 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class AdminGoodsFrontController extends HttpServlet { // 일반 클래스를 서블릿을 상속해서 컨트롤러 역활 할수있도록 설정 protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"doProcess() 호출 (페이지 GET/POST방식 모두 사용호출)\"); System.out.println(\"--------------@ 주소 계산 @-------------\"); // 주소 비교 (주소 매핑) // requestURI : /Model2JSP7/test.me (프로젝트명 + 주소) String requestURI = request.getRequestURI(); System.out.println(\" requestURI : \" + requestURI); // contextPath : /Model2JSP7 (프로젝트명) String contextPath = request.getContextPath(); System.out.println(\" contextPath : \" + contextPath); // 가상주소(/test.me) String command = requestURI.substring(contextPath.length()); System.out.println(\" command(가상주소) : \" + command); System.out.println(\"--------------@ 주소 비교후 처리 @-------------\"); Action action = null; ActionForward forward = null; // 주소에 따른 처리 구분 (주소 매핑후 이동) System.out.println(\"-----------------@ 페이지 이동 @--------------\"); if(forward != null){ // 이동할 정보가 있다 if(forward.isRedirect()){ // true - sendRedirect() // 가상주소(.bo -&gt; .bo), 화면전환(주소변경,화면 변경) System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(Redirect)\"); response.sendRedirect(forward.getPath()); }else{ // false - forward() System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(forward)\"); // 가상주소 -&gt; 실제페이지 (.bo -&gt; .jsp) + reqeust 객체 정보를 가지고 이동 RequestDispatcher dis = request.getRequestDispatcher(forward.getPath()); dis.forward(request, response); } }//end of 페이지이동 } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet() 호출 (페이지 GET방식 호출)\"); doProcess(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost() 호출 (페이지 POST방식 호출)\"); doProcess(req, resp); }} Action.java 생성12345678910111213public interface Action { // 상수,추상메서드 // 추상메서드 -&gt; 서브클래스들 한태 강제성 부여 // =&gt; 개발 형식의 통일(틀이 정해짐) // =&gt; 객체간의 관계가 약화됨 =&gt; 각각의 객체가 해당 동작만 처리/제어 // Action 페이지의 동작을 미리 선언해서 사용 public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception; } ActionForward.java 생성1234567891011121314151617181920212223242526272829public class ActionForward { //1.외부접근 못하도록 이동할 페이지와 이동할 방식 멤버변수 생성 private String path; private boolean isRedirect; // true면 sendRedirect방식으로 이동 //사용처: 주소와 화면의 전환이 동시에 일어날때 (가상주소 -&gt; 가상주소로 ) // false면 forward방식으로 이동 //사용처: 주소는 그대로인데 화면이 바뀔때 (가상주소에서 jsp보여줌) //2. getter setter생성 public String getPath() { return path; } public void setPath(String path) { this.path = path; } public boolean isRedirect() { return isRedirect; } public void setRedirect(boolean isRedirect) { this.isRedirect = isRedirect; } //3.toString @Override public String toString() { return \"ActionForward [path=\" + path + \", isRedirect=\" + isRedirect + \"]\"; }}","link":"/2020/09/06/200907jspi4/"},{"title":"Servlet상품3: 상품목록·상품리스트","text":"AdminGoodsFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 .ag -&gt; Action_DAO_DB -&gt;.jsp로 이동하니까 action객체사용 12345678//상품목록}else if(command.equals(\"/AdminGoodsList.ag\")){ System.out.println(\"C: /AdminGoodsListAction.ag 호출\"); //.ag -&gt; Action_DAO_DB -&gt;.jsp로 이동 action = new AdminGoodsListAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} AdminGoodsListAction.java 생성12345678910111213141516171819202122232425262728293031323334public class AdminGoodsListAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : AdminGoodsListAction의 execute() 호출\"); //관리자계정확인(세션 ID) HttpSession session = request.getSession(); String id = (String)session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null || !id.equals(\"admin\")){ //response.sendRedirect(\"./Main.me\"); 컨트롤러통해서 이동시키기 forward.setPath(\"./Main.me\"); forward.setRedirect(true); return forward; } //AdminGoodsDAO객체 생성 후 getGoodsList()생성 AdminGoodsDAO agdao = new AdminGoodsDAO(); List&lt;GoodsDTO&gt; goodsList = agdao.getGoodsList();; //등록된 상품 목록 전부 가져오기 System.out.println(\"M : \"+goodsList); //requset영역에 저장 request.setAttribute(\"goodsList\", goodsList); //페이지이동(뷰페이지로이동) forward.setPath(\"./admingoods/admin_goods_list.jsp\"); forward.setRedirect(false); return forward; }} admin_goods_list.jsp 생성 관리자만 페이지 볼 수 있게 하려면 session을 활용하여 코드를 작성하면 된다1234String id = (String) session.getAttribute(\"id\");if(!id.equals(\"admin\")){ response.sendRedirect(\"./MemberLogin.me\");} 전체코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 &lt;%// request 영역에 저장//request.setAttribute(\"goodsList\", goodsList);// request영역에서 정보를 꺼내서 테이블에 추가 List&lt;GoodsDTO&gt; goodsList = (List&lt;GoodsDTO&gt;)request.getAttribute(\"goodsList\"); //object-&gt;list타입 캐스팅//관리자만 페이지 볼 수 있게 추가String id = (String) session.getAttribute(\"id\");if(id == null || !id.equals(\"admin\")){ response.sendRedirect(\"./Main.me\");} %&gt;&lt;fieldset&gt;&lt;legend&gt;관리자용 상품등록&lt;/legend&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;번호&lt;/td&gt; &lt;td&gt;카테고리&lt;/td&gt; &lt;td&gt;사진&lt;/td&gt; &lt;td&gt;상품명&lt;/td&gt; &lt;td&gt;가격&lt;/td&gt; &lt;td&gt;수량&lt;/td&gt; &lt;td&gt;등록일&lt;/td&gt; &lt;td&gt;수정·삭제&lt;/td&gt; &lt;/tr&gt; &lt;% //List는 가변배열이므로 length가 없고 size가 존재한다. //size()메서드는 배열의 요소의 갯수를 리턴 for(int i=0; i&lt;goodsList.size(); i++){ //List 한칸의 정보 -&gt; GoodsDTO 객체 하나로 이동 GoodsDTO gdto = (GoodsDTO) goodsList.get(i); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=gdto.getGno() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getCategory() %&gt;&lt;/td&gt; &lt;td&gt; &lt;img src=\"./upload/&lt;%=gdto.getImage().split(\",\")[0]%&gt;\" height=\"100\"&gt; &lt;/td&gt; &lt;td&gt;&lt;%=gdto.getName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getPrice() %&gt;원&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getAmount() %&gt;개&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getDate() %&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=\"button\" class=\"btn\" value=\"수정\" onclick=\"location.href='./AdminGoodsModify.ag?gno=&lt;%=gdto.getGno()%&gt;'\"&gt; &lt;input type=\"button\" class=\"btn\" value=\"삭제\" onclick=\"location.href='./AdminGoodsDeleteAction.ag?gno=&lt;%=gdto.getGno()%&gt;'\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;/table&gt; &lt;/fieldset&gt; AdminGoodsDAO.java 생성 후 getGoodsList()메서드 코드 추가12345678910111213141516171819202122232425262728293031323334//상품목록public List&lt;GoodsDTO&gt; getGoodsList() { List&lt;GoodsDTO&gt; goodsList = new ArrayList&lt;GoodsDTO&gt;(); try { getCon(); sql = \"select * from itwill_goods\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); while(rs.next()){ GoodsDTO gdto = new GoodsDTO(); gdto.setGno(rs.getInt(\"gno\")); gdto.setCategory(rs.getString(\"category\")); gdto.setName(rs.getString(\"name\")); gdto.setPrice(rs.getInt(\"price\")); gdto.setColor(rs.getString(\"color\")); gdto.setAmount(rs.getInt(\"amount\")); gdto.setSize(rs.getString(\"size\")); gdto.setContent(rs.getString(\"content\")); gdto.setImage(rs.getString(\"image\")); gdto.setBest(rs.getInt(\"best\")); gdto.setDate(rs.getDate(\"date\")); goodsList.add(gdto); } System.out.println(\"DAO : 상품목록 모두 저장완료! \"+goodsList); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return goodsList; }//end of getGoodsList()","link":"/2020/09/07/200908jspi/"},{"title":"[안드로이드]다운로드, 기본개념, 프로젝트 기본순서, 액티비티생명주기, 로그캣","text":"안드로이드 다운로드 안드로이드 다운로드 안드로이드 설치가이드 안드로이드 AVD 생성 AVD = Android Virtual Device 스마트폰이나 태블릿 없이도 안드로이드 응용 프로그램의 테스트를 가능케 해준다. 실습하기 적당한 AVD는 xxhdpi(1080X1920)해상도이고 화면 5.5인치 보통 픽셀2 API 사용 안드로이드 SDK업데이트 확인 SDK = Software Development Kit 가장 최신버전을 다운로드하면 된다. 보통 R버전. 확인방법 : Tools -&gt; SDK manager 안드로이드 프로젝트에서 프로그래머가 주로 변겨하거나 접근할 폴더와 파일 activity_main.xml : 기본 액티비티(화면) MainActivity.java : 메인 java코드 strings.xml : 문자열이 저장된 파일 drawable폴더 : 앱에서 사용할 이미지 파일을 저장하는 폴더 AndroidMainfest.xml : 앱의 기본적인 정보가 설정된 파일 프로젝트 기본 순서안드로이드 프로젝트생성 : 프로젝트명 첫글자 대문자, 공백쓰지말것 new studio project에서 Empty Activity클릭 보통 Empty Activity로 프로젝트를 시작한다. 언어 기본설정 : java 최하 실행버전 기본설정 : Android 4.1 (Jelly Bean) .xml 화면 디자인 기본 배치관리자 : LinearLayout LinearLayout과 android:orientation=”vertical”` 항상 세트로 코딩 1234567&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\"&gt; layout_width와 layout_height 모든 태그에 작성 필수 id작성규칙 : 영어대소문자와 숫자로 이루어져야함. 실무에서 보통 소문자사용 123456&lt;TextView android:id=\"@+id/Text1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"반려동물 월드컵 시작하시겠습니까?\" /&gt; .java 코딩 자바코드는 3단계에 걸쳐서 작성된다 변수 선언 변수에 위젯 대입 클릭할때 동작하는 클래스 정의 12345678910111213141516171819202122232425262728//버튼의 java코드//1.변수선언Button mybtn//2.변수에 위젯대입mybtn = (Button) findViewById(R.id.button1);//3.버튼 클릭할때 동작하는 클래스 정의mybtn.setOnclickListener(new View.OnClickListener(){ public void onClick(View v){ // 동작할 코드 작성 }})//체크박스의 java코드//1.변수선언checkBox mycheck;//2.변수에 위젯대입mycheck = (CheckBox) findViewById(R.id.checkbox1);//3.버튼 클릭할때 동작하는 클래스 정의mycheck.setOncheckedChangeListener( new OnCheckedChangeListener(){ public void onCheckedChanged(CompoundButton arg0, boolean arg1){ //이 부분에 동작할 코드 작성 }}) 아래 코드는 MainActivity.java이다. 전역변수 생성 : 태그타입적은 뒤 소문자로 변수명 생성 view페이지에서 id값 가져올 때 findViewById(R.id.id명)을 사용 R은 R클래스이다. findViewById(R.id.id명)로 가져온 건 object타입이다. 이때 안드로이드스튜디오에서는 casting 불필요하다고 warning이 뜨지만 JAVA파일이므로 java에선 다운캐스팅해줘야한다. 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity { //전역변수 TextView text1, text2; CheckBox chkAgree; RadioGroup rG1; RadioButton dog, cat, rabbit; Button btnOk; ImageView imgPet; //r클래스(P102) : R클래스는 개발자가 건들일수없는 코드이다 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setTitle(\"반려동물 사진보기\"); //findViewById는 object이다 //안드로이드스튜디오에서는 에러나지만 JAVA에선 다운캐스팅해줘야한다 text1 = (TextView) findViewById(R.id.Text1); chkAgree = (CheckBox) findViewById(R.id.ChkAgree); text2 = (TextView) findViewById(R.id.Text2); (중략) }} RUN : AVD로 프로젝트 실행 및 결과 확인 액티비티생명주기 Activity란? 안드로이드 응용 프로그램은 PC용과 달리 화면이 작으므로 동시에 여러 개의 액티비티(화면)가 나올 수 없다. 하나의 액티비티가 실행중이면 다른 액티비티는 비활성화된다. 액티비티 생명주기 : 액티비티의 생성부터 소멸까지의 주기 로그캣 로그 모은 것을 화면 나타낸다. 작성 중인 프로그램에 예기치 못한 오류가 발생했을 때 원인을 파악하는 방법 중 하나. 로그캣을 정말 잘 설명해둔 안드로이드 문서 이미지파일확장자 안드로이드에서 가장 빠르게 처리할 수 있는 이미지파일확장자 : png 안드로이드 래퍼런스 Android-best-practices깃헙레포","link":"/2020/09/08/200909and/"},{"title":"Servlet상품5: 상품삭제","text":"AdminGoodsFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 12345678 //상품삭제}else if(command.equals(\"/AdminGoodsDeleteAction.ag\")){ System.out.println(\"C: /AdminGoodsDeleteAction.ag 호출\"); //.jsp -&gt; Action_DAO_DB -&gt;.ag로 이동 action = new AdminGoodsDeleteAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} AdminGoodsDeleteAction.java 생성12345678910111213141516171819202122232425262728293031323334353637public class AdminGoodsDeleteAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : AdminGoodsDeleteAction의 execute() 호출\"); //관리자계정확인(세션 ID) HttpSession session = request.getSession(); String id = (String)session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null || !id.equals(\"admin\")){ //response.sendRedirect(\"./Main.me\"); 컨트롤러통해서 이동시키기 forward.setPath(\"./Main.me\"); forward.setRedirect(true); return forward; } //한글처리 request.setCharacterEncoding(\"UTF-8\"); //전달받은 파라미터 저장 int gno = Integer.parseInt(request.getParameter(\"gno\")); //DB삭제을 위해 DAO생성 -&gt; deleteGoods(gno) AdminGoodsDAO agdao = new AdminGoodsDAO(); agdao.deleteGoods(gno); //리스트 페이지이동 //(AdminGoodsList.ag -&gt; 보이는 페이지도 AdminGoodsList.ag이므로 sendRedirect방식으로 이동) forward.setPath(\"./AdminGoodsList.ag\"); forward.setRedirect(true); return forward; }} AdminGoodsDAO.java 생성 후 deleteGoods(int gno)메서드 코드 추가 tmp는 DB의 몇개의 row가 영향을 받느냐를 나타내는데 여기서는 gno컬럼이 pk이므로 1 또는 0만 나옴 123456789101112131415//상품삭제public void deleteGoods(int gno) { try{ getCon(); sql = \"delete from itwill_goods where gno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, gno); int tmp = pstmt.executeUpdate(); System.out.println(\"DAO : 상품삭제완료 -&gt; \"+tmp); }catch(Exception e){ e.printStackTrace(); }finally { closeDB(); }}//end of deleteGoods","link":"/2020/09/08/200909jspi2/"},{"title":"[안드로이드]컴파운드버튼(체크박스,라디오버튼,스위치,토글버튼) 한눈에 비교하기","text":"컴파운드버튼컴파운드 버튼에는 체크박스, 라디오버튼, 스위치, 토글버튼등이 있다.이 중 헷갈리는 생김새가 있어 비교해보려고한다. 종류 모양 체크박스 라디오버튼 토글버튼(Toggle) 스위치(Switches) Radio버튼 Radio버튼은 꼭 RadioGroup과 함께 사용해야 여러 개 중 하나만 선택 가능하다. RadioGroup은 사용하지않은채 Radio버튼만 사용하면 checkBox버튼처럼 중복 선택된다. clearCheck() : 해당 라디오그룹안에 체크된 것을 모두 해제하는 메서드 123456789101112131415161718192021&lt;RadioGroup android:id=\"@+id/rGroup\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;RadioButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Yes\" /&gt; &lt;RadioButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Maybe\" /&gt; &lt;RadioButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"No\" /&gt;&lt;/RadioGroup&gt;","link":"/2020/09/09/200910and/"},{"title":"오픈소스컨트리뷰톤 온라인미팅7 후기","text":"컨트리뷰톤 결과보고서 작성오늘은 마지막 미팅이다. 벌써 한 달이 지났다니 정말 빠르다. 그동안 정말 많은 것을 배웠고 내가 오픈소스에 기여했다는 사실이 정말 뿌듯하다.오늘 미팅에서는 컨트리뷰톤 결과 보고서 작성에 관한 이야기를 주력으로 했다. 컨트리뷰톤인만큼 꼭 상을 받고싶다!내가 속해있는 모던자바스크립트튜토리얼프로젝트는 작년에 정보통신산업진흥원이 주는 장려상을 받았다고한다. 진짜 열심히 했는데 올해도 좋은 결과가 있었으면 좋겠다. 다른 컨트리뷰토너분들도 열심히 적어주셨다🙌 우리 꼭 🏆받자구요! GIT을 다루는 건 여전히 무섭지만(?) 정말 재미있다.알면 알수록 편한 기능이 쏟아지는 GIT을 마스터해보고싶다. 특히 지금 리베이스와 머지에서 굉장히 다양한 conflict을 만나고 있는데 만날때마다 심장이 덜컹한다.😱언젠가는 덤덤한 날이 오겠지…(먼산) 오픈소스메인테이너가 되려면?모던자바스크립트튜토리얼 오픈소스의 메인테이너인 보라님은 정말 멋있다.오픈소스를 운영한다고 해서 경제적이득이 주어지는 것도 아닌데 그는 오픈소스생태계에 기여하고싶다는 열정으로 작업을 이어나가고 있다. 정말 멋있는 사람이다. 오픈소스메인테이너가 되기 위해서는 해당 라이센스 체크 필수 MIT는 비상업적용도로 가능해서 best 괜찮은 오픈소스1 괜찮은 오픈소스2 면접질문 팁 클로저 번역하면서 이런 내용은 보충되었으면 하는 내용을 정리해보았습니다.스코프의 정의: 이름(변수)의 유효범위렉시컬 스코프: 정적 스코프라고도 불리운다. 동적 스코프의 단점 때문에 등장한 개념으로, 관련 내용은 ‘코딩을 지탱하는 기술’ 제 7장 ‘이름과 스코프’에서 확인할 수 있다. 배열과 메서드 학습팁! 배열을 조작하는지, 아니면 기존 배열은 건드리지 않고 조건을 적용한 새로운 배열을 반환하는지에 주의하며 메서드를 살펴보시기 바랍니다. pure function에 대한 자료들도 읽어보시면 좋을 것 같습니다.","link":"/2020/09/11/200912opensource/"},{"title":"Oracle DB생성방법 2가지, Oracle DB Tool, Parameterfile 유형","text":"DB 생성 방법 자동 - DBCA tool 수동 - SQL Plus tool Oracle DB ToolSQL PLUS 터미널 환경의 Tool 쿼리구문(select, DML, DDL뿐만아니라 관리명령어 포함)을 입력/실행/결과 확인 DBA, 일반유저(개발자) 모두 사용 가능 SQL Developer 그래픽 환경의 Tool 쿼리구문(select, DML, DDL)만 입력/실행/결과 확인 주로 일반유저(개발자) 사용 가능 DBCA 그래픽 환경의 Tool DB생성 및 삭제를 도와줌 EM 웹브라우저 환경의 Tool DB관리를 도와줌 DBA만 사용 가능 URL주소 의미 : 예시 http://localhost:1158/em localhost : DB가 존재하는 SERVER의 HOST명(IP주소)가 들어가는 자리 1158 : 고유 PORT번호, DB생성할때 만들어지는 고유한 번호 Parameterfile 유형PFILE 위치 : $ORACLE_HOME/dbs (어느 기업이건 동일한 위치) 이름 : initSID.ora 특징 : text file -&gt; 따라서 vi편집기로 수동 편집 가능 static file : DB운영 중 parameter값 변경시 바로 적용 안됨 -&gt; DB재시작시 적용됨. SPFILE 위치 : $ORACLE_HOME/dbs (어느 기업이건 동일한 위치) 이름 : spfileSID.ora 특징 : binary file (이진파일) -&gt; 따라서 수동 편집 불가능 -&gt; oracle이 유지관리 자동으로 함 vi편집기로 여는 순간 파일이 깨져버림 -&gt; 망하는거임 -&gt; oracle에게 보여달라고 명령하면 됨 참고링크 : 오라클DB구조 중 Parameter file dynamic file : DB운영 중 parameter값 변경시 바로 적용됨. -&gt; 이 특징때문에 대부분의 기업이 PFILE아닌 SPFILE를 사용 조회 : block사이즈와 캐시사이즈를 조회하는 쿼리 12SQL&gt; show parameter db_block_size;SQL&gt; show parameter db_cache_size; 변경 : 가장 많이 쓰는 구문. 12345//예시쿼리 : 캐시사이즈를 512메가로 변경SQL&gt; alter system set db_cache_size = 512M;//scope 옵션추가SQL&gt; alter system set db_cache_size = 512M scope = memory | both | spfile; scope 옵션 : 중요 memory : 현재 DB에만 적용, spfile에는 적용 X both(default) : 현재 DB와 spfile 둘 다 적용 O spfile : spfile에는 적용 O, 현재 DB적용 X -&gt; 즉 DB 재시작시 적용함 = static하게 적용하겠다는 의미.","link":"/2020/09/09/200911dbi/"},{"title":"오라클의 Database 켜고 끄기","text":"Database 시작 단계 shutdown : Instance가 켜지지않은 단계 parameterfile 읽고 nomount로 올라감 nomount : parameterfile에서 파라미터값이 정상적으로 읽은 뒤 파라미터값을 토대로 instance가 시작된 단계 파라미터값 중에 control_files 값이 있는데 여기에 controlfile정보가 저장되어 있음 Controlfile를 읽고 mount로 올라감 mount : Controlfile을 찾아서 정상적으로 읽은 상태 Datafile, Redologfile 위치 및 이름 변경 Controlfile이 다중화된 갯수만큼 그만큼 마운트 시간이 오래 걸린다 전체 DB복구: DB모드(Archive log mode)변경가능 명령어 : recover database; SMON이 redologfiles를 읽어서 DB동기화를 시켜줌 open : DB가 정상적으로 켜진 단계, 일반 DB사용자 접속 가능 nomount에서 할 수 있는 대표적인 관리작업 DB생성 DB생성명렁어 : create database; 위의 명령어는 아무데나 실행할 수 있는 명령어가 아니고 nomount에서만 할 수 있는 명령어이다. Controlfile 재생성 DB가 shutdown일때 쓸 수 있는 명령어원래 문법상 startup 명령어 뒤에는 세미콜론(;)이 붙지않는다.하지만 세미콜론을 붙여도 실행은 해준다. startup nomount : shutdown에서 nomount까지 올라가는 명령어 startup mount : shutdown에서 mount까지 올라가는 명령어 startup : shutdown에서 open까지 올라가는 명령어 명렁어를 통해 한 번에 3단계씩 올라갈 수 있다. DB가 각 단계에서 위로 올릴때 쓰는 명령어DB가 shutdown상태가 아닌 특정 단계에 있을 때 아래와 같은 명령어를 사용할 수 있다.아래 명령어는 한 번에 한 단계씩만 올라갈 수 있다. 두 단계씩 못 올라감.즉, nomount에서 open으로 올라가는 명령어는 없다. 차근차근 올라가야함. alter database mount; : nomount에서 mount까지 올라가는 명령어 alter database open; : mount에서 open까지 올라가는 명령어 지금 어디까지 켜져있는지 확인하는 명령어지금이 nomount인지 mount인지 어디인지 확인하는 명령어이다.지금 어느 상태인지 status가 알려준다. 1234567891011121314151617181920212223242526//명령어select status from v$instance;//shutdown상태인 경우 오류메세지 출력ERROR at line 1:ORA-01034: ORACLE not availableProcess ID: 0Session ID: 0 Serial number: 0//nomount상태인 경우 STARTED 출력STATUS------------------------STARTED//mount상태인 경우 MOUNTED 출력됨STATUS------------------------MOUNTED//open상태인 경우 OPEN 출력됨STATUS------------------------OPEN DB 종료하기DB시작할때는 한계단씩 켤수있으나 종료할때는 OPEN에서 SHUTDOWN으로 바로 내려가야한다. 현재 MOUNT이든지 OPEN이든지 무조건 SHUTDOWN으로만 내려올 수 있다. 그렇다면 OPEN인 상태에선 어떻게 MOUNT로 내려갈 수 있을까? OPEN에서 SHUTDOWN으로 내려간 뒤 다시 MOUNT로 올라가야한다. 종료 명령어 비정상적인 종료 : abort12SQL&gt; shut abortORACLE instance shut down. 정상적인 종료 : immediate, transactional, normal(default) shutdown 줄여서 shut 명령어 가능 shutdown모드 A I T N 새로 들어오는 접속을 허용 하는가? N N N N 현재 세션 종료될때까지 기다릴건지? N N N Y 현재 트랜잭션이 종료될때까지 기다릴건지? N N Y Y 체크포인트를 발생시켜서 커밋된 작업은 반영할 것인지? N Y Y Y shutdown immediate shutdown immediate = shut immediateDB를 정상적으로 끄면서 가장 빠르게 종료시키는 명령어체크포인트가 바로 발생하는 명령어 -&gt; redologfiles에 로그가 저장되고 더디블럭이 datafiles에 내려옴 -&gt; 동기화 된 채로 종료 1234SQL&gt; shut immediateDatabase closed.Database dismounted.ORACLE instance shut down. shutdown transactional shutdown transactional = shut transactional현재 진행되고있는 트랜잭션이 있다면 커밋/롤백으로 마무리될때까지 기다렸다가 종료하는 모드기다렸다가 종료하는 모드이므로 언제 꺼질지는 모른다.새로운 트랜잭션이 늘어나진않는다. 12345678910111213//HR세션(p113)insert into regions values (5,'Mars');//SYS세션 : 더이상 진행되지않음. 변화없음SQL&gt; shut transactional//HR세션rollback;//SYS세션 : 트랜잭션 종료되자마자 시작Database closed.Database dismounted.ORACLE instance shut down. shutdown normal(default) shutdown normal = shutdown = shut디폴트값이다접속되어있는 모든 유저들의 세션이 종료될때까지 기다려준다.새로운 트랜잭션이 늘어난다. 1234SQL&gt; shutDatabase closed.Database dismounted.ORACLE instance shut down. shut명령어를 날렸는데 너무 오래기다려서 더이상 기다릴 수없어서 명령어를 shut immediate로 바꾸고 싶다면? 명령어 취소 : ctrl + z","link":"/2020/09/13/200914dbi/"},{"title":"[오픈소스컨트리뷰톤2020] 온라인미팅 중 현직꿀팁List","text":"🍎프론트앤드 하는 일 jquery - 변한작업 -&gt; vue jsonp, cors : 면접때 프론트앤드개발자에게 무조건 물어봄. 보안이슈이기때문에. 모던js튜토리얼 2회독이상하기 도움이 엄청 되었다. 프론트앤드 웹스킬 한방에 정리한 사이트 🍎백앤드 하는 일 백앤드는 스프링배워서 컨트롤러짜는 기능까지 요구 서버 : node, spring 주로 사용 🍎현업에서 자주사용하는 언어 프론트개발자 : vue, ts(타입스크립트)로 진행함 프론트앤드 삼대장 : 뷰, 리액트, 앵귤러(카카오톡이 밀고있음) 순수js를 쓰는 회사는 거의없다 앱만들때는 : ios코틀린, 리액트(iso,안드), 네이티브 QA자동화 : 카탈론(자바랑 리액트) 🍎사이드플젝 아래 동아리들이 팀원을 구해서 프로젝트랑 연결해줌 비사이드 얍 메이커스 🍎프론트앤드 신입/경력과제 todoapp 배포(줄글로) zeplin.io 로 디자인 시안을 해서 화면을 주면 그걸 보고 구현 🍎프론트앤드 면접질문 팁 클로저 번역하면서 이런 내용은 보충되었으면 하는 내용을 정리해보았습니다.스코프의 정의: 이름(변수)의 유효범위렉시컬 스코프: 정적 스코프라고도 불리운다. 동적 스코프의 단점 때문에 등장한 개념으로, 관련 내용은 ‘코딩을 지탱하는 기술’ 제 7장 ‘이름과 스코프’에서 확인할 수 있다. 배열과 메서드 학습팁! 배열을 조작하는지, 아니면 기존 배열은 건드리지 않고 조건을 적용한 새로운 배열을 반환하는지에 주의하며 메서드를 살펴보시기 바랍니다. pure function에 대한 자료들도 읽어보시면 좋을 것 같습니다. 🍎power apps 기술women who code에서 마이크로소프트랑합작으로 만든 회사. 🍎현업에서 브랜치명 작성은 보통 어떻게 하는 지? 브랜치명 : 이슈나 티켓기반으로 작업 &gt; 브랜치명을 이슈번호나 티켓번호가 자동으로 셋팅됨. 브랜치명이 다른 팀원과 겹쳐도 됨. Feature/{issue number}/기능설명 기능개발: feature 버그: bugfix 🍎현업에서 PR보내기 실제 현업에선 절대 master로 PR보내는 것이 금지. 대부분 develop등 개발전용 브랜치에 PR보내도록 한다. PR 제목도 회사규칙에 따라 잘 남겨야한다. 예시 : [주제제목] 작업내용 🍎Jenkins공식레포메니저는 Jenkins서버 github에 변경내역을 webhook으로 감지가 되면 jenkis서버가 실행되고 build server가 연동되어 변경내역이 서버에 올라간다 🍎OT(Operational Technology) 오퍼레이션 테크놀로지 공장이나 산업군에 있는 곳의 스마트팩토링 작업 출장이 잦은 이유 : 요구사항을 뽑기(요구사항 명세서), 개발하기 참고링크 : 기업들의 OT보안 수요증가 🍎CSS 변경 후 실시간으로 반영이 안될때 원인 : CSS 캐쉬때문에 안나옴 empty cache and hard reload 진행 개발자도구 열고 (f12) 새로고침 버튼에서 마우스 오른쪽 클릭하면 3개 버튼 -&gt; 강력 새로고침 또는 캐시비우고 강력 새로고침 단축키 : ctrl + shift + r 🍎실무에선 추가로 생성한 branch는 보통 언제 삭제할까?깔끔한게 좋다며 괜히 브랜치 삭제해서 진짜 큰일 날뻔했다.도대체 새로 생성한 브랜치는 언제 삭제하는 지 궁금해져서 보라님께 물어봤다.아래 두가지 경우에서 삭제한다고 한다. PR날려서 머지되면 삭제함. 어차피 회사가면 jenkins라는 툴로 브랜치관리함.","link":"/2020/09/13/200914opensource/"},{"title":"Servlet일반상품1 : 기초","text":"`web.xml’에 코드 추가 쇼핑몰기능에서 일반 사용자가 보는 상품목록을 만들어보자. web.xml 코드 수정 후 꼭 서버 실행 후 주소창에 test.bo해서 흰 화면이 뜨는지 확인하고 코딩할 것 흰화면이 안뜨면 web.xml 설정이 잘못되었다는 의미임. 123456789&lt;!-- Model2 상품목록확인(일반사용자용+관리자) --&gt; &lt;servlet&gt; &lt;servlet-name&gt;GoodsFrontController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itwillbs.goods.action.GoodsFrontController&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;GoodsFrontController&lt;/servlet-name&gt; &lt;url-pattern&gt;*.go&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; src폴더아래에 새로운 패키지와 GoodsFrontController.java생성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class GoodsFrontController extends HttpServlet{ // 일반 클래스를 서블릿을 상속해서 컨트롤러 역활 할수있도록 설정 protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"doProcess() 호출 (페이지 GET/POST방식 모두 사용호출)\"); // 주소 비교 (주소 매핑) System.out.println(\"--------------@ 주소 계산 @-------------\"); // 프로젝트명 + 주소 String requestURI = request.getRequestURI(); System.out.println(\" requestURI : \" + requestURI); // 프로젝트명 String contextPath = request.getContextPath(); System.out.println(\" contextPath : \" + contextPath); // 가상주소 String command = requestURI.substring(contextPath.length()); System.out.println(\" command(가상주소) : \" + command); System.out.println(\"--------------@ 주소 비교후 처리 @-------------\"); Action action = null; ActionForward forward = null; // 주소에 따른 처리 구분 (주소 매핑후 이동) System.out.println(\"-----------------@ 페이지 이동 @--------------\"); if(forward != null){ // 이동할 정보가 있다 if(forward.isRedirect()){ // true - sendRedirect() // 가상주소(.bo -&gt; .bo), 화면전환(주소변경,화면 변경) System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(Redirect)\"); response.sendRedirect(forward.getPath()); }else{ // false - forward() System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(forward)\"); // 가상주소 -&gt; 실제페이지 (.bo -&gt; .jsp) + reqeust 객체 정보를 가지고 이동 RequestDispatcher dis = request.getRequestDispatcher(forward.getPath()); dis.forward(request, response); } }//end of 페이지이동 }//end of doProcess @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet() 호출 (페이지 GET방식 호출)\"); doProcess(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost() 호출 (페이지 POST방식 호출)\"); doProcess(req, resp); }} Action.java 생성12345678910111213public interface Action { // 상수,추상메서드 // 추상메서드 -&gt; 서브클래스들 한태 강제성 부여 // =&gt; 개발 형식의 통일(틀이 정해짐) // =&gt; 객체간의 관계가 약화됨 =&gt; 각각의 객체가 해당 동작만 처리/제어 // Action 페이지의 동작을 미리 선언해서 사용 public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception; } ActionForward.java 생성1234567891011121314151617181920212223242526272829public class ActionForward { //1.외부접근 못하도록 이동할 페이지와 이동할 방식 멤버변수 생성 private String path; private boolean isRedirect; // true면 sendRedirect방식으로 이동 //사용처: 주소와 화면의 전환이 동시에 일어날때 (가상주소 -&gt; 가상주소로 ) // false면 forward방식으로 이동 //사용처: 주소는 그대로인데 화면이 바뀔때 (가상주소에서 jsp보여줌) //2. getter setter생성 public String getPath() { return path; } public void setPath(String path) { this.path = path; } public boolean isRedirect() { return isRedirect; } public void setRedirect(boolean isRedirect) { this.isRedirect = isRedirect; } //3.toString @Override public String toString() { return \"ActionForward [path=\" + path + \", isRedirect=\" + isRedirect + \"]\"; }} GoodsDTO.java 생성 관리자용 상품목록 출력할때 만들었던 GoodsDTO.java을 사용하면 된다. 추가생성 할 필요없다. 관리자용 상품DTO와 일반사용자용 상품DTO는 동일하기때문에 나눌 필요가 없다. GoodsDAO.java 생성 DAO는 DTO와 달리 중요한 데이터에 접근하는 것이므로 관리자용DAO와 별도로 생성 및 관리되어야한다. DB연결메서드 생성 자원해제 메서드 생성 12345678910111213141516171819202122232425262728public class GoodsDAO { Connection con = null; PreparedStatement pstmt = null; ResultSet rs = null; String sql = \"\"; // 디비 연결 private void getCon() throws Exception{ // 커넥션 풀 Context init = new InitialContext(); DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/model2DB\"); con = ds.getConnection(); System.out.println(\"DAO : 디비연결 완료 \"+con); }//end of getCon() // 디비 자원해제 public void closeDB(){ try { if(rs != null) {rs.close(); } if(pstmt != null) {pstmt.close(); } if(con != null) {con.close(); } } catch (SQLException e) { e.printStackTrace(); } }//end of closeDB() }","link":"/2020/09/09/200910jspi/"},{"title":"Servlet장바구니1 : 기초","text":"`web.xml’에 코드 추가 장바구니기능을 만들어보자. web.xml 코드 수정 후 꼭 서버 실행 후 주소창에 test.bo해서 흰 화면이 뜨는지 확인하고 코딩할 것 흰화면이 안뜨면 web.xml 설정이 잘못되었다는 의미임. 123456789&lt;!-- Model2 장바구니 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;BasketFrontController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itwillbs.basket.action.BasketFrontController&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;BasketFrontController&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ba&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; BasketFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class BasketFrontController extends HttpServlet { // 일반 클래스를 서블릿을 상속해서 컨트롤러 역활 할수있도록 설정 protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"doProcess() 호출 (페이지 GET/POST방식 모두 사용호출)\"); // 주소 비교 (주소 매핑) System.out.println(\"--------------@ 주소 계산 @-------------\"); // 프로젝트명 + 주소 String requestURI = request.getRequestURI(); System.out.println(\" requestURI : \" + requestURI); // 프로젝트명 String contextPath = request.getContextPath(); System.out.println(\" contextPath : \" + contextPath); // 가상주소 String command = requestURI.substring(contextPath.length()); System.out.println(\" command(가상주소) : \" + command); System.out.println(\"--------------@ 주소 비교후 처리 @-------------\"); Action action = null; ActionForward forward = null; // 주소에 따른 처리 구분 (주소 매핑후 이동) System.out.println(\"-----------------@ 페이지 이동 @--------------\"); if(forward != null){ // 이동할 정보가 있다 if(forward.isRedirect()){ // true - sendRedirect() // 가상주소(.bo -&gt; .bo), 화면전환(주소변경,화면 변경) System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(Redirect)\"); response.sendRedirect(forward.getPath()); }else{ // false - forward() System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(forward)\"); // 가상주소 -&gt; 실제페이지 (.bo -&gt; .jsp) + reqeust 객체 정보를 가지고 이동 RequestDispatcher dis = request.getRequestDispatcher(forward.getPath()); dis.forward(request, response); } }//end of 페이지이동 }//end of doProcess @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet() 호출 (페이지 GET방식 호출)\"); doProcess(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost() 호출 (페이지 POST방식 호출)\"); doProcess(req, resp); }} Action.java 생성12345678910111213public interface Action { // 상수,추상메서드 // 추상메서드 -&gt; 서브클래스들 한태 강제성 부여 // =&gt; 개발 형식의 통일(틀이 정해짐) // =&gt; 객체간의 관계가 약화됨 =&gt; 각각의 객체가 해당 동작만 처리/제어 // Action 페이지의 동작을 미리 선언해서 사용 public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception; } ActionForward.java 생성1234567891011121314151617181920212223242526272829public class ActionForward { //1.외부접근 못하도록 이동할 페이지와 이동할 방식 멤버변수 생성 private String path; private boolean isRedirect; // true면 sendRedirect방식으로 이동 //사용처: 주소와 화면의 전환이 동시에 일어날때 (가상주소 -&gt; 가상주소로 ) // false면 forward방식으로 이동 //사용처: 주소는 그대로인데 화면이 바뀔때 (가상주소에서 jsp보여줌) //2. getter setter생성 public String getPath() { return path; } public void setPath(String path) { this.path = path; } public boolean isRedirect() { return isRedirect; } public void setRedirect(boolean isRedirect) { this.isRedirect = isRedirect; } //3.toString @Override public String toString() { return \"ActionForward [path=\" + path + \", isRedirect=\" + isRedirect + \"]\"; }} BasketDTO.java생성 DB테이블을 생성후 DTO를 아래 코드와 같이 생성한다 1234567891011121314151617181920public class BasketDTO { private int b_num; private String b_m_id; private int b_g_num; private int b_g_amount; private String b_g_size; private String b_g_color; private Date b_date; public int getB_num() { return b_num; } public void setB_num(int b_num) { this.b_num = b_num; } public String getB_m_id() { return b_m_id; } (중략)} BasketDAO.java 생성 DAO는 DTO와 달리 중요한 데이터에 접근하는 것이므로 관리자용DAO와 별도로 생성 및 관리되어야한다. DB연결메서드 생성 자원해제 메서드 생성 12345678910111213141516171819202122232425262728public class BasketDAO { Connection con = null; PreparedStatement pstmt = null; ResultSet rs = null; String sql = \"\"; // 디비 연결 private void getCon() throws Exception{ // 커넥션 풀 Context init = new InitialContext(); DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/model2DB\"); con = ds.getConnection(); System.out.println(\"DAO : 디비연결 완료 \"+con); }//end of getCon() // 디비 자원해제 public void closeDB(){ try { if(rs != null) {rs.close(); } if(pstmt != null) {pstmt.close(); } if(con != null) {con.close(); } } catch (SQLException e) { e.printStackTrace(); } }//end of closeDB() }","link":"/2020/09/14/200915jspi2/"},{"title":"Servlet장바구니2 : 장바구니에 담기","text":"BasketFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 12345678910// 주소에 따른 처리 구분 (주소 매핑후 이동)if(command.equals(\"/BasketAdd.ba\")){ //장바구니 추가 : .jsp -&gt; DB System.out.println(\"C: /BasketAdd.ba 호출\"); //.ag -&gt; .jsp로 이동 //컨트롤러 -&gt; 뷰페이지 이동 action = new BasketAddAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} BasketAddAction.java 생성1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BasketAddAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : BasketAddAction의 execute() 호출\"); // 로그인 정보 (로그인 처리필요) HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(false); return forward; } //한글처리 request.setCharacterEncoding(\"UTF-8\"); // 장바구니 저장 // 상품정보 저장가능 (GoodsDetail 페이지에서 전달) // BasketDTO / BasketDAO 객체 // 장바구니 객체 생성 // 파라미터값 저장(상품번호,구매수량,옵션(크기,색상)) + ID BasketDTO bdto = new BasketDTO(); bdto.setB_g_num(Integer.parseInt(request.getParameter(\"gno\"))); bdto.setB_g_amount(Integer.parseInt(request.getParameter(\"amount\"))); bdto.setB_g_size(request.getParameter(\"size\")); bdto.setB_g_color(request.getParameter(\"color\")); bdto.setB_m_id(id); //bdto.setB_date(b_date); //bdto.setB_num(b_num); System.out.println(\"장바구니 객체정보: \"+bdto); // BasketDAO 객체 생성 BasketDAO bdao = new BasketDAO(); //해당상품(+옵션까지)이 장바구니에 동일한게 있는지 체크 int result = bdao.checkGoods(bdto); // basketAdd() - 추가 if(result != 1){ //장바구니에 해당상품이 없다 bdao.basketAdd(bdto); } //장바구니list로 이동 forward.setPath(\"./BasketList.ba\"); forward.setRedirect(true); return forward; }} BasketDAO.java에 checkGoods()메서드 코드 추가이미 장바구니에 담았던 상품을 또 장바구니담기를 선택한 경우 모든 옵션이 같다면 수량을 1 증가시키는 메서드를 구현해보자. 123456789101112131415161718192021222324252627282930313233343536373839//동일한 상품이 있는지 체크public int checkGoods(BasketDTO bkdto) { int result = 0; try{ getCon(); //sql : id, gno, size, color 모두 만족하는 대상 검색 sql =\"select * from itwill_basket \" + \"where b_m_id=? and b_g_num=? and b_g_size=? and b_g_color=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, bkdto.getB_m_id()); pstmt.setInt(2, bkdto.getB_g_num()); pstmt.setString(3, bkdto.getB_g_size()); pstmt.setString(4, bkdto.getB_g_color()); rs = pstmt.executeQuery(); if(rs.next()){ //중복상품인 경우 result = 1; //구매수량 수정 sql =\"update itwill_basket set b_g_amount=b_g_amount+? \" + \"where b_m_id=? and b_g_num=? and \" + \"b_g_size=? and b_g_color=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bkdto.getB_g_amount()); pstmt.setString(2, bkdto.getB_m_id()); pstmt.setInt(3, bkdto.getB_g_num()); pstmt.setString(4, bkdto.getB_g_size()); pstmt.setString(5, bkdto.getB_g_color()); pstmt.executeUpdate(); System.out.println(\"기존의 상품에 수량 변경완료!\"); } System.out.println(\"기존의 상품 확인 결과: \"+(result==1? \"중복상품이 있다\":\"중복상품이 없다\")); sql = \"insert into itwill_basket\"; }catch(Exception e){ e.printStackTrace(); }finally { closeDB(); } return result;}//end of checkGoods() BasketDAO.java에 basketAdd()메서드 코드 추가123456789101112131415161718192021222324252627282930313233//장바구니에 담기public void basketAdd(BasketDTO bkdto) { int b_num = 0; try{ getCon(); //1. 장바구니 번호계산 sql = \"select max(b_num) from itwill_basket\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); if(rs.next()){ b_num = rs.getInt(1)+1; //인덱스 사용 호출 //rs.getInt(\"max(bno)\"); // 컬럼명 사용 호출 } System.out.println(\"DAO : b_num은 \"+b_num); //2.나머지 전달정보 DB에 저장 sql = \"insert into itwill_basket values(?,?,?,?,?,\" + \"?,now())\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, b_num); pstmt.setString(2, bkdto.getB_m_id()); pstmt.setInt(3, bkdto.getB_g_num()); pstmt.setInt(4, bkdto.getB_g_amount()); pstmt.setString(5, bkdto.getB_g_size()); pstmt.setString(6, bkdto.getB_g_color()); pstmt.executeUpdate(); System.out.println(\"장바구니 담기 성공\"); }catch(Exception e){ e.printStackTrace(); }finally { closeDB(); }}//end of basketAdd()","link":"/2020/09/14/200915jspi3basket/"},{"title":"Servlet장바구니3 : 장바구니리스트, 장바구니에서 상품삭제","text":"BasketFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 123456789101112131415 //장바구니 리스트}else if(command.equals(\"/BasketList.ba\")){ System.out.println(\"C: /BasketList.ba 호출\"); //DB - &gt; JSP페이지출력 action = new BasketListAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); } //장바구니에서 상품 삭제}else if(command.equals(\"/BasketDelete.ba\")){ System.out.println(\"C: /BasketDelete.ba 호출\"); //.jsp -&gt; Action_DAO_DB -&gt;.ag로 이동 action = new BasketDeleteAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} BasketListAction.java 생성 List 2개를 한꺼번에 가져가는 방법은? 한 개의 리스트안에 두 개의 리스트를 넣으면 된다! 리스트가 여러개이면 헷갈리니까 여기서는 Vector로 받을 것이다. Vector와 ArrayList의 차이점은 동기화! 자세한 건 위의 링크를 참고 request에 저장할때 : 두 줄 코드를 한줄코드로 작성할 수 있어야한다. 123456//두줄코드List&lt;BasketDTO&gt; basketList =(List&lt;BasketDTO&gt;) totalData.get(0);request.setAttribute(\"basketList\", basketList);//한줄코드request.setAttribute(\"basketList\", totalData.get(0)); request에 저장할때 원래 정보는 벡터에 저장되어 있지만, Action페이지에서 벡터의 정보를 꺼내서 각각 request에 저장해서 전달 이유1: view에서는 복잡한 코드가 있으면 안된다. View에서는 복잡한 연산을 피해야함. 바로 사용가능한 List형태로 전달하는것이 좋다. 123456//덩어리채로 request에 저장request.setAttribute(\"totalData\", totalData);//각각 꺼내서 request에 저장request.setAttribute(\"basketList\", totalData.get(0));request.setAttribute(\"goodsList\", totalData.get(1)); 전체코드123456789101112131415161718192021222324252627282930313233public class BasketListAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : BasketListAction의 execute() 호출\"); // 로그인 정보 (로그인 처리필요) HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(false); return forward; } //한글처리 request.setCharacterEncoding(\"UTF-8\"); //BasketDAO 이용하여 장바구니 정보(옵션, 구매수량)+해당 상품정보(이름,이미지,가격) 가져오는 메서드 호출 BasketDAO bkdao = new BasketDAO(); Vector totalData = bkdao.getBasketList(id); //저장 request.setAttribute(\"basketList\", totalData.get(0)); request.setAttribute(\"goodsList\", totalData.get(1)); //페이지이동 forward.setPath(\"./goods_order/goods_basket.jsp\"); forward.setRedirect(false); return forward; }} BasketDAO.java 생성 후 getBasketList()메서드 코드 추가12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//장바구니리스트public Vector getBasketList(String id) { //1. 변수생성 Vector totalData = new Vector(); //상품정보 List&lt;GoodsDTO&gt; goodsList = new ArrayList&lt;GoodsDTO&gt;(); //장바구니정보 List&lt;BasketDTO&gt; basketList = new ArrayList&lt;BasketDTO&gt;(); try{ getCon(); //2. 장바구니 정보 탐색 (id기준으로) sql =\"select * from itwill_basket where b_m_id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); rs = pstmt.executeQuery(); while(rs.next()){ System.out.println(\"&gt;&gt;&gt; 바스켓 rs while시작\"); BasketDTO bkdto = new BasketDTO(); bkdto.setB_date(rs.getDate(\"b_date\")); bkdto.setB_g_amount(rs.getInt(\"b_g_amount\")); bkdto.setB_g_color(rs.getString(\"b_g_color\")); bkdto.setB_g_num(rs.getInt(\"b_g_num\")); bkdto.setB_g_size(rs.getString(\"b_g_size\")); bkdto.setB_m_id(rs.getString(\"b_m_id\")); bkdto.setB_num(rs.getInt(\"b_num\")); //리스트에 저장 basketList.add(bkdto); //장바구니에 저장된 상품정보를 불러오기 //덮어쓰는 꼴이 되기때문에 PreparedStatement와 ResultSet 객체를 다시 생성해야한다. sql =\"select * from itwill_goods where gno=?\"; PreparedStatement pstmt2 = con.prepareStatement(sql); pstmt2.setInt(1, bkdto.getB_g_num()); ResultSet rs2 = pstmt2.executeQuery(); if(rs2.next()){ System.out.println(\"&gt;&gt;&gt; 굿즈 rs if시작\"); GoodsDTO gdto = new GoodsDTO(); gdto.setImage(rs2.getString(\"image\")); gdto.setName(rs2.getString(\"name\")); gdto.setPrice(rs2.getInt(\"price\")); // 나머지 정보는 필요에 따라 추가 가능 // 상품 리스트에 저장 goodsList.add(gdto); } System.out.println(\"&gt;&gt;&gt; 굿즈 rs if끝\"); }//end of while System.out.println(\"&gt;&gt;&gt; 바스켓 rs while끝\"); System.out.println(\"상품 정보 : \"+goodsList); System.out.println(\"장바구니 정보 : \"+basketList); // 장바구니 정보, 상품정보를 모두 저장완료 totalData.add(basketList); totalData.add(goodsList); System.out.println(\"백터 정보 확인 : \"+totalData); }catch(Exception e){ e.printStackTrace(); }finally { closeDB(); } return totalData;}//end of 장바구니리스트 goods_basket.jsp 생성123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%//한글처리request.setCharacterEncoding(\"UTF-8\");//basketList에서 구현한 정보를 전달받아서 처리List basketList = (List) request.getAttribute(\"basketList\");List goodsList = (List) request.getAttribute(\"goodsList\");BasketDTO bk = (BasketDTO) basketList.get(0);%&gt;&lt;!-- 장바구니 번호, 사진(대표이미지), 상품명, 사이즈,색상,수량,가격, 삭제 --&gt; &lt;table border=\"1\"&gt; &lt;caption&gt;&lt;%=bk.getB_m_id() %&gt;님의 장바구니&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;번호&lt;/td&gt; &lt;td&gt;사진&lt;/td&gt; &lt;td&gt;상품명&lt;/td&gt; &lt;td&gt;크기&lt;/td&gt; &lt;td&gt;색상&lt;/td&gt; &lt;td&gt;수량&lt;/td&gt; &lt;td&gt;가격&lt;/td&gt; &lt;td&gt;삭제&lt;/td&gt; &lt;/tr&gt; &lt;% //EL태그는 FOR문과 상관없이 &lt;c:forEach&gt; 사용해서 출력해야한다. for(int i=0; i&lt;basketList.size(); i++){ BasketDTO bkdto = (BasketDTO) basketList.get(i); GoodsDTO gdto = (GoodsDTO) goodsList.get(i); %&gt; &lt;tr&gt; &lt;!-- 순차넘버링 --&gt; &lt;td&gt;&lt;%=i+1%&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=\"./upload/&lt;%=gdto.getImage().split(\",\")[0] %&gt;\" height=\"100px\"&gt;&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bkdto.getB_g_size() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bkdto.getB_g_color() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bkdto.getB_g_amount() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getPrice() %&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=\"button\" class=\"btn\" value=\"[장바구니에서 삭제]\" onclick=\"location.href='./BasketDelete.ba?b_num=&lt;%=bkdto.getB_num()%&gt;'\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;%} %&gt; &lt;/table&gt;&lt;input type=\"button\" class=\"btn\" value=\"[구매하기]\" onclick=\"location.href='./OrderStar.or'\"&gt;&lt;input type=\"button\" class=\"btn\" value=\"[계속 쇼핑하기]\" onclick=\"location.href='./GoodsList.go'\"&gt; BasketDeleteAction.java 생성123456789101112131415161718192021public class BasketDeleteAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : BasketDeleteAction의 execute() 호출\"); //전달정보 저장 int b_num = Integer.parseInt(request.getParameter(\"b_num\")); //BoardDAO객체생성 deleteBoard BasketDAO bkdao = new BasketDAO(); bkdao.deleteBasket(b_num); System.out.println(\"M: 장바구니에서 삭제 완료\"); //장바구니list로 이동 ActionForward forward = new ActionForward(); forward.setPath(\"./BasketList.ba\"); forward.setRedirect(true); return forward; }}","link":"/2020/09/14/200915jspi4/"},{"title":"Servlet구매하기1 : 기초","text":"`web.xml’에 코드 추가 web.xml 코드 수정 후 꼭 서버 실행 후 주소창에 test.bo해서 흰 화면이 뜨는지 확인하고 코딩할 것 흰화면이 안뜨면 web.xml 설정이 잘못되었다는 의미임. 123456789&lt;!-- Model2 구매하기 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;OrderFrontController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itwillbs.order.action.OrderFrontController&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;OrderFrontController&lt;/servlet-name&gt; &lt;url-pattern&gt;*.or&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; OrderFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class OrderFrontController extends HttpServlet { // 일반 클래스를 서블릿을 상속해서 컨트롤러 역활 할수있도록 설정 protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"doProcess() 호출 (페이지 GET/POST방식 모두 사용호출)\"); // 주소 비교 (주소 매핑) System.out.println(\"--------------@ 주소 계산 @-------------\"); // 프로젝트명 + 주소 String requestURI = request.getRequestURI(); System.out.println(\" requestURI : \" + requestURI); // 프로젝트명 String contextPath = request.getContextPath(); System.out.println(\" contextPath : \" + contextPath); // 가상주소 String command = requestURI.substring(contextPath.length()); System.out.println(\" command(가상주소) : \" + command); System.out.println(\"--------------@ 주소 비교후 처리 @-------------\"); Action action = null; ActionForward forward = null; // 주소에 따른 처리 구분 (주소 매핑후 이동) System.out.println(\"-----------------@ 페이지 이동 @--------------\"); if(forward != null){ // 이동할 정보가 있다 if(forward.isRedirect()){ // true - sendRedirect() // 가상주소(.bo -&gt; .bo), 화면전환(주소변경,화면 변경) System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(Redirect)\"); response.sendRedirect(forward.getPath()); }else{ // false - forward() System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(forward)\"); // 가상주소 -&gt; 실제페이지 (.bo -&gt; .jsp) + reqeust 객체 정보를 가지고 이동 RequestDispatcher dis = request.getRequestDispatcher(forward.getPath()); dis.forward(request, response); } }//end of 페이지이동 }//end of doProcess @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet() 호출 (페이지 GET방식 호출)\"); doProcess(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost() 호출 (페이지 POST방식 호출)\"); doProcess(req, resp); }} Action.java 생성12345678910111213public interface Action { // 상수,추상메서드 // 추상메서드 -&gt; 서브클래스들 한태 강제성 부여 // =&gt; 개발 형식의 통일(틀이 정해짐) // =&gt; 객체간의 관계가 약화됨 =&gt; 각각의 객체가 해당 동작만 처리/제어 // Action 페이지의 동작을 미리 선언해서 사용 public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception; } ActionForward.java 생성1234567891011121314151617181920212223242526272829public class ActionForward { //1.외부접근 못하도록 이동할 페이지와 이동할 방식 멤버변수 생성 private String path; private boolean isRedirect; // true면 sendRedirect방식으로 이동 //사용처: 주소와 화면의 전환이 동시에 일어날때 (가상주소 -&gt; 가상주소로 ) // false면 forward방식으로 이동 //사용처: 주소는 그대로인데 화면이 바뀔때 (가상주소에서 jsp보여줌) //2. getter setter생성 public String getPath() { return path; } public void setPath(String path) { this.path = path; } public boolean isRedirect() { return isRedirect; } public void setRedirect(boolean isRedirect) { this.isRedirect = isRedirect; } //3.toString @Override public String toString() { return \"ActionForward [path=\" + path + \", isRedirect=\" + isRedirect + \"]\"; }} OrderDTO.java생성 DB테이블을 생성후 DTO를 아래 코드와 같이 생성한다 DB테이블 생성시 주의사항 : 테이블명 order 불가능 why? order by랑 비슷해서 테이블명이 아닌 명령어로 처리하려하기 때문. 그럼 실무에선 주로 어떻게 쓸까? tbl_order : 실무에서 자주 사용함 123456789101112131415161718192021222324252627282930313233343536public class OrderDTO { private int o_num; private String o_trade_num; private int o_g_num; private String o_g_name; private int o_g_amount; private String o_g_size; private String o_g_color; private String o_m_id; private String o_receive_name; private String o_receive_addr1; private String o_receive_addr2; private String o_receive_phone; private String o_receive_memo; private int o_sum_money; private String o_trade_type; private String o_trade_payer; private Date o_trade_date; private String o_trans_num; private Date o_date; private String o_status; public int getO_num() { return o_num; } public void setO_num(int o_num) { this.o_num = o_num; } public String getO_trade_num() { return o_trade_num; } (중략)} OrderDAO.java 생성 DB연결메서드 생성 자원해제 메서드 생성 123456789101112131415161718192021222324252627public class OrderDAO { Connection con = null; PreparedStatement pstmt = null; ResultSet rs = null; String sql = \"\"; // 디비 연결 private void getCon() throws Exception{ // 커넥션 풀 Context init = new InitialContext(); DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/model2DB\"); con = ds.getConnection(); System.out.println(\"DAO : 디비연결 완료 \"+con); }//end of getCon() // 디비 자원해제 public void closeDB(){ try { if(rs != null) {rs.close(); } if(pstmt != null) {pstmt.close(); } if(con != null) {con.close(); } } catch (SQLException e) { e.printStackTrace(); } }//end of closeDB()}","link":"/2020/09/15/200916jspi/"},{"title":"DB유저관리 : user 생성, 권한부여, 패스워드관리","text":"user 생성 create user 권한 소유자가 DB에 USER 생성 가능 user명, 초기패스워드를 설정하여 유저를 생성한 뒤 어떤 권한을 줄지 확인 1234567891011121314151617181920$&gt; conn sys/oracle as sysdba$&gt; create user demo identified by 초기패스워드;$&gt; conn demo/초기패스워드//출력값ERROR: DB에 접속할 수 있는 권한 부족//에러 발생하여 현재 접속된 유저가 없는 상태이다SQL&gt; conn sys/oracle as sysdbaConnected.SQL&gt; grant create session, create table 2 to demo;Grant succeeded.//권한이 생겨서 접속 성공SQL&gt; conn demo/demoConnected.SQL&gt; show userUSER is \"DEMO\" 명령어로 user 생성 default로 설정한 테이블스페이스의 공간할당을 user생성시 바로 처리한다. default T/S외 다른 T/S(ex user, system, sysaux, 새로_생성한_T/S) undo, temp는 디폴트 T/S로 사용할 수 없다. system, sysaux는 default T/S로 설정하는 것은 좋지 않다. 12345678910111213141516//기본값create user 새로운_유저명identified by 새로운_비밀번호default tablespace 테이블스페이스명temporary tablespace tempquota 사이즈 on 위와_동일한_테이블스페이스명quota 사이즈 on users;//예시create user testidentified by testdefault tablespace exampletemporary tablespace tempquota 30M on examplequota 20M on users; EM으로 user 생성 user계정잠금 유저한 명이 퇴사한 경우 lock하지않으면 그 계정으로 해킹시도가 일어날 수 있다. 후임자가 들어오면 unlock하면 됨 12345//계정잠금$&gt; alter user 유저명 account lock;//계정잠금해제$&gt; alter user 유저명 account unlock; 권한유형 2가지 권한유형 개념 소유자 System권한 DB를 조작할 수 있는 권한. 대략 100개 정도 된다. DBA Object권한 Object를 조작할 수 있는 권한. Object소유자 System권한System권한 부여 with admin option 옵션 : sys사용자가 나눠준 옵션을 다른 유저에게 나눠줄 수 있는 권한을 주는 옵션 123456789101112SQL&gt; conn sys/oracle as sysdbaConnected.SQL&gt; grant create session, create table, create sequence, create view 2 to demo 3 with admin option;Grant succeeded.SQL&gt; conn demo/demoConnected.SQL&gt; show userUSER is \"DEMO\" System권한 회수 with admin option 옵션으로 퍼져나간 시스템권한도 연쇄적으로 같이 회수될까? 퍼져나간 시스템권한은 연쇄적으로 회수되지않는다. 직접 명령어를 실행(revoke)해서 시스템권한을 각각 회수해야한다. 123456SQL&gt; conn sys/oracle as sysdbaConnected.SQL&gt; revoke create table 2 from demo;Revoke succeeded. Object권한Object권한 부여 hr사용자의 employees테이블의 내용을 select해보자 with grant option 옵션 : 오브젝트소유자가 나눠준 권한을 받은 유저가 다른 유저에게 자신이 받은 오브젝트 권한을 나눠줄 수 있다. 12345678SQL&gt; conn demo/demoConnected.SQL&gt; col last_name format a20SQL&gt; select employee_id, last_name 2 from employees ERROR at line 2:ORA-00942: table or view does not exist ERROR가 발생한다 =&gt; demo 사용자가 가지고 있는 employees테이블이 없기때문에 우린 다른 유저인 hr소유의 테이블을 검색하고싶다 어떻게 해야할까? Object의 소유자인 hr을 테이블명앞에 명시해보자. 12345SQL&gt; select employee_id, last_name 2 from hr.employees;ERROR at line 2:ORA-00942: table or view does not exist 여전히 에러가 발생한다. 왜일까? =&gt; 권한이 없기때문에 권한은 누가 줄수있을까? 원칙적으로 object의 소유자인 hr이 demo에게 권한을 줘야한다. DBA인 sys도 권한을 줄 수 있다. sys가 demo사용자에게 hr소유의 권한을 줄때의 명령어는 아래와 같다.123grant select, inserton hr.employeesto demo; 권한으로 뭘 줄수있을까? select, insert, update, delete 등등 1234567891011121314151617SQL&gt; conn hr/hrConnected.SQL&gt; grant select, insert 2 on employees 3 to demo 4 with grant option;Grant succeeded.SQL&gt; select employee_id, last_name 2 from hr.employees;EMPLOYEE_ID LAST_NAME----------- -------------------- 174 Abel (중량)107 rows selected. 성공적으로 실행됨을 확인할 수 있다. Object권한 회수 with grant option 옵션으로 퍼져나간 오브젝트권한도 연쇄적으로 회수가능할까? 퍼져나간 오브젝트권한도 연쇄적으로 회수 가능하다.(cascade효과) 123456789101112131415SQL&gt; conn hr/hrConnected.SQL&gt; revoke select, insert 2 on employees 3 from demo;Revoke succeeded.SQL&gt; conn demo/demoConnected.SQL&gt; 1 select employee_id, last_name 2* from hr.employees;ERROR at line 2:ORA-00942: table or view does not exist 패스워드관리 초기패스워드는 DBA가 생성한다. 패스워드 변경하는 명령어 user생성 시 profile에 대한 정의를 생략하면 default profile을 할당받는다. 123456789//기본형alter user 유저명indentified by 새로운_비밀번호;//예시SQL&gt; alter user demo 2 identified by a1234;User altered. profile(프로파일) uesr의 패스워드 관리 방법이 정의된 파일 모든 user는 반드시 하나의 profile을 할당받는다. profile 내 암호 보안 기능 설정 종류 명령어 설명 FAILED_LOGIN_ATTEMPTS 로그인 시도 실패 횟수 지정 PASSWORD_LOCK_TIME 지정된 로그인 연속 실패 횟수 이후 LOCK 상태로 유지되는 기간일 지정 PASSWORD_LIFE_TIME 암호가 만료되기 전 사용할 수 있는 기간 지정. 이 기간 내에 암호를 바꾸지 않으면 암호가 만료되어 이후 연결 거부 PASSWORD_GRACE_TIME 암호 만료 후 비밀번호 변경을 위한 유예기간(경고는 표시하지만 로그인을 허용) 지정. 유예 기간 동안 암호를 바꾸지 않으면 암호가 만료됨 PASSWORD_REUSE_TIME 암호를 재사용할 수 있는 기간 지정. PASSWORD_REUSE_TIME을 정수 값으로 설정한 경우에는 PASSWORD_REUSE_MAX를 UNLIMITED로 설정해야 함 PASSWORD_REUSE_MAX 현재 암호를 재사용할 수 있기 전에 필요한 암호 변경 횟수 지정. PASSWORD_REUSE_MAX를 정수 값으로 설정한 경우에는 PASSWORD_REUSE_TIME을 UNLIMITED로 설정해야 함 PASSWORD_VERIFY_FUNCTION 암호 복잡성 검사를 수행할 PL/SQL 함수를 CREATE PROFILE문에 인수로 전달함. ex) 비번은 영문대소문자와 특수묹 혼합 8글자이상이면서 아이디와 비번 똑같이 설정 금지하는 함수. 오라클이 기본적으로 제공하는 함수 $&gt; @?/rdbms/admin/utlpwdmg.sql PROFILE 생성할 프로파일 이름","link":"/2020/09/20/200921dbi/"},{"title":"200922코테준비방법등에 관한 상담","text":"코딩테스트 백준알고리즘, 프로그래머스 사이트를 통해 문제를 많이 풀 것. 코테 공부는 아래 내용을 중점삼아 공부해야한다. 객체 컬렉션(자료구조) 예외처리 람다식 java8버전부터 가능한 스트림 코테시 주의사항 절대 자책하지 말 것. 풀리지않으면 답을 보고 이해하는 데 중점을 맞출 것 java API배포 jsp는 유료 배포해야한다. 카페24 유료호스팅 설치비용 + 매달 호스팅비 이력서사이트 로켓펀치, 링크드인, 원티드에 이력서를 오픈해놓으면 해드헌터가 연락올 수 있다. 이력서를 오픈해놓을 것. 이력서팁 전혀 다른 업계라도 3년이라는 공백기가 생기지 않도록 경력기술을 해야한다. 이전 업계의 자격증과 교육, 경험들은 큰 것만 기술하고 나머지는 버린다. 주객전도가 될 수 있기때문. 영어경험 어필하는 건 매우 좋다. 포트폴리오 깃허브 추가계정을 생성하여 포트폴리오전용으로 활용할 수 있다. 기존 기능을 내 손으로 다시 만드는 것도 기술이고 능력이다. 개인프로젝트의 새로운 것을 찾기가 어렵다면 기존의 것을 자신만의 스타일로, 아니면 자신이 직접 다시 만들어도 좋다 자바API로 배포를 한다는 의미는 라이브러리를 만드는 것과 같다. 우리가 라이브러리 다운로드해서 쓰듯이 다운로드해서 사용할 수 있게 만들어야한다 이때 주의점은 저작권과 권한설정이다.","link":"/2020/09/21/200922journal/"},{"title":"DB fail 유형","text":"DB fail 유형 Statement fail User proc fail Network fail User error Instance fail Media fail Statement fail DB에 발생된 명령문(SQL구문)이 정상적으로 실행되지 않고 오류가 발생된 경우 원인 : 오타, 문법오류, 권한 부족, 공간 부족 등 해결 : 명령문 재작성, 권한 부여, 공간 부여 등 User proc fail DB에 접속된 user가 비정삭적으로 접속을 종료한 경우 원인 user가 비정상적으로 접속을 종료한 경우 DBA에 의해 session이 kill된 경우 Client PC가 다운된 경우 Network 불안정해서 접속이 끊어진 경우 해결 : 재접속하면 됨 &lt;- PMON이 알아서 트랜잭션 롤백 및 LOCK해제함 Network fail DB가 정상적으로 켜져 있는데 DB에 접속이 안되는 경우 원인 리스너가 꺼져있는 경우 Network가 불안정해서 DB접속이 아예 안되는 경우 해결 리스너 켜고 DB재시작 (순서중요) Newwork 안정화 작업 요청(DBA가 네트워크관리자에게 요청) User error(사용자 실수) DB에 발생된 명령어(SQL)구문이 정상적으로 실행되었으나 잘못된 작업을 진행한 경우 원인 : 잘못된 DML과 DDL 등 해결 트랜잭션 진행 중인 경우 rollback commit을 이미 한 경우 반대의 작업을 다시 수행해야함(insert했다면 delete하고…) 테이블을 실수로 삭제했다면 flashback Instance fail DB가 비정상적으로 종료된 경우 원인 DBA가 DB를 비정상종료(abort)한 경우 server pc가 다운되거나 정전이 발생한 경우 instance내 필수 구성요소 중 하나에 오류가 발생한 경우 해결 : DB재시작하면 됨 &lt;- DB가 재시작하는 동안에 SMON이 DB동기화 맞춰준다. Media fail 가장 심각한 오류 DB를 구성하는 필수 물리적인 파일 중 하나가 손실/손상된 경우 필수 물리적 파일 = datafile, controlfile, redologfile 원인 : 운영체제에서 datafile, controlfile, redologfile을 실수로 삭제한 경우 해결 datafile : 백업파일로부터 복구작업 진행해야한다. controlfile : 다중화된 파일로부터 복구 작업 진행해야한다. redologfile : 다중화된 파일로부터 복구 작업 진행해야한다.","link":"/2020/09/21/200922dbi2/"},{"title":"데이터충돌, DeadLock","text":"데이터충돌 = 세션충돌 = Lock충돌 Lock 동일한 시간에 동일한 데이터에 대해 서로 다른 세션이 동시에 적업하는 것을 막기위해 oracle은 DML발생시 관련행 단위로 LOCK을 구현. LOCK은 트랜잭션 종료(commit, rollback)시 해제된다. LOCK의 최소 단위는 행이다. LOCK이 구현된 행에 작업 요청 시 Queue(큐)에서 기다린다. ORACLE이 자동으로 락을 걸고 해지시켜준다. Lock 충돌발생하는 경우 커밋되지 앟은 트랜잭션 긴 트랜잭션 일반적인 Lock충돌(블로킹) 해결방법 블로킹 : 트랜잭션이 처리될 때 락이 걸림. 락이 해지 될때 까지 다른 트랜잭션이 해당 자원에 접근할 수 없음. DBA에서 문의(LOCK충돌인지 DB가 뻗어버린건지 모르니 확인해달라고 요청해야함) 블럭킹 하는 세션 132, 블럭킹 당하고 있는 세션 355 1234567891011121 select username, sid, serial#, blocking_session2 from v$session3 where username is not null;//출력값USERNAME SID SERIAL# BLOCKING_SESSION------------------------------ ---------- ---------- ----------------SYS 3 22449HR 132 2558SYS 243 41831HR 249 63962HR 355 16534 132 DBA는 kill할 세션 확인 후 아래 쿼리 실행 보통 블럭킹하고 있는 세션에게 commit해달라고 요청 후 kill해야한다. 12SQL&gt; alter system kill session '132, 2558' immediate;System altered. 교착상태(DeadLock) Lock충돌 해결방법 두 개 이상의 트랜잭션이 서로에게 락을 걸어 블로킹이 끊나지 않아 교착상태에 빠짐. (상대방이 원하는 자원을 내가 가지고 있고, 내가 원하는 자원을 상대방이 가진 경우. 서로 맞물린 상태.) DB에서 자동 감지하고 자동으로 해결해준다. DBA가 해결 할 필요 없다. DB의 해결방법 : 두 세션 중 비용적인 측면을 고려하여 하나의 세션을 선택한 다음 교착상태(DeadLock)이 발생되었다는 메세지와 함께 작업창을 열어준다. -&gt; 열린 작업창은 작업을 양보해라는 의미이다. COMMIT할지 ROLLBACK할지 선택해야한다. COMMIT : deadlock걸린 작업을 제외한 모든 작업들을 저장해준다. ROLLBACK : 모든 작업을 롤백한다. 참고 : http://blog.naver.com/PostView.nhn?blogId=sam_sist&amp;logNo=221009631931&amp;parentCategoryNo=&amp;categoryNo=&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postView","link":"/2020/09/21/200922dbi/"},{"title":"Servlet구매하기3 : 주문목록 및 주문 상세정보 자세히","text":"OrderFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 구매했던 내역의 정보를 확인하는 페이지를 만들어보자 1234567 //주문목록}else if(command.equals(\"/OrderList.or\")){ System.out.println(\"C: /OrderList.or 호출\"); action = new OrderListAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} OrderListAction.java 생성123456789101112131415161718192021222324252627282930public class OrderListAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : OrderListAction의 execute() 호출\"); // 한글처리 request.setCharacterEncoding(\"UTF-8\"); // 로그인 정보 (로그인 처리필요) HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } //orderdao + 전달된 정보를 저장 OrderDAO odao = new OrderDAO(); request.setAttribute(\"orderList\", odao.getOrderList(id)); //페이지이동 forward.setPath(\"./goods_order/order_list.jsp\"); forward.setRedirect(false); return forward; }} OrderDAO.java 생성 후 getOrderList()메서드 코드 추가123456789101112131415161718192021222324252627282930313233343536//주문정보 가져오기public List&lt;OrderDTO&gt; getOrderList(String id) { List&lt;OrderDTO&gt; orderList = new ArrayList&lt;OrderDTO&gt;(); try { getCon(); sql=\"select o_trade_num,o_g_name,o_g_amount,o_g_size,o_g_color,\" + \"sum(o_sum_money) as o_sum_money,\" + \"o_trade_type,o_trans_num,o_date,o_status \" + \"from itwill_order where o_m_id=? \" + \"group by o_trade_num \" + \"order by o_trade_num\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); rs = pstmt.executeQuery(); while(rs.next()){ OrderDTO odto = new OrderDTO(); odto.setO_trade_num(rs.getString(\"o_trade_num\")); odto.setO_g_name(rs.getString(\"o_g_name\")); odto.setO_g_amount(rs.getInt(\"o_g_amount\")); odto.setO_g_size(rs.getString(\"o_g_size\")); odto.setO_g_color(rs.getString(\"o_g_color\")); odto.setO_sum_money(rs.getInt(\"o_sum_money\")); odto.setO_trade_type(rs.getString(\"o_trade_type\")); odto.setO_trans_num(rs.getString(\"o_trans_num\")); odto.setO_date(rs.getDate(\"o_date\")); odto.setO_status(rs.getInt(\"o_status\")); orderList.add(odto); } } catch (Exception e) { e.printStackTrace(); }finally { closeDB(); } return orderList;}//end of getOrderList() order_list.jsp 생성 (jsp사용)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;%System.out.println(\"V : 주문목록 출력페이지\");// OrderListAction에서 전달된// orderList 정보를 저장사용List orderList = (List)request.getAttribute(\"orderList\");%&gt;&lt;table border=\"1\"&gt;&lt;tr&gt; &lt;td&gt;주문번호&lt;/td&gt; &lt;td&gt;상품명&lt;/td&gt; &lt;td&gt;결재 방법&lt;/td&gt; &lt;td&gt;주문금액&lt;/td&gt; &lt;td&gt;주문상태&lt;/td&gt; &lt;td&gt;주문일시&lt;/td&gt; &lt;td&gt;운송장번호&lt;/td&gt;&lt;/tr&gt;&lt;% for(int i=0;i&lt;orderList.size();i++){ OrderDTO ordto = (OrderDTO)orderList.get(i);%&gt;&lt;tr&gt; &lt;td&gt; &lt;a href=\"./OrderDetail.or?trade_num=&lt;%=ordto.getO_trade_num() %&gt;\"&gt; &lt;%=ordto.getO_trade_num() %&gt; &lt;/a&gt; &lt;/td&gt; &lt;td&gt;&lt;%=ordto.getO_g_name() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=ordto.getO_trade_type() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=ordto.getO_sum_money() %&gt;&lt;/td&gt; &lt;% // 주문상태 // 0 - \"대기중\" // 1 - \"발송준비\" // 2 - \"발송완료\" // 3 - \"배송중\" // 4 - \"배송완료\" // 5 - \"주문취소\" String status=\"\"; switch(ordto.getO_status()){ case 0: status=\"대기중\"; break; case 1: status=\"발송준비\"; break; case 2: status=\"발송완료\"; break; case 3: status=\"배송중\"; break; case 4: status=\"배송완료\"; break; case 5: status=\"주문취소\"; break; default: status=\"관리자 문의\"; } %&gt; &lt;td&gt;&lt;%=status %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=ordto.getO_date() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=ordto.getO_trans_num() %&gt;&lt;/td&gt;&lt;/tr&gt;&lt;%} %&gt;&lt;/table&gt;&lt;h2&gt;&lt;a href=\"./Main.me\"&gt; 메인페이지 &lt;/a&gt;&lt;/h2&gt; order_list.jsp 생성 (EL표현식사용) &lt;c:forEach var=&quot;orderList&quot; items=&quot;${orderList}&quot;&gt; 사용시 주의사항 var이름은 해당 페이지에서 사용 할 변수명이다. items는 request.setAttribute객체로 담아온 이름을 써야한다. EL같은 경우 DecimalFormat 클래스가 대신 fmt:formatNumber태그를 이용하여 쉽게 천의 단위로 포맷팅할 수 있다. &lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt; 임포트해줘야한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;%System.out.println(\"V : 주문목록 출력페이지\");// OrderListAction에서 전달된// orderList 정보를 저장사용 - EL표현식사용하려면 아래 코드없이 바로 사용가능// List orderList =(List)request.getAttribute(\"orderList\");%&gt;&lt;table border=\"1\"&gt;&lt;tr&gt; &lt;th&gt;주문번호&lt;/th&gt; &lt;th&gt;상품명&lt;/th&gt; &lt;th&gt;결제 방법&lt;/th&gt; &lt;th&gt;주문금액&lt;/th&gt; &lt;th&gt;주문상태&lt;/th&gt; &lt;th&gt;주문일시&lt;/th&gt; &lt;th&gt;운송장번호&lt;/th&gt;&lt;/tr&gt;&lt;c:forEach var=\"orderList\" items=\"${orderList}\"&gt;&lt;tr&gt; &lt;td&gt;&lt;a href=\"./OrderDetail.or?trade_num=${orderList.o_trade_num }\"&gt;${orderList.o_trade_num }&lt;/a&gt;&lt;/td&gt; &lt;td&gt;${orderList.o_g_name }&lt;/td&gt; &lt;td&gt;${orderList.o_trade_type }&lt;/td&gt; &lt;td&gt;&lt;fmt:formatNumber value=\"${orderList.o_sum_money }\" pattern=\"#,###원\" /&gt;&lt;/td&gt; &lt;td&gt; &lt;c:choose&gt; &lt;c:when test=\"${orderList.o_status == 0}\"&gt; &lt;b&gt;&lt;font color=\"blue\"&gt;대기중&lt;/font&gt;&lt;/b&gt; &lt;/c:when&gt; &lt;c:when test=\"${orderList.o_status == 1}\"&gt; &lt;b&gt;발송준비&lt;/b&gt; &lt;/c:when&gt; &lt;c:when test=\"${orderList.o_status == 2}\"&gt; &lt;b&gt;발송완료&lt;/b&gt; &lt;/c:when&gt; &lt;c:when test=\"${orderList.o_status == 3}\"&gt; &lt;b&gt;&lt;font color=\"red\"&gt;배송중&lt;/font&gt;&lt;/b&gt; &lt;/c:when&gt; &lt;c:when test=\"${orderList.o_status == 4}\"&gt; &lt;b&gt;&lt;font color=\"green\"&gt;배송완료&lt;/font&gt;&lt;/b&gt; &lt;/c:when&gt; &lt;c:when test=\"${orderList.o_status == 5}\"&gt; &lt;b&gt;주문취소&lt;/b&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;b&gt;관리자에게 문의하세요&lt;/b&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/td&gt; &lt;td&gt;${orderList.o_date }&lt;/td&gt; &lt;td&gt;${orderList.o_trans_num }&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;input type=\"button\" class=\"btn\" value=\"메인페이지로\" onclick=\"location.href='./Main.me'\"&gt;","link":"/2020/09/21/200922jspi/"},{"title":"Servlet구매하기4 : 주문 상세정보페이지","text":"OrderFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 구매했던 내역의 정보를 상세히 확인하는 페이지를 만들어보자 1234567 //주문목록 상세}else if(command.equals(\"/OrderDetail.or\")){ System.out.println(\"C: /OrderDetail.or 호출\"); action = new OrderDetailAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} OrderDetailAction.java 생성1234567891011121314151617181920212223242526272829303132public class OrderDetailAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : OrderDetailAction의 execute() 호출\"); // 한글처리 request.setCharacterEncoding(\"UTF-8\"); // 로그인 정보 (로그인 처리필요) HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } // 주문번호 (trade_num) 저장(파라미터) String trade_num = request.getParameter(\"trade_num\"); // DAO - 주문번호에 해당하는 정보 전부 가져오기 OrderDAO odao = new OrderDAO(); request.setAttribute(\"orderDetailList\", odao.getOrderDetail(trade_num)); // 페이지 이동(\"./goods_order/order_detail.jsp\") forward.setPath(\"./goods_order/order_detail.jsp\"); forward.setRedirect(false); return forward; }} OrderDAO.java 생성 후 getOrderDetail()메서드 코드 추가1234567891011121314151617181920212223242526272829303132//주문목록 상세페이지public List&lt;OrderDTO&gt; getOrderDetail(String trade_num) { List&lt;OrderDTO&gt; orderDetailList = new ArrayList&lt;OrderDTO&gt;(); try { getCon(); sql=\"select * from itwill_order wehre o_trade_num=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, trade_num); rs = pstmt.executeQuery(); while(rs.next()){ OrderDTO odto = new OrderDTO(); odto.setO_trade_num(rs.getString(\"o_trade_num\")); odto.setO_g_name(rs.getString(\"o_g_name\")); odto.setO_g_amount(rs.getInt(\"o_g_amount\")); odto.setO_g_size(rs.getString(\"o_g_size\")); odto.setO_g_color(rs.getString(\"o_g_color\")); odto.setO_sum_money(rs.getInt(\"o_sum_money\")); odto.setO_trade_type(rs.getString(\"o_trade_type\")); odto.setO_trans_num(rs.getString(\"o_trans_num\")); odto.setO_date(rs.getDate(\"o_date\")); odto.setO_status(rs.getInt(\"o_status\")); orderDetailList.add(odto); } } catch (Exception e) { System.out.println(\"getOrderDetail() 여기서 오류발생\"); e.printStackTrace(); } finally { closeDB(); } return orderDetailList;}//end of getOrderDetail() order_detail.jsp 생성 (java문법사용)123456789101112131415161718192021222324252627282930313233343536&lt;%//저장//request.setAttribute(\"orderDetailList\", ordao.getOrderDetail(trade_num));List&lt;OrderDTO&gt; orderDetailList = (List&lt;OrderDTO&gt;)request.getAttribute(\"orderDetailList\");%&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;상품명&lt;/td&gt; &lt;td&gt;상품크기&lt;/td&gt; &lt;td&gt;상품색상&lt;/td&gt; &lt;td&gt;주문개수&lt;/td&gt; &lt;td&gt;주문금액&lt;/td&gt; &lt;/tr&gt; &lt;% int total =0; for(OrderDTO ordto :orderDetailList){ total += ordto.getO_sum_money(); // total = total + ordto.getO_sum_money(); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=ordto.getO_g_name() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=ordto.getO_g_size() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=ordto.getO_g_color() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=ordto.getO_g_amount() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=ordto.getO_sum_money() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;%} %&gt; &lt;tr&gt; &lt;td colspan=\"5\"&gt; 총 주문 금액 : &lt;%=total %&gt; 원&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;a href=\"./Main.me\"&gt;메인페이지&lt;/a&gt; &lt;a href=\"./GoodsList.go\"&gt;계속 구매하기&lt;/a&gt; order_detail.jsp 생성 (EL표현식사용) &lt;c:forEach var=&quot;i&quot; items=&quot;${orderDetailList}&quot;&gt; 사용시 주의사항 var이름은 해당 페이지에서 사용 할 변수명이다. items는 request.setAttribute객체로 담아온 이름을 써야한다. 1234567891011121314151617181920212223242526272829303132333435&lt;%System.out.println(\"V : 주문목록상세 출력페이지\");%&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;상품명&lt;/th&gt; &lt;th&gt;상품사이즈&lt;/th&gt; &lt;th&gt;상품색상&lt;/th&gt; &lt;th&gt;주문개수&lt;/th&gt; &lt;th&gt;주문금액&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach var=\"i\" items=\"${orderDetailList }\"&gt; &lt;tr&gt; &lt;td&gt;${i.o_g_name}&lt;/td&gt; &lt;td&gt;${i.o_g_size }&lt;/td&gt; &lt;td&gt;${i.o_g_color }&lt;/td&gt; &lt;td&gt;${i.o_g_amount }&lt;/td&gt; &lt;td&gt;${i.o_sum_money }&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;tr&gt; &lt;td colspan=\"5\"&gt; 총 주문 금액 : &lt;c:set var=\"total\" value=\"0\"/&gt; &lt;c:forEach var=\"list\" items=\"${orderDetailList }\"&gt; &lt;c:set var=\"total\" value=\"${total + list.o_sum_money }\" /&gt; &lt;/c:forEach&gt; ${total }원 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;input type=\"button\" class=\"btn\" value=\"메인페이지로\" onclick=\"location.href='./Main.me'\"&gt;&lt;input type=\"button\" class=\"btn\" value=\"계속 구매하기\" onclick=\"location.href='./GoodsList.go'\"&gt;","link":"/2020/09/21/200922jspi2/"},{"title":"[안드로이드]고급위젯: 아날로그시계,디지털시계,크로노미터,타임피커,데이트피커,캘린더뷰,자동완성텍스트뷰와 멀티자동완성텍스트뷰","text":"아날로그시계와 디지털시계 화면에 시간을 표시하는 위젯 둘 다 view클래스 상속 =&gt; background속성 설정가능 DigitalClock은 추가로 textColor속성 설정가능 참고로 텍스트시계는 Digital Clock과 동일하지만 API level 17에서 deprecated. 123456789101112//아날로그시계&lt;AnalogClockandroid:id=\"@+id/simpleAnalogClock\"android:layout_width=\"wrap_content\"android:layout_height=\"wrap_content\" /&gt;//디지털시계&lt;DigitalClock android:id=\"@+id/simpleDigitalClock\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 크로노미터 Chronometer는 타이머형식의 위젯 시간을 측정할때 많이 사용 메서드 : start(), stop(), reset()있고 각각 크로노미터를 시작, 정지, 초기화한다. foramt속성 : %s는 분:초 또는 시:분:초형식으로 출력 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 변수생성simpleChronometer = (Chronometer) findViewById(R.id.simpleChronometer);start = (Button) findViewById(R.id.startButton);stop = (Button) findViewById(R.id.stopButton);restart = (Button) findViewById(R.id.restartButton);setFormat = (Button) findViewById(R.id.setFormat);clearFormat = (Button) findViewById(R.id.clearFormat);//크로노미터 시작 메서드start.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { simpleChronometer.start(); }});//크로노미터 정지 메서드stop.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { simpleChronometer.stop(); }});//크로노미터 재시작 메서드restart.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { simpleChronometer.setBase(SystemClock.elapsedRealtime()); }});//크로노미터 포맷형식 설정 메서드setFormat.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { simpleChronometer.setFormat(\"시간측정 : %s\"); }});//크로노미터 포맷형식 초기화 메서드clearFormat.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { simpleChronometer.setFormat(null); }}); 타임피커, 데이트피커, 캘린더뷰 TimePicker DatePicker CalendarView 자동완성텍스트뷰와 멀티자동완성텍스트뷰 p250 둘 다 EditText를 상속받는다. 자동완성단어는 주로 java 코드에서 배열로 설정하며 setAdapter()메소드를 이용한다. AutoCompleteTextView 단어 1개가 자동완성된다 MultiAutoCompleteTextView 쉼표(,)로 구분하여 여러 개 단어가 자동 완성된다.","link":"/2020/09/22/200923and-1/"},{"title":"[안드로이드]레이아웃종류와 비교 및 레이아웃 안에서 자주 사용되는 속성","text":"레이아웃의 종류 레이아웃은 ViewGroup 클래스로부터 상속된다. 리니어 (LinearLayout) : 선형 레이아웃 가장 많이 사용. 왼쪽 위부터 아래쪽 또는 오른쪽으로 차례로 배치 렐러티브 : 관계적 레이아웃. 위젯 자신이 속한 레이아웃의 상하좌우 위치를 지정하거나 다른 위젯으로부터 상대적인 위치를 지정 상대적인 위치로 배치 상대적 기준 : 부모(레이아웃) 또는 뷰 테이블 span 기능이 없다. 위젯을 행과 열의 개수를 지정한 테이블 형태로 배열. 그리드 웹(html)의 테이블 개념과 가깝다. 테이블레이아웃과 비슷하지만 행 또는 열을 확장하여 다양하게 배치가능 프레임 왼쪽 위에 일률적으로 겹쳐 배치하여 중복되어 보이는 효과가능. 여러개의 위젯을 배치한 후 상황에 따라서 필요한 위젯을 보이는 방식에 주로 활용 레이아웃 안에서 자주 사용되는 속성orientation : 배치할 위젯의 방향 설정. 수직(Vertical) / 수평(Horiwontal) 중 하나 선택. 수직(Vertical) : 레이아웃에 포함된 위젯이 수직방향인 위에서 아래로 차곡차곡 쌓인다. 수평(Horiwontal) : 위젯이 많은 경우 화면이 넘어가면서 자동으로 보이지않음 gravity : 위치 정렬 자신에게 포함된 자식(주로 위젯)을 어디에 위치 시킬지 결정. left / right / center / top / bottom등 가능 right||bottom 는 오른쪽 아래에 정렬한다는 의미. layout_gravity : 위치 정렬 자신의 위치를 부모(주로 레이아웃)의 어디쯤에 위치시킬지를 결정. 그래서 보통 gravity는 레이아웃에 layout_gravity는 위젯에 지정한다. padding : 위젯의 여백 layout_weight : 공간의 가중값 여러 레이아웃이 중복될 때 각 레이아웃이 전체 화면에서 차지하는 공간의 가중 값. 중복레이아웃을 사용할 경우 각 레이아웃의 크기를 지정해야한다. 레이아웃을 화면 전체에 채워야하기 때문에 dp, px등의 단위보단 전체화면에 대한 비율(%)인 layout_weight을 사용해야한다. baselineAligned : 크기가 다른 위젯들을 보기 좋게 정렬. true(디폴트) / false 참고코딩맛집개발자를 위한 레시피","link":"/2020/09/22/200923and/"},{"title":"[안드로이드]옵션메뉴, 컨텍스트메뉴, 토스트","text":"메뉴 사용자가 여러 개 중 하나를 선택하도록 하여 사용자의 명령을 받아들이는 간편한 방식. 안드로이드메뉴 종류 : 옵션메뉴, 컨텍스트 메뉴 종류별로 xml과 함께이용하거나 xml없이 자바코드만으로도 만들 수 있다 옵션메뉴 : xml이용 키패드의 메뉴 버튼을 누를때 나타난다 작성 순서 res에 menu폴더와 menu1.xml파일 생성 후 메뉴 코딩 자바코딩 : onCreateOptionMenu()메소드 오버라이딩 자바코딩 : onOptionItemSelected() 메소드 오버라이딩 위의 예제코드 보기: 안드로이드 - 옵션 메뉴 (Option Menu) 구현 방법 - Lkt_Programmer 컨텍스트 메뉴 : xml이용 위젯을 롱클릭했을때 화면 중앙에 나타난다. windows 팝업창과 비슷 작성순서 res에 menu폴더와 menu1.xml파일 생성 후 메뉴 코딩 자바코딩 : onCreate()안에 registerForContextMenu()로 위젯등록 자바코딩 : onCreateContextMenu()메소드 오버라이딩 위젯별로 별도의 파일을 만들어야한다. if문을 통해 위젯별 컨텍스트 메뉴를 등록해야한다. 자바코딩 : onContextItemSelected() 메소드 오버라이딩 activity_main.xml 코드 작성 소스코드 생략 menu1.xml 생성 및 코드작성123456789101112131415161718&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/itemRed\" android:title=\"빨간 배경\"&gt; &lt;/item&gt; &lt;item android:id=\"@+id/itemBlue\" android:title=\"파란 배경\"&gt; &lt;/item&gt; &lt;item android:id=\"@+id/itemRGreen\" android:title=\"초록 배경\"&gt; &lt;/item&gt; &lt;item android:id=\"@+id/itemOrig\" android:title=\"배경 초기화\"&gt; &lt;/item&gt;&lt;/menu&gt; menu2.xml 생성 및 코드작성123456789101112131415&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/subRotate\" android:title=\"버튼 90도 회전\"&gt; &lt;/item&gt; &lt;item android:id=\"@+id/subSize\" android:title=\"버튼 3배로 확대\"&gt; &lt;/item&gt; &lt;item android:id=\"@+id/subSize2\" android:title=\"버튼 원래대로\"&gt; &lt;/item&gt;&lt;/menu&gt; MainActivity.java 자바코딩 전역변수 생략 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setTitle(\"배경색바꾸기(컨텍스트 메뉴활용)\"); baseLayout = (LinearLayout) findViewById(R.id.baseLayout); button1 = (Button) findViewById(R.id.button1); button2 = (Button) findViewById(R.id.button2); //버튼 2개를 컨택스트메뉴에 등록하기 registerForContextMenu(button1); registerForContextMenu(button2);}//end of onCreate()@Overridepublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) { //view는 롱클릭한 위젯 super.onCreateContextMenu(menu, v, menuInfo); MenuInflater mi = getMenuInflater(); if(v == button1){ menu.setHeaderTitle(\"배경색 변경\"); mi.inflate(R.menu.menu1, menu); } if (v == button2){ mi.inflate(R.menu.menu2, menu); }}//end of ContextMenu()@Overridepublic boolean onContextItemSelected(@NonNull MenuItem item) { switch (item.getItemId()){ case R.id.itemRed: baseLayout.setBackgroundColor(Color.RED); return true; case R.id.itemBlue: baseLayout.setBackgroundColor(Color.BLUE); return true; case R.id.itemRGreen: baseLayout.setBackgroundColor(Color.GREEN); return true; case R.id.itemOrig: baseLayout.setBackgroundColor(Color.TRANSPARENT); return true; case R.id.subRotate: button2.setRotation(90); return true; case R.id.subSize: button2.setScaleX(3); return true; case R.id.subSize2: button2.setScaleX(1); button2.setRotation(0); return true; } return false;} 인플레이터(Inflater) 인플레이터는 자전거 등의 공기 펌프라는 뜻으로 풍선에 바람을 넣어서 실제 객체를 만들어 사용한다는 의미이다.정적으로 존재하는 xml을 java코드에서 가져와서 실제 객체로 만들어 사용하는 것이다.메뉴 인플레이터 : 메뉴xml파일을 java코드에 가져와 사용하는 것레이아웃 인플레이터 : 레이아웃xml을 java코드에 가져와 사용하는 것출처 : Android Studio를 활용한 안드로이드 프로그래밍 5판 p287 토스트 화면에 잠깐 나타났다가 사라지는 메시지 기본적인 사용형태1Toast.makeText(Context context, String message, int duratioin).show(); duratioin 속성 : LENGTH_SHORT와 LENGTH_LONG 둘 중 하나를 사용 setGravity(int gravity, int xOffset, int yOffset) 메서드 gravity 선택값 : TOP, LEFT, RIGTH, BOTTOM, CENTER Offset은 떨어진 거리를 나타냄 activity_main.xml 코드 작성 소스코드 생략 toast2.xml 생성 및 코드 작성123456789&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;ImageView android:src=\"@drawable/oreo\" android:layout_width=\"wrap_content\" android:layout_height=\"100dp\"/&gt;&lt;/LinearLayout&gt; MainActivity.java 자바코딩 전역변수 생략 123456789101112131415161718192021222324252627282930313233343536373839404142@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setTitle(\"사용자 정보 입력\"); tvName = (TextView) findViewById(R.id.tvName); tvEmail = (TextView) findViewById(R.id.tvEmail); btn1 = (Button) findViewById(R.id.btn1); btn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { dlgV = (View) View.inflate(MainActivity.this, R.layout.dialog, null); AlertDialog.Builder dlg = new AlertDialog.Builder(MainActivity.this); dlg.setTitle(\"사용자 정보 입력\"); dlg.setIcon(R.drawable.ic_menu_allfriends); dlg.setView(dlgV); dlg.setPositiveButton(\"확인\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { dlgEdtName = (EditText) dlgV.findViewById(R.id.dlgEdt1); dlgEdtEmail = (EditText) dlgV.findViewById(R.id.dlgEdt2); tvName.setText(dlgEdtName.getText().toString()); tvEmail.setText(dlgEdtEmail.getText().toString()); } }); dlg.setNegativeButton(\"취소\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { Toast toast = new Toast(MainActivity.this); toastV = (View) View.inflate(MainActivity.this, R.layout.toast1, null); toastText = (TextView) toastV.findViewById(R.id.toastText1); toastText.setText(\"취소했습니다\"); toast.setView(toastV); toast.show(); } }); dlg.show(); } });}","link":"/2020/09/22/200923and-2/"},{"title":"자바 클래스(객체) vs 추상클래스 vs 인터페이스","text":"클래스 객체를 생성하기위한 클래스(설계도) 사용하기위해서는 반드시 객체 생성 = 인스턴스화 = 메모리에 로드한다. 구성요소 3가지 변수 : 속성 메서드 : 동작 생성자 : 초기화 상속 가능 : 확장 extends 사용가능 관계 : 다중상속 불가 업캐스팅 가능 추상클래스 클래스 구성요소 3가지 변수 상수 일반메서드 추상메서드 생성자 상속 가능 관계 : 다중상속 불가 업캐스팅 가능 추상클래시끼리 상속 가능? 가능 extends를 사용 상속 후 추상메서드 오버라이딩(구현)해서 사용해야한다. 인터페이스 인터페이스는 클래스가 아니라서 구성요소가 다르다 구성요소 2가지 상수 추상메서드 상속 가능 =&gt; 구현 implements 사용가능 인터페이스끼리 상속 가능한가? 가능 extends를 사용 관계 : 다중구현 가능 추상메서드 : [public abstract] 인터페이스안의 모든 메서드의 접근지정자는 default가 아닌 public이다. 상속 후 추상메서드 오버라이딩(구현)해서 사용해야한다. 12345678910111213// [] 대괄호는 생략이 가능하다는 의미이다.// 추상메서드 선언방법 중 실무에서는 4번째방법으로 선언을 많이 한다interface A{ public static final 변수명; [public static final] 변수명; public abstract method1(); [public] abstract method1(); [public abstract] method1(); public [abstract] method1();} 비교표 비교 클래스 추상클래스 인터페이스 클래스인가? Y Y N 구성요소 변수, 메서드, 생성자 변수, 상수, 일반메서드, 추상메서드, 생성자 상수, 추상메서드 관계 다중상속 불가능 다중상속 불가능 다중구현 가능 상속가능여부 가능 extends(확장) 가능 extends(확장) 가능 implements(구현) 업캐스팅가능여부 Y Y Y 참고링크 기본클래스 이외에 자바 구성요소1 : 추상클래스, 인터페이스","link":"/2020/09/22/200923jspi-2/"},{"title":"Servlet관리자용주문목록1 : 기초","text":"`web.xml’에 코드 추가 web.xml 코드 수정 후 꼭 서버 실행 후 주소창에 test.bo해서 흰 화면이 뜨는지 확인하고 코딩할 것 흰화면이 안뜨면 web.xml 설정이 잘못되었다는 의미임. 123456789&lt;!-- Model2 주문리스트(관리자용) --&gt;&lt;servlet&gt; &lt;servlet-name&gt;AdminOrderFrontController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itwillbs.admin.order.action.AdminOrderFrontController&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;AdminOrderFrontController&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ao&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; AdminOrderFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class OrderFrontController extends HttpServlet { // 일반 클래스를 서블릿을 상속해서 컨트롤러 역활 할수있도록 설정 protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"doProcess() 호출 (페이지 GET/POST방식 모두 사용호출)\"); // 주소 비교 (주소 매핑) System.out.println(\"--------------@ 주소 계산 @-------------\"); // 프로젝트명 + 주소 String requestURI = request.getRequestURI(); System.out.println(\" requestURI : \" + requestURI); // 프로젝트명 String contextPath = request.getContextPath(); System.out.println(\" contextPath : \" + contextPath); // 가상주소 String command = requestURI.substring(contextPath.length()); System.out.println(\" command(가상주소) : \" + command); System.out.println(\"--------------@ 주소 비교후 처리 @-------------\"); Action action = null; ActionForward forward = null; // 주소에 따른 처리 구분 (주소 매핑후 이동) System.out.println(\"-----------------@ 페이지 이동 @--------------\"); if(forward != null){ // 이동할 정보가 있다 if(forward.isRedirect()){ // true - sendRedirect() // 가상주소(.bo -&gt; .bo), 화면전환(주소변경,화면 변경) System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(Redirect)\"); response.sendRedirect(forward.getPath()); }else{ // false - forward() System.out.println(\"C : \"+forward.getPath()+\"주소로 이동(forward)\"); // 가상주소 -&gt; 실제페이지 (.bo -&gt; .jsp) + reqeust 객체 정보를 가지고 이동 RequestDispatcher dis = request.getRequestDispatcher(forward.getPath()); dis.forward(request, response); } }//end of 페이지이동 }//end of doProcess @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet() 호출 (페이지 GET방식 호출)\"); doProcess(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost() 호출 (페이지 POST방식 호출)\"); doProcess(req, resp); }} Action.java 생성123456789101112public interface Action { // 상수,추상메서드 // 추상메서드 -&gt; 서브클래스들 한태 강제성 부여 // =&gt; 개발 형식의 통일(틀이 정해짐) // =&gt; 객체간의 관계가 약화됨 =&gt; 각각의 객체가 해당 동작만 처리/제어 // Action 페이지의 동작을 미리 선언해서 사용 public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception;} ActionForward.java 생성1234567891011121314151617181920212223242526272829public class ActionForward { //1.외부접근 못하도록 이동할 페이지와 이동할 방식 멤버변수 생성 private String path; private boolean isRedirect; // true면 sendRedirect방식으로 이동 //사용처: 주소와 화면의 전환이 동시에 일어날때 (가상주소 -&gt; 가상주소로 ) // false면 forward방식으로 이동 //사용처: 주소는 그대로인데 화면이 바뀔때 (가상주소에서 jsp보여줌) //2. getter setter생성 public String getPath() { return path; } public void setPath(String path) { this.path = path; } public boolean isRedirect() { return isRedirect; } public void setRedirect(boolean isRedirect) { this.isRedirect = isRedirect; } //3.toString @Override public String toString() { return \"ActionForward [path=\" + path + \", isRedirect=\" + isRedirect + \"]\"; }} AdminOrderDAO.java 인터페이스 생성123456public interface AdminOrderDAO { // 인터페이스안의 추상메서드이기때문에 // 관리자가 주문목록을 확인하는 기능 getAdminOrderList() public List getAdminOrderList(); } AdminOrderDAOImpl.java 클래스 생성 위에서 만든 인터페이스를 상속받아서 DAO클래스를 만든다. DB연결메서드 생성 자원해제 메서드 생성 123456789101112131415161718192021222324252627public class AdminOrderDAOImpl implements AdminOrderDAO { Connection con = null; PreparedStatement pstmt = null; ResultSet rs = null; String sql = \"\"; // 디비 연결 private void getCon() throws Exception{ // 커넥션 풀 Context init = new InitialContext(); DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/model2DB\"); con = ds.getConnection(); System.out.println(\"DAO : 디비연결 완료 \"+con); }//end of getCon() // 디비 자원해제 public void closeDB(){ try { if(rs != null) {rs.close(); } if(pstmt != null) {pstmt.close(); } if(con != null) {con.close(); } } catch (SQLException e) { e.printStackTrace(); } }//end of closeDB()}","link":"/2020/09/22/200923jspi/"},{"title":"[안드로이드]파일처리","text":"내장메모리 파일 처리 앱을 종료했다가 다시 실행할때 작업했던 부분에서 이어서 작업하고 싶은 경우에 사용한다. 내장메모리의 위치 : /data/data/패키지명/files폴더 파일읽기 : openFileInput() 메소드 사용 -&gt; FileInputStream을 반환한다. -&gt; write()메소드사용 파일쓰기 : openFileOutput() 메소드 사용 -&gt; FileOutputStream을 반환한다. -&gt; read()메소드사용 파일기반 입/출력처리 스트림이란 일반적인 절차 openFileInput()와 openFileOutput()로 파일열기 -&gt; write()와 read()로 파일 읽기/쓰기 close()로 꼭 닫기 간단한 다이어리 만들기예시 activity_main.xml코드1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\"&gt; &lt;DatePicker android:id=\"@+id/datepicker\" android:calendarViewShown=\"false\" android:datePickerMode=\"spinner\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;EditText android:id=\"@+id/edtdiary\" android:background=\"@android:color/holo_blue_light\" android:lines=\"8\" android:textColor=\"@android:color/white\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt; &lt;Button android:id=\"@+id/btnw\" android:enabled=\"false\" android:text=\"다이어리쓰기\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/LinearLayout&gt; MainActivity.java 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MainActivity extends AppCompatActivity { DatePicker dp; EditText edtDiary; Button btnWrite; String fileName; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setTitle(\"간단한 일기장\"); dp = (DatePicker) findViewById(R.id.datepicker); edtDiary = (EditText) findViewById(R.id.edtdiary); btnWrite = (Button) findViewById(R.id.btnw); Calendar cal = Calendar.getInstance(); int cYear = cal.get(Calendar.YEAR); int cMonth = cal.get(Calendar.MONTH); int cDay = cal.get(Calendar.DAY_OF_MONTH); dp.init(cYear, cMonth, cDay, new DatePicker.OnDateChangedListener() { public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) { fileName = Integer.toString(year) + \"_\" + Integer.toString(monthOfYear + 1) + \"_\" + Integer.toString(dayOfMonth) + \".txt\"; String str = readDiary(fileName); edtDiary.setText(str); btnWrite.setEnabled(true); } }); //다이어리쓰기 btnWrite.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { try{ FileOutputStream outfs = openFileOutput(fileName, Context.MODE_PRIVATE); String str = edtDiary.getText().toString(); outfs.write(str.getBytes()); outfs.close(); Toast.makeText(getApplicationContext(), fileName+\"이 저장됨\", Toast.LENGTH_SHORT).show(); }catch(IOException e){ } } });} //일기내용읽어서 반환 String readDiary(String fName){ String diaryStr = null; FileInputStream infs; try{ infs = openFileInput(fName); byte[] txt = new byte[500]; infs.read(txt); infs.close(); diaryStr = (new String(txt)).trim(); btnWrite.setText(\"일기 수정하기\"); }catch(IOException e){ edtDiary.setHint(\"일기를 쓰세요\"); btnWrite.setText(\"새로운 일기 저장\"); } return diaryStr; }} sd카드 읽기 전용 파일의 경우 프로젝트의 /res/raw폴더를 사용한다. 텍스트가 아닌 음악, 영상, 그림파을 등 응용프로그램은 안드로이드 SD카드에 저장하여 읽을 수 있다. Device File Explorer에서 /sdcard 폴더 또는 /storage/emulator/0 폴더에 파일을 업도르하면 SD카드에 저장 된다.","link":"/2020/09/23/200924and/"},{"title":"[안드로이드]4대 컴포넌트","text":"안드로이드의 4대 컴포넌트 액티비티 : 화면을 구성하는 가장 기본적인 컴포넌트 서비스 : 눈에 보이는 화면(액티비티)과 상관없이 백그라운드에서 동작하는 컴포넌트 브로드캐스트 리시버(Broadacast Receiver) : 응용 프로그램이나 장치에 메세지를 전달하면 발생하면 반응 콘텐트 프로바이더(Content Provider) : 응용 프로그램 사이에 데이터를 공유하기 위한 컴포넌트 인텐트(intent) : 안드로이드 4대 컴포넌트가 서로 데이터를 주고받기 위한 메세지 객체. 인텐트단방향 명시적 인텐트(Explicit intent) 타켓 컴포넌트(다른 액티비티)의 이름을 명확히 지정함 사용자가 새로운 액티비티를 직접 생성/호출시 사용 1234//명시적인텐트를 사용하여 데이터 전달//추가로 만든 secondActivity자바파일을 intent에 넣어서 mainActivity에 전달Intent i = new Intent(getApplicationContext(), SecondActivity.class);startActivity(i); 순서 putExtra()로 인텐트에 데이터 넣어서 startActivity() 메소드 사용하여 인텐드를 다른 액티비티로 전달 getStringExtra(), getIntExtra(), getBooleanExtra()등으로 전달받은 데이터에 접근 finish()로 끝내기 예시 메인액티비티 새컨액티비티 양방향 명시적 인텐트 메인엑티비티에서 세컨드 엑티비티로 데이터를 넘긴 후 세컨드 엑티비티에서 다시 메인 엑티비티로 데이터를 돌려줄 때 사용 putExtra()로 인텐트에 데이터 넣어서 전달 getExtra()로 전달받은 데이터 떠냄 순서 putExtra()로 인텐트에 데이터 넣어서 startActivityForResult() 메소드 사용하여 인텐드를 다른 액티비티로 전달하기 putExtra()에 메인액티비티에 돌려줄 인텐트를 생성하여 넣은 뒤 setResult()로 돌려주기 finish()로 끝내기 메인액티비티에서는 onActivityResult()메소드를 오버라이딩하고 오버라이딩된 메소드안에서 getStringExtra(), getIntExtra(), getBooleanExtra()등으로 전달받은 데이터에 접근하여 사용하기 예시 메인액티비티 세컨액티비티 암시적 인텐트(Implicit Intent) 타켓컴포넌트의 클래스명이나 패지키명을 지정하지 않음 약속된 액션을 지정하여 안드로이드에서 제공하는 기존 응용 프로그램을 실행하는 방법 전화걸기 예시 AndroidManifest파일 메인액티비티 명시적 인텐트 vs 암시적 인텐트 참고 https://m.blog.naver.com/PostView.nhn?blogId=fnel7031&amp;logNo=220705998997&amp;proxyReferer=https:%2F%2Fwww.google.com%2F http://wiki.gurubee.net/pages/viewpage.action?pageId=26743688","link":"/2020/09/27/200928and/"},{"title":"Servlet관리자용주문목록4 : 고객주문목록에서 삭제","text":"주문 목록 삭제 /AdminOrderList.ao ‘삭제’ 클릭 -&gt; 페이지 이동( 가상주소 ) 주문번호 가지고 이동 컨트롤러 -&gt; Action -&gt; DAO 주문번호 사용해서 정보 삭제 delete 구문 사용 리스트 페이지로 이동 AdminOrderFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가1234567 //주문목록에서 삭제}else if(command.equals(\"/AdminOrderDelete.ao\")){ System.out.println(\"C : AdminOrderDelete.ao 호출\"); action = new AdminOrderDeleteAction(); try{ forward = action.execute(request, response); }catch(Exception e) {e.printStackTrace();} } AdminOrderDeleteAction.java 생성1234567891011121314151617181920212223242526272829303132public class AdminOrderDeleteAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { //한글처리 request.setCharacterEncoding(\"UTF-8\"); // 관리자 ID해당하는 세션값 제어 HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null || !id.equals(\"admin\")){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } //전달정보 저장 String trade_num = request.getParameter(\"trade_num\"); //DB처리 AdminOrderDAO aodao = new AdminOrderDAOImpl(); aodao.deleteOrder(trade_num); //페이지이동 forward.setPath(\"./AdminOrderList.ao\"); forward.setRedirect(true); return forward; }} 여기서 삭제후에 삭제되었다는 알람이 떴으면 좋겠다. 그럴땐 js코드를 넣어주면 된다. 대신 기존에 썼던 페이지이동 코드(forward.setPath와 setRedirect)는 쓰지못한다. 리퀘스트안의 자바코드이기때문에 js보다 먼저 실행되기때문이다. js코드(location.href)를 사용하더라고 주소를 맵핑했기때문에 모델2구조는 유지된다. 12345678910111213141516//처리결과를 js사용하여 페이지 이동//인코딩response.setContentType(\"text/html; charset=UTF-8\");//출력통로생성PrintWriter out = response.getWriter();out.print(\"&lt;script&gt;\");out.print(\" alert('성공적으로 삭제되었습니다');\");out.print(\" location.href='./AdminOrderList.ao'\"); //모델2유지됨out.print(\"&lt;/script&gt;\");out.close();//페이지이동//forward.setPath(\"./AdminOrderList.ao\");//forward.setRedirect(true);//return forward;return null; AdminOrderDAO.java 에 deleteOrder()메서드 코드 추가12345678910111213141516171819public interface AdminOrderDAO { // 인터페이스안의 추상메서드이기때문에 // 관리자가 주문목록을 확인하는 기능 getAdminOrderList() public List getAdminOrderList(); // 주문번호를 이용하여 주문상태만 변경 public void updateOrder(String trade_num); // 주문번호를 사용해서 주문상태,운송장번호 변경 가능 public void updateOrder(OrderDTO odto); // 주문번호에 해당하는 주문정보(리스트 전체)를 가져오는 동작을 처리 public abstract List getAdminOrderDetail(String trade_num); // 주문번호를 이용하여 삭제 public void deleteOrder(String trade_num); } AdminOrderDAOImpl.java에 deleteOrder()메서드 코드 추가123456789101112131415// 주문삭제@Overridepublic void deleteOrder(String trade_num) { try{ getCon(); sql=\"delete from itwill_order where o_trade_num=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, trade_num); pstmt.executeUpdate(); }catch(Exception e){ e.printStackTrace(); }finally{ closeDB(); }}//end of deleteOrder()","link":"/2020/09/23/200924jspi/"},{"title":"IT편집자 직무멘토링","text":"직무멘토링오늘은 현직 IT편집자로 재직중이신 컨트리뷰토너분의 멘토링을 들었다.교육콘텐츠에 관심이 많았는데 멘토링덕분에 IT편집자가 무엇을 하는지 솔직담백하게 그리고 유쾌하게 들을 수 있었다. IT편집자 업루량 : 1년에 MAX 4권 저자 설득의 과정 : 지식 나눔의 기쁨, 용돈, 조용하고 강력한 자기 PR 한빛이 제일 유명한 IT출판사. 덩치가 제일 큼 IT편집자가 하는 일 저자 글스기 교육과 보조 실질적인 조언 아이디어기획, 저자와 컨택, 레이아웃부터 가격결정까지 전체를 다 함 10년정도 개발자하다가 편집자할 수 있음 제일 유명한 사람은 개앞맵시 편집자초봉 : 편집자 4년차가 3천만원정도 + 워라밸 출판과정 원고 &gt; 초고 &gt; 퇴고 : 7~80% 시간 할애 조판 하판 초보저자가 편집자를 만날 수 있는 방법 아이디어 기획서를 이메일로 보내기 원고를 이메일로 보내기 Q.아이디어 기획서에 어떤 점들이 명시되어 있는 게 편집자의 눈에 딱 들어오나요? 가장 중요한 것은 4단계정도의 목차. 자세한 목차야말로 눈에 띌 수 밖에 없음. 목차쓰는 거 은근 어려움. 1단원은 뭐뭐~ 2단원은 뭐뭐~ 등등 또는 네임드한 개발자가 되는 것 Q. 책을 쓰려면 얼마나 알아야 할까요? 1년차도 책을 쓸 수 있다. 실제로 1년차인데 책을 쓰고 계신 저자분들이 있다. 가지고 있는 지식을 잘 표현하는 것이 중요하다. 수익구조종이책 제작비 + 유통비 + 온/오프라인서점(교보/Yes24) + 저자 + 출판사 = 10 + 10 + 60 +10+ 10 저자의 인쇄가 10%면 굉장히 많이 받는 것이고 유시민작가도 10%를 max로 받았다. 초보저자인 경우 보통 8% 인쇄를 받는다. cf) 교보문고 오프라인 매대 1자리는 한달에 30만원을 호가함 이북 이북은 종이책의 65~70%정도로 가격측정을 함. 저자는 총 판매금액의 25%를 받는다. 권당 금액을 매기지않고 총 판매금액으로 매긴다.","link":"/2020/09/23/200923opensource/"},{"title":"자바 코딩테스트 공부방법 및 추천사이트","text":"코딩테스트 사이트최근 코딩테스트를 할 수 있는 많은 사이트가 생겼다.차근차근 단계를 올려가며 코딩테스트를 준비하고자한다. 코드업 기초 100제 https://codeup.kr/problemsetsol.php?psid=23 구름레벨 https://level.goorm.io/ leetcode https://leetcode.com/problemset/top-100-liked-questions/ 코딜리티 https://app.codility.com/programmers/ 해커링크 https://www.hackerrank.com/ 백준온라인저지 https://www.acmicpc.net/workbook/view/1152 프로그래머스 https://www.welcomekakao.com/learn/challenges?tab=all_challenges 코딩테스트를 위한 알고리즘 공부순서알고리즘 공부로 끝나는 것이 아니라 기록을 위해 레포지토리를 생성하였다. 코드업 기초 100제 https://codeup.kr/problemsetsol.php?psid=23 백준온라인저지 그리디 https://www.acmicpc.net/problemset?search=greedy 탐색 알고리즘 (완전탐색 / BFS /DFS) 기본 동적 프로그래밍 레벨별 코딩테스트 준비방법 만약 기존 프로그래밍을 해왔던 분 이거나 위 페이지에서의 3단계 문제가 쉬운 분 에겐 백준 알고리즘의 2~3단계 이후 난이도를 추천합니다.또한 최종적으로 대기업 코딩테스트를 목표로 하신다면 프로그래머스의 2단계 정도는 쉽게 푸실수 있다면(웬만하면 문제당 30분 이내로 정답을 띄우면) 도전할 만 하다고 생각합니다.참고로 중소기업 코딩테스트와 대기업 코딩테스트는 중소기업 코딩테스트가 근소하게 어려운 느낌입니다. 아무래도 실무적인 부분이 많이 들어갔기 때문인듯 합니다. 대기업은 코테 이후, 기술면접이 어려우므로 대기업 레벨 이라 하여 어렵다고 지례 짐작하시면 안됩니다. (삼성전자 기준이며 카카오는 조금 더 어렵습니다, 카카오는 통과해본적이 없어서 이후는 모르겠네요)진행하시다 막힐경우 프로그래머스 기준 3~4단계 까지의 문제는 본 카페에 글을 올려주시면 도와드릴 수 있습니다. (정답을 100% 알려드리는게 아니라 같이 고민할 수 있다는 것 입니다…) 언어는 c/c++, java, python 으로 제한하려 합니다.출처 : http://cafe.daum.net/cjgreen2006/AZdl/3?svc=cafeapi 대기업 IT직군 코딩테스트 합격을 위한 현실적이고 직관적인 공부 순서 코드포스 블루 레벨 정도면 국내 코테에서 떨어질 일은 없다.영상 간단 정리. 프로그래밍 언어 때기. (C# / 파이썬 / 자바 등) 동빈나(본인)은 C++ / 파이썬을 추천. 파이썬으로 시작해도 불이익이 크지 않다. 미래를 위해 C++도 좋다. 코드업 기초 100제 공부. 백준 온라인 저지 알고리즘 공부. 그리디 알고리즘 탐색 알고리즘 (완전탐색 / BFS /DFS) 기본 동적 프로그래밍 그래프 이론 중급 / 고급 동적 프로그래밍 문자열 고급 알고리즘은 대기업 코테용으로 공부할 필요가 없다. 코드포스 블루 레벨 정도면 국내 코테에서 떨어질 일은 없다. 그리디 / 동적 프로그래밍 / 탐색 정도면 블루 레벨 가능 삼성 역량 테스트 B형 정도면 국내 대기업 IT 직군에 취업할 수 있다. 연구직이나 대학원 진학을 꿈군다면 고급 알고리즘 공부는 필요하다. 대기업 공체는 문제 수와 관계 없이 절반 이상 맞추면 대기업에 합격하는 추세다. 완벽할 정도로 공부할 필요 없다. 공부 루트를 알면 굳이 학원을 다닐 필요가 없다. 삼성전자 역량 테스트는 백준 사이트에서 확인 가능. 카카오 테스트는 프로그래머스에서 확인 가능. 유튜브에서 동빈나(본인) 알고리즘 강의 절반을 듣고 백준 알고리즘 풀고 삼성 문제 풀면 충분하다.출처 : https://youtu.be/ukkLCl9yBvE Scanner보다는 BufferedReader, StringTokenizer를 쓰는 이유출처 : https://sangwoo0727.github.io/java/JAVA-20_input/","link":"/2020/09/28/200929codingTest/"},{"title":"오픈소스컨트리뷰톤2020 수상후기","text":"오픈소스컨트리뷰톤2020 멘티 참여후기내가 참여한 모던자바스크립트 프로젝트가 장려상을 수상했다!👑참여하는 것만으로도 영광이었는데 이렇게 상까지 받게되니 정말 기쁘다. 그동안 배운 것들은 정리해보았다. 컨트리뷰톤기간동안 진행된 모든 회의에 참여하여 깃과 깃허브사용법등 깊이있는 버전관리지식과 오픈소스생태계 지식을 얻을 수 있었다. 다양한 분야의 컨트리뷰터분들이 유용한 현직자 팁을 매회의때마다 공유해주셨다. 책에서는 배울 수 없는 살아있는 지식을 많이 습득할 수 있었다. 평일 아침마다 진행되는 스터디에 참여하여 자극을 받고 유익했던 스터디내용을 공유할 수 있었다. 매주 화요일 저녁에 진행되는 스터디에 참여하여 직접 퀴즈를 내봄으로써 모던자바스크립트에 대한 깊이 있는 지식을 쌓는 것은 물론 저장소를 직접 운영해보았다. 🌟좋은 사람들을 많이 만났다.🌟 스터디 레포지토리 운영 후기모던 자바스크립트 튜토리얼자료가 정말 좋아서 완독을 목표로 오픈소스컨트리뷰톤기간동안 같이 스터디할 분들을 모집했다.Zoom회의를 통해 목표와 공부방법설정을 진행하였다.이걸 기록해놓으면 좋겠다는 생각에 레포지토리를 생성해서 활용하자고 제안하였고 스터디원분들이 다 좋다고 하셔서 말을 꺼낸 내가 운영하게 되었다!한 명과의 레포관리만 해보았지 이렇게 여러명에서 사용하게 될 레포를 관리하는 건 처음이라 신났다.깃허브 레포에서 사용하지못했던 많은 기능이 있었기에 이참에 열심히 활용해봐야겠야겠다고 생각했다. 레포생성하기 스터디원 contributors로 추가하기 첫 회의때 이야기 나누었던 부분을 리드미작성하기 위키활용하기 위키를 활용하기 위해 어떤 정보를 작성할까 고민했다. 그러다 회의록을 작성하면 좋겠다는 생각이 들었다. 사정이 있어 지난 스터디에 참석 못 한 스터디원들에게도 위키를 통해 정보를 공유하여 다음 스터디참석에 원활하게끔 만들 수 있을 것 같았다. 어떤 사람이 참석했는지 출석부를 만들면 좋겠다고 생각했는데 우리 스터디 규정중에 퀴즈제출을 활용하면 좋겠다는 생각이 들었다. 더불어 퀴즈를 기준으로 퀴즈 모음을 만들어 한 눈에 퀴즈와 풀이를 볼 수 있게끔 하고싶었다. 그래서 퀴즈리스트를 만들어서 제출자 아이디와 퀴즈, 풀이를 함께 링크를 걸어 한 눈에 파악할 수 있도록하고 출석체크까지 겸 했다. 이슈템플릿 만들기 퀴즈나 전반적인 스터디 질문에 대비하여 이슈템플릿도 만들어보았다. 질문은 다 줌미팅에서 해결했기에 결과적으로는 아무도 사용하지 않았지만ㅋㅋㅋ 그렇게 탄생한 모던JS스터디레포!한 달동안 직접 담당하여 운영해보니 깃헙의 매력에 푹 빠져버렸다.이렇게 숨은 기능이 많을 줄이야!다음에도 꼭 컨트리뷰톤에 참여하고싶다.내가 직접 멘토가 되는 그날이 오기를 소망해본다!","link":"/2020/10/01/200929opensource/"},{"title":"[자바JAVA]1018 : [기초-입출력] 시간 입력받아 그대로 출력하기, next()와 nextLine()차이, parseInt, valueOf의 차이","text":"문제 1018 : [기초-입출력] 시간 입력받아 그대로 출력하기시(hour)와 분(minute)이 “:” 으로 구분된 형식에 맞추어 시간이 입력될 때, 그대로 출력하는 연습을 해보자. 입력예시 13:16 출력예시 13:16 코드1 : nextLine()이용12345678910import java.util.Scanner;class Main { public static void main(String[] args) { Scanner scan = new Scanner(System.in); String time = scan.nextLine(); scan.close(); System.out.printf(\"%s\", time); }} 코드2 : Integer.parseInt()이용123456789101112import java.util.Scanner;class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.next(); sc.close(); String[] time = str.split(\":\"); System.out.printf(\"%d:%d\", Integer.parseInt(time[0]), Integer.parseInt(time[1])); }} 코드3 : Integer.valueOf()이용123456789101112import java.util.Scanner;class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.next(); String[] time = str.split(\":\"); sc.close(); System.out.printf(\"%d:%d\", Integer.valueOf(time[0]),Integer.valueOf(time[1])); }} 세 코드 비교Scanner를 close 유무로 수행시간과 메모리 차이가 발생한다. nextLine() Integer.parseInt() Integer.valueOf() close 전 수행시간 109ms 110ms 109ms close 후 수행시간 109ms 114ms 113ms close 전 메모리 14960kb 15028kb 15004kb close 후 메모리 14972kb 14976kb 14972kb next()와 nextLine()차이 next() : 공백을 기준으로 입력. nextLine() : 한 라인을 기준으로 입력. 따라서 split()하기 좋음. 12345678910111213//입력값 가나다 라 마 바 사 일때//next() 사용String n = sc.next(); System.out.println(n);//nextLine() 사용 String nl = sc.nextLine(); System.out.println(nl);//출력값가나다 가나다 라 마 바 사 parseInt, valueOf의 차이 parseInt : 리턴타입 기본 자료형 valueOf : 리턴타입 객체 valueOf는 결국 parseInt를 호출하는 형태이다. 문자열을 변환할 때 객체로 받아서 사용하느냐, 기본 자료형으로 받아서 사용하느냐의 차이다.출처 : https://brunch.co.kr/@artiveloper/11 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/09/29/200930al-2/"},{"title":"[자바JAVA]1012 : [기초-입출력] 실수 한 개 입력받아 그대로 출력하기, float실수소수점 표현하기","text":"문제 : 1012 : [기초-입출력] 실수 한 개 입력받아 그대로 출력하기실수형(float)로 변수를 선언하고 그 변수에 실수값을 저장한 후저장되어 있는 실수값을 출력해보자. 입력예시 11.414213 출력예시 11.414213 내코드12345678910111213import java.util.Scanner;class Main { public static void main(String[] args) { float x; Scanner sc = new Scanner(System.in); x = sc.nextFloat(); System.out.print(x); }}//입력값 1.414213일때 출력값1.414213 출력값확인하고 코드소슽 틀렸는데 테스트값이 일치하지않았다. 통과못한 테스트값을 보니 아래 테스트를 통과하지 못했다.아래와 같은 출력값이 나와야하는데 내 코드 결과는 1.56이었다. 12//입력값 1.560000일때 출력값1.560000 재시도하여 성공한 코드1234567891011121314151617import java.util.Scanner;class Main { public static void main(String[] args) { float x; Scanner sc = new Scanner(System.in); x = sc.nextFloat(); sc.close(); //효율을 위해 꼭 자원해제 System.out.printf(\"%f\\n\", x); }}//입력값 1.414213일때 출력값1.414213//입력값 1.560일때 출력값1.560000 배운 지식정수나 문자는 전혀 상관없지만 소수점이하 자릿수가 있는 경우에는 소수점이하 자릿수까지 표현가능하다.아래 코드처럼 다양한 소수점을 표현할 수 있다.이때 잘린 소수점이 있다면 반올림된다. 12345678910System.out.println(x);System.out.printf(\"%.1f\\n\", x);System.out.printf(\"%.3f\\n\", x);System.out.printf(\"%f\\n\", x);//입력값 1.560일때 출력값1.561.61.5601.560000 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/09/29/200930al/"},{"title":"[자바JAVA]1011 : [기초-입출력] 문자 한 개 입력받아 그대로 출력하기","text":"문제 1011 : [기초-입출력] 문자 한 개 입력받아 그대로 출력하기문자형(char)으로 변수를 하나 선언하고, 변수에 문자를 저장한 후 변수에 저장되어 있는 문자를 그대로 출력해보자. 코드1234567891011import java.util.Scanner;class Main { public static void main(String[] args) { char x; Scanner sc = new Scanner(System.in); x = sc.next().charAt(0); sc.close(); //효율을 위해 꼭 자원해제 System.out.print(x); }} 배운 지식 Scanner class in Java supports nextInt(), nextLong(), nextDouble() etc. But there is no nextChar() To create an object of Scanner class, we usually pass the predefined object System.in, which represents the standard input stream. We may pass an object of class File if we want to read input from a file. To read numerical values of a certain data type XYZ, the function to use is nextXYZ(). For example, to read a value of type short, we can use nextShort() To read strings, we use nextLine(). To read a single character, we use next().charAt(0). next() function returns the next token/word in the input as a string and charAt(0) function returns the first character in that string.출처 : https://www.geeksforgeeks.org/scanner-class-in-java/ 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/09/29/200930al-1/"},{"title":"[스프링부트]Springboot 기본 개념","text":"Spring Framework 스프링 프레임워크는 자바 생태계에서 가장 대중적인 응용프로그램 개발 프레임워크입니다. 중요한 특징 두가지는 의존성 주입(DI, Dependency Injection) 제어의 역전(IOC, Inversion Of Control)이들로 인해서 결합도를 낮추는 방식으로 어플리케이션을 개발할 수 있습니다. 이러한 개발방식으로 개발한 응용프로그램은 단위테스트가 용이하기 때문에 퀄리티 높은 프로그램을 개발할 수 있습니다.스프링으로 개발하다보면 Transaction Manager, Hibernate Datasource, Entity Manager, Session Factory와 같은 설정을 하는데에 어려움이 많이 있었습니다. 최소한의 기능으로 Spring MVC를 사용하여 기본 프로젝트를 셋팅하는데 개발자에게 너무 많은 시간이 걸렸습니다. 이러한 어려움을 해결하기 위해 나온게 Spring Boot입니다.출처 : https://sas-study.tistory.com/274 스프링 부트 스타터 사이트스프링 부트 스타터 사이트로 이동해서 스프링 프로젝트 생성해보자.실무에서도 많이 사용한다. 기본 설정 프로젝트 선택 Project: Gradle Project Spring Boot: 2.3.x 최신버전으로 진행하기 (SNAPSHOT)은 개발진행중인 베타버전을 뜻 함. (SNAPSHOT)없는 버전으로 선택하기 Language: Java Packaging: Jar Java: 11 Project Metadata groupId: hello artifactId: hello-spring Dependencies: Spring Web, Thymeleaf Controller, Service, Repository Controller : 컨트롤러를 통해서 외부요청을 받고 Service : 서비스에서 비즈니스 로직을 만들고 Repository : 레포지토리에서 데이터를 저장한다. IntelliJ Gradle 대신에 자바 직접 실행나는 윈도우 사용자이므로 File &gt; Setting &gt; Gradle 검색을 통해 설정을 변경하였다. 최근 IntelliJ 버전은 Gradle을 통해서 실행 하는 것이 기본 설정이다. 이렇게 하면 실행속도가 느리다. 다음과 같이 변경하면 자바로 바로 실행해서 실행속도가 더 빠르다.Preferences Build, Execution, Deployment Build Tools Gradle Build and run using: Gradle IntelliJ IDEA Run tests using: Gradle IntelliJ IDEA 참고본 포스팅은 인프런강의 스프링 입문 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술에서 공부한 내용을 바탕으로 직접 구글링한 내용을 더해 작성하였다.","link":"/2020/10/03/201003spring/"},{"title":"[국비교육 자바JAVA 팀프로젝트]1.팀플주제구상(feat.입문자를 위한 팀협업도구추천)","text":"팀프로젝트학원에서 다음주부터 팀프로젝트를 진행한다고 한다. 팀프로젝트는 개인프로젝트와 달리 굉장히 신경써야 할 부분이 많다.그걸 어떻게 아느냐고?나는 경영학도로서 대학 4년을 내내 수강했던 거의 모든 강의에서 팀 프로젝트 했기때문에 이런 사람, 저런 사람 그리고 볼 꼴, 못 볼 꼴을 다봤다. 따라서 팀프로젝트에는 자신있다!지치지 않을 자신!좋든 안 좋든 이 모든 경험이 직장생활에서 좋은 거름이 되어줄 것이라 믿어 의심치않는다.전 직장에서도 그 거름으로 탄탄히 성장했기 때문이다.이번에도 잘해보자! 조편성조 구성은 학원에서 진행해준다고 한다.내가 직접 하고 싶었는데 수준에 맞춰(?) 고루 팀원을 구성한다고 한다.학원 수강기간내내 찜해둔 몇몇 친구들과 함께 하고싶었는데… 쳇-나처럼 열정가득한 사람들과 함께 했으면 좋겠다.팀프로젝트가 개인프로젝트로 변질되기도 하는데 이번에는 팀원 다 잘 참여하여 모두 좋은 결과를 가져갔으면 좋겠다.팀플을 하면 갠플과 다른 배울 점이 있으니까! 팀프로젝트주제아직 팀도 구성이 안되었지만 나는 팀플주제를 고민하고있다.준비없는 첫 회의는 폭망의 지름길이다.나라도 주제를 몇가지 준비해서 침묵을 깨고 성공적인 팀플을 해보려고한다.내 목표는 첫 회의때 주제선정완료와 업무배분까지 끝내고 싶다. 간절🙏 팀프로젝트 주제로는 레퍼런스가 많은 주제가 좋다.왜냐하면 찾아볼 수 있는 레퍼런스가 많아야 팀원들이 포기하지않고 끝까지 함께 나아갈 수 있기때문이다. 주제 패션 쇼핑몰 인강사이트(결제포함) 예매사이트(영화, 숙박) 팀협업도구팀 협업도구를 꽤 오랫동안 찾아보았다.Trello, 잔디, 지라, 깃헙 등등 다양한 팀협업도구들이 존재했다.난 실무에서 사용하는 협업툴을 미리 써보고싶다.지난번 프론트앤드 직무멘토링때 들었던 지라를 사용해보고싶어졌다.혼자서 조금 테스트 해봤는데 이전에 개인프로젝트할때 적용해보았던 Azure DevOps와 비슷했다.이러한 협업툴이 필요한 이유는 한 눈에 내가 뭘 해야하고 뭘 했는지 탁탁 보이기때문이다.개인프로젝트때에도 큰 효과가 있었는테 팀플이면 그 효과가 더욱더 클 것이다. 현재 학원에서 깃헙을 아는 사람들도 거의 없어서 (강사님이 깃헙 사용해보았는지 물어봐서 거수를 했는데 나만 손들었다…) 브랜치를 나눠서 내가 체크하고 merge하는 식으로 진행해야 할 것 같다. 꼬이면 답도 없기때문에… 깃헙 : 백업 지라 : 커뮤니케이션 커뮤니케이션 툴과 관련하여 멘토님의 조언컨트리뷰톤때 만난 멘토님께서 내 블로그글을 보시더니 좋은 팀협업도구와 팀협업에 관해 몇가지 조언을 해주셨다.멘토님은 그저 빛…☀️난 참 운도 좋고 인복이 많은 것 같다.🤗 나도 팀원들이 깃헙도 처음인데 지라도 쓰자고하면 혼돈일까봐 고민했던 부분인데 어떻게 그 부분을 정확히 캐치해내시고 입문자에게 딱 맞는 간단한 협업툴을 소개해주셨다.천사인게 틀림없어…☀️아멘 레파지토리에 프로젝트라는 곳이 있는데 지라처럼 칸반 형식으로 프로젝트 관리를 할 수 있어요. 여기서 만들고 바로 이슈로 등록도 가능하고요, 젠허브라고 크롬 확장 플러그인으로 제공하는게 있는데 프로젝트보다 조금 더 많은 기능을 제공해요.지라는 너무 오버스펙이 될 수도 있어서 첨언 드린건데 다행이네요생각보다 지라가 쓰기 더 까다로울 수 있어서 좀 더 라이트한 버전의 뭔가를 쓰는게 좋을거 같아요. 트렐로, 노션에이나 깃헙 모두 이슈에 코멘트를 단다던가 할 수 있어요.출처 : 멘토님의 경험 또 멘토님이 팀플에서 활용했던 Commit &amp; PR &amp; Branch Rule를 레퍼런스로 알려주셨다.협업에 대해 자세하게 배울 수 있는 유익한 시간이었다.특히 커밋룰은 간과하기 쉬운데 세부사항을 알 수 있어 정말 좋았다. Github의 Projects 사용기저런 형식을 뭐라고 부르는 지 몰랐는데 칸반형식이라고 부르는 구나. 또 하나 배웠다. 배운 건 바로 써먹어봐야지!팀원들에게 추천을 하려면 내가 먼저 잘 알아야하므로 알려주신 내용 바로 내 레포에 적용해보았다. 완벽해!Simple is the BEST!!!👍 ZenHub 사용기말씀해주신 ZenHub도 적용해보았다.ZenHub는 로드맵과 리포트기능이 아주 매력적이다. 매력포인트 리포트기능 DATE를 설정가능한 로드맵기능 ZenHub크롬확장자를 다운로드 하지않았다면 Zenhub탭이 다른 사용자에게는 보이지않는다. ZenHub유저끼리는 보인다!","link":"/2020/10/02/201002team/"},{"title":"[자바JAVA]사용자로부터 정수 10개를 입력받은 후 3의 배수만 골라서 출력하기","text":"문제정수 10개를 입력받아 배열에 저장한 후, 배열을 검색하여 3의 배수만 골라서 출력하시오. 3의 배수가 없을 경우 “해당사항 없음” 메세지를 출력 하시오. 내코드123456789101112131415161718192021222324252627282930313233public static void main(String[] args) { // 정수형 배열 선언 int inputTen[] = new int[10]; // 스캐너로 총 10개의 정수를 사용자로부터 입력 받기 Scanner sc = new Scanner(System.in); System.out.print(\"10개의 정수를 입력하세요\"); for (int i = 0; i &lt; inputTen.length; i++) { inputTen[i] = sc.nextInt(); } // 배열에서 3의 배수만 골라서 ArrayList에 담기 ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i=0; i &lt; inputTen.length; i++){ if(inputTen[i]%3 == 0){ result.add(inputTen[i]); } } // 3의 배수가 있을 경우 ArrayList전체 출력하고 없을 경우 해당사항 없음 메세지 출력 if(result.size() &gt; 0 ){ for(Integer i : result){ System.out.println(i); } }else{ System.out.println(\"해당사항 없음\"); }}//end of main() 배열을 두 개를 생성하면 메모리 낭비가 생긴다. 변수가 가능하다면 객체대신 변수를 사용하는 것이 메모리효율에 좋다. 변수인 int는 4바이트인데 객체는 최소 4바이트 이상이니까. 따라서 이 문제에선 변수를 쓰는 것이 속도도 빠르다. 왜냐면 메모리를 만드는 시간이 드니까 강사님코드 10개 check하는 변수를 생성 123456789101112131415161718192021222324252627public static void main(String[] args) { // 정수형 배열 선언 int inputTen[] = new int[10]; // 스캐너로 총 10개의 정수를 사용자로부터 입력 받기 Scanner sc = new Scanner(System.in); System.out.print(\"10개의 정수를 입력하세요\"); for (int i = 0; i &lt; inputTen.length; i++) { inputTen[i] = sc.nextInt(); } //3의 배수만 출력 int ck = 0; for(int i=0;i&lt;inputTen.length;i++){ if(inputTen[i]%3 == 0){ System.out.println(\"3의 배수 :\"+inputTen[i]); }else{ ck++; if(ck ==10){ System.out.println(\"해당사항 없음\"); } } }}//end of main()","link":"/2020/10/04/201005jsp/"},{"title":"인텔리제이 윈도우 단축키 표(IntelliJ shortcut key for window)","text":"IntelliJ window 단축키이클립스로 개발공부를 해왔지만 스프링을 공부하면서 좋다는 소문만 들었던 인텔리제이 커뮤니티버전을 다운로드받았다.나도 인텔리제이쓴다!!하며 color scheme도 고르고 룰루랄라 시작했는데.. 이런!단축키가 달라서 코딩속도가 엄청 느리다…답답해!!!!!!!!스스로 너무 답답해서 인텔리 윈도우용 단축키를 정리해나가고자한다. 인텔리제이 단축키 정리표 카테고리 Action 단축키 이동 줄이동 Alt + Shift + ↑↓ 한줄 아래로 복붙 Ctrl + d 코드 한 줄 삭제 Ctrl + y 파일 가장 위, 아래로 이동 Ctrl + Home, End 자동완성 괄호안에서 ;로 코드완성하기 Ctrl + Shift + Enter 변수 추출하기 Ctrl + Alt + v 생성자,Getter와Setter,메서드 오버라이딩 자동완성 Alt + Insert 자바클래스 main메서드 자동생성 main + Tab System.out.println(); 자동완성 메인메서드안에서 sout + Tab System.out.printf(“”); 자동완성 메인메서드안에서 souf + Tab 수정 동일한 변수명 한꺼번에 수정 변수명에서 Shift + F6 실행 런 Ctrl + Shift + F10 이전실행을 재실행 Shift + F10 생성 같은 폴더안에 새로운 java class만들기 Ctrl + Alt + Insert 정렬 자동 코드 정렬 Ctrl + Alt + L 🔑이동 줄이동 : Alt + Shift + ↑↓ 한줄 아래로 복붙 : Ctrl + d 코드 한줄 삭제 : Ctrl + y 파일 가장 위, 아래로 이동 : Ctrl + Home, End 🔑자동완성 괄호안에서 ;로 코드완성하기 : Ctrl + Shift + Enter 변수 추출하기 : Ctrl + Alt + v 생성자,Getter와Setter,메서드 오버라이딩등 자동생성 : Alt + Insert 자바클래스 main메서드 자동생성 : main + Tab System.out.println(); 자동완성 : 메인메서드안에서 sout + Tab System.out.printf(“”); 자동완성 : 메인메서드안에서 souf + Tab 🔑수정 동일한 변수명 한꺼번에 수정 : 변수명에서 Shift + F6 🔑실행 런 : Ctrl + Shift + F10 이전실행을 재실행 : Shift + F10 🔑생성 같은 폴더안에 새로운 java class만들기 : Ctrl + Alt + Insert 추천 플러그인 presentaion Assistant : 화면 하단에 단축키 알려준다. IntelliJ, VSCode, Eclipse, Visual Studio 단축키 비교 https://okdevtv.com/mib/intellij/shortcuts","link":"/2020/09/30/201001intelliJkey/"},{"title":"[JSP] get방식과 post방식 차이점","text":"get 방식 VS post 방식 get 전달되는 데이터를 주소줄(URL)에 적어서 전달 파라미터의 길이 제한 : 256byte 처리 속도가 빠름 보안성이 나쁨 post 전달되는 데이터를 본문(Body)에 담아서 전달=&gt;주소줄X 파라미터의 길이 제한 : 없음. 처리 속도가 느림 보안성이 좋음","link":"/2020/10/04/201005jspGetVSPost/"},{"title":"[자바JAVA] 전위연산(a++)과 후위연산(++a) 차이점","text":"전위 증감 연산자(prefix) VS 후위 증감 연산자(postfix) 전위 증감 연산자(++a,–a) : 연산 후 대입 후위 증감 연산자(a++,a–) : 대입 후 연산 예시아래 문제를 통해 차이점을 알아보자 123456int a, b;a = b = 10;boolean c = ++a &gt; b++ || a++ &gt;= ++b;System.out.println(a+\",\"+b);System.out.println(\"변수 c의 값 :\"+c); 답1211, 11true 풀이 ++a &gt; b++의 값은 11 &gt; 10 이라서 true a++ &gt;= ++b의 값은 11 &gt;= 12 라서 false 그렇다면 출력할때 왜 12,12가 아닌 11,11이 나올까? 컴파일러는 앞부분이 true인 경우 굳이 || 연산자 뒤를 연산 할 필요가 없다. 따라서 12,12가 아닌 11,11이고 이것이 논리연산자의 특징이다. 참고 추가학습 : 코딩 도장","link":"/2020/10/04/201005jspPrefixVSPostfix/"},{"title":"[OS] 프로세스(Process)와 스레드(Thread)의 차이 VS 웹서버(WEB SERVER) VS 웹어플리케이션서버(WAS, Web Application Server)","text":"프로세스 VS 스레드 프로세스 : 주기억장치에 로드된 상태의 프로그램(실행되고 있는 프로그램) 작업관리자의 백그라운드프로세스가 많을수록 컴터속도가 느려짐 설치된 애플리케이션을 실행하게되면 운영체제(OS)로부더 메모리의 일정영역을 할당받고 CPU와 HDD를 이용해서 동작하는 것 스레드(Thread) : 프로세스 동작의 최소 단위. 모든 프로세스는 하나 이상의 스레드로 구성 웹서버(WEB SERVER) VS 웹어플리케이션서버(WAS, Web Application Server) 웹서버 : DB사용 불가능 클라이언트측 정적데이터 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠(.html .jpeg .css 등)를 제공하는 컴퓨터 프로그램 Web Server의 예 : Apache Server, Nginx, IIS(Windows 전용 Web 서버) 등 WAS : DB사용 가능 서버측 동적데이터 사용 DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server WAS의 예 : Ex) Tomcat, JBoss, Jeus, Web Sphere 등 참고 : https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html","link":"/2020/10/04/201005jspProcessVSThreadNWebServerVSWAS/"},{"title":"[JSP] Redirect방식과 Forwarding방식 차이점","text":"Redirect VS Forwarding sendRedirect방식 페이지 이동 O 주소 변경 O (가상주소끼리의 이동) session,application 영역의 데이터 전달 가능 사용처: 주소와 화면의 전환이 동시에 일어날때 (가상주소 .bo -&gt; 가상주소로 .bo) Forwarding방식 페이지 이동 O 주소 변경 X (jsp 뷰 페이지로 이동) request,response,session,application 영역의 데이터 전달가능 사용처: 주소는 그대로인데 화면이 바뀔때 (가상주소 .bo에서 request객체정보를 가지고 이동하면서 .jsp를 보여줌)","link":"/2020/10/04/201005jspRedirectVSForwarding/"},{"title":"세션(Session)와 쿠키(Cookie)의 차이 그리고 캐시(Cache)","text":"세션 vs 쿠키 공통점 : 데이터 저장 차이점 세션 : 정보를 서버에 저장 서버가 종료되면 사라짐 브라우저별로 하나씩 생성 정확한 데이터를 사용 쿠키 : 정보를 클라이언트에 저장(사용자PC의 하드디스크에 저장) 서버가 종료되면 안 살아짐 쿠기 사용기간이후 사라짐 쿠기 삭제할 수 있음 사용자의 PC가 바이러스로 인해서 파일이 손상될 가능성이 큼 세션과 쿠키 vs 캐시 state(상태가 있는): 세션과 쿠키 목적: 상태를 잃어버리면 안될 때 사용 ex)사용자 자동로그인 Stateless(상태가 없는): 캐시 목적: 빠르게 로딩하기위해서 사용","link":"/2020/10/04/201005jspSessionVSCookie/"},{"title":"[자바JAVA]1023 : [기초-입출력] 실수 1개 입력받아 부분별로 출력하기, split대신 StringTokenizer사용","text":"문제 1023 : [기초-입출력] 실수 1개 입력받아 부분별로 출력하기실수 1개를 입력받아 정수 부분과 실수 부분으로 나누어 출력한다. 만약 실수 부분이 0으로 시작하지 않는다면(예를 들어 1.000009) scanf(“%d.%d”, &amp;a, &amp;b)도 하나의 방법이 될 수 있다. 입력 :실수 1개가 입력된다.(단, 입력값은 절댓값이 10000을 넘지 않으며, 소수점 이하 자릿수는 최대 6자리까지이고0이 아닌 숫자로 시작한다.) 출력 :첫 번째 줄에 정수 부분을, 두 번째 줄에 실수 부분을 출력한다. 123456//입력예시1.414213//출력예시1414213 방법1 : split()사용123456789101112131415public class c1023 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String f = sc.next(); String[] ff = f.split(\"\\\\.\"); String int1 = ff[0]; String int2 = ff[1]; System.out.println(int1); System.out.println(int2); }} 방법2 : StringTokenizer사용StringTokenizer는 단 한 개의 구분자만을 사용할 수 있으므로 복잡한 구분자를 사용해야 할 때는Scanner 나 split을 사용해야 한다. 1234567891011public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.next(); //StringTokenizer 사용 StringTokenizer st = new StringTokenizer(s,\".\"); while (st.hasMoreElements()) { System.out.println(st.nextToken()); }} 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/10/05/201006al/"},{"title":"[스프링SPRING] 프레임워크란, Spring 특징과 기능, 컨테이너란","text":"Framework란? 어떤것을 구성하는 구조/뼈대/틀 사용될 기능을 클래스/인터페이스로 만들어놓고 제공해주는 형태 직접적인 구현X, 활용O 프레임워크 등장배경 : 기존 언어의 불편함을 개선하기 위해서 개발생산성 향상됨 spring beans DTD : 해당 문서의 저장되는 데이터를지정한다. 컨테이너 Container Container 는 Spring 의 핵심입니다. Container 는 개발자를 대신하여, Bean 을 생성 / 관리 / 제거합니다. Container 가 Bean 을 관리해주기 때문에, 개발자는 모듈 간에 의존 및 결합으로 인해 발생하는 문제로부터 자유로워 졌습니다. 아래와 같이 독립적인 코드를 작성해서 Annotaion 만 남겨주면 Container 가 개발자가 원하는 상황에 코드를 실행합니다. 따라서 개발자는 메서드가 언제, 어디서 호출되어야 하는지 그리고 메서드를 호출하기 위해 필요한 매개 변수를 준비해서 전달하지 않습니다. Container 가 개발자 대신 알아서 호출합니다.이렇게 Container 가 개발자를 대신하여 메서드가 호출될 때와 메서드가 필요한 자원을 전달하는 설계 구조를 Inversion of Control (IOC) 이라 합니다.IOC 는 메서드가 필요로 하는 자원을 코드가 실행되는 타임에 전달하는데, 이를 Dependency Injection (DI) 이라 합니다. 예를 들어 Container가 알아서 greeting 메서드가 필요로 하는 name 매개변수를 전달하는 과정과 run 메서드가 필요로 하는 RestTemplate 매개변수를 전달하는 과정 모두 Dependency Injection (DI) 입니다.출처: https://ibocon.tistory.com/122 Spring 자바 웹 애플리케이션을 생성하기위한 오픈소스 스프링은 경량 프레임워크이면서 경량 컨테이너이다. 컨테이너란 무엇일까? ex) 톰캣 EJB(Enterprise Java Beans)프레임워크 : 굉장히 무거움. 스프링 이전에 사용됨. 스프링의 특징 스프링의 특징 추가설명 제어의 역행(IoC, Inversion of Control) 서블릿/빈 개발자가 코드로 작성X, 프레임워크로 수행 의존성 주입(DI, Dependency Injection) 클래스를 사용한 객체를 개발자가 코드로 생성X, 프레임워크가 생성해서 사용 관점 지향 (AOP, Aspect-Oriented Programming) 핵심기능(주요기능) 제외한 부수적인 기능을 프레임워크가 생성해서 제공 영속성-(DB) - 라이브러리 연동 제공 - POJO(Plain Old Java Object)방식 프레임워크 스프링의 주요 기능 스프링의 주요 기능 설명 SPRING Core 다른 기능과 설정값을 분리하기위한 IoC 기능을 제공한다. SPRING Context 스프링의 기본 기능으로 각각의 애플리케이션을 작동하는 Bean(=객체)에 대한 접근을 처리한다. SPRING DAO 모델2보다 향상된 JDBC기능 활용할 수 있다. SPRING ORM MyBatis(마이바티스)와 같은 영속성 프레임워크 연동기능을 제공한다. SPRING AOP 관점지향 프로그래밍를 제공한다. SPRING Web 웹 개발에 필요한 기능을 제공한다. SPRING WebMVC 스프링에서 MVC구현에 관한 기능을 제공한다. Tomcat은 컨테이너다? 톰캣은 서블릿컨테이너다. 서블릿 생성,초기화,서비스 실행, 서비스 소멸등 모든 서블릿에 관한 권한을 가지고 있다.","link":"/2020/10/04/201005springi/"},{"title":"컴파일에러와 런타임에러 차이","text":"컴파일에러 VS 런타임에러 차이 컴파일에러 : 컴파일시 발생하는 에러, IDE의 빨간줄 에러 컴파일이란 개발자가 작성한 고급언어를 기계어로 바꾸어주는 것 런타임에러 : 프로그램 실행시 발생하는 에러, IDE의 노란줄 에러 RUN 버튼 클릭 후, 즉 프로그램 실행 후 CONSOLE에 나타나는 에러","link":"/2020/10/05/201006jspi/"},{"title":"[이슈해결]Exception in thread java.lang.ArrayIndexOutOfBoundsException: 점(.)사용시 에러 해결방법","text":"문제상황Scanner로 사용자로부터 문자열을 입력받아 점(.)을 기준으로 split() 하려고 실행하니 Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 런타임에러가 발생했다. 123456789public static void main(String[] args) { Scanner sc = new Scanner(System.in); String f = sc.next(); String[] ff = f.split(\".\"); String int1 = ff[0]; String int2 = ff[1]; System.out.println(int1); System.out.println(int2); } 콘솔창에 런타임에러발생 1212.123Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 0 해결 split(&quot;.&quot;)에서 split(&quot;\\\\.&quot;)으로 변경해준다. 123456789public static void main(String[] args) { Scanner sc = new Scanner(System.in); String f = sc.next(); String[] ff = f.split(\"\\\\.\"); String int1 = ff[0]; String int2 = ff[1]; System.out.println(int1); System.out.println(int2); } 원인 정규표현식에서 점(.)은 임의의 한 문자(종류를 가리지않지만 \\는 넣을 수 없음)를 의미한다. split()과 replace()를 사용할 때, 점(.)이 정규식으로 적용되어 모든 문자를 “”으로 만들어 버린다. 점(.)을 점(.) 그대로 인식시키기 위해서는 \\.로 해줘야 한다. 하지만 \\ 또한 예약어이기 때문에 \\\\로 표시해줘야 한다. 따라서 \\\\.을 입력해줘야 원하는 .을 출력할 수 있다. 참고 https://ohgyun.com/4","link":"/2020/10/05/201006java/"},{"title":"[자바JAVA]1034 : [기초-출력변환] 8진 정수 1개 입력받아 10진수로 출력하기(설명), Scanner로 2진수, 8진수 16진수 받기, 진수변환","text":"문제 1034 : [기초-출력변환] 8진 정수 1개 입력받아 10진수로 출력하기(설명)8진수로 입력된 정수 1개를 10진수로 바꾸어 출력해보자. 입력예시8진 정수 1개가 입력된다. 113 출력예시10진수로 바꾸어 출력한다. 111 코드1234567891011121314151617import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.next(); sc.close(); //String을 8진수로 변경 int octal = Integer.parseInt(s, 8); //8진수를 10진수로 출력 System.out.printf(\"%d\", octal); }} 배운 지식2진수, 8진수 16진수를 Scanner로 받으려면 String 데이터타입 또는 int데이터타입을 이용하면된다. String에서 n진수로 변환 2진수 : Integer.valueOf(String s, 2);, return : int 8진수 : Integer.valueOf(String s, 8);, return : int 16진수 : Integer.valueOf(String s, 16);, return : int 10진수에서 n진수로 변환 2진수 : Integer.toBinaryString(int i), return : String 8진수 : Integer.toOctalString(int i), return : String 16진수 : Integer.toHexString(int i), return : String 10진수를 2, 8, 16 진수로 변환하는 소스코드 n진수에서 10진수로 변환 2진수 : Integer.parseInt(String s, 2);, return : int 8진수 : Integer.parseInt(String s, 8);, return : int 16진수 : Integer.parseInt(String s, 16);, return : int 2진수처리 비교 - 정수를 입력받아 2진수 비트연산하여 10진수로 출력하기 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/10/06/201007al-c1034/"},{"title":"[안드로이드]이미지파일 넣기","text":"이미지파일 넣기 안드로이드에서 가장 빠르게 처리할 수 있는 이미지파일확장자 : png 이미지를 사용하려면 그림 파일을 [res]-[drawable]폴더에 미리 복사해놓아야한다. 이미지파일은 res폴더 하위 drawable폴더 안에 복사·붙여넣기한 뒤 ImageView태그로 불러올 수 있다. @의미는 참조이다. 예를 들어 android:src=&quot;@drawable/이미지파일명&quot;인 경우 drawable을 참조해서 그 안의 이미지파일명을 불러와달라는 의미이다. 이미지뷰와 이미지버튼의 xml속성 src : 이미지 경로 maxHeight/maxWidth : 이미지 크기 지정 scaleType : 이미지 확대/축소방식 결정 123456&lt;ImageView android:id=\"@+id/imageView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:src=\"@drawable/이미지파일명\" /&gt;","link":"/2020/10/06/201007and/"},{"title":"[스프링SPRING]회원관리프로그램예시를 통한 MODEL2방식에서 스프링방식으로 변경","text":"회원관리프로그램 순서회원정보를 DB에서 읽어서 출력하는 동작을 구현해보자 Action 인터페이스 - execute() MemberControllerTest 객체 생성 -&gt; 호출 SelectMemberAction 객체 사용 DAO 객체 생성 -&gt; 처리 (출력) 의존관계 Select &lt;-&gt; DAO : DAO 객체를 주입 객체를 미리 생성(Spring) member.xml 생성 Action.java 인터페이스 생성1234public interface Action { // Action 페이지의 동작을 미리 선언해서 사용 public void execute() throws Exception;} MemberControllerTest.java 코드 생성 기존 모델2 방법 : Action action = new SelectMemberAction(); 스프링 방법 : SelectMemberAction로도 가능하지만 Action처럼 업캐스팅통한 표현이 약한 결합을 띄고있다는 것을 표현하는 것이기때문에 Action처럼 업캐스팅방식이 더 많이 사용한다 BeanFactory fac = new XmlBeanFactory(new FileSystemResource(\"member.xml\")); //SelectMemberAction action = (SelectMemberAction) fac.getBean(\"action\"); Action action = (Action) fac.getBean(\"action\"); //업캐스팅 &lt;!--￼1--&gt; SelectMemberAction.java 생성1234567891011121314151617181920212223242526272829public class SelectMemberAction implements Action{ @Override public void execute() throws Exception { // Action 인퍼테이스를 사용하여 다형성구현 System.out.println(\"M: SelectMemberAction 클래스의 execute메서드실행\"); /* 예를 들어 * 1.파라미터 저장하기 * 2.세션아이디체크 */ //모델2방식 //3.DB접근 -&gt; DAO객체 생성 //MemberDAO mdao = new MemberDAOImpl(); //의존주입(DI)방식 //3.DB접근 -&gt; DAO객체 생성 BeanFactory fac = new XmlBeanFactory(new FileSystemResource(\"member.xml\")); MemberDAO mdao = (MemberDAO) fac.getBean(\"mdao\"); //4.메서드 List list = mdao.getMemberList(); System.out.println(\"M: List데이터저장 [\"+ list+\"]\"); //5.페이지이동 System.out.println(\"M: 페이지이동(View)\"); }} MemberDAO.java 인터페이스 생성12345678import java.util.List;public interface MemberDAO { //DAO역할을 하는 객체로 사용됨 //회원목록가져오기 public List getMemberList();} MemberDAOImpl.java 생성12345678910111213141516public class MemberDAOImpl implements MemberDAO{ //디비연결메서드 //자원해제메서드 @Override public List getMemberList() { System.out.println(\"DAO: 디비연결\"); System.out.println(\"DAO: sql작성 &amp; pstmt객체생성 &amp; ?입력 &amp; sql쿼리구문실행 &amp; rs에 가져온 정보를 List저장\"); System.out.println(\"DAO: 자원해제\"); List list = new ArrayList&lt;&gt;(); list.add(\"빽다방\"); list.add(\"더벤티\"); return list; }} member.xml 인터페이스 생성 파라미터가 없으므로 bean태그만 생성. 안에 &lt;property name=&quot;&quot;&gt;를 사용하지않아도 됨 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- DTD --&gt;&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"&gt;&lt;beans&gt; &lt;!-- Controller_Action --&gt; &lt;bean id=\"action\" class=\"com.itwill.member.SelectMemberAction\"&gt; &lt;!-- 파라미터가 없으므로 bean태그만 생성 --&gt; &lt;/bean&gt; &lt;!-- DAO --&gt; &lt;bean id=\"mdao\" class=\"com.itwill.member.db.MemberDAOImpl\"&gt; &lt;!-- 파라미터가 없으므로 bean태그만 생성 --&gt; &lt;property name=\"\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;","link":"/2020/10/05/201006springi-1/"},{"title":"[스프링SPRING]Spring 기본 동작순서, JSP와 SPRING의 차이점","text":"스프링기본동작순서 JSP와 SPRING의 차이점문득 궁금해져서 검색해보니 아주 명쾌한 비유와 설명을 찾았다. JSP란?JSP는 HTML문서에 내부적으로 자바문법을 사용할 수 있게 하는 웹페이지 스크립트 언어입니다. Spring Framework 란?Spring은 다양한 개발 빠르게 적용할 수 있게 만들어 놓은 도구입니다. Java는 삽을 들고 땅을 파는 거라면, Spring은 포크레인으로 땅을 파는 것과 같다고 표현할 수 있습니다. JSP와 Spring의 차이JSP는 웹 페이지 영역에서 사용되고, Spring은 웹 서비스 전반적 환경을 구성합니다. Spring이 나라라고 한다면, JSP는 도시 입니다. 스프링은 프로그램 전반적인 근본이 되는 환경을 구축하고있고, JSP는 그 환경의 일부분에 사용되는 언어입니다.출처 : https://cloudstudying.kr/questions/79","link":"/2020/10/05/201006springi/"},{"title":"[자바JAVA]1041 : [기초-산술연산] 문자 1개 입력받아 다음 문자 출력하기(설명), Scanner로 char받기","text":"문제 1041 : [기초-산술연산] 문자 1개 입력받아 다음 문자 출력하기(설명)영문자 1개를 입력받아 그 다음 문자를 출력해보자.영문자 ‘A’의 다음 문자는 ‘B’이고, 영문자 ‘0’의 다음 문자는 ‘1’이다. 참고숫자는 수를 표현하는 문자로서 ‘0’ 은 문자 그 자체를 의미하고, 0은 값을 의미한다. 힌트아스키문자표에서 ‘A’는 10진수 65로 저장되고 ‘B’는 10진수 66으로 저장된다.따라서 문자도 값으로 덧셈을 할 수 있다. 입력예시영문자 1개가 입력된다. 1a 출력예시 1b 첫번째 코드12345678910111213141516171819import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.next(); sc.close(); //String -&gt; char char c = s.charAt(0); //char+1 int i = c+1; //char로 출력 System.out.printf(\"%s\", (char)i); }} 두번째 코드위의 코드보다 더 간결하게 나타낼 수 있다. 12345678import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); char a = sc.nextLine().charAt(0); System.out.printf(\"%c\", a+1); } } 배운 지식꼭 기억하자 char를 Scanner로 받을땐 sc.nextLine().charAt(0);로 받으면 String이 아닌 Char형태로 바로 받을 수 있다. char를 printf로 출력할때 &quot;%s&quot;가 아니라 &quot;%c&quot;로 출력하면 된다. 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/10/07/201008al-c1041/"},{"title":"[스프링SPRING]스프링(STS)설치 및 MVC프로젝트 기본 설정","text":"스프링 설치 스프링 공식 사이트에서 project탭 클릭 &gt; Spring Tool 4 클릭 스프링설치후 exe파일을 실행 workspace생성 후 Lanch Help &gt; Marketplace &gt; sts 검색 후 Spring Tools 3 Add-On for Spring Tools 4를 설치한다 restart하고 나면 Create a project &gt; Spring Legacy Project &gt; Spring MVC project 클릭 project name 작성하고 next클릭 &gt; the top-level pacakge 을 지정 보통 회사도메인주소 뒤부터 작성 ex)com.test 설치와 프로젝트 생성까지 끝! MVC 프로젝트기본설정 Preferences에서 아래 내용을 설정해준다 General show heap status 틱하기 General &gt; Appearance &gt; Colors and Fonts &gt; basic &gt;Text Font 더블클릭 &gt; 폰트크기지정 General &gt; Web Browser &gt; Use external web browser 틱 &gt; chrome 틱하기 Web의 CSS Files, HTML Files, JSP Files을 각각 Encoding UTF-8로 설정 Create a project &gt; Spring Legacy Project &gt; Spring MVC project 클릭하여 생성 새로 생성한 프로젝트명 우클릭 &gt; Properties 클릭 Project Facets : Dynamic Web Module와 Java의 버전을 원하는 대로 수정 &gt;apply pom.xml에서 java-version을 4번과 일치하게 수정 스프링 프로그램의 project 탭 &gt; maven &gt; Update Maven Project &gt; 새로 만든 프로젝트명 tick &gt; ok 이제 모든 설정이 완료되었으므로 프로젝트를 우클릭하여 잘 설정되어있는지 체크해본다. java compiler : java버전이 일치하는 지 project facets : Dynamic Web Module와 Java의 버전을 일치하는 지 java build path : JRE 시스템 라이브러리 버전이 일치하는 지 Deployment Assemly : Maven Dependencies가 존재하는 지(없으면 add할 것) Mybatis 설치 스프링 MVC패턴 프로젝트, MAVEN REPOSITORY 참고","link":"/2020/10/06/201007spring-1/"},{"title":"[스프링SPRING]스프링 MVC프로젝트, 주요 어노테이션(Annotation)","text":"Spring MVC 프로젝트 생성하는 두가지 방법 Spring Legacy Project WAS-tomcat 경험과 model2 경험 필요 상대적으로 설정하는 것이 어렵다. 실무에서 기존 프로젝트를 이해하기 쉽다 (실무에서 주로 사용하기때문에) 모든 버전의 스프링을 사용가능 단점 : 리소스가 많이 필요하다. Create a project &gt; Spring Legacy Project &gt; Spring MVC project 클릭하여 생성 Spring Starter Project(Spring Boot) 최대한 간결하게 실행, 배포하기 위한 방법 WAS없이 실행가능 최근 유행 &gt; 빠르게 처리가능하기에 간단한 테스트용으로 자주 사용 단점 : jsp뷰 별도의 설정 필요 Spring MVC *.me 주소를 직접 처리해서 사용하는 개발방법 Spring MVC 특징 M odel 데이터 처리(DB) V iew 화면 처리(jsp) C ontroller 뷰와 모델을 연결 MVC패턴을 사용하는 이유 두가지 개발자,디자이너의 영역을 분리 각각의 주소(URI)통한 페이지 제어하기 때문에 유지보수 쉽다. 스프링 MVC프로젝트안 src 폴더하위의 각 파일이 가진 의미 servlet-context.xml : 스프링 프로젝트에서 웹과 관련된 모든 속성을 처리 root-context.xml : 스프링 프로젝트에서 웹을 제외한 모든 속성을 처리 FrontController패턴 기존 패턴(Page Controller)보다 더 강제적으로 페이지제어를 할 수 있게 됨 기존 패턴(컨트롤러 하나가 전체 로직을 제어) –위임 사용–&gt; FrontController(일부분만 제어하는 컨트롤러 생성) 스프링MVC패턴에서 컨트롤러의 역할 페이지 요청에 따라 파라미터 처리(DTO객체, VI객체) 애노테이션을 사용한 처리 로직이 집중되게끔 해주는 역할 테스트 동작의 편의성 1234567---------------------------------------------------------------- 주소요청 -&gt; FC &lt;-&gt; C &lt;-&gt; Service &lt;-&gt; DAO &lt;-&gt;MyBatis &lt;-&gt; MySQL | V---------------------------------------------------------------- Spring MVC 각 작업분류 작업 스프링MVC가 처리해주는 작업 URI를 분석해서 알맞는 Controller 찾기 Controller에 필요한 메서드 호출 Controller의 결과 데이터를 VIEW로 전달 적절한 VIEW 페이지를 찾아서 연결 개발자가 처리해야하는 작업 특정 URI에 동작하는 Controller를 설계 서비스 객체 생성 (약한결합) DAO 객체 생성 (약한결합) Controller 내부에 원하는 동작을 메서드로 설계 VIEW에서 전달받은 데이터 출력 스프링 웹 프로젝트 Presentation Layer : UI담당하는 계층, 웹,모바일 구분 view-jsp 페이지, html/css/js 페이지, Controller 페이지 처리 Business Layer : 서비스 계층, 사용자 요구사항을 바탕으로 구현하는 계층(기능적 구현) 컨트롤러와 DB 직접 연결을 방지하는 역할 Data Access Layer(=Persistence Layer) : 데이터처리 계층, DB관련 처리 DAO객체 처리 My(i)Batis 호출(마이바티스가 아래의 DB에 접근함) Data Base 주요 애노테이션(Annotation) 주요 애너테이션 특징 @Controller 스프링 MVC 컨트롤러 객체의미 (클래스) @RequestMapping 특정 URI에 매칭되는 클래스,메서드처리 (클래스,메서드) @RequestParam 요청정보 중에서 파라미터값을 찾을때사용(파라미터) @ModelAttribute 자동으로 해당 객체를 뷰까지 전달 (메서드,파라미터) @SessionAttribute 세션객체 안에서 정보를 유지 (클래스) @Repository DAO 객체 (클래스) @Service 서비스 객체(클래스)","link":"/2020/10/07/201008spring/"},{"title":"[자바JAVA]1059 : [기초-비트단위논리연산] 비트단위로 NOT 하여 출력하기(설명), Scanner로 2진수받기","text":"문제 1059 : [기초-비트단위논리연산] 비트단위로 NOT 하여 출력하기(설명)입력 된 정수를 비트단위로 참/거짓을 바꾼 후 정수로 출력해보자.비트단위(bitwise)연산자 ~ 를 붙이면 된다.(~ : tilde, 틸드라고 읽는다.) 12345678910111213** 비트단위(bitwise) 연산자는,~(bitwise not), &amp;(bitwise and), |(bitwise or), ^(bitwise xor),&lt;&lt;(bitwise left shift), &gt;&gt;(bitwise right shift)가 있다.예를 들어 1이 입력되었을 때 저장되는 1을 32비트 2진수로 표현하면 00000000 00000000 00000000 00000001 이고,~1은 11111111 11111111 11111111 11111110 가 되는데 이는 -2를 의미한다.예시int a=1;printf(\"%d\", ~a); //-2가 출력된다. 입력예시정수 1개가 입력된다. (-2147483648 ~ +2147483647) 12 출력예시비트 단위로 1 -&gt; 0, 0 -&gt; 1로 바꾼 후 그 값을 10진수로 출력한다. 1-3 코드12345678910import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); System.out.println(~a); }} 배운 지식괜히 어렵게 생각했다. 2진수를 만들어야한다고 생각해서 사용자로부터 String을 받아서 2진수로 변경 후 비트연산자 적용하여 10진수로 출력하려고 했는데 잘 되지않았다. 앞으로 2진수로 받아야한다하면 그냥 int로 받아야겠다! 2진수 처리 비교- 2진수, 8진수 16진수를 Scanner로 받으려면 String 데이터타입으로 지정해야한다. 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/10/11/201012al-c1059/"},{"title":"[자바JAVA]1064 : [기초-삼항연산] 정수 3개 입력받아 가장 작은 수 출력하기(설명), 삼항연산자로 최소값찾기","text":"문제 1064 : [기초-삼항연산] 정수 3개 입력받아 가장 작은 수 출력하기(설명)입력된 세 정수 a, b, c 중 가장 작은 값을 출력하는 프로그램을 작성해보자.단, 조건문을 사용하지 않고 3항 연산자 ? 를 사용한다. 입력예시3개의 정수가 공백으로 구분되어 입력된다. 2147483648 ~ +2147483648 13 -1 5 출력예시가장 작은 값을 출력한다. 1-1 내코드삼항연산은 쉽지만 헷갈리기때문에 정신을 똑바로 차리고 참과 거짓을 콜론(:)으로 가려내야한다. 123456789101112131415import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] nums = sc.nextLine().split(\" \"); sc.close(); int a = Integer.parseInt(nums[0]); int b = Integer.parseInt(nums[1]); int c = Integer.parseInt(nums[2]); System.out.printf(\"%d\", a&gt;b? b&gt;c? c:b : a&gt;c? c:a); }} 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/10/12/201012al-c1064/"},{"title":"[스프링SPRING]STS 단축키 추가하기(스프링 이클립스 단축키), System.out.printf()단축키","text":"STS 단축키 추가하기Spring Tool Suite 4(STS)는 이클립스환경이다. 이클립스와 동일하게 단축키도 이용가능한 줄 알았다.sout + Ctrl + Space를 통해서 System.out.println()을 이용하려고 했는데 단축키가 적용되지않았다.sysout 매번 입력하기는 너~~~~무 귀찮기때문에 구글링하여 직접 단축키를 추가해보았다. 이클립스도 STS와 별반 다르지않게 단축키를 추가할 수 있다. 1. Window &gt; Preferences 클릭 &gt; Templates검색2. Java-Editor하위의 Templates 클릭(사진 속 1번 참조) 여기서 내장되어있는 단축키를 확인할 수 있다. 기존 단축키 수정도 가능하고 새로운 단축키 추가도 가능하다 3. New버튼클릭(사진 속 2번 참조)4. Edit Template에 단축키 추가(사진 속 3번 참조) Name : 원하는 단축키 Context : Java statements 설정 Description : 단축키 설명 입력 Pattern : 단축키 입력시 원하는 동작 추가 12//Pattern예시System.out.println(${word_selection}${});${cursor} 나는 두가지를 단축키로 추가하였다. System.out.println()를 sout으로 단축키 추가 지정 System.out.printf()를 souf로 단축키 추가 지정 12345//`System.out.println()`를 `sout`으로 단축키 추가 지정시 Pattern예시System.out.println(${word_selection}${});${cursor}//`System.out.printf()`를 `souf`로 단축키 추가 지정시 Pattern예시System.out.printf(${word_selection}${});${cursor} 5. OK클릭 &gt; Apply and Close 클릭(사진 속 4번 참조) 단축키가 잘 되는 지 확인한다. 완-벽!","link":"/2020/10/07/201008stsAddShortcuts/"},{"title":"[자바JAVA]1066 : [기초-조건&#x2F;선택실행구조] 정수 3개 입력받아 짝&#x2F;홀 출력하기(설명), Scanner 기본구분자, whitespace(화이트스페이스)뜻","text":"문제 1066 : [기초-조건/선택실행구조] 정수 3개 입력받아 짝/홀 출력하기(설명)세 정수 a, b, c가 입력되었을 때, 짝(even)/홀(odd)을 출력해보자. 입력예시세 정수 a, b, c 가 공백을 두고 입력된다. 10 &lt;= a, b, c &lt;= +2147483647 11 2 8 출력예시 123oddeveneven 코드11234567891011121314151617import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] nums = sc.nextLine().split(\" \"); sc.close(); for(int i=0; i&lt;nums.length; i++){ if(Integer.parseInt(nums[i])%2 == 0){ System.out.println(\"even\"); } else { System.out.println(\"odd\"); } } }} 내가 제일 처음 생각한 코드이다.최대한 반복을 줄이고싶어서 String 배열로 받아서 if문안에서 int로 변형했다.좋은 코드가 있을까싶어 다른 코드들도 구글링했는데 더 좋은 코드를 찾았다. 코드212345678910111213141516171819import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] arr = new int[3]; for(int i=0; i&lt;3; i++) { arr[i]= sc.nextInt(); if(arr[i]%2 ==0) { System.out.println(\"even\"); } else { System.out.println(\"odd\"); } } sc.close(); }} 배운 지식두 코드의 메모리사용과 시간, 코드길이를 비교해보았다 코드1(String Array사용) 코드2(int Array사용) 메모리 14908 14948 시간 112 113 코드길이 590 B 458 B 공백으로 나누어야하니까 String Array만 써야하는 줄 알았는데 int Array도 가능했다.코드길이도 더 짧다.어떻게 nextInt()는 space를 받아들일까? Scanner default delimiter (스캐너 클래스 기본 구분자)엄청 열심히 검색해서 그 답을 알아냈다.그 답은 nextInt()메서드가 아닌 Scanner 클래스에 있었다. A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various next methods.출처 : https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html 여기서 말하는 기본 구분자(default delimiter)는 화이트스페이스(whitespace)라고한다. whitespace (화이트 스페이스)그렇다면 화이트스페이스(whitespace)가 무엇일까?화이트 스페이스란 말그대로 의미없는 공백, 탭, 행 등등을 의미한다.예를 들어 소스코드 끝에 있는 공백이라든지 의미없는 새로운 행이 있다. 화이트 스페이스의 종류 space tabs new lines The Scanner class provides a versatile way of reading data of various types including Files, InputStreams and simple String objects. The input data must be delimited by some character. By default the delimiters are white space (space, tabs, and new lines). The class provides methods for changing the delimiter.출처 : http://csc.columbusstate.edu/woolbright/java/scanner.html 자바에서는 whitespace인지 아닌지 구분하는 isWhitespace()메서드가 있다. https://docs.oracle.com/javase/6/docs/api/java/lang/Character.html#isWhitespace(char) 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이 1089","link":"/2020/10/12/201012al-c1066/"},{"title":"[SQL퀴즈] not a single-group group function 해결, group by사용, outer join사용","text":"문제employees 테이블과 departments 테이블로부터 각 부서에 대한 부서번호(department_id), 부서이름(department_name), 위치(location_id) 및 사원(employee_id) 수를 보여주는 쿼리구문을 작성하시오.단, 사원이 없는 부서도 출력을 시키시오. 두 테이블 구조는 아래와 같다. 123456789101112131415$&gt; desc employees;이름 널? 유형 -------------- -------- ------------ EMPLOYEE_ID NOT NULL NUMBER(6) FIRST_NAME VARCHAR2(20) LAST_NAME NOT NULL VARCHAR2(25) EMAIL NOT NULL VARCHAR2(25) PHONE_NUMBER VARCHAR2(20) HIRE_DATE NOT NULL DATE JOB_ID NOT NULL VARCHAR2(10) SALARY NUMBER(8,2) COMMISSION_PCT NUMBER(2,2) MANAGER_ID NUMBER(6) DEPARTMENT_ID NUMBER(4) 12345678$&gt; desc departments;이름 널? 유형 --------------- -------- ------------ DEPARTMENT_ID NOT NULL NUMBER(4) DEPARTMENT_NAME NOT NULL VARCHAR2(30) MANAGER_ID NUMBER(6) LOCATION_ID NUMBER(4) 내쿼리12345678select e.department_id, d.department_name, d.location_id, count(e.employee_id)from employees ejoin departments don d.department_id = e.department_id;//출력값ORA-00937: 단일 그룹의 그룹 함수가 아닙니다00937 00000 - \"not a single-group group function\" 강사님코드12345SELECT d.department_id, d.department_name, d.location_id, COUNT(e.employee_id)FROM employees e RIGHT OUTER JOIN departments dON e.department_id = d.department_idGROUP BY d.department_id, d.department_name, d.location_id; 배운 지식첫번째 join할때 내 코드는 inner join으로 조인조건을 만족하는 행만 반환한다 반면 outer join은 조인조건을 만족하는 행과 조인조건을 만족하지않는 행을 모두 반환하기때문에 문제에서 제시했던 단, 사원이 없는 부서도 출력을 시키시오.까지 만족시킬 수 있다. 따라서 outer join을 사용해야한다. 두번째 not a single-group group function 의미는 해당 SQL쿼리문에 특정 열이 GROUP BY구에서 참조되지 않으면 그 열과 Group function를 포함할 수 없으므로 group by를 넣어야한다. Group by절 Group by절은 count하는 열빼고 다 작성해야한다.","link":"/2020/10/12/201013dbi-q11-2/"},{"title":"[자바JAVA]1071 : [기초-반복실행구조] 0 입력될 때까지 무한 출력하기1(설명)","text":"문제 1071 : [기초-반복실행구조] 0 입력될 때까지 무한 출력하기1(설명)정수가 순서대로 입력된다. (-2147483648 부터 +2147483647까지, 단 개수는 알 수 없다.) 0이 아니면 입력된 정수를 출력하고, 0이 입력되면 출력을 중단해보자.while( ), for( ), do while( ) 등의 반복문을 사용할 수 없다. 참고goto 명령문을 사용하면 간단한 반복 실행을 만들 수 있다.반복 실행 부분을 빠져나오기 위해(즉 무한 반복을 방지하기 위해)반복 실행 되는 도중에 조건을 검사해야 한다. goto 이름:이 명령은 이름: 이 작성된 곳으로 프로그램의 실행 흐름을 바꾸어 준다. “이름:” 과 같이 콜론(:)이 붙어있는 부분을 이름표(label, 레이블)라고 한다.레이블은 특별한 선언 없이 사용할 수 있으며 언더바(_)나 영문자로 시작하면 된다.레이블은 한 단어처럼 공백없이 모두 붙여 써야 한다. switch( ) … case … : … break; 에서case … : 도 일종의 레이블이라고 생각할 수 있다. goto 레이블:명령을 사용하면 반복되는 부분을 여러 개 자유롭게 만들 수 있다. goto 명령은 반복 실행을 만들어낼 수 있는 가장 간단한 명령이지만,복잡하게(스파게티 코드) 사용하는 경우, 이해가 어렵고 오류가 생기기 쉽다. 입력예시정수가 순서대로 입력된다. (-2147483648부터 +2147483647까지, 단 개수는 알 수 없다.) 17 4 2 3 0 1 5 6 9 10 8 출력예시입력된 정수를 줄을 바꿔 하나씩 출력하는데, 0이 입력되면 종료한다.(0은 출력하지 않는다.) 12347423 코드1234567891011121314import java.util.Scanner;class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int nums; while(true){ nums = sc.nextInt(); if(nums == 0) break; System.out.println(nums); } }} 배운지식첫번째 C언어나 C++과는 달리 자바에는 goto 문이 없습니다. 따라서 이렇게 반복문을 가리키는 이름(label)은 break 문이나 continue 문에만 사용될 수 있습니다.출처 : http://tcpschool.com/java/java_control_etc 두번째 갯수를 모르면 for반복문이 아니라 while반복문을 사용해야한다. 그리고 while반복문사용시 무한루프로 빠질 수 있으므로 나가는 조건을 꼭 확인한다. 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이 1089","link":"/2020/10/13/201014al-c1071/"},{"title":"[SQL퀴즈] substr과 TO_CHAR차이","text":"문제employees 테이블로부터 각 월의 16일 이전에 채용된 사원을 모두 출력하는 쿼리구문을 작성하시오.사용가능한 컬럼명 : hire_date, last_name 내코드123select last_name, hire_datefrom employeeswhere substr(hire_date, -2, 2) &lt; 16; 강사님쿼리123SELECT last_name, hire_date FROM employees WHERE TO_CHAR(hire_date, 'DD') &lt; 16; 배운지식날짜형식은 나라에 따라 달라진다. 우리나라는 년-월-일순이지만 미국은 보통 월-일-년순, 뉴질랜드는 보통 일-월-년이기도 하다. 이처럼 다양한 나라가 서로 다른 날짜형식을 사용한다.내 코드처럼 substr를 사용하면 날짜형식이 변하는 순간 다시 index값을 찾아서 작성해야한다. 하지만 TO_CHAR를 사용하면 DD를 찾기때문에 날짜형식이 달라도 날짜만을 찾아서 쿼리를 진행할 수 있어 수월하다.","link":"/2020/10/12/201013dbi-q11-3/"},{"title":"[스프링SPRING]페이지이동하기, 파라미터가지고 페이지이동하기","text":"특정 주소를 처리하는 메서드 2가지방식(페이지이동하기) 리턴타입이 있는지 없는지에 따라 두가지 방식으로 나누어진다 메서드 리턴타입이 void인 경우 [주소.jsp] 페이지 호출 메소드 리턴타입이 String인 경우 [리턴되는_문자열.jsp] 페이지 호출 return타입 없는 경우 void 메서드를 사용하면 된다 입력하는 주소 : http://localhost:8088/test/home 메서드 실행에 따라 호출되는 페이지 : home.jsp 123456// http://localhost:8088/test/home@RequestMapping(\"home\")private void doA() { System.out.println(\"doA 메서드 호출\"); logger.info(\"Logger: doA()호출\");} return타입 있는 경우 string, int, 객체 등등 알맞은 데이터타입을 적어주면 된다. 입력하는 주소 : http://localhost:8088/test/doC 메서드에 따라 호출되는 페이지 : abc.jsp 12345678910111213@Controllerpublic class SampleController2 { // 로그정보를 처리하는 객체 생성 private static final Logger logger = LoggerFactory.getLogger(SampleController2.class); // http://localhost:8088/test/doC @RequestMapping(\"doC\") private String doC() { //리턴타입 String인 경우 logger.info(\"doC 메서드 호출\"); return \"abc\"; }} 파라미터가지고 페이지이동하기 파라미터의 데이터타입에 따라 다양하게 전달 가능 파라미터 앞에 애노테이션과 키명을 적어주어야한다 @ModelAttribute(&quot;키_이름&quot;) 예시 : 쇼핑몰로그인기능구현 파라미터 타입이 String인 경우 리턴타입이 String일때 리턴값 redirect: 또는 forward:로 페이지이동하기 입력하는 주소 : http://localhost:8088/test/testParam?msg=&quot;hi&quot; 메서드에 따라 호출되는 페이지 : doC.jsp java코드 파라미터를 return할때 함께 줄 수 없을까? 즉 return “doC?msg=Hi”;가 가능할까? NOPE 안된다. 그 이유는 doC?msg=hi.jsp로 매핑이 되서 오류가 발생한다. 12345678// http://localhost:8088/test/testParam?msg=\"hi\"@RequestMapping(value = \"testParam\")private String doC1(@ModelAttribute(\"msg\") String msg, @ModelAttribute(\"name\") String username) { logger.info(\"doC1 메서드 호출, 파라미터 메세지: \"+msg+\", 유저이름: \"+username); return \"doC\"; // return \"doC?msg=Hi\"; // Q. 에러의 이유가 'doC?msg=hi.jsp'로 매핑이 되서 그런거 아닌가요? A. 맞음} doC.jsp 뷰 페이지 코드 표현식에는 el표현식방식과 jsp표현식방식이 있다. 두가지 표현방식 중 주로 EL표현식을 사용한다. 그 이유는 EL표현식은 데이터가 NULL일때 컴파일에러가 없이 빈 공백으로 표시되기때문에 안정성이 높아서. 123456&lt;strong&gt;(el태그 사용)&lt;/strong&gt; 전달받은 메세지 파라미터는 ${msg } 입니다. 너의 이름은? ${name }&lt;br&gt;&lt;strong&gt;(jsp표현식 사용)&lt;/strong&gt; 전달받은 메세지 파라미터는 &lt;%=request.getParameter(\"msg\") %&gt; 입니다. 너의 이름은? &lt;%=request.getParameter(\"name\") %&gt;&lt;br&gt;//출력값(el태그 사용) 전달받은 메세지 파라미터는 hi 입니다. 너의 이름은?(jsp표현식 사용) 전달받은 메세지 파라미터는 hi 입니다. 너의 이름은? null 파라미터 타입이 객체인 경우 기존에는 request.setAttribute로 객체를 넘겼는데 스프링에서는 model객체(스프링mvc에서 제공해주는 객체)를 사용 model 객체는 객체를 저장해서 뷰페이지로 전달 model 객체 생성 방법 두가지 첫번째 방법: 키와값 쌍으로 전달 model.addAttribute(&quot;vo&quot;, vo); 두번째 방법: 키없이 객체만 전달 model.addAttribute(vo); 키없이 객체만 전달한 경우 받을때는 클래스 첫글자를 소문자 변경해서 el표현식으로 호출해야함. 공통코드 : ProductVO.java라는 객체생성 123456789101112131415161718192021222324252627282930313233343536// 도메인 : 프로젝트에서 중요한 의미를 가지는 명사로 ex) 회원, 글, 상품, 주문 ... 등등//자바빈(DTO == VO)설계규약//규칙1번 : public클래스public class ProductVO { //규칙2 : private로 멤버변수 생성 private String name; private double price; //규칙4 : 생성자(생략가능 - 생략하면 디폴트생성자) public ProductVO() {}; public ProductVO(String name, double price) { this.name = name; this.price = price; }; //규칙3 : getter setter메서드생성 public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } // 5. toString @Override public String toString() { return \"제품정보 [name=\" + name + \", price=\" + price + \"]\"; }} 동일한 페이지명으로 페이지이동시 자바코드 입력한 주소 : http://localhost:8088/test/doD 메서드에 따라 호출되는 페이지 : doD.jsp 123456789101112131415161718192021@Controllerpublic class SampleController3 { // 페이지 이동시 객체 정보를 가지고 이동 // 로그정보 처리 객체 private static final Logger logger = LoggerFactory.getLogger(SampleController3.class); // http://localhost:8088/test/doD @RequestMapping(\"doD\") public void doD(Model model) { logger.info(\"doD() 호출!!!\"); //상품객체생성 ProductVO vo = new ProductVO(\"phone\", 100); // 첫번째 방법 : 키와값 쌍으로 전달 model.addAttribute(\"vo\", vo); // 두번째 방법: 키없이 객체만 전달 model.addAttribute(vo); }} doD.jsp 뷰페이지 코드 1234567891011121314151617181920&lt;body&gt;전달받은 객체 호출&lt;br&gt;&lt;!-- toString()를 통해서 출력 --&gt;&lt;%=request.getAttribute(\"vo\") %&gt;&lt;p&gt;&lt;/p&gt;제품명 : ${vo.name } &lt;br&gt;가격 : ${vo.price } &lt;br&gt;&lt;hr&gt;제품명 : ${productVO.name } &lt;br&gt;가격 : ${productVO.price } &lt;br&gt;&lt;/body&gt;//출력값전달받은 객체 호출제품정보 [name=phone, price=100.0]제품명 : phone가격 : 100.0제품명 : phone가격 : 100.0 다른 페이지명으로 페이지이동시 자바코드 입력한 주소 : http://localhost:8088/test/doD 메서드에 따라 호출되는 페이지 : doDPage.jsp 12345678910111213141516171819202122@Controllerpublic class SampleController3 { // 페이지 이동시 객체 정보를 가지고 이동 // 로그정보 처리 객체 private static final Logger logger = LoggerFactory.getLogger(SampleController3.class); // http://localhost:8088/test/doD @RequestMapping(\"doD\") public String doD(Model model) { logger.info(\"doD() 호출!!!\"); //상품객체생성 ProductVO vo = new ProductVO(\"phone\", 100); // 첫번째 방법: 키와값 쌍으로 전달 model.addAttribute(\"vo\", vo); // 두번째 방법: 키없이 객체만 전달 model.addAttribute(vo); return \"doDPage\"; }} doDPage.jsp 뷰페이지 코드 1234567891011121314151617181920&lt;body&gt;전달받은 객체 호출(doDpage.jsp)&lt;br&gt;&lt;!-- toString()를 통해서 출력 --&gt;&lt;%=request.getAttribute(\"vo\") %&gt;&lt;p&gt;&lt;/p&gt;제품명 : ${vo.name } &lt;br&gt;가격 : ${vo.price } &lt;br&gt;&lt;hr&gt;제품명 : ${productVO.name } &lt;br&gt;가격 : ${productVO.price } &lt;br&gt;&lt;/body&gt;//출력값전달받은 객체 호출(doDpage.jsp)제품정보 [name=phone, price=100.0]제품명 : phone가격 : 100.0제품명 : phone가격 : 100.0","link":"/2020/10/12/201013spring/"},{"title":"[자바JAVA]1072 : [기초-반복실행구조] 정수 입력받아 계속 출력하기","text":"문제 1072 : [기초-반복실행구조] 정수 입력받아 계속 출력하기n개의 정수가 순서대로 입력된다.(-2147483648 부터 +2147483647까지, 단 n의 최대 개수는 알 수 없다.)n개의 입력된 정수를 순서대로 출력해보자.while( ), for( ), do~while( ) 등의 반복문을 사용할 수 없다. 문제 힌트를 보면 C언어의 lable과 goto를 사용하라고 나왔다.goto는 자바에 있는 예약어지만 기능은 없다. 입력예시첫 줄에 정수의 개수 n이 입력되고,두 번째 줄에 n개의 정수가 공백을 두고 입력된다. (-2147483648 부터 +2147483647까지, 단 n의 최대 개수는 알 수 없다.) 1251 2 3 4 5 출력예시n개의 정수를 한 개씩 줄을 바꿔 출력한다. 1234512345 풀이1 메모리: 15004 시간: 114 123456789101112public static void main(String[] args) throws IOException { //sol1 메모리: 15004 시간: 114 Scanner sc = new Scanner(System.in); int len = sc.nextInt(); int[] value = new int[len]; for(int i = 0; i &lt;value.length; i++) { value[i] =sc.nextInt(); System.out.println(value[i]); }} 풀이2 메모리: 14316 kb 수행 시간: 111 ms 12345678910111213public static void main(String[] args) throws IOException { // sol2 // 메모리: 14316 kb 수행 시간: 111 ms Scanner sc = new Scanner(System.in); int len = sc.nextInt(); int[] nums = new int[len]; for(int i : nums){ nums[i] = sc.nextInt(); System.out.println(nums[i]); } sc.close();} 풀이3 메모리 :11132 kb 수행 시간:68 ms 12345678910public static void main(String[] args) throws IOException { //sol3 // 메모리 :11132 kb 수행 시간:68 ms BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String n = br.readLine(); String[] num = br.readLine().split(\" \"); for(String s : num){ System.out.println(s); }} 배운지식입력을 두 번 받으면 되는 문제였다.난 어떻게든 한 번 입력받고 처리할려고했으니 잘 될 턱이 있나…역시 BufferedReader가 빠르다 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이 1089","link":"/2020/10/13/201014al-c1072/"},{"title":"[자바JAVA]1082 : [기초-종합] 16진수 구구단?","text":"문제 1082 : [기초-종합] 16진수 구구단?16진수(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)를 배운 영일(01)이는 16진수끼리 곱하는 16진수 구구단?에 대해서 궁금해졌다.A, B, C, D, E, F 중 하나가 입력될 때, 1부터 F까지 곱한 16진수 구구단의 내용을 출력해보자.(단, A 부터 F 까지만 입력된다.) 입력예시16진수로 한 자리 수가 입력된다.(단, A 부터 F 까지만 입력된다.) 1B 출력예시입력된 16진수에 1부터 F까지 순서대로 곱한, 16진수 구구단을 줄을 바꿔 출력한다.계산 결과도 16진수로 출력해야 한다. 123456789101112131415B*1=BB*2=16B*3=21B*4=2CB*5=37B*6=42B*7=4DB*8=58B*9=63B*A=6EB*B=79B*C=84B*D=8FB*E=9AB*F=A5 코드12345678910111213141516171819202122import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String input = sc.nextLine(); sc.close(); //String에서 16진수로 변경 int b = Integer.valueOf(input, 16); //출력 String s, ans; for (int i = 1; i &lt; 16; i++) { s = Integer.toHexString(i).toUpperCase(); ans = Integer.toHexString(b * i).toUpperCase(); System.out.println(input + \"*\" + s + \"=\" + ans); } }//end of main()} 배운지식10진수를 16진수로 변환하는 방법을 도식화해서 나타낸 것이다. 16진수는 1부터 16까지이므로 for문의 조건은 F가 아니라 16으로 설정해야한다. 진법변환 정리 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이 1089","link":"/2020/10/14/201015al-c1082/"},{"title":"[자바JAVA]1084 : [기초-종합] 빛 섞어 색 만들기(설명)","text":"문제 1084 : [기초-종합] 빛 섞어 색 만들기(설명)빨강(red), 초록(green), 파랑(blue) 빛을 섞어 여러 가지 빛의 색을 만들어 내려고 한다.빨강(r), 초록(g), 파랑(b) 각각의 빛의 개수가 주어질 때,(빛의 강약에 따라 0 부터 n-1 까지 n가지의 빛 색깔을 만들 수 있다.) 주어진 rgb 빛들을 다르게 섞어 만들 수 있는 모든 경우의 조합(r g b)과 총 가짓 수를 계산해보자. 입력예시빨녹파(r, g, b) 각 빛의 강약에 따른 가짓수(0부터 128까지))가 공백을 사이에 두고 입력된다.예를 들어, 3 3 3 은 각 색깔 빛에 대해서 그 강약에 따라 0부터 2까지 3가지의 색이 있음을 의미한다. 12 2 2 출력예시만들 수 있는 rgb 색의 정보를 오름차순(계단을 올라가는 순, 12345… abcde…, 가나다라마…)으로 줄을 바꿔 모두 출력하고, 마지막에 그 개수를 출력한다. 1234567890 0 00 0 10 1 00 1 11 0 01 0 11 1 01 1 18 내코드출력값은 완벽하나 시간초과 결과가 나타났다. 123456789101112131415161718192021222324252627package codeUp100;import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] color = sc.nextLine().split(\" \"); sc.close(); int rPick = Integer.parseInt(color[0]); int gPick = Integer.parseInt(color[1]); int bPick = Integer.parseInt(color[2]); int count = 0; for(int r=0; r&lt;rPick; r++){ for(int g=0; g&lt;gPick; g++){ for(int b=0; b&lt;bPick; b++){ System.out.printf(\"%d %d %d\\n\", r,g,b); count ++; } } } System.out.println(count); }//end of main()} 시간초과를 해결하기 위해서는 BufferReader 와 BufferWriter 클래스를 사용하여 입력, 출력받아야한다. 12345678910111213141516171819202122232425262728293031323334import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.Scanner;public class Main { public static void main(String[] args) { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try { String[] n = br.readLine().split(\" \"); int count = 0; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); for (int i = 0; i &lt; Integer.valueOf(n[0]); i++) { for (int j = 0; j &lt; Integer.valueOf(n[1]); j++) { for (int k = 0; k &lt; Integer.valueOf(n[2]); k++) { bw.write(i + \" \" + j + \" \" + k + \"\\n\"); count++; } } } bw.write(String.valueOf(count)); bw.flush(); } catch (NumberFormatException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }//end of main()} 배운지식BufferReader 와 BufferWriter 클래스를 사용하여 입력, 출력받으면 시간초과 해결할 수 있다.System.out.println();이 굉장히 느리다는 것을 알게되었다. BufferedWriter를 이용해 bf.write(i + &quot;\\n&quot;); 출력속도는 0.9581 StringBuilder를 이용해 문자열 하나로 만든 다음, System.out.println(sb); 출력속도는 1.1881 참고링크: 자바 입출력 관련 정리(코드업 1084번, java) 추가 코드내 멘토님이 내 코드를 보시고 코드리뷰를 해주셨다.코드리뷰까지 받다니 난 참 럭키다.코드리뷰를 받으니까 재미있다! 항상 내 코드가 최선이 아니라는 생각에 더 나은 코드를 배우고싶었기때문이다.이 재미가 바로 성장하는 즐거움일까? 행-복!이번에 멘토님이 알려주신건 빅오표기법이었다. 신기했지만 동시에 어려웠다. 수련이 더 필요하다…멘토님이 중첩for문을 보곤 단일 for문을 알려주셨다.사실 나도 단일 for문쓰고싶었는데 내 마음을 어떻게 아셨지?ㅋㅋㅋㅋㅋㅋ천재인듯. 1234567891011121314151617181920212223//단일for문Scanner sc = new Scanner(System.in);String color[] = sc.nextLine().split(\" \");int r = Integer.parseInt(color[0], 10);int g = Integer.parseInt(color[1], 10);int b = Integer.parseInt(color[2], 10);int loop = r * g * b;int rLoop = g * b;int gLoop = b;try(BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out))){ for(int i=0; i&lt;loop; i++){ int colorR = i / rLoop; int colorG = (i%rLoop) / gLoop; int colorB = i % b; bw.write(colorR +\" \" + colorG + \" \" + colorB+\"\\n\"); } bw.write(loop+\"\"); bw.flush();}catch(IOException ie){ ie.printStackTrace(); 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이 1089","link":"/2020/10/14/201015al-c1084/"},{"title":"[국비교육 자바JAVA 팀프로젝트]2.팀결성, 내가 팀장?!, 첫회의 결과, 깃허브로 팀프로젝트하기","text":"팀결성, 내가 팀장?!팀구성원은 학원에서 여러 가지를 고려하여 나누어주었다. 우리 강의실은 총 16명의 수강생이있고 2팀으로 나누어졌다. 팀끼리 모였는데 다들 어색어색했다. 침묵의 시간…팀장을 선출하는데 아무도 팀장을 하고싶어하지않아 오픈카톡에서 익명투표를 했다. 그리고 내가 선출되어버렸다.어느정도 예견된 결과였다. 동아리든 팀프로젝트이든 난 항상 팀장으로 선발되었다ㅋㅋㅋㅋㅋ 익숙. 이것이 운명인가?남은 1개월이란 기간동안 다들 좋은 결과를 가져갈 수 있도록 해야지! 팀장의 마음가짐 팀원 모두가 팀프로젝트를 끝내고 무언갈 하나씩 얻어갔으면 좋겠다. 팀장이 없더라도 헤매지않고 프로세스안에서 팀원 각자 해결할 수 있는 협업 프로세스를 만들고 싶다. 함께 하는 팀을 만들고 싶다. 재미있는 의견이 자유롭게 오고갔으면 좋겠다. 첫 회의때의 내 목표내가 팀장이 될 걸 알고(?) 있었기때문에 첫 회의때 해내고 싶었던 목표들을 미리 생각해놓았다. 한 2주전부터ㅋㅋㅋㅋㅋㅋ국비학원 팀프로젝트인 경우 주제가 신선한지는 크게 중요하지 않다.가장 중요한 것은 해내는 것. 바로 완성도라고 생각했다.주제선정에 시간을 쏟을 필요가 전혀 없다고 판단했고 최대한 빨리 시작하는 것이 중요하다는 생각이 들었다. 갈수록 시간이 부족할테니까…다양하게 고려해야 할 것들이 있지만 다년간의 팀프로젝트경험으로 말하는 건데 이 자바프로젝트에서 가장 중요한 건 각 팀원의 기능구현이다. 이는 취업과 직결되어있고 면접시 필수 질문이 되기 때문이다.따라서 기능이 아닌 부차적인 것들은 빠르게 결정하려고 노력했다. 첫 회의때 끝내고 싶었던 목표 팀프로젝트 주제 디자인패턴 결정 커뮤니케이션 도구 확정 파트분배 첫 회의 결과다행히 첫 회의때 팀원들이 좋은 의견을 많이 내주어서 원해던 목표의 80%를 결정할 수 있었다.또한 팀원이 8명인만큼 페어프로그래밍을 하자고 의견을 제시하였고 팀원들도 좋다고 해서 2인 1팀으로 각 팀마다 게시판을 맡아서 짝프로그래밍을 하기로 했다. 팀프로젝트 주제 : 다내놔는 회원이 구매자인 동시에 판매자가 될 수 있는 쇼핑 플랫폼입니다. 쇼핑몰이 레퍼런스도 많고 팀원들중 다수가 하고자했던 프로젝트였다. 다나와처럼 컴퓨터와 관련된 상품을 판매하는 사이트로 모티브를 잡았다. 팀프로젝트 이름도 한 팀원의 재치로 금방 정해졌다. 디자인패턴 결정 : springMVC패턴 springMVC패턴은 지금 공부하고 있고 model2패턴은 이미 수업이 끝났다. 그나마 익숙한 model2패턴을 할지 springMVC패턴으로 도전할 지 논의가 있었다. 이를 익명투표를 통해 해결했다. 커뮤니케이션 도구 확정 : 오픈카톡, 깃허브 레포 깃허브 레포를 적극 어필했고 팀원들에게 받아들여져서 레포를 생성하고 collaborator로 팀원들을 초대했다. 깃허브 레포지토리 : 다내나샵 칸반보드 형식인 깃허브 Projects를 사용하여 전체 프로세스 진행사항을 체크할 수 있도록 하였다. 다른 팀프로젝트 레포지토리를 참고하여 팀프로젝트 규정을 wiki에 작성했다. 회의록 중 중요한 사항을 남기기위해 새로운 페이지에 작성했다. 1234567891011121314151617181920212223## 💻 협업규칙1. 담당파트를 Pair프로그래밍으로 진행합니다.2. 각 팀에서는 진행사항을 수시로 Projects탭에 업데이트합니다. - 1. 드래그를 통해 진행사항 업데이트.(To do, WIP, Done 중 선택) - 1. 추가 기술은 자신의 팀에 `+` 버튼을 눌러 자세히 적어서 추가합니다.3. DB테이블은 팀전체가 함께 구상합니다.## 💻 Commit Rule기능기능-상세기능ex) \"회원가입\"\"로그인-유효성확인\"## 💻 PR RulePR은 기능단위로 진행합니다.rebase 대신 merge 사용합니다.## 💻 주요 회의록1. [201014 첫회의](https://github.com/sowon-dev/danenaShop/wiki/201014-%EC%B2%AB%ED%9A%8C%EC%9D%98) 파트분배 : 못함…. CSS : 부트스트랩 직접 view페이지를 작성할지말지 의견이 분분했다. 각각의 장단점이 분명히 존재하기 때문이다. 직접 만들기 장점 : 변수명등을 직접 생성하기때문에 뷰페이지 이해도 쉬움 단점 : 직접 뷰페이지를 만들기때문에 긴 생성시간, 부족한 미적인 요소 템플릿 가져다쓰기 장점 : 미적요소 향상, 전체프로젝트생성시간 단축 단점 : 페이지 이해가 어려움, 긴 적응시간 따라서 다수결에 의해 템플릿을 이용하기로 했다. 앞으로 해야할 것 협업규칙은 가장 기본적인 것들만 내가 찾아서 적은 것이므로 팀원들과 회의를 통해 구체화 할 예정이다. CSS 템플릿 선택 파트분배 DB테이블 설계","link":"/2020/10/13/201014team/"},{"title":"[스프링SPRING]Spring MVC JUNIT TEST Failure와 Error차이","text":"Spring MVC JUNIT TEST결과 Failure : 테스트의 기대값과 결과값이 틀린경우 발생한다. 개발자가 기대값을 지정하고 그것과 다른 결과값이 나올 경우 발생한다. Error : 테스트 수행시 오류발생, NullPointerException과 같은 RuntimeError일 경우 발생한다. 주로 xml파일에 오타등의 에러가 발생하면 Error가 발생한다. xml 파일은 태그 안에 코드를 작성하므로 오타가 발생하는 지 안 하는지 바로 빨간줄체크가 되지 않는다(런타임에러체크). 따라서 이걸 junit이 해결해준다.","link":"/2020/10/14/201015spring-1/"},{"title":"DB BACKUP","text":"DB BACKUP(DB복구) 도구 USER 관리방식의 backup : 운영체제 명령어(CP)를 사용한 백업과 복구 RMAN 관리방식의 backup : RMAN(알맨)프로그램과 RMAN명령어를 사용한 백업과 복구 RMAN = recovery manager의 약자 오라클이 제공해주는 전문 리커버리 툴 백업(이하 bk) 전략 전체 DB bk : 모든 Datafile과 하나이상의 Controlfile을 포함한 백업 부분 DB bk : 특정 Datafile만, Controlfile만 백업 백업 모드 Offline bk(=cold bk) : DB가 꺼진 상태(shut, nomount, mount)에서의 백업 Online bk(=hot bk) : DB가 켜진 상태(open)에서의 백업 백업 유형(Datafile만 해당됨) Full bk : Datafile의 모든 block을 포함한 백업 Incremental bk : 마지막 백업 이후 변경된 block만을 포함한 백업 백업 파일 유형 image copy : 복사본 형태의 백업 파일 유형 (원본:백업본 = 1:1) 확장자명 .dbf backupset : 파일들의 모음(묶음)형태의 백업 파일 유형 (원본:백업본 = n:1) 확장자명 .bkp DB백업 순서 위의 4가지방식을 결정한 뒤 DB백업을 진행해야한다. 실습 : USER 관리방식의 backup + 전체 DB bk + Offline bk(=cold bk) + Full bk + image copy 현재 가지고 있는 datafile과 controlfile 정보조회 현재 내가 가지고 있는 datafile 8개, controlfile 3개 12345678910111213141516171819202122SQL&gt; select name from v$datafile;NAME--------------------------------------------------------------------------------/u01/app/oracle/oradata/ORCL/datafile/o1_mf_system_fwvn49fw_.dbf/u01/app/oracle/oradata/ORCL/datafile/o1_mf_users_hp871s7n_.dbf/u01/app/oracle/oradata/ORCL/datafile/o1_mf_sysaux_fwvn5f1l_.dbf/u01/app/oracle/oradata/ORCL/datafile/o1_mf_undotbs1_fwvn66mp_.dbf/u01/app/oracle/oradata/ORCL/datafile/o1_mf_example_hp86s7s0_.dbf/u01/app/oracle/oradata/ORCL/datafile/o1_mf_users_fwvn681o_.dbf/u01/app/oracle/oradata/ORCL/datafile/appuser01.dbf/u01/app/oracle/oradata/ORCL/datafile/appuser02.dbf8 rows selected.SQL&gt; select name from v$controlfile;NAME--------------------------------------------------------------------------------/u01/app/oracle/oradata/ORCL/controlfile/o1_mf_fwvn95xm_.ctl/u01/app/oracle/fast_recovery_area/orcl/ORCL/controlfile/o1_mf_fwvn96cd_.ctl/home/oracle/control103.ctl 백업을 위해 DB를 정상적으로 종료한다. 12SQL&gt; shut immediateSQL&gt; ! 백업파일을 저장할 폴더를 생성한다. 1[oracle@localhost oracle]$ mkdir backup controlfile백업하기 백업할 컨트롤파일이 있는 곳으로 이동 후 copy명령어를 입력한다 원본경로 안에서 cp명령어를 날릴경우 원본경로는 생략가능하다 1234567891011121314//현재 컨트롤파일확인[oracle@localhost oracle]$ cd /u01/app/oracle/oradata/ORCL/controlfile[oracle@localhost oracle]$ lso1_mf_fwvn95xm_.ctl$&gt; cp 원본경로/이름 복사경로/이름//컨트롤파일백업[oracle@localhost oracle]$ cp cp o1_mf_fwvn95xm_.ctl /home/oracle/backup/conbk.ctl//백업잘되었는지 확인[oracle@localhost oracle]$ cd /home/oracle/backup[oracle@localhost backup]$ lsconbk.ctl datafile백업하기 .(점)의 의미 : 원본파일명 그대로 복사하겠다는 의미. 123456789101112131415//현재 데이터파일 확인[oracle@localhost backup]$ cd /u01/app/oracle/oradata/ORCL/datafile/[oracle@localhost datafile]$ lsappuser01.dbf o1_mf_sysaux_fwvn5f1l_.dbf o1_mf_undotbs1_fwvn66mp_.dbf redo1c.log redo4c.logappuser02.dbf o1_mf_system_fwvn49fw_.dbf o1_mf_users_fwvn681o_.dbf redo2c.logo1_mf_example_hp86s7s0_.dbf o1_mf_temp_fwvnbgvk_.tmp o1_mf_users_hp871s7n_.dbf redo3c.log//데이터파일 전체 백업[oracle@localhost datafile]$ cp *.dbf /home/oracle/backup/.//백업완료되었는지 확인[oracle@localhost datafile]$ cd /home/oracle/backup[oracle@localhost backup]$ lsappuser01.dbf conbk.ctl o1_mf_sysaux_fwvn5f1l_.dbf o1_mf_undotbs1_fwvn66mp_.dbf o1_mf_users_hp871s7n_.dbfappuser02.dbf o1_mf_example_hp86s7s0_.dbf o1_mf_system_fwvn49fw_.dbf o1_mf_users_fwvn681o_.dbf 다시 DB로 복귀하기 1234[oracle@localhost backup]$ exitexitSQL&gt;","link":"/2020/10/15/201016dbi/"},{"title":"[스프링SPRING]JDBC로그 라이브러리 설치","text":"Log4Jdbc Log4j2 JDBC 4 » 1.16 설치해당 라이브러리는 jdbc와 관련된 로그를 콘솔에 출력할 수 있다. Log4Jdbc Log4j2 JDBC 4 » 1.16 복사하여 pom.xml에 붙여넣기 root-context.xml에서 아래 두 값을 변경해준다. driverClassName의 value를 net.sf.log4jdbc.sql.jdbcapi.DriverSpy로 변경 url의 value를 jdbc:log4jdbc:mysql://localhost:3306/springdb?useSSL=false로 변경 1234567891011121314151617181920&lt;!-- DriverManagerDataSource 객체 --&gt;&lt;!-- DataSource 정보를 가지고 있는 DriverManagerDataSource 객체를 생성 &gt; --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;&lt;!-- &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/springdb?useSSL=false\"/&gt;--&gt; &lt;property name=\"driverClassName\" value=\"net.sf.log4jdbc.sql.jdbcapi.DriverSpy\"/&gt; &lt;property name=\"url\" value=\"jdbc:log4jdbc:mysql://localhost:3306/springdb?useSSL=false\"/&gt; &lt;property name=\"username\"&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property name=\"password\"&gt; &lt;value&gt;1234&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- DataSource 객체 end --&gt; log4jdbc.log4j2.properties파일과 logback.xml파일을 src/main/resources에 넣어준다 test실행시키면 앞으로 코드를 작성할때 log정보를 자세하게 확인할 수 있다. 원하는 출력값은 제일마지막줄의 윗줄에 나타난다. 1234567891011121314151617181920212223242526272829303132333435363738394041INFO : jdbc.connection - 1. Connection openedINFO : jdbc.audit - 1. Connection.new Connection returned INFO : jdbc.audit - 1. Connection.getAutoCommit() returned trueINFO : jdbc.audit - 1. PreparedStatement.new PreparedStatement returned INFO : jdbc.audit - 1. Connection.prepareStatement(select now()) returned net.sf.log4jdbc.sql.jdbcapi.PreparedStatementSpy@7004e3dINFO : jdbc.sqlonly - select now() INFO : jdbc.sqltiming - select now() {executed in 0 msec}INFO : jdbc.audit - 1. PreparedStatement.execute() returned trueINFO : jdbc.resultset - 1. ResultSet.new ResultSet returned INFO : jdbc.audit - 1. PreparedStatement.getResultSet() returned net.sf.log4jdbc.sql.jdbcapi.ResultSetSpy@4b1abd11INFO : jdbc.resultset - 1. ResultSet.getMetaData() returned com.mysql.jdbc.ResultSetMetaData@40021799 - Field level information: com.mysql.jdbc.Field@4a1c0752[catalog=,tableName=,originalTableName=,columnName=now(),originalColumnName=,mysqlType=12(FIELD_TYPE_DATETIME),flags= BINARY, charsetIndex=63, charsetName=US-ASCII]INFO : jdbc.resultset - 1. ResultSet.getType() returned 1003INFO : jdbc.resultset - 1. ResultSet.next() returned trueWARNING: An illegal reflective access operation has occurredWARNING: Illegal reflective access by org.apache.ibatis.reflection.Reflector (file:/C:/Users/ITWILL/.m2/repository/org/mybatis/mybatis/3.4.1/mybatis-3.4.1.jar) to method java.lang.String.value()WARNING: Please consider reporting this to the maintainers of org.apache.ibatis.reflection.ReflectorWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operationsWARNING: All illegal access operations will be denied in a future releaseINFO : jdbc.resultset - 1. ResultSet.getString(now()) returned 2020-10-15 15:24:24.0INFO : jdbc.resultset - 1. ResultSet.wasNull() returned falseINFO : jdbc.resultsettable - |----------------------||now() ||----------------------||2020-10-15 15:24:24.0 ||----------------------|INFO : jdbc.resultset - 1. ResultSet.next() returned falseINFO : jdbc.resultset - 1. ResultSet.close() returned voidINFO : jdbc.audit - 1. PreparedStatement.getConnection() returned net.sf.log4jdbc.sql.jdbcapi.ConnectionSpy@4f20a5e0INFO : jdbc.audit - 1. Connection.getMetaData() returned com.mysql.jdbc.JDBC4DatabaseMetaData@54da32dcINFO : jdbc.audit - 1. PreparedStatement.getMoreResults() returned falseINFO : jdbc.audit - 1. PreparedStatement.getUpdateCount() returned -1INFO : jdbc.audit - 1. PreparedStatement.close() returned INFO : jdbc.connection - 1. Connection closedINFO : jdbc.audit - 1. Connection.close() returned 2020-10-15 15:24:24.0INFO : org.springframework.context.support.GenericApplicationContext - Closing org.springframework.context.support.GenericApplicationContext@5f16132a: startup date [Thu Oct 15 15:24:24 KST 2020]; root of context hierarchy","link":"/2020/10/14/201015spring/"},{"title":"[자바JAVA]11005번 진법 변환2","text":"문제 11005번 진법 변환 210진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오.10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.A: 10, B: 11, …, F: 15, …, Y: 34, Z: 35 입력예시첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36) N은 10억보다 작거나 같은 자연수이다. 160466175 36 출력예시첫째 줄에 10진법 수 N을 B진법으로 출력한다. 1ZZZZZ 코드1234567891011121314151617181920212223242526272829303132package backjoon;import java.util.ArrayList;import java.util.List;import java.util.Scanner;// https://www.acmicpc.net/problem/11005public class mento11005 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String[] input = sc.nextLine().split(\" \"); sc.close(); int n = Integer.parseInt(input[0]); int b = Integer.parseInt(input[1]); List&lt;Character&gt; list = new ArrayList&lt;&gt;(); while(n &gt; 0) { if (n % b &lt; 10) { list.add((char) (n % b + '0')); } else { // 나머지가 10이상이면 A(10) B(11) C(12) ... Z(35) list.add((char) (n % b - 10 + 'A')); } n /= b; // b로 계속 나누기 } //출력 for(int i=0; i&lt;list.size(); i++){ System.out.print(list.get(i)); } }//end of main()} 배운 지식 숫자를 char로 나타내고 싶을때는 (char)로 형변환 형변환시 괄호가 중요하다 char를 아스키코드로 나타내고 싶을때는 숫자를 더하기 12345678910111213141516171819202122//괄호의 중요성System.out.println((char) 9+'0'); //57System.out.print((char) (9+'0')); //9//10보다 작은 수 테스트System.out.print((char) (8+'0')); //8System.out.print((char) (7+'0')); //7System.out.print((char) (6+'0')); //6System.out.print((char) (5+'0')); //5System.out.print((char) (4+'0')); //4System.out.print((char) (3+'0')); //3System.out.print((char) (2+'0')); //2System.out.print((char) (1+'0')+\"\\n\"); //1//숫자를 char로 나타내고 싶을때는 (char) 형변환System.out.println((char) 65); //A//char를 아스키코드로 나타내고 싶을때는 숫자를 더할 것System.out.println('A'+1); //66//위의 두 방법 합쳐서도 가능System.out.println((char) ('A'+1)); //B 16진수 변환 도식화 멘토님코드메소드로 뺄 생각은 안해봤는데 훨씬 흐름을 이해하기 쉬운 것 같다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;class Main { public static void main(String[] args) { new Main().solve(); } private void solve() { Scanner sc = new Scanner(System.in); String[] input = sc.nextLine().split(\" \"); int base10 = Integer.parseInt(input[0], 10); int base = Integer.parseInt(input[1], 10); String result = changeBaseN(base10, base); System.out.println(result); } private String changeBaseN(int base10, int base) { String[] nBase = makeNBase(base); String result = \"\"; while (base10 &gt;= base) { int num = base10 % base; base10 = base10 / base; result = nBase[num] + result; } result = nBase[base10] + result; return result; } private String[] makeNBase(int base) { String[] nBase = new String[base]; for (int i = 0; i &lt; base; i++) { if (i &lt; 10) { nBase[i] = i + \"\"; } else { nBase[i] = (char)('A' + (i - 10)) + \"\"; } } return nBase; }}","link":"/2020/10/18/201018al-b11005/"},{"title":"[자바JAVA]1093 : [기초-1차원배열] 이상한 출석 번호 부르기1(설명)","text":"문제 1093 : [기초-1차원배열] 이상한 출석 번호 부르기1(설명)정보 선생님은 수업을 시작하기 전에 이상한 출석을 부른다.선생님은 출석부를 보고 번호를 부르는데,학생들의 얼굴과 이름을 빨리 익히기 위해 번호를 무작위(랜덤)으로 부른다.그리고 얼굴과 이름이 잘 기억되지 않는 학생들은 번호를 여러 번 불러이름과 얼굴을 빨리 익히려고 하는 것이다.출석 번호를 n번 무작위로 불렀을 때, 각 번호(1 ~ 23)가 불린 횟수를 각각 출력해보자. 입력예시첫 번째 줄에 출석 번호를 부른 횟수인 정수 n이 입력된다. (1부터 10000까지)두 번째 줄에는 무작위로 부른 n개의 번호(1부터 23까지)가 공백을 두고 순서대로 입력된다. 12101 3 2 2 5 6 7 4 5 9 출력예시1번부터 번호가 불린 횟수를 순서대로 공백으로 구분하여 한 줄로 출력한다. 11 2 1 1 2 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 코드12345678910111213141516171819202122232425package codeup100;import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int count = sc.nextInt(); //출석 번호를 부른 횟수 int[] students = new int[23]; int numbers = 0; for (int i = 0; i&lt;count; i++) { numbers = sc.nextInt(); //무작위로 부른 n개의 번호(1 ~ 23) students[numbers - 1] += 1; } sc.close(); //출력 for (int i = 0; i &lt; students.length; i++) { System.out.printf(\"%d \", students[i]); } }} 배운 지식스캐너를 처음부터 다 입력 받으려고 하지말고 for문안에서 받고 규칙 students[numbers - 1]을 이해하는 것이 핵심이다. 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/10/18/201019al-c1093/"},{"title":"[스프링SPRING] 한글처리","text":"web.xml에서 한글처리 코드 추가 web-app태그 사이에 입력한다 12345678910111213141516 &lt;!-- 한글처리 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;","link":"/2020/10/18/201019spring-1/"},{"title":"[스프링SPRING]스프링 웹계층 : 서비스(비즈니스 로직), 컨트롤러(프레젠테이션)","text":"스프링 웹계층 서비스 계층(비즈니스 계층) 사용자의 요구사항을 일치시켜서 구현하는 계층 DAO와 Controller 사이를 연결 고객마다 다르게 처리해야하는 부분을 처리 DB와 무관하게 처리할 수 있는 영역 컨트롤러(외부호출)의 영속계층(persistence)종속을 막아준다. 컨트롤러가 트렌젝션, 예외처리등을 모두 처리해야하지만 종속적인 상황을 벗어나면 컨트롤러는 컨트롤러의 역할만 할 수 있다. @Service 의미 : 해당 클래스를 서비스 객체로 처리(스프링에서 인식할 수 있게 만듦) 프리젠테이션 계층(컨트롤러) 컨트롤러 + 뷰 기능 공통적인 URI경로, 각 기능별 URI 지정 결과처리, 페이지 이동, 예외처리 컨트롤러는 모듈로서 특정 메뉴, 기능묶음 단위로 생성한다. URI를 어떤 방식으로 처리할 것인지에 대한 설계가 필요하다. GET방식 외부에서 접근해오는 페이지 (주로 입력페이지) 정보를 조회하는 페이지 POST방식 데이터를 처리해야하는 페이지 MemberService.java 인터페이스 생성123456789package com.itwillbs.service;import com.itwillbs.domain.MemberVO;public interface MemberService { // 회원 가입 (일반회원가입테이블에 sns계정 컬럼 추가하기) // 일반적으로는 DAO랑 같은 메소드명을 사용하여 일관성을 유지한다 public void insertMember(MemberVO vo);} MemberServiceImpl.java 클래스 생성 MemberService 인터페이스를 구현 123456789101112131415161718192021222324252627package com.itwillbs.service;import javax.inject.Inject;import org.springframework.stereotype.Service;import com.itwillbs.domain.MemberVO;import com.itwillbs.persistence.MemberDAO;@Servicepublic class MemberServiceImpl implements MemberService { //DB와 연결 (의존주입) @Inject private MemberDAO mdao; @Override public void insertMember(MemberVO vo) { //컨트롤러 -&gt; 서비스 호출 -&gt; DAO 호출 -&gt; Mapper -&gt; DB System.out.print(\"S : 회원가입동작\"); if(vo == null) { //처리 return; } mdao.insertMember(vo); }} root-context.xml 코드추가123 &lt;!-- 서비스패키지(com.itwillbs.service)와 연결 --&gt; &lt;context:component-scan base-package=\"com.itwillbs.service\" /&gt;&lt;/beans&gt; MemberServiceTest.java 테스트 클래스 생성12345678910111213141516171819202122232425package com.itwillbs.test;import javax.inject.Inject;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.itwillbs.domain.MemberVO;import com.itwillbs.service.MemberService;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration( locations = {\"file:src/main/webapp/WEB-INF/spring/root-context.xml\"})public class MemberServiceTest { //서비스객체를 직접 생성하지 않고 의존 주입 @Inject private MemberService service; @Test public void insertServiceTest() throws Exception { MemberVO vo = new MemberVO(\"uesrGang\", \"4321\", \"강조지\", \"jorge@com\", null, null); service.insertMember(vo); }}","link":"/2020/10/18/201019spring/"},{"title":"[스프링SPRING] 메인페이지, 로그아웃","text":"MemberController.java 추가 코드 작성 retrun시 redirect로 페이지이동할때 파라미터를 VO객체 가지고 가는 방법 Model객체로 파라미터를 전달할 수 없기 때문에 RedirectAttributes 객체를 사용해야한다. RedirectAttributes의 addFlashAttribute과 addAttribute의 차이 RedirectAttributes POST방식 데이터 넘기기일까? 총정리 rttr.addAttribute(&quot;mvo&quot;, returnVO);사용 못하는 이유 컴파일 에러 발생 Failed to convert value of type 'com.itwillbs.domain.MemberVO' to required type 'java.lang.String' 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 로그인 기능 */// http://localhost:8088/member/login@RequestMapping(value = \"/login\", method = RequestMethod.GET)public String loginGET() throws Exception{ l.info(\"C: 로그인 입력페이지 GET\"); return \"/member/loginForm\";}@RequestMapping(value = \"/login\", method = RequestMethod.POST)//public String loginPOST(@ModelAttribute(\"userid\") String id, @ModelAttribute(\"userpw\") String pw) throws Exception{public String loginPOST(MemberVO vo, HttpSession session, RedirectAttributes rttr) throws Exception{ l.info(\"C: 로그인 처리페이지 POST\"); //1.한글처리 =&gt; web.xml에서 완료 //2.전달받은 파라미터 저장 =&gt; loginPOST()메서드의 파라미터값으로 저장함. l.info(\"C: \"+ vo.getUserid() + vo.getUserpw()); //3.서비스객체생성 =&gt; 22번째 코드로 의존주입완료 //4.서비스 로그인 체크 동작(HttpSession) MemberVO returnVO = service.loginMember(vo); l.info(\"C: 리턴VO결과(서비스에서 예외처리를 진행했으므로 null이 출력되면 코드에 문제있다는 의미) \"+returnVO); //5.메인페이지로 이동(주소줄과 view페이지 동시에 main으로 변경되어야함) // 해당 정보 있는 경우 : =&gt; main페이지로 이동 //if(returnVO.getUserid() != null) { //에러가 발생하는 이유: if(returnVO != null) { //5.세션값생성 session.setAttribute(\"id\", returnVO.getUserid()); //Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); //map.put(\"username\", returnVO.getUsername()); //map.put(\"useremail\", returnVO.getUseremail()); //rttr.addAttribute(\"mvo\", map); rttr.addFlashAttribute(\"mvo\", returnVO); //l.info(\"C: 모델에 뭐 들어있니?\"+model); return \"redirect:/member/main\"; } else { // 해당 정보 없는 경우 : =&gt; login페이지로 이동 return \"redirect:/member/login\"; }}//end of loginPOST()/* 메인페이지 */// http://localhost:8088/member/main@RequestMapping(value = \"/main\", method = RequestMethod.GET)public void mainGET() throws Exception{ //model.addAttribute(\"mvo\", model); l.info(\"C: 메인 출력페이지 GET\");}/* 로그아웃 */@RequestMapping(value = \"/logout\", method = RequestMethod.GET)public void logoutGET(HttpSession session) throws Exception{ l.info(\"C: 로그아웃 GET\"); session.invalidate(); // return \"redirect:/member/main\"; 얼럿창출력안하고싶을때 사용} main.jsp 뷰페이지생성123456789101112&lt;h1&gt;member/main.jsp&lt;/h1&gt;&lt;%String id = (String) session.getAttribute(\"id\");if(id == null) response.sendRedirect(\"/member/login\");%&gt;jsp표현식 세션 : &lt;%= id %&gt; &lt;br&gt;el표현식 세션: ${id } &lt;br&gt;그냥 : ${username } , ${useremail } &lt;br&gt;mvo그냥 : ${mvo.username } , ${mvo.useremail } &lt;br&gt;&lt;hr&gt;&lt;input type=\"button\" onclick=\"location.href='/member/logout'\" value=\"로그아웃\"&gt; logout.jsp 뷰페이지생성 로그아웃 뷰페이지를 만들기 원치않으면 로그인페이지에서 값을 하나 전달받아서 그 값이 있을 경우 얼럿창을 출력하게끔 login.jsp에서 처리할 수 있다. 123456789101112&lt;h1&gt;member/main.jsp&lt;/h1&gt;&lt;%String id = (String) session.getAttribute(\"id\");if(id == null) response.sendRedirect(\"/member/login\");%&gt;jsp표현식 세션 : &lt;%= id %&gt; &lt;br&gt;el표현식 세션: ${id } &lt;br&gt;그냥 : ${username } , ${useremail } &lt;br&gt;mvo그냥 : ${mvo.username } , ${mvo.useremail } &lt;br&gt;&lt;hr&gt;&lt;input type=\"button\" onclick=\"location.href='/member/logout'\" value=\"로그아웃\"&gt;","link":"/2020/10/19/201020spring/"},{"title":"깃허브에서 프로젝트 STS로 내려받기, 특정 브랜치만 내려받기","text":"main브랜치깃헙의 최근 업데이트 내용 중 가장 큰 변화는 main브랜치이다.기존의 master브랜치의 의미 명확성에 대한 논의가 계속 있다가 깃헙이용자들이 가장 많이 사용하는 main브랜치를 default브랜치로 사용할 수 있게 되었다. 좋은 변화지만 덕분에 push했는데 merge가 안되서 곤욕을 치뤘다…. 깃허브 원격저장소에 있는 프로젝트를 내 로컬에 내려받기원격저장소의 default branch는 main이다. 1 팀레포지토리에서 code&lt;&gt;탭의 code 초록버튼 클릭 &gt; Clone2 Spring tool인 STS 클릭 &gt; open perspective &gt; git &gt; open 3 clone a git repository &gt; URL : 복사한 URL붙여넣기 &gt; next &gt; 복사하고싶은 branch 선택 &gt; next 4 Destination 설정 후 finish Directory : 내 컴퓨터에 저장하고 싶은 곳 initial branch : 초기 브랜치 master, main 등 선택 가능 5 perspective에서 java로 이동 git아이콘의 왼쪽 아이콘이 java perspective이다. 6 import &gt; projects from git &gt; next &gt; exising local repository &gt;next7 방금 올린 깃레포명 클릭 &gt; finish8 추가사항 STS 기본설정 Spring MVC 패턴 기본 순서 깃허브 원격저장소에 있는 프로젝트를 내 로컬에 내려받기만약 origin에 있는 main브랜치를 가져오고싶다면 아래와 같이 입력하면 된다.아래 명령어는 로컬에 동일한 이름의 브랜치를 생성하면서 해당 브랜치로 바로 checkout된다. 1$&gt; git checkout -t origin/main","link":"/2020/10/21/201022git/"},{"title":"[스프링SPRING]MySQL DB 한글이 ?로 출력될때 워크벤치로 간단히 한글깨침 해결방법","text":"사용중인 버전내가 사용중인 버전은 아래와 같다. 기존에는 최신서버버전을 사용하고 있었으나 프로젝트때문에 다운그레이드했다. MySQL Server v5.6.50 MySQL Workbench v8.0.22 스프링프로젝트를 하던 중 콘솔에는 한글이 깨짐없이 출력되나 DB에 ?로 한글데이터가 깨져서 입력되어있었다.이를 해결하기 위해 구글링 엄청나게 많이 한 뒤에 해결할 수 있었다.다른 사람은 시간을 아끼길 바라며 적어본다… 또르르.. 일단 현재 mySQL상태를 알아보자. cmd를 열어 아이디와 비번으로 로그인을 한 뒤 status를 입력한다. 빨간 부분을 보면 UTF-8이 아니다. 이럴 경우 한글이 깨질수 있으니 utf-8로 설정해줘야한다. 첫번째 시도 : my.iti 변경하기구글링하면 가장 많이 발견할 수 있는 방법이 my.ini 변경방법이다.아쉽게도 나는 C:\\Program Files\\MySQL\\MySQL Server 5.6경로에 my.ini파일이 없었다. my.int 파일이 있는 경우 해결방법 두번째 시도 : MySQL Workbench로 해결하기아래 이미지처럼 workbench에 접속하여 administration 탭을 클릭한 뒤 status and system variables 클릭 system variables클릭 cha검색 character_set_client 부터 character_set_system까지 filesystem을 제외하고 다 utf8로 변경해준다. 따로 저장버튼은 없고 refesh 클릭 하지만 여전히 데이터입력시 ?가 발생했다. 마지막 시도 : MySQL Workbench + my.iti 변경2번째시도를 완료한 상태에서 숨김폴더인 C:\\ProgramData\\MySQL\\MySQL Server 5.6 경로로 이동하여 숨겨진 my.iti파일을 찾았다.해당 파일에서 #SERVER SECTION전까지를 아래 처럼 추가해주었다. 123456789101112131415[client]default-character-set = utf8[mysqld]character-set-client-handshake=FALSEinit_connect=&quot;SET collation_connection = utf8_general_ci&quot;init_connect=&quot;SET NAMES utf8&quot;character-set-server = utf8collation-server = utf8_general_ci [mysqldump]default-character-set = utf8 [mysql]default-character-set = utf8 그 후 윈도우의 서비스 앱을 열어 (작업관리자 제일 마지막 탭 서비스) MySQL56을 서비스 다시시작을 클릭했다.그랬더니 한글이 깨지지않고 DB에 들어와있다!더이상의 물음표살인마는 없다!!!! 참고 https://m.blog.naver.com/xhdlrkd/221762674910","link":"/2020/10/24/201024mysql/"},{"title":"[스프링SPRING]관리자용 회원 리스트","text":"MemberController.java 코드 추가 12345678910111213141516171819/* 관리자용 회원 목록 */@RequestMapping(value = \"/list\", method = RequestMethod.GET)public String listGET(HttpSession session, Model model) throws Exception{ // 1. 관리자 세션 제어 String id = (String) session.getAttribute(\"id\"); if(id == null || !(id.equals(\"admin\"))){ l.info(\"C: 관리자아닌 접근 ID - \"+id); return \"redirect:/member/main\"; } // 2. 서비스 - 회원 목록 가져오는 동작 //List&lt;MemberVO&gt; memberList = service.getMemberList(); // 3. 정보 저장 -&gt; 뷰(/member/memberlist.jsp) -&gt; (Model 객체 ) model.addAttribute(\"memberList\", service.getMemberList()); // 4. 페이지이동 return \"/member/memberList\";} main.jsp 뷰에 연결 main.jsp에서 관리자용 회원목록으로 가는 링크 연결하고 뷰 생성 1234567891011&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id != null){ if(id.equals(\"admin\")){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" class=\"btn\" onclick=\"location.href='/test/member/list'\"&gt; &lt;input type=\"button\" value=\"상품전체목록(관리자용)\" class=\"btn\" onclick=\"location.href='/test/member/adminGoodsList'\"&gt; &lt;input type=\"button\" value=\"주문전체목록(관리자용)\" class=\"btn\" onclick=\"location.href='/test/member/adminOrderList'\"&gt; &lt;% }}%&gt; memberList.jsp 뷰 생성1234567891011121314151617181920212223242526272829303132&lt;body&gt;&lt;%//1. 로그인세션제어(관리자는 제외)String id = (String) session.getAttribute(\"id\");//다운캐스팅if(id == null || !id.equals(\"admin\")){ //순서바뀌면 에러발생하므로 항상 null 먼저 비교할 것 response.sendRedirect(\"/test/member/main\");}%&gt;&lt;h2 style=\"text-align: center;\"&gt;회원목록&lt;/h2&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;이메일&lt;/td&gt; &lt;td&gt;회원가입일&lt;/td&gt; &lt;td&gt;최근회원정보수정일&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=\"${memberList}\" var=\"mb\"&gt; &lt;tr&gt; &lt;td&gt;&lt;c:out value=\"${mb.userid}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.userpw}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.username}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.useremail}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.regdate}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;td&gt;&lt;c:out value=\"${mb.updatedate}\"&gt;&lt;/c:out&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;input type=\"button\" value=\"메인으로\" class=\"btn\" onclick=\"location.href='/test/member/main'\"&gt;&lt;/body&gt; MemberService.java 인터페이스에 메서드 추가여기서 List는 java.util에 있는 리스트이다. import java.util.List;를 임포트해주면 된다. 12//관리자용 회원목록public List&lt;MemberVO&gt; getMemberList(); MemberServiceImpl.java 메서드 오버라이딩 코드 추가 굳이 변수생성하여 담을 필요없이 바로 리턴하면 된다. 1234567//관리자용 회원목록@Overridepublic List&lt;MemberVO&gt; getMemberList() { //List&lt;MemberVO&gt; memberList = mdao.getMemberList(); //return memberList; return mdao.getMemberList();} MemberDAO.java 인터페이스에 메서드 추가12//회원정보리스트 출력public List&lt;MemberVO&gt; getMemberList(); MemberDAOImpl.java 메서드 오버라이딩 코드 추가 바로 리턴에 보낼 수 있으나 굳이 변수에 담은 이유는 캐스팅이 필요없음을 보여주고 콘솔에 출력하여 확인하고자함이다. 12345678910//관리자용 회원목록@Overridepublic List&lt;MemberVO&gt; getMemberList() { //while문 대신 selectList하면 됨! 세상간단! List&lt;MemberVO&gt; memberList = sqlSession.selectList(namespace+\".memberList\"); System.out.println(\"DAO: getMemberList결과 - \"+memberList); return memberList; //아래처럼 나타낼 수 있으나 변수에 담은 이유는 캐스팅이 필요없음을 보여주고 콘솔에 출력하고자함임 //return sqlSession.selectList(namespace+\".memberList\"); } memberMapper.xml SQL쿼리 추가 관리자빼고 회원목록 출력하는 쿼리작성 List를 넘겨줘야하는데 왜 MemberVO를 넘겨줄까? 123&lt;select id=\"MemberList\" resultType=\"com.itwillbs.domain.MemberVO\"&gt; select * from tbl_member where userid not in('admin')&lt;/select&gt;","link":"/2020/10/25/201026spring/"},{"title":"[스프링SPRING]스프링게시판2:파일구조와 DB테이블생성, DB글쓰기테스트","text":"기본 패키지생성 src/main/java폴더 하위에 아래 4가지 패키지가 기본으로 있어야한다. controller domain persistence service src/main/resources폴더 하위에 mapper폴더를 생성한다. 패키지로 생성하지않도록 주의한다. DB 테이블생성컬럼과 제약조건을 포함하여 게시판 테이블을 생성한다. web.xml 한글처리 코드 추가1234567891011121314&lt;!-- 한글처리 --&gt;&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 부트스트랩 템플릿 적용하기원하는 부트 스트랩으로 뷰페이지를 생성한 뒤 컨트롤러로 연결한다 boardVO.java 도메인생성12345678910111213141516171819202122232425262728293031public class BoardVO { private Integer bno; private String title; private String content; private String writer; private Timestamp regdate; private int viewcnt; //bno는 경우 캐스팅을 해야하기때문에 integer로 데이터타입을 변경한다. public BoardVO() {} public BoardVO(Integer bno, String title, String content, String writer, Timestamp regdate, int viewcnt) { super(); this.bno = bno; this.title = title; this.content = content; this.writer = writer; this.regdate = regdate; this.viewcnt = viewcnt; } public Integer getBno() { return bno; } public void setBno(Integer bno) { this.bno = bno; }} root-context.xml 코드 추가 기존에 작성했던 DB연결 객체 아래에 SqlSessionFactory 객체와 DAO패키지, 서비스패키지를 연결한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:mybatis-spring=\"http://mybatis.org/schema/mybatis-spring\" xsi:schemaLocation=\"http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.3.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\"&gt; &lt;!-- Root Context: defines shared resources visible to all other web components --&gt; &lt;!-- DB연결 객체 --&gt; &lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"net.sf.log4jdbc.sql.jdbcapi.DriverSpy\" /&gt; &lt;property name=\"url\" value=\"jdbc:log4jdbc:mysql://localhost:3306/springdb?useSSL=false\"/&gt; &lt;property name=\"username\"&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property name=\"password\"&gt; &lt;value&gt;1234&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- SqlSessionFactory 객체 (Connection + MyBatis 객체연결 역할, DB해제는 못하고 Connection해제만 가능)--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 위에서 생성된 객체를 주입하기 위해서는 value가 아니라 ref를 통해서 주입해야한다 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"configLocation\" value=\"classpath:/Mybatis-config.xml\" /&gt; &lt;!-- Mapper와 연결 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mappers/**/*Mapper.xml\" /&gt; &lt;/bean&gt; &lt;!-- SqlSesstionTemplate 객체 (DB연결/해제(pstmt, resultset포함 해제가능) 역할)--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\" destroy-method=\"clearCache\"&gt; &lt;!-- 바로 위에 있는 sqlSessionFactory객체를 생상자 의존주입 --&gt; &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; &lt;!-- DAO패키지(com.itwillbs.persistence)와 연결 --&gt; &lt;context:component-scan base-package=\"com.itwillbs.persistence\" /&gt; &lt;!-- 서비스패키지(com.itwillbs.service)와 연결 --&gt; &lt;context:component-scan base-package=\"com.itwillbs.service\" /&gt;&lt;/beans&gt; BoardDAO.java 인터페이스에 메서드 추가12345678package com.itwillbs.persistence;import com.itwillbs.domain.BoardVO;public interface BoardDAO { //글쓰기 (create) public void create(BoardVO vo) throws Exception;} BoardDAOImpl.java 메서드 오버라이딩 코드 추가12345678910111213141516171819202122package com.itwillbs.persistence;import javax.inject.Inject;import org.apache.ibatis.session.SqlSession;import com.itwillbs.domain.BoardVO;public class BoardDAOImpl implements BoardDAO { //DB접근을 위해 필요한 객체 @Inject private SqlSession session; //Mapper의 위치정보를 저장 private static final String namespace = \"com.itwillbs.mapper.BoardMapper\"; //글쓰기 @Override public void create(BoardVO vo) throws Exception { session.insert(namespace+\".create\", vo); System.out.println(\"DAO 글쓰기메서드\"); } } boardMapper.xml SQL쿼리 추가 mapper 명 작성하는 룰은 고정이다. =&gt; 도메인명Mapper.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.itwillbs.mapper.BoardMapper\"&gt; &lt;insert id=\"create\"&gt; insert into tbl_board (title,content,writer) values (#{title},#{content},#{writer}) &lt;/insert&gt;&lt;/mapper&gt; 테스트 파일 BoardDAOTest.java 생성 src/test/java 하위에 test 파일인 BoardDAOTest.java를 생성한다. 서비스는 컨트롤러 역할의 테스트 객체이다. 아래 코드를 작성하고 서버를 run하면 콘솔과 DB에 데이터를 확인할 수 있다. 1234567891011121314151617181920212223242526272829303132333435package com.itwiilbs.controller;import javax.inject.Inject;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.itwillbs.domain.BoardVO;import com.itwillbs.persistence.BoardDAO;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {\"file:src/main/webapp/WEB-INF/spring/root-context.xml\"})public class BoardDAOTest { @Inject private BoardDAO bdao; @Test public void testDAO() throws Exception{ System.out.println(\"TEST: boardDAO -&gt; bdao\"); } @Test public void testInsertBoard() throws Exception{ BoardVO vo = new BoardVO(); vo.setTitle(\"공지사항\"); vo.setContent(\"공지안내입니다. 테스트입니다.\"); vo.setWriter(\"관리자\"); bdao.create(vo); System.out.println(\"T: 글쓰기메서드 \"+vo); }}","link":"/2020/10/26/201027spring-1/"},{"title":"[스프링SPRING]스프링게시판1: 기초","text":"프로젝트 시작전 DB 사용 계정 생성 (root/1234) 디비 생성 (springdb) 테이블 생성 + 설계 (관계 설정) 더미데이터 추가 MVC 패키지 구조 결정 개발역활 구분 -&gt; 할당 테스트 처리 여부 화면 화면 출력 방식 결정 : HTML+JS 또는 JSP 경로설정 : 절대경로와 상대경로 기본설정 : pom.xml 기존 pom.xml에 Servlet주석부분에 아래 코드를 추가한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!-- Servlet --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Test --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 추가 라이브러리 --&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${org.springframework-version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${org.springframework-version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.bgee.log4jdbc-log4j2/log4jdbc-log4j2-jdbc4 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.bgee.log4jdbc-log4j2&lt;/groupId&gt; &lt;artifactId&gt;log4jdbc-log4j2-jdbc4&lt;/artifactId&gt; &lt;version&gt;1.16&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 기본설정 : log4jdbc 설정 pom.xml로 가져왔으므로 아래 파일들을 src/main/resources에 추가해준다. log4jdbc.log4j2.properties logback.xml Mybatis-config.xml 기본설정 : DB연결DB 연결이 잘되었는지 테스트를 헤야한다. root-context.xml의 namespace탭에서 필요한 것들 tick하기 root-context.xml에 DB객체 생성 1234567891011&lt;!-- DB연결 객체 --&gt;&lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"net.sf.log4jdbc.sql.jdbcapi.DriverSpy\" /&gt; &lt;property name=\"url\" value=\"jdbc:log4jdbc:mysql://localhost:3306/springdb?useSSL=false\"/&gt; &lt;property name=\"username\"&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property name=\"password\"&gt; &lt;value&gt;1234&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 기본설정 : DB연결 테스트하기DB 연결이 잘되었는지 테스트를 헤야한다. src/test/java/controller에 test class를 생성한다 1234567891011121314151617181920212223242526272829package com.itwiilbs.controller;import java.sql.Connection;import javax.inject.Inject;import javax.sql.DataSource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {\"file:src/main/webapp/WEB-INF/spring/root-context.xml\"})public class boardDataSourceTest { //datasource객체 생성(DI) //@Inject private DataSource ds; @Test public void testDataSource() throws Exception{ System.out.println(\"ds 테스트 \"+ds); //ds의 객체생성이 안되면 null로 출력됨 try (Connection con = ds.getConnection()){ System.out.println(\"Conntect확인 \" + con); }catch(Exception e) { e.printStackTrace(); } }} Junit으로 run을 해준다. 작동이 정상인지 확인한다.","link":"/2020/10/26/201027spring/"},{"title":"여성개발자컨퍼런스2020 후기","text":"여성개발자컨퍼런스2020 후기일요일 오전 10시부터 진행되는 여성개발자컨퍼런스2002에 참여했다.한시간 간격으로 정말 다양한 분야의 훌륭한 연사님들은 한자리에서 만나뵐 수 있었다.업계에 있는 사람만이 전달해줄 수 있는 살아있는 지식을 오늘 정말 많이 받았다. 강연들을때마다 좋은 내용들은 기록하면서 듣는 편인데 이번 컨퍼런스는 강연 하나하나 몰입감있게 봐버려서 기록이 많이 없다 ㅋㅋㅋㅋㅋㅋ 이렇게 좋은 강연을 기록도 안하고 봤다니…나는 기억보다 기록을 믿는 사람으로서 항상 기록을 남기고자 노력해왔는데 너무 아쉽다.이건 순 컨퍼런스탓이다. 컨퍼런스가 너무 유익해서 기록할 틈이 없어, 틈이! 이번 컨퍼런스의 모든 점이 좋았지만 특히 기록해야 할 점은 운영방식과 소통방식 선정의 탁월성이다.첫 컨퍼런스임에도 불구하고 컨퍼런스의 원활한 진행과 운영방식, 소통채널 선택등을 운영진분들의 깊은 내공이 느껴진다. 슬라이도를 통한 QNA : 유튜브를 통한 강연을 하다보면 좋은 질문들이 유튜브댓글로 올라오지만 시간의 흐름때문에 놓치는 경우가 많이 발생한다. 이를 예방하면서도 익명성을 보장하고 따봉에 따라 질문의 우선순위 설정해주는 슬라이도는 가히 혁신적이다. 컨퍼런스와 딱 적합한 툴이 아닐 수 없다. 슬랙채널 활성화 : 슬랙채널을 단순히 만드는 것뿐만아니라 자유롭게 소통할 수 있도록 다양한 장치들을 마련해주셔서 나도 모르게 댓글을 달고 있는 나자신을 발견하게된다. 강연 중간 쉬는 시간 10분동안 화장실도 안가고 스몰톡들을 재미있게 읽고있는 내자신ㅋㅋㅋㅋ 또한 연사자분이 강연 끝나고도 슬랙채널에서 시간 관계상 하지 못했던 QNA를 마저 해주시고 같이 강연을 듣고 있던 분들이 강연에 주요한 내용을 슬랙에 정리해서 올려주시도했다. 이렇게 유익해도 되나 싶을 정도로의 유익함이었다. 📌컨퍼런스 행사 일정 변경 안내 강연 세션의 조연님 &lt;엔지니어의 리더십&gt;과 정효진님 &lt;모두를 위한 기술, 디지털 접근성&gt;의 강연시간이 변경되어 업데이트된 컨퍼런스 시간표를 다시 안내드립니다. 강연15:00 ~ 15:50 &lt;엔지니어의 리더십&gt; 조연16:00 ~ 16:50 &lt;모두를 위한 기술, 디지털 접근성&gt; 정효진게시: 여성개발자컨퍼런스 2020: Women Invented Programming&nbsp;2020년 10월 17일 토요일 이렇게 퀄리티있는 컨퍼런스를 심지어 무료로 듣다니 나는 참 럭키다.그리고 이 컨퍼런스가 나에게 더욱 특별한 이유는 내 지인이 연사자로 나오기 때문!!!나까지 심장 떨려서 혼났다. 내 지인이지만 정말 멋있는 분이다. 감탄과 감동 그 자체.일요일 하루를 이 컨퍼런스에 집중했는데 전혀 시간이 아깝지 않았고 오히려 시간을 번 느낌이다.나보다 먼저 내가 가고싶은 길을 가고 있는 그들의 이야기를 들을 수 있어 정말 유익한 시간이었다.또 했으면 좋겠다. SM업계컨퍼런스의 첫 문을 열었던 슬기로운 전산실 생활의 갱님은 10년이상의 SM업계 경력을 가지신 연사님이었고 정말 재미있게 강연해주셨다. 연사님은 대기업, 중소기업, 스타트업 그리고 공공기관까지 거의 모든 기업형태의 SM을 경험해보신 실력자셨다. 정말 자신의 일을 사랑하시는 것이 느껴지는 강연이었다.연사님의 강연을 듣고 내가 생각하는 각 기업형태의 SM차이는 아래와 같다. 대기업SM 신기술을 테스트하면서 동시에 현재 시스템 유지보수하는 업무도 수행한다. 레거시코드와의 싸움이 많다. IT회사의 전산실인 경우 사업무에서 개발한 솔루션들의 첫번째 적용례가 된다. 전산실과 사업부서가 협업하는 TF구성도 빈번하다. 모든 것을 코드가 아닌 숫자로 말한다. Ex) 비용절감, 오류건수 중소기업SM 신기술을 됐고 지금 돌아가는 시스템을 빠르게 잘 만드는 업무를 수행해야한다. 레거시코드와의 싸움이 많다. 업무를 자동화하여 인력을 감축하고자하는 경영진들의 의지가 강력할수도있다. 공공기간SM 공문에서 시작해서 공문으로 끝난다. 어느날 갑자기 예산이 날아들어오기도 한다. 웹사이트 총량제가 있다. 모든 사업을 국민들에게 기회균등하게 제공할 수 있는 솔루션이 중요하다. 사용자 나이대가 천차만별이라 그 어느곳보다 쉬운 UI를 연구해야한다. 스타트업SM SI(솔루션을 시장에 빨리 내놓기)와 SM(유지보수)일을 동시에! 애자일 방식 레거시코드와의 싸움이 적은 대신 ‘맨땅에 해딩’해야하는 스트레스가 존재한다. 성장하는 것이 느껴짐 자기PR의 달인컨퍼런스의 불멍토그에선 또 하나의 개발자 취업기의 윤슬기님은 비전공자에 전혀 다른 업계에 종사하시다가 프론트앤드개발자가 된 성장스토리를 들려주셨다. 연사님 깃헙 잔디는 볼때마다 멋있다. TMI로 주말은 확실히 쉬시는 게 분명하다.ㅋㅋㅋㅋㅋ수많은 배울 점에 가장 와닿았던 부분은 SNS를 활용하여 자신의 구직상황을 적극적으로 PR한 점이다.사실 완전히 준비되지 않은(?) 상태에서 자신을 PR하기가 망설여질 수 있다. 하지만 연사님은 간절함을 가지고 동네방네에 취업 준비중임을 홍보하셨고 그를 통해 입사제의를 4번이나 받으셨다고 한다.정말 멋있는 분이다.취업준비에 대한 마음가짐에 대해 이야기를 나눠주셨는데 코테를 준비하고있어 마음이 무겁기만 한 요즘, 연사님의 따뜻한 말에 큰 위로를 받았다. 떨어져도 절망말자. 지금까지 준비해 온 자신을 믿어주기. 지금까지 준비해 온 나 자신 잘하고있어! 떨어져도 절망말자!나에게 꼭 필요한 말이고 항상 해주고싶은 말이다.","link":"/2020/10/25/201025womynconference/"},{"title":"[스프링SPRING]스프링게시판5: 글 수정, 글 삭제","text":"BoardController.java 코드 추가 @SessionAttributes() : 컨트롤러의 정보를 저장하는 어노테이션 기존 Session객체와 다른 점 : 서버단 전체에서 저장한 정보를 이용할 수 있다. 반면 @SessionAttributes()은 해당 컨트롤러안에서만 저장한 데이터를 이용할 수 있다. 예를 들어 제목이 not null제약조건이지만 공백이 있는 경우 저장된다. 잘못된 정보이므로 이전 정보로 되돌리고 싶을때 @SessionAttributes(&quot;boardVO&quot;)로 되돌릴 수 가 있다. @SessionAttributes(&quot;boardVO&quot;) : boardVO의 정보를 세션으로 저장하고 다닌다. @SessionAttributes, SessionStatus 123456789101112131415161718192021222324252627//글 수정@RequestMapping(value = \"/modify\", method = RequestMethod.GET)public void modifyGET(@RequestParam(\"bno\") int bno, Model model) throws Exception{ l.info(\"C: modify 겟 메서드 파라미터 : \"+bno); model.addAttribute(\"bvo\", service.readContent(bno));}@RequestMapping(value = \"/modify\", method = RequestMethod.POST)public String modifyPOST(BoardVO vo,RedirectAttributes rttr) throws Exception{ l.info(\"C: modify 포스트 메서드 파라미터 : \"+vo); service.modify(vo); rttr.addFlashAttribute(\"result\", \"up-ok\"); return \"redirect:/board/listAll\";}//글삭제@RequestMapping(value = \"/remove\", method = RequestMethod.POST)public String removePOST(@RequestParam(\"bno\") int bno,RedirectAttributes rttr) throws Exception{ l.info(\"C: remove 포스트 메서드\"); // 글번호 저장 // 서비스객체 사용하여 글 삭제 service.remove(bno); // 삭제정보 저장해서 이동 // 글삭제 후 얼럿창 -&gt; 글목록으로 페이지 이동 rttr.addFlashAttribute(\"result\", \"delete-ok\"); return \"redirect:/board/listAll\";} read.jsp 뷰 버튼 수정123456789101112131415161718192021222324252627282930313233343536373839&lt;button type=\"submit\" class=\"btn btn-warning\" &gt;글 수정&lt;/button&gt;&lt;button type=\"submit\" class=\"btn btn-danger\" &gt;글 삭제&lt;/button&gt;&lt;button type=\"submit\" class=\"btn btn-primary\" &gt;글 목록으로&lt;/button&gt;//스크립트&lt;script type=\"text/javascript\"&gt;$(document).ready(function(){ //form 오브젝트 출력 //console.log()가 alert()보다 더 많은 정보를 출력해준다. let formObj = $(\"form[role='form']\"); //alert(formObj); //console.log(formObj); //목록 $(\".btn-primary\").on(\"click\", function(){ &lt;!-- 글 번호 가져가지고 페이지이동 첫번째 방법 --&gt; //let tmp = '${bvo.bno}'; //alert(\"목록으로 가기 버튼 클릭\"+tmp); location.href=\"/board/listAll\"; }); //수정버튼 클릭시 $(\".btn-warning\").click(function(){ //alert(\"수정버튼클릭\"); //formObj.attr(\"action\",\"/board/modify\", \"method\",\"get\").submit(); 잘못된 문법인데 왜 작동할까? formObj.attr({ action: \"/board/modify\", method: \"get\", }).submit(); }); //삭제버튼 클릭시 $(\".btn-danger\").click(function(){ formObj.attr(\"action\",\"/board/remove\").submit(); }); })//end of jQuery&lt;/script&gt; modify.jsp 뷰 연결 console.log()가 alert()보다 더 많은 정보를 출력해준다. 개발시에는 console.log()를 더 많이 사용하자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ include file=\"../include/header.jsp\" %&gt;&lt;!-- Main content --&gt;&lt;section class=\"content\"&gt; &lt;div class=\"row\"&gt; &lt;!-- left column --&gt; &lt;div class=\"col-md-12\"&gt; &lt;!-- general form elements --&gt; &lt;div class=\"box box-primary\"&gt; &lt;div class=\"box-header\"&gt; &lt;h3 class=\"box-title\"&gt;ITWILL 게시글 상세페이지&lt;/h3&gt; &lt;/div&gt; &lt;!-- /.box-header --&gt; &lt;!-- 글 번호 가져가지고 페이지이동 2번째 방법 --&gt; &lt;form method=\"post\" role=\"form\" action=\"\"&gt; &lt;input type=\"hidden\" name=\"bno\" value=\"${bvo.bno }\"&gt; &lt;!-- 바디 --&gt; &lt;div class=\"box-body\"&gt; &lt;div&gt; &lt;span class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;글번호&lt;/label&gt; &lt;input type=\"text\" name=\"bno\" class=\"form-control\" style=\"width:200px;display:inline;margin-right:100px;\" value=\"${bvo.bno}\" readonly&gt; &lt;/span&gt; &lt;span class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;글쓴이&lt;/label&gt; &lt;input type=\"text\" name=\"writer\" class=\"form-control\" style=\"width:200px;display:inline;margin-right:100px;\" value=\"${bvo.writer}\" readonly&gt; &lt;/span&gt; &lt;span class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;작성일자&lt;/label&gt; &lt;input type=\"text\" name=\"regdate\" class=\"form-control\" style=\"width:200px;display:inline;margin-right:100px;\" value=\"${bvo.regdate}\" readonly&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;제목&lt;/label&gt; &lt;input type=\"text\" name=\"title\" class=\"form-control\" value=\"${bvo.title}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;내용&lt;/label&gt; &lt;textarea name=\"content\" rows=\"5\" class=\"form-control\"&gt;${bvo.content}&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=\"box-footer\"&gt; &lt;button type=\"submit\" class=\"btn btn-warning\" &gt;글 수정&lt;/button&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;글 목록으로&lt;/button&gt; &lt;/div&gt; &lt;!-- 바디 끝 --&gt; &lt;/div&gt; &lt;!-- /.box --&gt; &lt;/div&gt; &lt;!--/.col (left) --&gt; &lt;/div&gt; &lt;!-- /.row --&gt;&lt;/section&gt;&lt;!-- /.content --&gt;&lt;/div&gt;&lt;!-- /.content-wrapper --&gt;&lt;script type=\"text/javascript\"&gt;$(document).ready(function(){ let formObj = $(\"form[role='form']\"); console.log(formObj); //목록으로 $(\".btn-primary\").on(\"click\", function(){ location.href=\"/board/listAll\"; }); //수정버튼 클릭시 $(\".btn-warning\").click(function(){ formObj.submit(); }); })//end of jQuery&lt;/script&gt;&lt;%@ include file=\"../include/footer.jsp\" %&gt; listAll.jsp 코드 추가 얼럿창 구현코드를 스크립트 태그안에 구현해준다. 12345678910111213141516&lt;script type=\"text/javascript\"&gt; let result=\"${result}\"; let isResist = \"${isRegist}\"; if(result == 'success' &amp;&amp; isResist == 'true'){ alert('성공적으로 글 작성되었습니다.'); }else if(result == 'success' &amp;&amp; isResist != 'true'){ alert('글쓰기가 실패하였습니다.'); }else if(result =='up-ok'){ alert('성공적으로 글이 수정되었습니다.'); }else if(result =='delete-ok'){ alert('성공적으로 글이 삭제되었습니다.'); }else{ //글쓰기없이 출력시 alert창 필요없음 }&lt;/script&gt; BoardService.java 인터페이스에 메서드 추가12345//글 수정public void modify(BoardVO vo) throws Exception;//글 삭제public void remove(Integer bno) throws Exception; BoardServiceImpl.java 메서드 오버라이딩 코드 추가1234567891011//글 수정@Overridepublic void modify(BoardVO vo) throws Exception { bdao.modify(vo);}//글 삭제@Overridepublic void remove(Integer bno) throws Exception { bdao.delete(bno);} BoardDAO.java 인터페이스에 메서드 추가12345//글수정public void modify(BoardVO vo) throws Exception;//글삭제public void delete(Integer bno) throws Exception; BoardDAOImpl.java 메서드 오버라이딩 코드 추가123456789101112//글 수정@Overridepublic void modify(BoardVO vo) throws Exception { System.out.println(\"DAO: bno는?\"+vo.getBno()); session.update(namespace+\".modify\", vo);}//글 삭제@Overridepublic void delete(Integer bno) throws Exception { session.delete(namespace+\".delete\", bno);} BoardMapper.xml SQL쿼리 추가12345678910&lt;update id=\"modify\"&gt; update tbl_board set title=#{title},content=#{content} where bno=#{bno} &lt;/update&gt;&lt;delete id=\"delete\"&gt; delete from tbl_board where bno=#{bno}&lt;/delete&gt;","link":"/2020/10/28/201029spring-1/"},{"title":"[스프링SPRING]스프링게시판4: 글 상세 내용 보기","text":"BoardController.java 코드 추가 @ModelAttribute 와 @RequestParam 란 @ModelAttribute : model객체를 사용하는 것이므로 주소줄에 나타나지 않게 할 수 있다. @RequestParam : request.getParameter()와 동일한 의미로 사용하나 String뿐만 아니라 데이터타입 상관없이 처리가능 하다.(문자열, 정수형, 날짜) =&gt; 단순 타입(ex기본형 데이터등)은 어노테이션 생략가능. 차이점이 존재한다. @ModelAttribute뿐만 아니라 @RequestParam에서 Map 데이터타입으로 여러개 파라미터를 받아 올 수 있다. 즉 두 파라미터 다 여러 개의 파라미터를 받을 수 있지만 주로 1:!은 @RequestParam을 사용하고 메인이나 오브젝트로 파라미터를 받을 경우는 @ModelAttribute으로 받는다. 두 어노테이션 다 생략가능하지만 명시해주는 게 좋음. 12345678910//글번호에 해당하는 게시글 상세 보기@RequestMapping(value = \"/read\", method = RequestMethod.GET)//@ModelAttribute 와 @RequestParam 둘 다 동일한 결과//public void readGET(@ModelAttribute(\"bno\") int bno) throws Exception{ //0출력public void readGET(@RequestParam(\"bno\") int bno, Model model) throws Exception{ //0출력 l.info(\"C: read 겟 메서드, 글번호: \"+(bno*0)); //서비스객체 : 해당 글번호를 사용하여 글 정보 가지고오기 model.addAttribute(\"bvo\", service.readContent(bno));} read.jsp 뷰 연결1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ include file=\"../include/header.jsp\" %&gt;&lt;!-- Main content --&gt;&lt;section class=\"content\"&gt; &lt;div class=\"row\"&gt; &lt;!-- left column --&gt; &lt;div class=\"col-md-12\"&gt; &lt;!-- general form elements --&gt; &lt;div class=\"box box-primary\"&gt; &lt;div class=\"box-header\"&gt; &lt;h3 class=\"box-title\"&gt;ITWILL 게시글 상세페이지&lt;/h3&gt; &lt;/div&gt; &lt;!-- /.box-header --&gt; &lt;!-- 글 번호 가져가지고 페이지이동 2번째 방법 --&gt; &lt;form method=\"post\" role=\"form\"&gt; &lt;input type=\"hidden\" name=\"bno\" value=\"${bvo.bno }\"&gt; &lt;/form&gt; &lt;!-- 바디 --&gt; &lt;div class=\"box-body\"&gt; &lt;div style=\"text-align: center;\"&gt; &lt;span class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;글번호&lt;/label&gt; &lt;input type=\"text\" name=\"title\" class=\"form-control\" style=\"width:200px;display:inline;margin-right:100px;\" value=\"${bvo.bno}\" readonly&gt; &lt;/span&gt; &lt;span class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;글쓴이&lt;/label&gt; &lt;input type=\"text\" name=\"writer\" class=\"form-control\" style=\"width:200px;display:inline;margin-right:100px;\" value=\"${bvo.writer}\" readonly&gt; &lt;/span&gt; &lt;span class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;작성일자&lt;/label&gt; &lt;input type=\"text\" name=\"writer\" class=\"form-control\" style=\"width:200px;display:inline;margin-right:100px;\" value=\"${bvo.regdate}\" readonly&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;제목&lt;/label&gt; &lt;input type=\"text\" name=\"title\" class=\"form-control\" value=\"${bvo.title}\" readonly&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;내용&lt;/label&gt; &lt;textarea name=\"content\" rows=\"5\" class=\"form-control\" readonly&gt;${bvo.content}&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &lt;button type=\"submit\" class=\"btn btn-warning\" &gt;글 수정&lt;/button&gt; &lt;button type=\"submit\" class=\"btn btn-danger\" &gt;글 삭제&lt;/button&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" &gt;글 목록으로&lt;/button&gt; &lt;/div&gt; &lt;!-- 바디 끝 --&gt; &lt;/div&gt; &lt;!-- /.box --&gt; &lt;/div&gt; &lt;!--/.col (left) --&gt; &lt;/div&gt; &lt;!-- /.row --&gt;&lt;/section&gt;&lt;!-- /.content --&gt;&lt;/div&gt;&lt;!-- /.content-wrapper --&gt;&lt;script type=\"text/javascript\"&gt;$(document).ready(function(){ //form 오브젝트 출력 //console.log()가 alert()보다 더 많은 정보를 출력해준다. let formObj = $(\"form[role='form']\"); //alert(formObj); //console.log(formObj); //목록 $(\".btn-primary\").on(\"click\", function(){ &lt;!-- 글 번호 가져가지고 페이지이동 첫번째 방법 --&gt; //let tmp = '${bvo.bno}'; //alert(\"목록으로 가기 버튼 클릭\"+tmp); location.href=\"/board/listAll\"; }); //수정버튼 클릭시 $(\".btn-warning\").click(function(){ //alert(\"수정버튼클릭\"); //formObj.attr(\"action\",\"/board/modify\", \"method\",\"get\").submit(); 잘못된 문법인데 왜 작동할까? formObj.attr({ action: \"/board/modify\", method: \"get\", }).submit(); }); })//end of jQuery&lt;/script&gt;&lt;%@ include file=\"../include/footer.jsp\" %&gt; BoardService.java 인터페이스에 메서드 추가 캐스팅이 되는 데이터타입은 wapper클래스로 파라미터 데이터타입을 지정하는 것이 혹시모를 데이터 손실을 예방할 수 있다. int -&gt; Integer 123//글번호에 해당하는 게시글 상세 보기//public BoardVO readContent(int bno) throws Exception;public BoardVO readContent(Integer bno) throws Exception; BoardServiceImpl.java 메서드 오버라이딩 코드 추가123456//글번호에 해당하는 게시글 상세 보기@Overridepublic BoardVO readContent(Integer bno) throws Exception { BoardVO bvo = bdao.readContent(bno); return bvo;} BoardDAO.java 인터페이스에 메서드 추가12//글번호에 해당하는 게시글 상세 보기public BoardVO readContent(Integer bno) throws Exception; BoardDAOImpl.java 메서드 오버라이딩 코드 추가123456//글번호에 해당하는 게시글 상세 보기@Overridepublic BoardVO readContent(Integer bno) throws Exception { //sqlSession 객체 사용하여 Mapper 호출 return session.selectOne(namespace+\".readContent\", bno);} BoardMapper.xml SQL쿼리 추가1234&lt;select id=\"readContent\" resultType=\"BoardVO\"&gt; select * from tbl_board where bno =#{bno}&lt;/select&gt;","link":"/2020/10/28/201029spring/"},{"title":"[스프링SPRING MVC] 비밀번호찾기 및 임시 비밀번호 발급(지메일Gmail)","text":"pom.xml 코드 추가이메일로 비밀번호찾기 및 임시비밀번호 발급을 구현하기 위해서는 라이브러리를 추가해야한다. 123456&lt;!-- 메일 api --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 지메일을 이용하는 경우 구글 계정에서 보안 수준이 낮은 앱의 액세스를 허용해야한다.보내는 사람과 받는 사람 둘 다 보안 수준이 낮은 앱의 액세스를 허용해야지만 정상 작동한다. MemberController.java 코드 추가123456789/* 비밀번호 찾기 */@RequestMapping(value = \"/findpw\", method = RequestMethod.GET)public void findPwGET() throws Exception{}@RequestMapping(value = \"/findpw\", method = RequestMethod.POST)public void findPwPOST(@ModelAttribute MemberVO member, HttpServletResponse response) throws Exception{ service.findPw(response, member);} findpw.jsp 뷰 연결123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;link rel=\"stylesheet\" href=\"https://www.w3schools.com/w3css/4/w3.css\"&gt;&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\"&gt;&lt;script src=\"http://code.jquery.com/jquery-latest.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function(){ $(\"#findBtn\").click(function(){ $.ajax({ url : \"/member/findpw\", type : \"POST\", data : { id : $(\"#id\").val(), email : $(\"#email\").val() }, success : function(result) { alert(result); }, }) }); })&lt;/script&gt;&lt;style type=\"text/css\"&gt;.mybtn{ width:150px; height:40px; padding:0; display:inline; border-radius: 4px; background: #212529; color: #fff; margin-top: 20px; border: solid 2px #212529; transition: all 0.5s ease-in-out 0s;}.mybtn:hover .mybtn:focus { background: white; color: #212529; text-decoration: none;}&lt;/style&gt;&lt;title&gt;비밀번호 찾기&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"w3-content w3-container w3-margin-top\"&gt; &lt;div class=\"w3-container w3-card-4 w3-auto\" style=\"width: 382px;height: 456.3px;\"&gt; &lt;div class=\"w3-center w3-large w3-margin-top\"&gt; &lt;h3&gt;비밀번호 찾기&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt; &lt;label&gt;아이디&lt;/label&gt; &lt;input class=\"w3-input\" type=\"text\" id=\"id\" name=\"id\" placeholder=\"회원가입한 아이디를 입력하세요\" required&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;이메일&lt;/label&gt; &lt;input class=\"w3-input\" type=\"text\" id=\"email\" name=\"email\" placeholder=\"회원가입한 이메일주소를 입력하세요\" required&gt; &lt;/p&gt; &lt;p class=\"w3-center\"&gt; &lt;button type=\"button\" id=\"findBtn\" class=\"w3-button w3-hover-white w3-ripple w3-margin-top w3-round mybtn\"&gt;찾기&lt;/button&gt; &lt;button type=\"button\" onclick=\"history.go(-1);\" class=\"w3-button w3-hover-white w3-ripple w3-margin-top w3-round mybtn\"&gt;로그인으로&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; MemberService.java 인터페이스에 메서드 추가12345//이메일발송public void sendEmail(MemberVO vo, String div) throws Exception;//비밀번호찾기public void findPw(HttpServletResponse resp, MemberVO vo) throws Exception; MemberServiceImpl.java 메서드 오버라이딩 코드 추가 네이버 이메일을 이용하는 경우 String hostSMTP = &quot;smtp.naver.com&quot;; email.setSmtpPort(587); 지메일을 이용하는 경우 String hostSMTP = &quot;smtp.gmail.com&quot;; email.setSmtpPort(465); 처음엔 동일한 587 포트를 사용했으나 오류가 발생하여 구글링끝에 465로 설정하니 정상 작동하였다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//비밀번호 찾기 이메일발송@Overridepublic void sendEmail(MemberVO vo, String div) throws Exception { // Mail Server 설정 String charSet = \"utf-8\"; String hostSMTP = \"smtp.gmail.com\"; //네이버 이용시 smtp.naver.com String hostSMTPid = \"서버 이메일 주소(보내는 사람 이메일 주소)\"; String hostSMTPpwd = \"서버 이메일 비번(보내는 사람 이메일 비번)\"; // 보내는 사람 EMail, 제목, 내용 String fromEmail = \"보내는 사람 이메일주소(받는 사람 이메일에 표시됨)\"; String fromName = \"프로젝트이름 또는 보내는 사람 이름\"; String subject = \"\"; String msg = \"\"; if(div.equals(\"findpw\")) { subject = \"베프마켓 임시 비밀번호 입니다.\"; msg += \"&lt;div align='center' style='border:1px solid black; font-family:verdana'&gt;\"; msg += \"&lt;h3 style='color: blue;'&gt;\"; msg += vo.getId() + \"님의 임시 비밀번호 입니다. 비밀번호를 변경하여 사용하세요.&lt;/h3&gt;\"; msg += \"&lt;p&gt;임시 비밀번호 : \"; msg += vo.getPw() + \"&lt;/p&gt;&lt;/div&gt;\"; } // 받는 사람 E-Mail 주소 String mail = vo.getEmail(); try { HtmlEmail email = new HtmlEmail(); email.setDebug(true); email.setCharset(charSet); email.setSSL(true); email.setHostName(hostSMTP); email.setSmtpPort(465); //네이버 이용시 587 email.setAuthentication(hostSMTPid, hostSMTPpwd); email.setTLS(true); email.addTo(mail, charSet); email.setFrom(fromEmail, fromName, charSet); email.setSubject(subject); email.setHtmlMsg(msg); email.send(); } catch (Exception e) { System.out.println(\"메일발송 실패 : \" + e); }}//비밀번호찾기@Overridepublic void findPw(HttpServletResponse response, MemberVO vo) throws Exception { response.setContentType(\"text/html;charset=utf-8\"); MemberVO ck = mdao.readMember(vo.getId()); PrintWriter out = response.getWriter(); // 가입된 아이디가 없으면 if(mdao.idCheck(vo.getId()) == null) { out.print(\"등록되지 않은 아이디입니다.\"); out.close(); } // 가입된 이메일이 아니면 else if(!vo.getEmail().equals(ck.getEmail())) { out.print(\"등록되지 않은 이메일입니다.\"); out.close(); }else { // 임시 비밀번호 생성 String pw = \"\"; for (int i = 0; i &lt; 12; i++) { pw += (char) ((Math.random() * 26) + 97); } vo.setPw(pw); // 비밀번호 변경 mdao.updatePw(vo); // 비밀번호 변경 메일 발송 sendEmail(vo, \"findpw\"); out.print(\"이메일로 임시 비밀번호를 발송하였습니다.\"); out.close(); }} MemberDAO.java 인터페이스에 메서드 추가임시 비밀번호를 발급하면서 해당 비밀번호를 DB에 update하는 메서드를 구현한다. 12// 비밀번호 변경public int updatePw(MemberVO vo) throws Exception; MemberDAOImpl.java 메서드 오버라이딩 코드 추가12345//비밀번호변경@Overridepublic int updatePw(MemberVO vo) throws Exception { return sqlSession.update(namespace+\".updatePw\", vo);} MemberMapper.xml SQL쿼리 추가1234&lt;!-- 비밀번호 변경 --&gt;&lt;update id=\"updatePw\" &gt; update member set pw = #{pw} where id = #{id}&lt;/update&gt; 결과물서버 이메일 계정에서 admin계정으로 임시 비밀번호를 전송하였다.admin@naver.com은 당연히 존재하지 않는 계정이니 서버이메일계정으로 반송되어왔다.이메일 내용에 임시 비밀번호가 잘 출력됨을 확인할 수 있다.더불어 DB도 수정된 임시비밀번호로 update되어있음을 확인 할 수 있다. 참고 https://m.blog.naver.com/heartflow89/221108884368 https://m.blog.naver.com/heartflow89/221114309890 stackoverflow : smtp.gmail.com:587이 실패할때","link":"/2020/10/31/201101findpw/"},{"title":"[스프링SPRING]Controller에서 예외처리","text":"스프링에서 예외를 처리하기위해 아래 3가지 방법이 있다. 컨트롤러 메서드 내에세 try-catch로 처리 컨트롤러에 @ExceptionHandler메서드가 처리 @ControllerAdvice클래스의 @ExceptionHandler메서드가 처리 예외를 처리하게되면 클라이언트에게 보여줄 View를 지정해야하는데 그 방식에는 크게 2가지 방법이 있다. 응답상태코드별로 뷰 지정: error-page 예외 종류별로 뷰 지정: SimpleMappingExceptionResolver 1 Controller에서 예외처리 어노테이션 종류스프링프레임워크에서 예외처리 할때 사용되는 어노테이션에는 3가지가 있다. 어노테이션 사용처 예시 @ExceptionHandler 특정 controller만 예외처리할때 사용 @ControllerAdvice 글로벌 예외처리할때 사용 @ControllerAdvice(“특정패키지명”) 괄호안에 특정 package명을 기재하면 해당 package만 예외처리함 @ControllerAdvice(“com.test.springeprjt”): excom.test.springeprjt를 라는 특정 package 예외처리 @ReqeustStatus사용 HTTP 상태코드를 원하는 대로 변경할 수 있음 간단한 예시로 @ExceptionHandler를 사용하기 전과 후를 비교해보자. @ExceptionHandler 사용전다양한 에러처리 메서드를 사용하는 경우 try catch문 중복이 발생할 수 있다.이런 경우 공통적인 try Catch문을 @ExceptionHandler로 처리해줄수있다. 123456789101112131415161718192021@Controllerpublic class ExceptionController { @RequestMapping(\"/example1\") public String main() throws Exception { try{ throw new Exception(\"500 에러가 발생함\"); }catch(Exception e){ return \"common_error\" } } @RequestMapping(\"/example2\") public String main2() throws Exception { try{ throw new NullPointerException(\"NPE가 발생함\"); }catch(Exception e){ return \"common_error\" } }} @ExceptionHandler 사용후Exception를 받아주는 컨트롤러 catcher메서드를 만들었다. 이를 통해 main메서드와 main2메서드의 중복코드가 해소되었다.또한 컨트롤러 catcher메서드와 catcher2메소드를 Exception별로 나누었다. catcher메서드는 Exception를 받고 catcher2메소드는 NullPointerException만 받게 된다. 이를 통해 특정Exception에 맞게 예외를 처리해줄 수 있다. 123456789101112131415161718192021222324@Controllerpublic class ExceptionController { @ExceptionHandler(Exception.class) public String catcher(Exception e, Model model){ model.addAttribute(\"e\", e); return \"common_error\" } @ExceptionHandler(NullPointerException.class) public String catcher2(Exception e, Model model){ model.addAttribute(\"e\", e); return \"common_error\" } @RequestMapping(\"/example1\") public String main() throws Exception { throw new Exception(\"500 에러가 발생함\"); } @RequestMapping(\"/example2\") public String main2() throws Exception { throw new NullPointerException(\"NPE가 발생함\"); }} 그럼 이제 실제로 사용해보자! CommonExceptionAdvice.java를 컨트롤러 패키지에 생성테스트용으로 advice객체를 생성한다. advice란 AOP용어 중의 하나이다.@ControllerAdvice는 글로벌예외처리할 때 사용하므로 해당 클래스가 컨트롤러에 발생하는 모든 예외를 처리하는 클래스임을 의미한다. 123456789101112131415161718192021222324252627282930313233343536import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;import org.springframework.web.servlet.ModelAndView;@ControllerAdvicepublic class CommonExceptionAdvice { private static final Logger l = LoggerFactory.getLogger(CommonExceptionAdvice.class); // @ExceptionHandler(Exception.class)// public String common(Exception e, Model model) {// model.addAttribute(\"e\", e); // Model객체 지원x기에 ModelAndView 객체를 사용// return \"common_error\";// } @ExceptionHandler(Exception.class) private ModelAndView errorModelAndView(Exception e) { ModelAndView mav = new ModelAndView(); mav.setViewName(\"common_error\"); mav.addObject(\"e\", e); return mav; } //@ExceptionHandler(MethodArgumentTypeMismatchException.class) public String commonMismatch(Exception e) { return \"common_error\"; //출력값 //INFO : com.itwiilbs.controller.CommonExceptionAdvice - E: commonMismatch(e) 호출 org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: \"\" //E: commonMismatch 호출org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: \"\" }} CommonExceptionAdvice 객체에서는 Model객체를 파라미터로 사용하는것을 지원하지 않기때문에 ModelAndView 객체를 사용해야한다. common_error.jsp 페이지 생성error.jsp는 어떻게 표현하면 좋을까? 보통 “관리자에게 문의하세요”라는 문구가 사용자에게 보여진다. 가장 간단한 형태로 만들어보면 아래와 같다.isErrorPage=”true”이면 항상 500에러가 나타나므로 isErrorPage=”false”로 설정해줘야한다. 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" isErrorPage=\"false\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;common_error&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;common_error페이지&lt;/h2&gt;&lt;h2&gt;웁스! 잘못된 접근입니다. 관리자에게 문의하세요&lt;/h2&gt;e : ${e }&lt;hr&gt;메세지 : ${e.getMessage() }&lt;hr&gt;&lt;c:forEach items=\"${e.getStackTrace() }\" var=\"stack\" &gt; ${stack.toString() }&lt;br&gt;&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 2 뷰지정하기응답상태코드별로 error-page 이용하기위 CommonExceptionAdvice.java 코드를 보면 return값으로 특정 jsp 페이지(common_error.jsp)를 호출하고 있다.해당 컨트롤러에서 처리하지 못한 error들은 어떻게 될까? 톰캣에서 기본적으로 제공하는 error 페이지를 호출된다.톰캣에서 제공하는 에러페이지는 예쁘지도않고 사용자친화적이지도 않다.이때 커스텀한 에러 페이지를 사용하게 되는데 서버에서 주는 상태코드별로 디폴트페이지를 web.xml에서 지정해줄 수 있다.자주 처리하는 HTTP 상태코드는 400,401,403,404,500이다. 12345678910111213141516171819202122&lt;web-app&gt; &lt;error-page&gt; &lt;error-code&gt;400&lt;/error-code&gt; &lt;location&gt;/WEB-INF/view/system/exception/400.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;401&lt;/error-code&gt; &lt;location&gt;/WEB-INF/view/system/exception/401.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;403&lt;/error-code&gt; &lt;location&gt;/WEB-INF/view/system/exception/403.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/view/system/exception/404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/view/system/exception/500.jsp&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt; SimpleMappingExceptionResolver 이용하기예외종류별로 error를 보여주고 싶을때는 어떻게 할까?SimpleMappingExceptionResolver를 사용하면 된다.sevlet-cntext.xml 파일에 예외종류에 맞는 에러뷰를 등록할 수 있다.MyErrorPage에 대한 상태코드를 원하는 대로(아래 예제에선 404) 지정할 수 있다. 12345678910111213&lt;beans:bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;beans:property name=\"defaultErrorView\" value=\"common/error/defaultError\" /&gt; &lt;beans:property name=\"exceptionMappings\"&gt; &lt;beans:props&gt; &lt;beans:prop key=\"MyException\"&gt;common/error/MyErrorPage&lt;beans:/prop&gt; &lt;/beans:props&gt; &lt;/beans:property&gt; &lt;beans:property name=\"statusCodes\"&gt; &lt;beans:props&gt; &lt;beans:prop key=\"MyErrorPage\"&gt;404&lt;beans:/prop&gt; &lt;/beans:props&gt; &lt;/beans:property&gt;&lt;/beans:bean&gt; 참고 try catch구문 Springboot Exception처리","link":"/2020/11/01/201102spring/"},{"title":"[SQL]더미데이터 쉽게 쌓기","text":"쉽게 더미데이터 쌓기테이블 구조는 아래와 같다 123456789101112mysql&gt; desc tbl_board;+---------+--------------+------+-----+-------------------+----------------+| Field | Type | Null | Key | Default | Extra |+---------+--------------+------+-----+-------------------+----------------+| bno | int(11) | NO | PRI | NULL | auto_increment || title | varchar(200) | NO | | NULL | || content | text | YES | | NULL | || writer | varchar(200) | NO | | NULL | || regdate | timestamp | NO | | CURRENT_TIMESTAMP | || viewcnt | int(11) | YES | | NULL | |+---------+--------------+------+-----+-------------------+----------------+6 rows in set (0.03 sec) tbl_board 테이블에 데이터 한 줄 입력한 뒤 아래의 쿼리를 실행하면 전체 행의 2배씩 데이터가 쌓인다.예를들어 데이터가 1행들어있고 아래 쿼리 한번 실행 =&gt; 총 데이터 2행 한번 더 쿼리 실행 =&gt; 총 데이터 4행 한번 더 쿼리 실행 =&gt; 총 데이터 8행 한번 더 쿼리 실행 =&gt; 총 데이터 16행등등 12S&gt; insert into tbl_board (title,content,writer)(select title,content,writer from tbl_board);","link":"/2020/11/02/201103db/"},{"title":"[국비교육 자바JAVA 팀프로젝트]4. 첫 기능통합과 아쉬웠던 점, 팀장의 결단","text":"첫 기능통합과 그 후첫 스프린트와 두번째 스프린트가 끝났다.사실 이걸 스프린트라고 부르는 줄은 몰랐고 개인적으로 다년간의 팀프로젝트를 경험한 결과 마감기한이 없으면 늘어지기 마련이라서 함께 마감기한을 정하자고 회의안건을 올렸고 팀원들과 동의하에 스프린트마감일을 정했다. 용어가 있나싶어 검색해봤더니 이러한 방식을 스프린트 방법론이라고 한다고 한다.하나 배웠다! 첫 기능 통합을 했다. 통합은 팀장인 내가 전적으로 맡아서 진행했다.아래와 같이 두가지 방식을 사용하여 기능통합을 했다. 통합순서 각 브랜치들을 메인브랜치로 머지. 충돌방지를 위해 공통설정파일과 공용파일들은 따로 소스코드를 받아서 직접 푸시. 첫 기능통합 후 다음 계획은 팀원별 다음 기능개발이었다.하.지.만. 소스코드 통합 후 기능 테스트부분에서 많은 아쉬움이 있었다. 통일되지 못한 CSS, 자잘한 오류들을 테스트할때마다 새롭게 발견했다.혼자 통합 후 테스트를 하는데 시간이 꽤나 걸리는 일이었다.이래서 기업들이 테스터 담당자를 뽑는 구나…. 처음엔 혼자서 자잘한 오류를 해결해나갔다. 하지만 오류코드의 양이 많아지고 어떤 부분에서 어떠한 오류가 있는지 그리고 개선안까지 적다보니 혼자서 지쳐갔다.특히 가독성이 좋지않은 소스코드들(심지어 주석하나도 없음…이건 팀플인데…왜 주석이 없죠?)도 있어서 정말 난감했다. 이때 첫번째로 든 해결책은 테스터 담당 팀원 배정이었다.하지만 다시 한번 곰곰히 생각해보니 팀원 다같이 테스트하는 것이 낫다는 판단이 들었다.이는 크게 2가지 이유때문이었다. 팀원 모두 테스터하면 좋은 점 테스터가 발견 못한 오류나 에러 발견 가능성 높음 다른 팀원이 어떤 기능을 어떻게 구현했는지 확인하여 프로젝트의 이해도 제고 팀원 모두가 테스터, 그 결과는?먼저 첫 기능 통합한 main브랜치를 모든 팀원이 pull해서 기능테스트를 해달라고 요청했다.그냥 하라고만 하면 다들 잘 안하니까 (후후 난 다 RGRG) 각자 아쉬운 점 2가지씩 생각해서 댓글을 달아달라고 덧붙였다.그리고 예시로서 내가 통합시 생각해두었던 아쉬웠던 점 2가지와 개선방향을 먼저 작성했다. 그 결과!! 괜히 고민했다 싶을 정도로 다양한 아쉬운 점들이 나왔다. 다들 꼼꼼하게 테스트해주었고 개선점까지 적어주었다. 너무나 만족스러운 결과였다. 다양한 개선안을 보고 각 기능 담당자가 고도화를 하기로했다. 따로 정리하지않아도 자신이 담당한 부분만 찾아서 읽으면 되기때문에 정리 할 시간이 필요없었다.각 기능별 개선점을 따로 정리 할 시간이 필요없는 점도 정말 만족했다! 좋았던 점 8명의 의견이 모이니 나혼자서 찾지못했던 아쉬운 점을 발견하여 프로젝트 완성도를 높일 수 있었다. 테스터 혼자했다면 한두시간은 걸릴 일이였을텐데 팀원 다같이 해서 1시간안에 다양한 개선점이 나왔다. 게시글의 댓글형식으로 달다보니 따로 개선방향을 정리 할 필요없이 담당자가 자기가 해당하는 부분만 직접 찾아보면 된다. 배운 점 괜히 혼자 고민했다. 팀원들과 고민하면 이렇게 쉽게 해결될 것을! 함께하니 시간도 절약되었다. 또 하나 배웠다! 고민을 함께 나누면 해결점을 빨리 찾을 수 있다! 역시 예시가 중요하다. 개선방향까지 답을 끌어내고 싶어서 예시를 작성할때 개선방향까지 적은 점이 효과가 좋았다. 스프린트 계획 순차 기간 목표 첫번째 스프린트 10월 21일부터 11월 1일까지 (11일) 페어별 도메인단위 기능구현 두번째 스프린트 11월 2일부터 11월 4일까지 (2일) 기능 테스트 후 기능고도화 세번째 스프린트 11월 4일부터 11월 11일까지 (7일) 담당자별 도메인단위 기능구현 네번째 스프린트 11월 12일부터 11월 15일까지 (3일) 기능 테스트 후 프로젝트고도화 첫 스프린트와 두 번째 스프린트가 나에게 남긴 것 선택과 집중을 배우기 모두가 나같지 않다. 마음비우자! CSS 그만 건드리고 로직을 중점적으로 보자. 팀플에 에너지 몰빵말고 내 공부를 위한 에너지를 적절히 분배하자 윈윈게임을 좋아하는 팀장의 결단내가 원하는 팀플은 모두가 원하는 것을 한가지씩 가져가는 팀플이다.팀원분들 중 한 분이 자신은 앱개발쪽으로 생각하고 있다고 지나가는 말을 해주셨다.지나가는 말이었지만 계속 머리속에 맴돌았다. 남은 짧은 기간동안 어떻게 해야 윈윈 할 수 있을까?팀플젝을 안드로이드로 구현할 수 있는 방법은 없을까? 먼저 웹을 기준으로 DB에서 데이터를 끌어와서 앱에 뿌릴 수 있는지 검색해보았다.현재 팀플젝은 Mysql DB를 사용하고 있는데 안드로이드는 내장 sqlplus를 주로 사용하고 mysql연결이 꽤나 복잡하다는 글이 많았다.어떻게 해야하나… 모두가 하나씩 원하는 것을 가져갔으면 좋겠는데…발을 동동 구르며 다양한 방법들을 찾아보면서도 한편으로는 프로젝트 발표일이 2주밖에 안남았는데 한 명이 빠지면 프로젝트완성도가 떨어지지 않을까하는 걱정도 들었다. 난 참 사람에 관심이 많아서 탈이야… 괜한 오지랖일지도 몰라 학원에서 배운 안드로이드수업은 아주 기초적인 것이여서 우리가 어느 정도의 앱을 구현할 수 있는지가 감이 오지않았다. 고민하다가 담임강사님께 물어봐야지하며 잠들었다.그리고 다음날 아침에 그 팀원을 강의실에서 만났다. 그래서 내가 가장 궁금했던 mysql DB를 안드로이드에 연동해서 화면에 출력할 수 있는지를 물어봤다. 그 팀원분은 가능하다고 했다. 그러자 내 마음에 확신이 들었다.‘좋았어. 내가 2인분한다.’ 그리고 어제내내 고민했던 내용을 그 팀원분에게 털어놓았다.내가 생각하는 팀플과 지금 개발하시는 기능들은 제가 담당할테니 앱개발하시면 어떻겠냐고 물었다. 웹기능 전체 구현은 남은 시점에서 힘드니까 간단한 기능을 앱으로 구현해주시면 좋을 것 같다는 말과 함께.팀원분은 그럼 참 좋겠다고 답해주셨다.그 답변을 듣자마자 내 입밖으로는 “그럼 그렇게 합시다!”가 튀어나왔다.그리곤 마음속으로 이렇게 되뇌였다. 그래! 내가 1인 2인분을 해내면 돼! 난 할 수 있어! 할 수 있을…거야! 할 수 있다! 이제 팀 전체의 동의를 구해야했다. 정기회의날에 회의안건으로 올리고 솔직하게 이야기를 했다. 내가 책임지고(?) 2인분을 하겠다는 말과 함께.신뢰가 나름 두터운 터라 팀원분들이 흔쾌히 동의해주었다.괜한 오지랖이 되지 않도록 더 열심히 2인분 아니 3인분의 코딩해야겠다.힘내자! 할 수 있다!","link":"/2020/11/05/201105team/"},{"title":"스타트업 및 팀을 위한 Notion 활용 사례 공유 웨비나","text":"웨비나 소개스타트업 및 팀을 위한 Notion 활용 사례 공유 웨비나 링크 웨비나 목적COVID-19 사태로 인한 화상회의, 재택근무가 증가함에 따라 Notion을 통한 협업 사례 공유스타트업 및 액셀러레이팅을 Notion 으로 진행한 사례 공유팀 빌딩 및 초기 Notion 협업 대시 보드 세팅 및 운영 사례 공유 발표 내용20:00 웨비나 소개 - 이해봄20:10 노션으로 애자일 조직 만들기 - 오세용20:40 창업가 커뮤니티 빌딩을 위한 노션 활용 사례- 김기태21:10 노션을 통해 새로운 프로젝트 시작하고 운영하기 - 이해봄21:40 Q&amp;A 노션으로 만든 해봄님 소개페이지의 퀄리티가 대박이었다. 도구를 잘 쓰는 사람들은 일을 효율적으로 잘 한다. 진짜 멋있다. 더불어 스타트업과 팀을 위한 노션 페이지를 공유해주시고 설명해주셨는데 그저 감탄했다. 노션 정말 못하는 게 없구나! 심지어 예쁘기까지하다. 노션에 욕심이 생긴다. 노션으로 애자일 조직 만들기 - 오세용내가 고민하는 부분을 이미 다 고민하고 조직에 적용까지 하신 연사님이었다.너무나 재미있게 강연을 들었다.가장 공감했던 말은 팀에게 가장 좋은 협업도구는 유명한 도구가 아니라 팀에게 적합한 도구이다.현재 팀프로젝트 팀장으로서 협업도구에 대해 한참 고민했었다. 그때는 현업에서 슬랙,지라나 데브옵스등 유명한 협업도구를 사용했기에 나도 미리 사용해보고싶었다. 이때 멘토님이 내 고민을 보시고 깃헙 projects를 추천해주셨다.아주 탁월한 선택이었다. 팀플주제구상(feat.입문자를 위한 팀협업도구추천) 무료 협업도구 슬랙대신 매터모스터 노션 구글드라이브","link":"/2020/10/26/201103notion/"},{"title":"[REST API]페이지 전달방식","text":"Rest 방식의 사용원칙 URI가 원하는 리소스를 의미한다. (영어 복수형으로 주소를 사용) URI에는 식별할 수 있는 데이터를 전달하는것이 일반적인 방법 예를들어 게시판 - CRUD 이라면 사용가능한 주소형태는 아래와 같다. …/boards/123 =&gt; 123번 글을 조회 …/boards/123/replies/11 =&gt; 123번글의 11번째 댓글 조회 …/boards/123/11 =&gt; 123번글의 11번째 댓글 조회 …/boards/ =&gt; 신규 글용 작성 페이지 전달방식 [/작업명/기본키 + 메서드 + 데이터] 형태로 REST방식으로 페이지 전달하면 된다. 예시 방식 용도 …/boards/123 GET 자료 조회용 …/boards/123 DELETE 자료 삭제용 …/boards/, …/boards/new/ POST 신규 자료 작성용 …/boards/123 PUT 자료 전체 수정용 …/boards/123 PATCH 자료 일부 수정용 크롬 웹 도구인 ARC cookie exchange를 사용하면 편하게 방식을 구분할 수 있다.","link":"/2020/11/11/201112restapi/"},{"title":"[국비교육 자바JAVA 팀프로젝트]5. 팀플발표후기와 팀 프로젝트가 나에게 남긴 것","text":"팀플의 끝은 웹호스팅완성한 팀 프로젝트를 cafe24 호스팅을 했다. 학원에서 호스팅서버는 6개월 정도 제공된다고 했다.그 안에 취직이 되었으면 좋겠다!처음 호스팅해보는 거라 시간이 오래걸릴 거라 예상했는데 역시나 오래 걸렸다.웹 호스팅을 하면서 4시간 걸려서 MySQL연동하고 war파일 제대로 연동하고 올렸다니 짜잔-?!?! 섬네일이 엑박으로 뜨는 에러가 발생했다.섬네일이 엑박이 뜨는 이유는 경로설정에서 문제가 있었다. server.xml안에 코드를 썼는데 그걸 그대로 웹서버에 올리니 웹서버가 제대로 작동하지 않았다.강사님께 도움을 요청했지만 아직 해결하지 못했다. 차근차근 해결해야지. 성공할 때까지 하면 성공한다! 팀프로젝트 PPT의 완성PPT구성을 어떻게 하면 좋을까 고민하다가 아래와 같이 틀을 잡았다.우리 팀은 웹사이트뿐만 아니라 안드로이드 앱도 만들었기 때문에 웹 시연과 앱 발표를 함께 진행했다. 팀 프로젝트 발표자료 구성 프로젝트 개요 기술 스택 웹사이트 설명과 시연 모바일 앱 시연과 설명 질의응답 팀 프로젝트 발표자료는 틀을 먼저 만든 뒤 팀원 각자 힘 준 기능들을 최대 4장까지 만들어달라고 요청했다.총 팀원이 8명으로 많다 보니 중구난방이 될까 봐 예시 먼저 작성해서 공유했다. 팀 프로젝트 발표자료 작성 진행 방법 발표구성을 잡고 PPT 컨셉을 잡음 예시 슬라이드 하나를 만들어서 공유 디자인이 들어간 빈 슬라이드를 10개 정도 만들어서 안에 내용만 채우면 되도록 공유 글씨체, 색상 통일 요청 마감 기한을 정함 (기한을 4일로 넉넉히 작성할 수 있도록 했다.) 위와 같이 진행한 덕분에 팀원들 각자의 스타일이 들어있지만, 통일감도 있는 멋진 PPT를 만들 수 있었다.발표는 각자 구현한 기능을 발표할지 한 명이 발표할지 고민했었는데 아무도 발표하고 싶어 하지 않아서 내가 발표하기로 했다.아무래도 내가 짠 코드가 아니다 보니 제대로 전달할 수 있을지에 대한 고민이 있었다. 이를 해결하기 위해 그들이 작성한 코드와 PPT슬라이드를 제대로 전달하기 위해서 정말 많이 정독했다. 발표 당일발표 1시간 전까지 PR을 계속 받고 머지를 진행했다. 어찌나 바쁘던지 로컬호스트에서 발표하기로 강사님께 양해를 구하고 원활한 발표를 위해 사전 세팅을 진행했다.그 와중에 cafe24에 어떻게든 섬네일 기능을 고치려고 바둥바둥 노력했다.정말 정신없이 바빴다 ㅋㅋㅋㅋ 강사님이 발표는 1시간 정도 주어지지만 보통 40분 정도 끝난다고 했다.하지만…웹 시연뿐만 아니라 앱 시연이 들어가서 그런 걸까? 1시간 꽉 채워서 발표했다.질의응답에 많은 질문을 기대했는데 생각보다 많지 않아 아쉬웠다. 우리 팀은 나와 앱 개발 담당한 팀원 총 2명이 발표를 진행하였고 발표가 끝난 후 각 기능을 구현한 팀원들이 질의를 받고 응답했다. 발표 후 아쉬웠던 점이 있다. 시연 시 몇몇 기능을 누락했다. 특히 내가 공들여 구현한 댓글기능 시연을 완전히 잊어버렸다 ㅋㅋㅋ 후 연습 많이 했는데 실수를 해서 아쉬웠다. 다른 팀은 각자 구현한 기능 슬라이드 발표 후 해당 기능만 시연하는 형식으로 진행했다. 이 방법이 살짝 아쉬웠던 점은 팀프로젝트의 기능들은 유기적으로 연결되어있는데 기능담당자가 자신이 담당한 기능만 발표하다 보니 유기적인 연결을 볼 수 없었다. 하지만 장점은 나처럼 까먹지 않고… 모든 기능을 빠짐없이 시연할 수 있다는 점이었다! 팀프로젝트가 나에게 남긴 것 협업능력 UP!알고 있었지만 나는 역시 원격 협업에 능한 사람이었다. 대면하지 않더라도 여러 협업 툴을 통해 긴밀하게 팀원들과 연결되어있음을 느낄 수 있었다. 이번 협업 툴의 선택은 정말 만족스러웠다. 뿌-듯다음 팀플이 있다면 깃헙의 issue와 projects를 연결하여 이용하고 싶다.또한 최근 사랑에 빠진 노션을 이용해보고 싶다.카카오톡으로 이야기를 하다 보니 각 기능에 대한 이야기는 해당 담당자끼리 또 다른 톡방을 만들게 되고 그러다 보니 공유가 원활하지 않고 또한 여러 톡방이 생겨 복잡해져 버렸다.슬랙이나 issue, 노션을 사용하여 이러한 복잡함을 해결할 수 있기때문에 다음번에는 꼭 이용해보고싶다. 코드읽는 능력 UP!팀원들이 구현 중 도움이 필요할 때 도와준 적이 있다. 다양한 팀원들을 도와주다 보니 다양한 스타일의 코드와 주석을 접하게 되어서 코드를 읽는 능력이 많이 향상되었다. 신입으로 입사를 해도 다른 개발자가 쓴 코드와 주석을 읽는 시간이 더 많을 텐데 미리 경험할 수 있는 값진 시간이었다. 팀원을 믿는 능력 UP!성격이 완벽주의적인 면이 있어서 내 파트가 아닌데도 스스로 개선점을 찾아 고생해서 혼자서 수정하곤 한다.이번에도 역시나 기능 통합시 몇몇 부분을 고치고 있는 나를 발견해버렸다. 그러다보니 자꾸 지쳐갔다…..팀플에서 팀장이 지치면 안되기 때문에 팀원을 믿기위한 장치를 고안했다.기능 테스트를 모든 팀원들에게 요청하고 각 기능 담당자가 팀원들의 테스트 결과를 보고 스스로 고칠 수 있도록 유도했다.이를 통해서 팀원을 믿고 의지하는 능력이 향상되었다. 마음수련 능력 UP!모두가 다 그렇지만 인생사 계획대로 되는 일이 많지 않다.팀플도 마찬가지이다. 각자의 사정으로 계획에 차질이 생기고 마감기한은 다가오고 숨이 막히는 기분이었다.특히 계획을 성실히 지켜준 팀원들에게 미안했다.그런 마음이 들 때마다 나는 되뇌었다. ‘괜찮아. 모두 그들의 방식으로 최선을 다하고 있는 거야.’‘완성되지 않아도 괜찮아.’ 완성되어야만 한다고 강력히 생각하면서도 말이라도 입밖으로 내어봤다.ㅋㅋㅋㅋㅋ다름을 인정하려고 노력하고 이번엔 꽤 성공적이었다.팀플은 여전히 어렵지만 나는 이번 팀플을 통해 더 나은 내가 되었다.성장하는 느낌을 받는 건 항상 좋은 일이다.앞으로도 더 성장하는 내가 되고 싶다.","link":"/2020/11/16/201117team/"},{"title":"[REST API]ResponseEntity 타입클래스","text":"@RestController의 한계@RestController는 결과로 view를 제공하지 않기때문에 에러 발생유무를 확인할 수 없다.이때 사용할 수 있는 것이 웹 HTTP 상태 코드이다. HTTP 상태코드 HTTP 상태코드 MDN 에러처리하는 방법 구분 코드 설명 100번대 현재 데이터의 처리중인 상태 100 데이터의 일부만 서버가 받은 경우 200번대 정상적인 응답상태 200 에러가 없이 정상처리된 경우 204 정상처리가 되었으나 서버에 전달할 값이 없는 경우 300번대 다른 URL을 처리하는 상태 301 요청된 페이지가 새 URL로 변경된 경우 304 이미 기존의 데이터와 변경이 없는 경우 400번대 서버에서 인식불가한 상태 400 전송된 Request객체에 문제가 있어 서버가 인지하지 못하는 경우 403 서버에서 허락되지 않는 경우(서버에 접근권한이 없는 경우) 404 URL에 해당하는 자원을 찾을 수 없는 경우 406 전송방식의 오류 발생한 경우(주로 REST작동시 발생) 500번대 서버 내부의 문제가 발생한 상태 500 서버에서 처리시 문제가 발생한 경우 502 게이트웨이, 프록시에 문제가 발생한 경우(=과부화, 개발자의 영역이 아니라 엔지니어의 영역임) 503 일시적인 과부화 상태인 경우, 서비스 중단상태인 경우(개발자의 영역이 아니라 엔지니어의 영역임) 504 지정된 처리시간이 지나서 처리를 못하는 경우 ResponseEntity 타입클래스 HTTP 상태코드를 활용하여 상태처리를 할 수 있다. @RestController사용하지 않고 일반컨트롤러에서도 @ResponseBody을 통해서 rest로 처리가능하다. ResponseEntity를 사용하면 단순한 객체 정보도 JSON형태로 전달가능하지만, HTML 정보와 JS정보까지 전달할 수 있다.(예를 들어 Header정보) 이를 통해 결과확인 및 오류메세지 체크가 가능해진다. 12345678910111213141516171819202122@RestController@RequestMapping(value = \"/test/*\")public class TestController { //ResponseEntity를 사용하면 단순한 객체 정보도 JSON형태로 전달가능하지만, //HTML 정보와 JS정보까지 전달할 수 있다.(예를 들어 Header정보) //이를 통해 결과확인 및 오류메세지 체크가 가능해진다. @RequestMapping(value = \"res2\") public ResponseEntity res2() { System.out.println(\"res2 메서드 호출\"); //응답정보 중에 header에 데이터를 add해서 보낸다. HttpHeaders responseHeaders = new HttpHeaders(); responseHeaders.add(\"Content-type\", \"text/html; charset=UTF-8\"); String msg = \"&lt;script&gt;\"; msg += \"alert('얼럿창테스트');\"; msg += \"location.href='/res1';\"; msg += \"&lt;/script&gt;\"; return new ResponseEntity(msg,responseHeaders, HttpStatus.INTERNAL_SERVER_ERROR); }}","link":"/2020/11/10/201111restapi/"},{"title":"기술블로그 추천","text":"추천하는 기술블로그11번가 OpenAPI https://openapi.11st.co.kr/openapi/OpenApiFrontMain.tmall 가비아 : https://blog.naver.com/gabianow(그룹웨어) 네이버 밴드 : https://developers.band.us/ 네이버 D2 : https://d2.naver.com/home NBP : https://blog.naver.com/n_cloudplatform(네이버 클라우드) 아임포트 : https://www.iamport.kr/pricing (pg사 연동 ,문자보내기) 당근마켓 : https://medium.com/daangn 드라마앤컴퍼니 : https://blog.dramancompany.com/ (리멤버 앱) 라인 : https://engineering.linecorp.com/ko/blog/ https://engineering.linecorp.com/ja/(일본) 메가존 : https://megazone.tistory.com/ 빌드업웍스 https://blog.naver.com/buw00882 알리바바 https://github.com/alibaba 우아한 형제들 https://woowabros.github.io/ 이노그리드 http://www.innogrid.com/ https://blog.naver.com/innogrid (클라우드) 카카오 https://www.kakaocorp.com/ 카카오기술블로그 https://tech.kakao.com/ 카카오 TV https://tv.kakao.com/channel/2743187/video 쿠팡 https://medium.com/coupang-tech LG CNS https://blog.lgcns.com/ SK 플래닛 https://skpblog.tistory.com/ https://www.skplanet.com/main 한국 데이터 산업 진흥원 https://www.kdata.or.kr/ 레진 기술블로그 https://tech.lezhin.com/ Mozilla http://hacks.mozilla.or.kr/ 마켓 컬리 https://helloworld.kurly.com/ Airbnb https://medium.com/airbnb-engineering Netflix https://netflixtechblog.com/ facebook https://engineering.fb.com/ Spoqa(도도포인트) https://spoqa.github.io/jobs/ google https://developers.googleblog.com/","link":"/2020/11/16/201117techbloglist/"},{"title":"[자바JAVA]1097 : [기초-2차원배열] 바둑알 십자 뒤집기(설명)","text":"문제 1097 : [기초-2차원배열] 바둑알 십자 뒤집기(설명)부모님을 기다리던 영일이는 검정/흰 색 바둑알을 바둑판에 꽉 채워 깔아 놓고 놀다가…“십(+)자 뒤집기를 해볼까?”하고 생각했다.바둑판(19 * 19)에 흰 돌(1) 또는 검정 돌(0)이 모두 꽉 채워져 놓여있을 때,n개의 좌표를 입력받아 십(+)자 뒤집기한 결과를 출력하는 프로그램을 작성해보자. 입력예시 123456789101112131415161718192021220 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 01 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 10 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 01 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 10 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0210 1012 12 출력예시 123456789101112131415161718190 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Scanner;public class c1097 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[][] arr = new int[19][19]; //2차원배열생성 //입력값 배열에 넣기 for(int i=0; i&lt;arr.length; i++){ for(int j=0; j&lt;arr.length; j++){ arr[i][j] = sc.nextInt(); //System.out.printf(\"%d \",arr[i][j]); } //System.out.println(); } int count = sc.nextInt(); // 십자 뒤집기 횟수(n) //1이면 0으로 0이면 1로 for(int n=0; n&lt;count; n++){ int x = sc.nextInt()-1; //10 12 int y = sc.nextInt()-1; //10 12 //[10, i]가 0이면 1로, 1이면 0으로 for(int i=0; i&lt;arr.length; i++){ if(arr[x][i] == 0){ arr[x][i] = 1; }else{ arr[x][i] = 0; } } //[j, 12]가 0이면 1로, 1이면 0으로 for(int j=0; j&lt;arr.length; j++){ if(arr[j][y] == 0){ arr[j][y] = 1; }else{ arr[j][y] = 0; } } } sc.close(); //답 출력 for(int i=0; i&lt;arr.length; i++){ for(int j=0; j&lt;arr.length; j++){ System.out.printf(\"%d \", arr[i][j]); } System.out.println(); } }//end of main} 배운지식십자뒤집기가 이해되지않아 한참 규칙을 찾기위해 애썼다.주어진 좌표(10,12)이면 [10, n]가 0이면 1로, 1이면 0으로 뒤집고 [n, 12]가 0이면 1로, 1이면 0으로 뒤집는다는 뜻이었다.이제 제대로 이해했으니 다신 헷갈리지말자. 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/11/20/201121al-c1097/"},{"title":"[자바JAVA]1099 : [기초-2차원배열] 성실한 개미","text":"문제 1099 : [기초-2차원배열] 성실한 개미영일이는 생명과학에 관심이 생겨 왕개미를 연구하고 있었다.왕개미를 유심히 살펴보던 중 특별히 성실해 보이는 개미가 있었는데, 그 개미는 개미굴에서 나와 먹이까지 가장 빠른 길로 이동하는 것이었다. 개미는 오른쪽으로 움직이다가 벽을 만나면 아래쪽으로 움직여 가장 빠른 길로 움직였다. (오른쪽에 길이 나타나면 다시 오른쪽으로 움직인다.)이에 호기심이 생긴 영일이는 그 개미를 미로 상자에 넣고 살펴보기 시작하였다.미로 상자에 넣은 개미는 먹이를 찾았거나, 더 이상 움직일 수 없을 때까지오른쪽 또는 아래쪽으로만 움직였다.미로 상자의 구조가 0(갈 수 있는 곳), 1(벽 또는 장애물)로 주어지고,먹이가 2로 주어질 때, 성실한 개미의 이동 경로를 예상해보자. 단, 맨 아래의 가장 오른쪽에 도착한 경우, 더 이상 움직일 수 없는 경우, 먹이를 찾은 경우에는더이상 이동하지 않고 그 곳에 머무른다고 가정한다. 미로 상자의 테두리는 모두 벽으로 되어 있으며, 개미집은 반드시 (2, 2)에 존재하기 때문에 개미는 (2, 2)에서 출발한다. 입력예시1 123456789101 1 1 1 1 1 1 1 1 11 0 0 1 0 0 0 0 0 11 0 0 1 1 1 0 0 0 11 0 0 0 0 0 0 1 0 11 0 0 0 0 0 0 1 0 11 0 0 0 0 1 0 1 0 11 0 0 0 0 1 2 1 0 11 0 0 0 0 1 0 0 0 11 0 0 0 0 0 0 0 0 11 1 1 1 1 1 1 1 1 1 출력예시1 123456789101 1 1 1 1 1 1 1 1 11 9 9 1 0 0 0 0 0 11 0 9 1 1 1 0 0 0 11 0 9 9 9 9 9 1 0 11 0 0 0 0 0 9 1 0 11 0 0 0 0 1 9 1 0 11 0 0 0 0 1 9 1 0 11 0 0 0 0 1 0 0 0 11 0 0 0 0 0 0 0 0 11 1 1 1 1 1 1 1 1 1 입력예시2 123456789101 1 1 1 1 1 1 1 1 11 0 0 1 0 0 0 0 0 11 0 0 1 1 1 0 0 0 11 0 0 0 0 0 0 1 0 11 0 0 0 0 0 0 1 0 11 0 0 0 0 1 0 0 0 11 0 0 0 0 1 2 0 0 11 0 0 0 0 1 0 0 0 11 0 0 0 0 0 0 0 0 11 1 1 1 1 1 1 1 1 1 출력예시2 123456789101 1 1 1 1 1 1 1 1 11 9 9 1 0 0 0 0 0 11 0 9 1 1 1 0 0 0 11 0 9 9 9 9 9 1 0 11 0 0 0 0 0 9 1 0 11 0 0 0 0 1 9 9 9 11 0 0 0 0 1 2 0 9 11 0 0 0 0 1 0 0 9 11 0 0 0 0 0 0 0 9 11 1 1 1 1 1 1 1 1 1 내코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Scanner;public class c1099 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); //개미집 10*10 만들기 int[][] antHouse = new int[11][11]; //개미집에 입력값 넣기 int w; for(int i=1; i&lt;antHouse.length; i++){ for(int j=1; j&lt;antHouse.length; j++){ w = sc.nextInt(); antHouse[i][j] = w; } } //오른쪽 아래로 내려갈수있도록 count변수로 y좌표 기억하기 int count = 2; Boolean isTwo = false; for(int i=2; i&lt;11; i++){ for(int j=count; j&lt;11; j++) { //System.out.println(\"좌표(x,y)는 (\"+ i +\" , \"+ j + \") 값은?\"+antHouse[i][j]); //먹이(2)인 경우 if (antHouse[i][j] == 2) { isTwo = true; antHouse[i][j] = 9; break; } //갈 수 있는 길(0)인 경우 if (antHouse[i][j] == 0) { antHouse[i][j] = 9; } //벽(1)인 경우 else if (antHouse[i][j] == 1) { count = j-1; break; } } //먹이(2)인 경우 if(isTwo) { break; } } sc.close(); //출력 for(int i=1; i&lt;antHouse.length; i++){ for(int j=1; j&lt;antHouse.length; j++){ System.out.printf(\"%d \", antHouse[i][j]); } System.out.println(); } }} 문제 풀이개미는 조건상 항상 오른쪽과 아래로만 움직이기때문에 좌표(x,y)에서 y좌표를 기억해야했다.따라서 count라는 변수를 생성하여 y좌표를 기억하고 x++를 시켰다.또한 antHouse[i][j] == 2인 경우에는 flag를 걸어두어 이중 for문을 다 빠져나갈 수 있도록 설계했다.문제를 해결하고 나서 더 나은 방법이 있는지 구글링했는데 while문으로 좌표를 증가시켜 해결하는 방법으로도 풀수도 있었다. 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이","link":"/2020/11/20/201121al-c1099/"},{"title":"2020미래유망기술세미나 후기","text":"2020 미래유망기술 세미나 소개 한국과학기술정보연구원(KISTI)은 오는 11월 26일(목) 서울 코엑스 아셈볼룸에서 「Bridge to Future, 데이터로 만나는 미래유망기술」을 주제로 “2020 미래유망기술세미나”를 개최합니다.본 세미나는 올해로 15회를 맞는 국내 최대의 과학기술 세미나로 미래를 좌우할 핵심 유망기술을 발굴하여 제시하고, 그 기술들의 확보 및 사업화 전략을 논의하는 자리입니다.포스트코로나시대에 과학기술 데이터 분석 활용을 통한 선도형 미래 유망기술과 사업화 아이템을 소개함으로써 국가 디지털 경쟁력 확보에 기여하고 한국 경제 중추인 중소기업이 신사업 기회 탐색과 새로운 기업가치를 창출 전략을 모색하고자 합니다.출처 : 초대글 by 한국과학기술정보연구원장 최희윤 &lt;2020 제15회 미래유망기술세미나&gt; &quot;KISTI, 미래를 움직일 유망기술 한눈에 본다&quot; 11월 26일(목), 『 Bridge to Future, 데이터로 만나는 미래유망기술』을 주제로“2020…게시: KISTI 한국과학기술정보연구원&nbsp;2020년 11월 19일 목요일 후기오랜만에 사고가 확장되는 느낌을 받은 세미나였다. 정말 재미있었다! 특히 데이터기반으로 뽑아낸 미래유망기술키워드는 정말 솔깃했고 앞으로 어떤 기술에 연구가 이루어지고 있는지 알 수 있는 좋은 시간이었다. 연구가 이루어진다는 것은 그 분야에 자금이 흐른다는 뜻이으로 더욱 유망할 수밖에. 모든 세션이 다 흥미로웠지만 내게 특히 재미있었던 세션은 두가지이다. 딥러닝으로 예측한 미래 고성장 과학기술 100선 by 고병열 센터장 (KISTI 미래기술분석센터) 포스트 코로나 대응 새로운 비즈니스 기회 창출 유망 사업화 아이템 by 최윤정 센터장 (KISTI 기술사업화센터) 딥러닝으로 예측한 미래 고성장 과학기술 100선 by 고병열 센터장 (KISTI 미래기술분석센터) 후기기술클러스터를 대상으로 딥러닝 기반 미래 성장가능성 예측 지형도를 봤는데 정말 흥미로웠다. 지형도에 따르면 7년 후 성장가능성이 높은 유망기술 후보군을 기준으로 7가지 이슈를 도출할 수 있었다. 순번 이슈 예시 또는 추가 설명 1 지구온난화 세가지 키워드의 융합: 지구온난화 대처 + 데이터/인공지능의 활용 + 소재연구 2 기후변화를 예측하는 감시·센싱·모니터링기술 기후변화로 인한 생태계, 토지, 조류 변화, 가뭄, 홍수 등 재난예측 3 의료분야 데이터관리(영상처리기술, 로봇기술등), 소재개발(DNA나노기술등), 질병예측·진단·치료 4 물 재해관리분야(홍수위험관리 및 예측등), 수자원 관리분야(폐수처리, 재생수, 담수화등), 에너지원분야(바이오연료 생산등) 5 신재생에너지·지속가능에너지 수소에너지분야, 지속가능한에너지분야(태양,풍력,파력등),에너지소재분야(상변화소재,메타물질,리튬황전지등), 에너지관리분야(스마트에너지시스템, 가상발전소, 발전량예측등) 6 이미징기술·나노기술 이미지기술, 나노기술 7 사회문제해결형 과학기술 도시화, 정신질환, 아동영양결핍 등 위 키워드 중 관심있는 키워드가 꽤 있었다. 탄성파 데이터 처리 및 해석 : 탄성파 데이터 처리는 원래 의료용으로 사용하는 기술이 아니였으나 MRI비용을 줄일 수 있는 대안기술로 활용할 수 있다. 위성기반 토양수분측정기술은 미세먼지 예측에 활용가능하다. 인공위성을 통한 빅데이터 비즈니스성장률은 20~30%정도이며 환경모니터링에 활용가능하다. 이미징기술 : 의료영상분할기술뿐만 아니라 농업자동화에 활용가능하다. 수소에너지에도 다양한 급이 있다는 사실이 신기했다. 그레이, 그린, 블루 중 green hydrogen은 탄소가 zero이므로 주목해야한다. 포스트 코로나 대응 새로운 비즈니스 기회 창출 유망 사업화 아이템 by 최윤정 센터장KISTI 2020 미래유망기술세미나에서 발표된 미래 유망 사업 분야 오픈엑세스 논문 플랫폼 KORA국가 오픈엑세스 플랫폼인 KOAR를 통해서 국내 연구자들의 공개논물을 자유롭게 이용할 수 있다.이번 세미나를 통해 관심을 가지게 된 탄성파 데이터 처리 및 해석에 대해 검색해봤다. PDF로 다운로드할 수 있고 바로 볼 수 도 있어 유용했다.","link":"/2020/11/26/201126emergingtech/"},{"title":"Framework VS Library 프레임워크와 라이브러리의 차이","text":"프레임워크와 라이브러리 차이점실행주체에 있어 차이점이 있다. 라이브러리 : I call 라이브러리 내가 필요할 때마다 라이브러리를 실행시킬수있다. 내가 원하는 대로 수정이 가능하다. 비유하자면 Ikea(아이키아) 프레임워크 : Framework calls 내가 작성한 코드 프레임워크가 내가 작성할 코드를 실행시킨다. 프레임워크의 규칙을 잘 따라야지만 내 코드가 정상 작동한다. 비유하자면 모델하우스 공통점 : 프레임워크와 라이브러리 모두 누군가가 자주 발생하는 문제들을 해결하거나 더 좋은 코드를 위해 미리 만들어 둔 코드이다. In summaryFrameworks and libraries are both code written by someone else that helps you perform some common tasks in a less verbose way.A framework inverts the control of the program. It tells the developer what they need. A library doesn’t. The programmer calls the library where and when they need it.The degree of freedom a library or framework gives the developer will dictate how “opinionated” it is.By The Difference Between a Framework and a Library By freecodecamp 참고 라이브러리? 프레임워크? 차이점 아직도 모름? 5분 순삭. BY 노마드코더 The Difference Between a Framework and a Library By freecodecamp","link":"/2020/12/03/201204LibraryVSFramework/"},{"title":"DevOps와 CI&#x2F;CD차이","text":"팀프로젝트를 웹호스팅한 후 소스코드 하나 바꿀때마다 jar파일 다시 업로드하고 서비스url에서 잘 작동되는지 다시 테스하는 일들을 매번 반복하고 있다.이를 효율적으로 할 수 있는 방법이 없는지 깃헙에 공개된 다른 팀프로젝트 개발문서들을 읽으며 공부하다가 DevOps와 CI/CD단어를 동시에 그리고 자주 마주쳤다.정확히 무엇인지 몰라서 이번 기회에 확실히 정리해보려고 한다. DevOps란? DevOps = Development(개발+테스트) + Operations(운영)DevOps란 개발과 운영의 합성어로 운영환경에서부터 개발, 배포까지 진행되는 프로세스의 속도를 높이는 접근방식을 의미한다. 이러한 접근 방식을 적용하려면 개발 팀과 운영 팀간의 장벽을 허물고 자주 협력해야함에 따라 필요한 것을 정리해둔 모델이 있다. 바로 CALMS 모델이다. DevOps의 CALMS MODEL이 중 눈에 띄는 것은 역시 CI/CD이다. 자동화는 DevOps의 핵심이다. CI/CD란? CI (Continuous Integration) 다수의 개발자가 작성·수정한 소스코드를 지속적으로 통합·테스트하는 것을 의미한다. CD (Continuous Delivery/Deployment)란 개발, 통합, 배포, 릴리즈, 테스트를 자동화하여 지속적으로 배포하는 것을 의미한다. 전통적인 방식으로는 코드수정하고 배포하는데 까지 많은 시간이 소요되었다. 특히 QA테스팅에서 많은 버그가 발생되었다. CI/CD를 통해 지속적으로 통합·테스트·배포를 하고 이 흐름을 자동화하여 효율적으로 일을 처리할 수 있게 되었다. CI/CD 예시 [Delfood] CI/CD 서버 구축과 첫 배포CI/CD의 이해하기 쉽도록 잘 정리된 적용사례이다. 개인적으로 만든 프로젝트를 배포한 경험에 관한 글을 볼 수 있다. 라인개발자가 작성한 CI/CD적용 글 : 데이터 기반으로 지속적인 CI/CD 개선 환경 만들기 DevOps단계별 사용하는 기술DevOps에선 어떤 기술들이 사용될까? 아래 이미지에서 확인해볼 수 있다! 요약DevOps와 CI/CD차이DevOps는 개발과 운영을 통합하여 프로세스의 속도를 높이는 접근방식이다.CL/CD는 지속적으로 통합·테스트·배포를 하고 이 흐름을 자동화하는 것을 말한다. 참고 https://blog.oursky.com/2019/08/19/how-to-build-cicd-pipeline/ https://www.dotnettricks.com/learn/devops/what-is-devops-and-devops-advantages https://aws.amazon.com/ko/devops/what-is-devops/ DevOps 엔지니어는 어떤 사람일까요? by RedHat https://www.redhat.com/ko/topics/devops https://deveric.tistory.com/106","link":"/2020/12/04/201205devOpsandCICD/"},{"title":"오픈소스 개발자가 알려주는 GitHub 오픈소스 포트폴리오 세미나 후기","text":"세미나 소개 및 후기 오픈소스 개발자가 알려주는 GitHub오픈소스 포트폴리오강연내용 GitHub소개와 개인 포트폴리오 작성 실사례 GitHub오픈소스 개발참여이력by 리얼리눅스 요즘 한창 포트폴리오를 정리하고 있다. 프로젝트에 많은 시간과 노력을 들인 만큼 이를 잘 설명하는 포트폴리오를 작성하고 싶어졌다. 여러 참고자료들을 찾아보고 있다가 해당 강연을 알게되고 얼른 신청했다.유익한 강연이었다. 특히 마지막에 질의응답시간에 성심성의껏 답변해주셔서 정말 유익했다. 한국 오픈소스 개발자 커뮤니티강연덕분에 재미있는 커뮤니티를 알게되었다. 바로 한국 오픈소스 개발자 커뮤니티이다.해당 사이트에 접속하면 한국 개발자 인기 순위와 한국 저장소 인기 순위를 볼 수 있다.인기 저장소 중 몇몇은 나도 star를 찍어놓은 곳이었다.내이름도 순위권에 안에 들면 얼마나 좋을까미래를 꿈꾸는 건 언제나 신나는 일이다. 전세계 버전도 있다. gitstar-ranking은 star를 많이 받은 users, organizations, repositories순위를 한 눈에 보여준다. 세계적으로 유명한 레포지토리들은 역시 example과 readme.md, contributing.md가 잘 작성되어있었다. 더불어 이슈템플릿과 PR템플릿, 그리고 그 가이드라인까지도… 인기있는 레포지토리 방문만했을뿐인데 그 안에서도 배울점이 참 많다. 깃헙으로 만든 이력서 및 포트폴리오 예시 JSpiner님의 이력서링크드인에 있는 지인 추천의 말기능을 PR로 구현한 점은 정말 신박했다. webstoryboy의 포트폴리오 샘플 이 포트폴리오는 화면이 여러 디지털기기들로 이동하는 디자인은 참 재미있었다. 반응형 디자인을 나타내고 싶으셨던 것 같다. creative-portfolios는 리스트업된 모든 포트폴리오가 예술이었다. 진짜 art다 art! hacktoberfest강사님이 처음 오픈소스를 기여한다면 hacktoberfest를 추천해주셨다. fest기간동안 참여하면 된다고하셨다. 처음 참여하는 사람들을 위한 튜토리얼도 있다. 질의응답 번역오픈소스 기여한 적이 있는데 이를 매력적으로 포트폴리오에 적고싶다면 어떻게 적으면 좋을까요? 오픈소스문화(이슈남기기 코드리뷰받기 pr남기기)를 이해하고 협업능력이 향상되었다는 점과 오픈소스프로젝트의 해당 기술을 잘 알기에 번역을 할 수 있으니 기술적인 부분의 이해도가 높다는 점을 어필하면 좋을 것 같습니다. 혹시 강사님께서 처음 오픈소스에 기여하셨을때 어떤 프로젝트로 시작하셨나요? 첫 참여 이후 다음 오픈소스프로젝트를 어떤 기준잡고 찾으셨을까요? 우연한 계기로 리눅스 perf 퍼프라는 프로젝트로 시작했습니다.다음 오픈소스 프로젝트를 찾을 때는 인기있는 프로젝트나 잘 merge해줄 것 같은 프로젝트를 선택하는 것은 좋은 접근 방식이 아닙니다. 지속적으로 오픈소스에 참여하고 싶다면 내가 무슨 기술에 관심이 있는지 생각한 뒤 다음 오픈소스를 찾아야합니다.자기관찰을 먼저 하시고 자신의 관심사에 기반한 오픈소스를 선택하시면 지속적으로 기여가 가능할 것입니다.","link":"/2020/12/02/201202githubOpenSourcePortfolio/"},{"title":"[자바JAVA]14. Longest Common Prefix","text":"문제 14. Longest Common Prefix공통으로 가장 긴 접두사를 찾는 문제이다. Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string “”.strs[i] consists of only lower-case English letters. 입출력예시 12345678//예시1Input: strs = [\"flower\",\"flow\",\"flight\"]Output: \"fl\"//예시2Input: strs = [\"dog\",\"racecar\",\"car\"]Output: \"\"Explanation: There is no common prefix among the input strings. 풀이 코드123456789101112131415class Solution { public String longestCommonPrefix(String[] strs) { String prefix=\"\"; if(strs.length == 0) return prefix; prefix = strs[0]; for(int i=1; i&lt;strs.length; i++){ String cur = strs[i]; while(cur.indexOf(prefix) != 0){ prefix = prefix.substring(0, prefix.length()-1); } } return prefix; }} 배운 지식indexOf()를 사용할 생각을 못했다.indexOf()는 주어진 요소가 배열에 있다면 그 첫번째 인덱스 값를 반환하고 없으면 -1을 반환한다. 아래 3가지 모두 0을 리턴한다. 123\"ant\".indexOf(\"ant\") =&gt; 0\"ant\".indexOf(\"an\") =&gt; 0\"ant\".indexOf(\"a\") =&gt; 0 strs[0]전체를 prefix로 두고 만약 strs[1]과 일치하지 않는다면 strs[0]의 마지막 char를 지워나가는 방식이다.예를 들어 strs배열이 아래와 같다고 하자. 123strs[0] = \"flower\"strs[1] = \"flow\"strs[2] = \"flight\" for문 시작 i=1일때,flow에 flower가 속해있지않다. -&gt; prefix에서 flower의 마지막 char인 r을 제거 -&gt; 다시 while문flow에 flowe가 속해있지않다. -&gt; prefix에서 flowe의 마지막 char인 e를 제거 -&gt; 다시 while문flow에 flow가 0번째로 속해있다. -&gt; prefix는 flow가 되고 while문 종료 for문 시작 i=2일때,flight에 flow가 속해있지않다. -&gt; prefix에서 flow의 마지막 char인 w을 제거 -&gt; 다시 while문flight에 flo가 속해있지않다. -&gt; prefix에서 flo의 마지막 char인 o를 제거 -&gt; 다시 while문flight에 fl가 0번째로 속해있다. -&gt; prefix는 fl가 되고 while문 종료 항상 생각의 전환을 하자. 항상 더 나은 코드가 있다. 다른 문제 풀이가 보고싶다면? 모든 릿코드(LeetCode)(leetcode) java 풀이","link":"/2020/12/06/201206al-l0014/"},{"title":"[자료구조DataStructure]자료구조와 알고리즘 차이, 배열","text":"자료구조와 알고리즘 자료구조(data structure) : 데이터를 효율적으로 사용하기 틀이다. 이러한 효율성은 시간 복잡도(time complexity)와 공간 복잡도(space complexity) 기준으로 평가된다. 시간 복잡도란, 해당 자료구조의 시간 효율성의 척도이며 작을 수록 좋은 자료구조이다. 공간 복잡도란, 해당 자료구조의 공간 효율성의 척도이며 작을 수록 좋은 자료구조이다. 알고리즘 : 어떤 값을 입력으로 받아 원하는 값으로 출력하는 잘 정의된 계산 과정이다. 알고리즘 효율성은 실험적 분석방법과 이론적 분석방법으로 분석가능하다. 이론적분석시 가장 대표적인 것이 빅오표기법이다. 실험적 분석 : 직접 코드를 구현하는 분석방법으로 한계가 있기때문에 이론적 분석방법을 이용한다. 이론적 분석 : 빅오표기법 자료구조와 알고리즘의 관계 : 효율적인 알고리즘을 만들기 위해 필요한 것이 자료구조이다. 배열 여러 데이터를 하나의 이름으로 그룹핑해서 관리하기 위해 사용하는 자료구조 배열의 구성 = element의 집합, element = index + value 특징 : 크기가 정해져있다. 기능이 없다. 작고 가볍고 단순하다. 즉 좋은 부품으로 사용할 수 있다. 요약 자료구조 : 데이터를 효율적으로 조직하는 방법 알고리즘 : 문제를 해결하는 방법 자료구조와 알고리즘의 관계 : 효율적인 알고리즘을 만들기위해 자료구조가 필요하다. 참고 https://cloudstudying.kr/courses/23 https://wayhome25.github.io/cs/2017/04/17/cs-18/","link":"/2020/12/06/201207dataStructure1/"},{"title":"JDC 첨단과학단지 입주기업과 함께하는 디지털잡페어","text":"디지털잡페어 후기이 좋은 잡페어를 왜 많은 예비 개발자들이 안 듣는 걸까? 정말 귀중한 시간이었다.특히 다른 사람의 포트폴리오를 볼 수 있는 경험이 신입 개발자로선 쉽지않은데 포트폴리오를 페이스북과 아마존다니는 개발자분들이 리뷰와 첨삭까지 해주신다. 정말 많이 배울 수 있었다. 나도 용기낼까하다가 망설였는데 용기내서 신청하신 분도 정말 대단하다! 싸피하시는 거 같던데 역시 잘하시는 분이었어….. 민창현연사님의 직업을 대하는 자세가 인샆깊었다. 그는 사용자가 원하는 것을 어떻게 잘 제공할 수 있는지를 많이 생각한다고 했다. 난 지금은 내가 필요해서 웹클리핑프로젝트를 진행중인데 다음에는 더 많은 고객의 니즈를 제공할 수 있는 사이트를 만들고 싶다. 이준호대표님은 회사는 제너럴리스트보단 스페셜리스트를 더 찾는다며 그 이유를 설명해주셨는데 그 설명이 참 와닿았다. 스페셜리스트가 되기위해 노력해야겠다. 마지막에 이호준대표님이 해주신 말은 공감을 넘어 참 감동적이었다. 보석이 흙속에 묻혀있다고해서 보석이 아닌게 아닙니다.여러분이 취업이 잘 안되는 것은 시대가 그런 것이지 여러분의 탓이 아닙니다. 취업이 안된다고 좌절하지 않으셨으면 좋겠습니다.by 바울랩 이호준대표 이호준대표님은 제코베에서 뵙고 완전 팬이 되어버렸다. 세상에 이렇게 따뜻한 사장님도 있구나 하는 생각이 들었다.정말 직원을 생각하고 또 배움을 원하는 사람들을 성심성의껏 도와주시는 분이다.참 의미 있는 삶이다. 나도 그렇게 살고싶다.내 직업이 남에게 직접적으로 도움이 되는 삶.정말 직업만족도 최상일 듯! 강연내용 중 인상깊었던 내용Q. 주니어 레벨에게 바라는 점 &lt;바울랩 이호준대표&gt; 사실과 의견을 구분할 수 있는 솔직함이 중요하다상황을 예로 들자면 주니어 개발자분에게 프로젝트 시작했는 지라고 물었을때 아직 안 했다면 안했다고 솔직하게 답변하는 분이 좋다.조직이 필요한 일을 아직까지 안했다고 안좋게 생각할 수 있지만 시작하지않았다고 솔직하게 말함으로써 앞으로 어떻게 해야할지 대표입장에서 플래닝할 수 있기때문이다. &lt;재이랩스 이준호대표&gt; 스타트업은 열정있는 주니어 개발자분이 좋다. 몸사리기보단 의견이 부딪히더라도 자신의 의견을 피력해야한다. 열정있는 분은 제재라도 시킬 수 있지만 열정이 없는 분은 열정을 끌어올려드릴수가없다. &lt;아마존 민창현 개발자&gt; 최근 주니어에 대한 부정적인 일을 겪고있다. 조직은 프로젝트 플래닝을 하고 난이도에 따라 업무분장을 한다. 주니어에게 적당한 난이도의 업무를 줬는데 한 번도 해본적없어서 못하겠다고 했다. 주니어레벨에 잘 할 수 있는 일을 플래닝해서줬음에도 못하겠다는 말을 들었을때 굉장히 힘들었다.자신에게 주어진 일을 잘 맡아서 해줬으면 좋겠다. 만약 못하겠다면 팀장이나 시니어와 면담을 해서 조직에 해가 되지않도록 조치해야한다.또 회의때 주니어는 자신의 의견을 잘 내지못한다. 만약 주니어가 팀회의에서 적절한 자신의 의견을 낸다면 이 사람이 얼마나 공부했는 지를 느낄수있어서 좋다. &lt;페이스북 김종욱개발자&gt; 페이스북은 4개 축으로 인턴을 평가하여 입사제의를 한다. 코딩실력, 문제해결능력, 학습속도 등이 있다. 이 중 주니어레벨에서 가장 중요한 것은 학습속도라고 생각한다. 기술은 진화하고 변화한다. 필요한 기술을 얼마나 빨리 익히는 지가 중요하다. 더불어 질문을 잘 하는 것도 중요하다. 모르는 부분을 직면했을때마다 물어보는 것이 아니라 하루이상 고민했던 질문만 시니어에게 물어보는 것이 좋다. Q. 해외취업 계기 &lt;아마존 민창현 개발자&gt; 개발자들이 모여서 개발자영어스터디를 하는데 그곳에서 정보를 얻고 아마존 하이어링이벤트에 참여하게 되었다. 이전에 민창현님 강연을 들은 적이 있어서 어떤 식으로 창현님이 입사하셨는지 잘 알고있다. 정말 좋은 강연이었다. 이번에도 역시 좋은 말씀 많이 해주셔서 많이 배웠다.민창현님 Amazon 개발자가 말해주는 해외취업 웨비나 후기 바로가기 &lt;페이스북 김종욱개발자&gt; 네이버 다니는 중에 구글 면접을 보고 재택으로 일하는 걸 찾다가 페이스북에서 연락이 와서페이스북코리아 1년이상 다니다가 글로벌지사로 옮기게되었다.글로벌회사들은 채용절차가 정형화되어있기때문에 미리 준비를 할 수 있다. 따라서 한 번 시도해보는 것이 제일 중요하다.해외기업은 한국기업보다 다양성을 더욱 존중하기때문에 여성분들도 꼭 도전했으면 좋겠다. 추가내용바울랩에서 이호준대표님이 인상깊었던 부분을 기록해주셨다.기록 덕분에 중요한 내용을 다시 상기시킬 수 있어 좋았다. ICT 취업 준비를 하는 청년에게 듣고, 개발자 선배가 답하다 — With 페이스북과 아마존 개발자, 재이랩스와 위니브(바울랩) 대표","link":"/2020/12/09/201210digitalJobFair/"},{"title":"[자바JAVA]13. Roman to Integer","text":"문제 13. Roman to Integer로마숫자를 아라비아숫자로 나타내는 문제이다.Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. 입출력 예시 첫번째 풀이 코드입력값을 split으로 자른다음 역순으로 접근했다.i를 먼저 반복문 돌린 뒤 예외사항들을 if조건문+swich case문으로 해결했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution { public int romanToInt(String s) { int result = 0; String[] chars = s.split(\"\"); for(int i= chars.length-1; i&gt;=0; i--) { boolean isException = false; if (i != chars.length - 1){ switch (chars[i]){ case \"I\": if (chars[i + 1].equals(\"V\") || chars[i+1].equals(\"X\")){ isException = true; result -= 1; } break; case \"X\": if (chars[i + 1].equals(\"L\") || chars[i+1].equals(\"C\")){ isException = true; result -= 10; } break; case \"C\": if (chars[i + 1].equals(\"D\") || chars[i+1].equals(\"M\")){ isException = true; result -= 100; } break; } } if(!isException){ switch (chars[i]){ case \"I\": result += 1; break; case \"V\": result += 5; break; case \"X\": result += 10; break; case \"L\": result += 50; break; case \"C\": result += 100; break; case \"D\": result += 500; break; case \"M\": result += 1000; break; } } }//end of for return result; }} for문 안에 if문 그 안에 swich문 그 안에 또 if문으로 굉장히 복잡하다.3번의 들여쓰기가 있다면 코드를 되돌아보라는 유명한 코딩격언이 있다.따라서 다시 방법을 생각해보고 구글링해보았다. 더 나은 풀이 코드역순으로 접근하는 법은 동일하지만 삼항연산자로 훨씬 깔끔하다.배열을 사용하지 않고 charAt()을 인덱스를 사용했다. 123456789101112131415161718192021222324252627class Solution { public int romanToInt(String s) { int num = 0; int len = s.length(); char c; for (int i = len - 1; i &gt;= 0; i--) { c = s.charAt(i); if (c == 'I') { num += (num &gt;= 5 || num &gt;= 10) ? -1 : 1; } else if (c == 'V') { num += 5; } else if (c == 'X') { num += (num &gt;= 50 || num &gt;= 100) ? -10 : 10; } else if (c == 'L') { num += 50; } else if (c == 'C') { num += (num &gt;= 500 || num &gt;= 1000) ? -100 : 100; } else if (c == 'D') { num += 500; } else if (c == 'M') { num += 1000; } } return num; }} 두 코드 차이점두 코드에는 확실한 차이가 있다. Runtime Memory 첫번째 풀이 15 ms 39.8 MB 더 나은 풀이 3 ms 38.8 MB 배운 지식보자마자 switch case문이 생각나서 어떻게든 적용해보려고 노력했다.swich case가 쉽다고 생각했는데 반복문을 대체할 수 있는 방법이 어떤 것이 있을까 생각하게되었다.String이면 이 문제처럼 charAt()로 접근할 수도 있다. 런타임이 5배가 차이나는 이유가 무엇일까? 내가 생각한 이유 처음 접근법은 for문 + if문 + swich문 + if문 이렇게 중첩 두번째 접근법은 for + if ~else 멘토님이 말해주신 런타임이 5배 차이나는 이유 성능에서 차이가 발생한 점은 if - else나 switch의 조건 차이가 아니라String[] chars = s.split(“”);요놈 때문에 발생한 차이일거에요.조건문은 아무리 깊어져도 성능에 크게 영향을 주지 않습니다 멘토님이 자료구조에 대해 더 공부하면 좋겠다고 말씀해주셨다.자료구조는 기본소양!이니까자료구조 항상 어려워서 어떻게 공부하면 좋을까 생각만하고있었다.찾아보니 교과서인 생활코딩에서 자료구조 입문강의가 있었다. 이를 함께 공부해야겠다. 다른 문제 풀이가 보고싶다면? 모든 릿코드(LeetCode)(leetcode) java 풀이","link":"/2020/12/06/201206al-l0013/"},{"title":"이클립스 윈도우 단축키 표(Eclipse shortcut key for window)","text":"🔑이클립스 단축키 정리표 카테고리 Action 단축키 이동 줄이동 Alt + ↑↓ 검색 프로젝트 내 파일명으로 찾아 열기 ctrl + Shift + r 전 범위에서 찾기 ctrl + h 현재 커서가 있는 소스에서 문자 검색 ctrl + f 원하는 문자 선택 후 해당 프로젝트 내에 해당 문자 검색 Ctrl + Alt + g 실행 런 ctrl + F11 주석 한 번 더 누르면 해지가능한 주석 ctrl + shift + c 한 번 더 누르면 해지불가능한 주석 ctrl + shift + / 주석된 블럭을 선택 후 주석 제거 ctrl + shift + \\ 정렬 자동 코드 정렬 Ctrl + shift+ f 주석 오류 IntelliJ, VSCode, Eclipse, Visual Studio 단축키 비교 https://okdevtv.com/mib/intellij/shortcuts","link":"/2020/12/24/201224eclipseKey/"},{"title":"SVN사용법과 git차이점","text":"형상관리 도구의 종류 Client/Server 타입 : Subversion(SVN), CVS, Perforce, ClearCase, TFS 분산저장소 타입 : Git, Mercurial, Bitkeeper, SVK, Darcs Folder 공유 타입 : RCS, SCCS SVN vs GIT 비교 시스템 각 개발자만의 version history 한계 SVN Centeralized Version Control System; CVCS; 중앙집중 버전관리 불가능 commit한 내용에 실수가 있을 시에 서버에(다른 개발자에게) 바로 영향을 미치게 되고 만약 중앙서버에 문제가 생기면 협업 불가능 GIT Distributed Version Control System; DVCS; 분산 버전관리 가능 다양한 기능이 있기때문에 SVN보다 진입장벽이 높음 둘 중 어느 것이 무조건 더 좋다는 건 없는 것 같다. 팀에 맞게 사용하면 된다. SVN GUI 사용법 회색 화살표 ▶ : local에서만 수정하고, 서버에서는 수정되지 않은 파일 Commit하면 된다. 파란 화살표 ◀ : local에서는 수정되지 않고, 서버에서만 수정된 파일 Update하면 된다. 빨간 화살표 ◀-▶ : local에서도 수정되었고, 서버에서도 수정된 파일 충돌 부분을 확인하면서 수정한다. 용어 Commit : 서버로 나의 로컬 소스 코드를 올린다. git와 다른 점 : git같은 경우, 팀원들이 각각의 branch를 따로 만들어 로컬 소스를 서버에서 관리할 수 있었지만 SVN은 main브랜치 하나만 있다. Update : 서버 소스코드를 나의 로컬로 다운받는다. Override and Commit… : 서버를 무시하고 로컬에 있는 파일을 서버에 덮어 쓴다. Override and Update… : 로컬을 무시하고 서버에 있는 파일을 내 로컬로 덮어 쓴다. 참고 https://goddaehee.tistory.com/158 https://www.dunebook.com/svn-vs-git-core-differences/ https://devcheon.tistory.com/2","link":"/2020/12/27/201228svn/"},{"title":"Oracle SQL","text":"주석두 가지 방법이 있다.쿼리 마지막라인에 --주석문을 사용하면 그 뒤의 내부적으로 추가되는 sql구문에 주석이 인식되어질 수 있어 에러가 발생할 수 있다.따라서 --주석문보다 /* 주석문 */을 사용하는 습관을 들이는 것이 좋다. --주석문 : 한 줄 주석처리 1234567insert into test( ppl_name, -- 사원이름 ppl_dept -- 사원부서) values ( #{name}, #{dept}) /* 주석문 */ : 범위를 주석처리 123select member from dualunion all /* member테이블과 dept테이블을 합침*/select dept from dual ||(쌍 파이프)문자열이나 컬럼을 합쳐주는 역할을 한다. 12345678910// 예시select rpad('010-', 8, '*'), lpad('1234', 5, '-') from dual;// 출력값rpad : 010-****lpad : -1234// 콤마대신 ||(쌍파이프 사용)select rpad('010-', 8, '*') || '(개인정보보호)' || lpad('1234', 5, '-') from dual;010-****(개인정보보호)-1234 UNION 위의 사진에서 왼쪽테이블을 table1, 오른쪽테이블은 table2라고 해보자. 123456789101112131415//unionselect * from table1unionselect * from table2//출력값id컬럼안에 1,2,3,4//union allselect * from table1union allselect * from table2//출력값id컬럼안에 1,2,3,2,3,4 CASE WHEN THEN ELSE ENDJAVA에서 IF ELSE구문같은 역할을 한다. 규칙 CASE문은 반드시 END로 끝나야한다. ELSE 뒷 부분에 NULL이 와선 안된다. 12345678910case when x = y then a else b end: 조건 x = y 가 true 일 경우 a 이고 그렇지 않으면 bcase when x &lt; y then a when x = y then b else c end: 조건 x&lt;y가 true 일 경우 a 로, 조건 x = y 일 경우엔 b 로 그렇지 않으면 c 로 변경case XYZ when 'foo' then 'moo' else 'bar' end: XYZ 가 foo일 경우 moo로 변경, 그렇지 않으면 bar로 변경출처: https://joke00.tistory.com/103 [Smile virus] 참고 https://mazekb.tistory.com/424 https://sesok808.tistory.com/510 https://www.sqlservertutorial.net/sql-server-basics/sql-server-union/ https://joke00.tistory.com/103","link":"/2020/12/28/201229oracleSQL/"},{"title":"톰캣서버 중복에러 관리자권한으로도 해결 안될 때 임시해결방법","text":"문제상황이클립스에서 톰캣 서버를 실행하던 중 80 port가 already in use라는 에러가 발생했다.차분히 cmd를 열고 taskkill했는데 오류 : 프로세스(PID 4)를 종료할 수 없습니다. 원인: 액세스가 거부되었습니다가 출력되었다.관리자권한으로 다시 실행하여 taskkill했지만 여전히 동일하 오류 메세지가 출력되었다. 아마 ISS(인터넷정보서비스)를 설치하면서 동일한 80포트를 사용했기때문에 톰캣서버와 충돌난 것 같다.추측일뿐 정확한 원인은 지금까지도 찾아보고 있다… 톰캣서버충돌시 해결방법 명령프롬프트를 연다. netstat -ano를 입력한다. 충돌된 포트를 찾은 뒤 PID를 기억한다. 나의 경우 충돌된 포트가 80이므로 PID는 4이다. taskkill /f /pid 4를 입력한다. 거부가 된 경우 관리자 권한으로 cmd를 실행한 뒤 위 방법을 재시도한다. cmd를 관리자 권한으로 실행하기 위해선 파일탐색기에 cmd입력한 뒤 앱에서 우클릭하여 관리자권한으로 실행할 수 있다. 보통 여기서 프로세스가 종료된다. 나처럼 권리자권한으로 실행했음에도 액세스 거부가 방생한 경우 아래 임시 방법을 사용할 수 있다. 임시해결방법 톰캣 서버 HTTP 포트를 80에서 8080으로 변경해준뒤 테스트 실행시 URL에 :8080을 붙여주니 웹페이지가 정상적으로 출력되었다. 12345//예시www.test.com/home/main//8080추가www.test.com/home/main:8080 컨트롤러에 의해 알아서 맵핑이 되기때문에 즐겨찾기에 저장해놓은 뒤 프로젝트를 테스트하면 편하다.","link":"/2020/12/29/201230taskkillerror/"},{"title":"[자바JAVA]1014 : [기초-입출력] 문자 2개 입력받아 순서 바꿔 출력하기(설명), Scanner vs BufferedReader 차이","text":"문제 1014 : [기초-입출력] 문자 2개 입력받아 순서 바꿔 출력하기(설명)2개의 문자(ASCII CODE)를 입력받아서 순서를 바꿔 출력해보자. 참고char x, y;scanf(“%c %c”, &amp;x, &amp;y);printf(“%c %c”, y, x); //출력되는 순서를 작성와 같은 방법으로 해결할 수 있다. 입력예시 1A b 출력예시 1b A 풀이1 : Scanner + char 사용12345678910111213public class quizCodeup1014 { public static void main(String[] args) throws IOException { // 풀이1 : char로 받아서 출력 // 메모리 12480 시간 93 Scanner sc = new Scanner(System.in); char x = sc.next().charAt(0); char y = sc.next().charAt(0); sc.close(); System.out.printf(\"%c %c\", y, x); }} 풀이2 : Scanner + String 사용12345678910111213public class quizCodeup1014 { public static void main(String[] args) throws IOException { // 풀이2 : String으로 받아서 출력 // 메모리 12376 시간 96 Scanner sc = new Scanner(System.in); String x = sc.next(); String y = sc.next(); sc.close(); System.out.println(y+\" \"+x); }} 풀이3 : BufferedReader + StringTokenizer 사용1234567891011public class quizCodeup1014 { public static void main(String[] args) throws IOException { // 풀이3 : BufferedReader사용 // 메모리 :11140 시간:66 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); String[] anz = {st.nextToken(), st.nextToken()}; System.out.println(anz[1]+\" \"+anz[0]); }} 코드 비교 Scanner + char 사용 Scanner + String 사용 BufferedReader + StringTokenizer 사용 수행시간 93 ms 96 ms 66 ms 메모리 12480 kb 12376 kb 11140 kb 배운 지식알고리즘 최적화를 위해 Scanner보단 BufferedReader가 좋다. 원리 경계 Scanner 사용자 요청시 데이터 매번 읽어옴 space, enter 모두 경계로 인식 BufferedReader 일정량을 한 번에 읽어온 후 버퍼에 보관 -&gt; 사용자 요청시 버퍼에서 읽어옴 enter만 경계로 인식 BufferedReader 특징 입력값 String으로 고정이기에 타입변환 필요함 자체적으로 Exception처리된 Scanner와 달리 따로 IOException 처리해야함 버퍼에 저장되는 데이터에 공란을 기준으로 여러 값이 있는 경우 파싱 필수 -&gt; StringTokenizer 사용 참고 https://www.java67.com/2016/06/5-difference-between-bufferedreader-and-scanner-in-java.html https://sjs2215.tistory.com/93 https://studywithus.tistory.com/61 다른 문제 풀이가 보고싶다면? 모든 코드업100제 자바java 풀이 1089","link":"/2020/12/27/201227al-c1014/"},{"title":"포트(port)란? HTTP port 80과 HTTPS 443의 차이","text":"port 443과 80의 차이 http의 기본 포트: 80. https의 기본 포트: 443. 123456789http 프로토콜http://www.google.com - http 프로토콜. 구글이 망하지만 않는다면 잘 접속된다.http://www.google.com:80 - 80 포트를 명시했다. 잘 접속된다.http://www.google.com:81 - 81 포트를 명시했다. 목적이 다른 포트이므로 접속이 안 된다.https 프로토콜https://www.google.com - https 프로토콜. 잘 접속된다.https://www.google.com:443 - 443 포트를 명시했다. 잘 접속된다.https://www.google.com:444 - 444 포트를 명시했다. 목적이 다른 포트이므로 접속이 안 된다. port란? 포트(port) : 논리적인 접속장소특히 인터넷 프로토콜인 TCP/IP를 사용할 때에는 클라이언트 프로그램이 네트워크 상의 특정 서버 프로그램을 지정하는 방법으로 사용된다.네트워크 상에서 통신을 할 때 IP를 토대로 해당 서버가 있는 컴퓨터에 접근한다.그런데 대부분의 경우 하나의 컴퓨터에는 여러 개의 서버가 실행될 수 있다.컴퓨터에 여러 개의 서버가 실행되고 있다면, 어느 서버에 접속해야 하는지 컴퓨터에게 알려주어야 한다.이때 사용되는 것이 포트 번호이다. HTTP의 경우 지정된 포트 번호가 있는데 이런 것들을 “잘 알려진 포트들” “Well-known port”이라고도 한다. 포트 0 ~ 1023은 예약되어있다.나머지 65535개는 사용할 수 있다. IP와 PORT의 차이 IP : 컴퓨터를 찾을 때 필요한 주소 Port : 그 컴퓨터 안에서 프로그램을 찾기 위한 수단. 참고 https://johngrib.github.io/wiki/why-http-80-https-443/ https://study-recording.tistory.com/13 https://captcha.tistory.com/5","link":"/2020/12/30/201231portdiff/"},{"title":"[자바JAVA]125. Valid Palindrome","text":"문제 125. Valid PalindromeGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.Note: For the purpose of this problem, we define empty string as valid palindrome. 입출력예시 1234567//예시1Input: \"A man, a plan, a canal: Panama\"Output: true//예시2Input: \"race a car\"Output: false Palindrome(팰린드롬)이란?해당 문제는 팰린드롬이라고 불린다.한국에서 쉽게 찾아볼 수 있는 예로는 옛날옛적 &lt;슈퍼주니어의 로꾸꺼&gt;가 있다.그 가사를 보면 12345678아많다많다많다많아다이뿐이뿐이뿐이다여보게저기저게보여여보안경안보여통술집술통 소주만병만주소다이심전심이다 뽀뽀뽀아좋다좋아 수박이박수다시합창합시다 문제 접근법아좋다좋아는 앞에서부터 뒤로 읽거나 뒤에서 앞으로 읽어도 아좋다좋아가 된다.문제에서 원하는 것은 알파벳과 숫자만 체크를 해서 boolean형태로 리턴하는 것이다.즉, 아 좋 다 좋 아, 아, 좋다. 좋아! 등등 아무리 많은 공백과 특수기호가 있더라도 true가 반환되어야한다. 그렇다면 String에서 어떻게 알파벳과 숫자만 남겨두고 나머지는 잘라버릴 수 있을까? split()을 사용할까?처음에는 split()을 생각해봤는데 특수문자와 기호가 너무 많기 때문에 다 처리하는 것은 불가능했다. 그럼 replace로 대체해버릴까?replace(char oldChar, char newChar)의 형태로 파라미터로 character가 들어간다.특수문자와 기호등이 너무 많아 char로 처리가 불가능하다. replaceAll로 정규식을 이용하자!replaceAll(String regex, String replacement)의 형태로 파라미터로 regex(정규식)을 넣을 수 있다. 코드 Runtime 24ms Memory 40MB 1234567891011121314public static boolean isPalindrome(String s) { //sol1. =&gt; Runtime 24ms Memory 40MB //정규식으로 알파벳이 아닌 것들을 없앤다 String s1 = s.toLowerCase().replaceAll(\"[^a-zA-Z0-9]\", \"\"); System.out.println(s1); //반으로 나눈뒤 글자가 일치하는 지 확인한다. for(int i=0; i&lt;s1.length()/2; i++){ if(s1.charAt(i) != s1.charAt(s1.length()-i-1)){ return false; } } return true;} 한 줄 코드구글링을 하다보니 한 줄로 풀이를 한 코드가 눈에 띄었다. Frankenstein’s-Function-One-Line-Java-Solution Runtime 39 ms Memory 40.4 MB 코드1과 비교해보니 성능면에서 좋지않았다. 하지만 한 줄로 풀이할 수 있음에 엄청난 재미를 느꼈다! 생각 해 낸 개발자는 엄청난 희열을 느꼈겠지? 123456public static boolean isPalindrome(String s) { //sol2 =&gt; Runtime 39 ms Memory 40.4 MB return new StringBuilder().append(s).reverse().toString() .replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase() .equals(s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase()) ? true: false;} 배운내용 : 정규표현식자주 사용하는 정규식은 암기해두면 좋다. 위에서 사용한 정규식 [^a-zA-Z0-9]을 설명하자면, [] : 문자열을 뜻한다. ^ : 문자열안에 들어가면 not의 의미한다. a-z : 소문자 전체를 의미한다. A-Z : 대문자 전체를 의미한다. 0-9 : 숫자 전체를 의미한다. 즉 대소문자와 숫자를 포함하지 않는 문자열 전체를 뜻하는 정규식이다.참고로 한글은 가-힣이다. ^는 두가지 의미가 있다. 위에서는 2번으로 사용되었다. ^, \\A: (위치) 문자열의 시작 [^문자열] : 문자열의 문자를 제외한 문자에 매핑 참고 링크 : 정규표현식, 자주 사용하는 정규식 배운내용 : replace() VS replaceAll() 차이점 replace() replaceAll() 형태 replace(char oldChar, char newChar) replaceAll(String regex, String replacement) Parameters character regular expression Returns replaced string replaced string 12345678String s = \"안녕하세요! 행복하세요~\"//예시 : replace()System.out.println(s.replace(\"하\",\"ha\")); // 안녕ha세요! 행복ha세요~//예시 : replaceAll()System.out.println(s.replaceAll(\"요\",\"yo\")); // 안녕하세yo! 행복하세yo~System.out.println(s.replaceAll(\"[^가-힣]\",\"\")); // 안녕하세요행복하세요 Java String replace() 다른 문제 풀이가 보고싶다면? 모든 릿코드(LeetCode)(leetcode) java 풀이","link":"/2021/01/09/210110replacevsreplaceall/"},{"title":"[자바JAVA]136. Single Number","text":"문제 136. Single Number주어진 array안에 쌍이 아닌 홀로 있는 숫자를 찾는 문제이다.Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. 입출력예시 1234567891011//예시1Input: nums = [2,2,1]Output: 1//예시2Input: nums = [4,1,2,1,2]Output: 4//예시3Input: nums = [1]Output: 1 풀이 코드 1 : 비트연산자 비트 연산자(^) : 대응되는 비트가 서로 같으면 0을, 다르면 1을 반환함. (비트 XOR 연산) 123//예시a^a = 0a^1 = 1 Runtime 1 ms Memory 47.9 MB1234567891011121314151617181920public class _0136SingleNumber { public static int singleNumber(int[] nums) { int val=0; for(int i=0;i&lt;nums.length;i++){ val^=nums[i]; } return val; } public static void main(String[] args) { int[] nums =// {2, 2, 1}; //{4,1,2,1,2}; //{1}; //{-1,-1,-2}; //=&gt; -2 //{1,3,1,-1,3}; System.out.println(singleNumber(nums)); }} 풀이2 : HashMap사용 HashSet : contains()을 통해 있으면 remove, 없으면 add해서 남은 값을 출력 Runtime 10 ms Memory 40 MB1234567891011121314151617181920212223public class _0136SingleNumber { public static int singleNumber(int[] nums) { Set&lt;Integer&gt; box = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { if (box.contains(nums[i])) { box.remove(nums[i]); } else { box.add(nums[i]); } } return box.stream().findFirst().get(); } public static void main(String[] args) { int[] nums =// {2, 2, 1}; //{4,1,2,1,2}; //{1}; //{-1,-1,-2}; //=&gt; -2 //{1,3,1,-1,3}; System.out.println(singleNumber(nums)); }} 성능 비교 비트연산자사용 해시맵사용 Runtime 1 ms 10 ms Memory 47.9 MB 40 MB 다른 문제 풀이가 보고싶다면? 모든 릿코드(LeetCode)(leetcode) java 풀이","link":"/2021/01/11/210111al-l0136/"},{"title":"[오류일지] slick slider 라이브러리 적용 안 되는 에러","text":"slick slider 라이브러리슬라이드배너기능을 구현하기위해 슬릭 라이브러리를 사용했다.slick slider는 jQuery 기반으로 만들어진 라이브러리이다. 따라서 jQuery가 필요하다.슬라이더 라이브러리는 다양하지만 슬릭 슬라이더 라이브러리의 홈페이지가 가장 친절하다. 라이브러리를 사용하기 위해서 스크립트와 css를 연결해줘야한다.홈페이지에서 Downliad Now를 통해서 ZIP파일로 다운로드한 뒤 프로젝트에 넣어도 좋고 아래 jsDelivr CDN를 이용해도 좋다.아래 코드를 프로젝트에 붙여넣기만 하면 바로 사용가능하다. 1234567CSS&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"//cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.css\"/&gt;JS&lt;script type=\"text/javascript\" src=\"//cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.min.js\"&gt;&lt;/script&gt; 문제상황CSS와 JS headerSet에 적용시켰으나 slick.css가 제대로 적용되지않았다.슬릭의 클래스명이 자동으로 적용되어야한다. 적용되지 않은 모습 해결방법CSS는 우선순위가 있다. 이 순서는 외워야한다. 기본적으로 뒤에 나오는 css가 우선순위가 높습니다. !important &gt; inline style attribute &gt; id &gt; class, 다른 attribute, 수도클래스(:first-child같은 것) &gt; tag element, 수도엘레먼트(::before같은 것) 순으로 우선순위가 높습니다. 우선순위가 같다면 개수가 많은 css가 우선순위가 높습니다.출처 : ZeroCho 블로그 잘 적용된 모습","link":"/2021/01/14/210115slickSlider/"},{"title":"[자바JAVA]172. Factorial Trailing Zeroes","text":"문제 172. Factorial Trailing Zeroes주어진 int n을 팩토리얼로 나타내어 Trailing Zeroes를 구하는 문제이다.Given an integer n, return the number of trailing zeroes in n!. 입출력예시 1234567891011121314151617//예시1Input: n = 3Output: 0Explanation: 3! = 6, no trailing zero.//예시2Input: n = 5Output: 1Explanation: 5! = 120, one trailing zero.//예시3Input: n = 0Output: 0//예시4Input: n = 25Output: 6 코드 및 풀이팩토리얼 테이블이나 계산기로 확인하여 규칙을 찾을 수 있다.n이 5의 배수인 경우 규칙을 찾을 수 있다. 팩토리얼 Trailing Zeroes갯수 5! 1 10! 2 15! 3 20! 4 24! 4 25! 6 25! 6 30! 7 50! 12 순차적으로 증가하는 가 싶었지만 25!에서 Trailing Zeroes 갯수는 5가 아니라 6이다.이를 어떻게 규칙으로 만들 수 있을까?나눗셈을 한번 더 적용하면 된다. 25/5 = 5 여기서 5를 한번 더 나누면 5/5 = 1이다.총 5+1로 6을 찾아낼 수 있다. 50!으로해봐도 동일한 결과가 나온다. 즉 규칙은 n이 0보다 클때까지 계속 5로 나누어주는 것이다.그리고 몫을 누적한 값을 리턴하면 된다. 123456789101112131415161718public class _0172FactorialTrailingZeroes { public static int trailingZeroes(int n) { int result = 0; while( n &gt; 0 ){ n = n/5; result += n; } return result; } public static void main(String[] args) { int n = //3; //=&gt;0 // 5;//=&gt;1 // 0; //=&gt;0 25; //=&gt;6 System.out.println(trailingZeroes(n)); }} Trailing Zeroes란? 유튜브 강의에 따르면 소수점 오른쪽에 있으면서 그 뒤에 숫자가 오지않는 0을 의미한다.반면 본 문제에서는 제약조건이 0 &lt;= n &lt;= 104 이므로 뒤에 숫자가 오지않는 0이라고 생각하면 된다. 팩토리얼 계산기 factorial 계산기 다른 문제 풀이가 보고싶다면? 모든 릿코드(LeetCode)(leetcode) java 풀이","link":"/2021/01/18/210118al-l0172/"},{"title":"웹접근성","text":"웹접근성이란?웹 접근성(web accessibility)은 장애인이나 고령자들이 웹 사이트에서 제공하는 정보를 비장애인과 동등하게 접근하고 이용 할 수 있도록 보장하는 것으로 웹 접근성 준수는 법적의무사항이다.브라우저들은 HTML의 사소한(?) 에러들은 자동으로 고쳐준다.따라서 태그가 닫혔는지 굳이 체크하지않아도 괜찮다. 하지만 웹접근성을 준수하기 위해선 직접 닫아줘야한다. 원칙 1 인식의 용이성 (Perceivable) : 모든 콘텐츠는 사용자가 인식할 수 있어야 한다. 적절한 대체 텍스트 제공해야 한다. 멀티미디어 콘텐츠에는 자막, 원고 또는 수화를 제공해야 한다. 콘텐츠는 색에 관계없이 인식될 수 있어야 한다. 명확한 지시사항 제공해야 한다. 텍스트 콘텐츠와 배경 간의 명도 대비는 4.5대 1 이상이어야 한다. 자동 재생 금지 이웃한 콘텐츠는 구별될 수 있어야 한다. 원칙 2 운용의 용이성(Operable) : 사용자 인터페이스 구성요소는 조작 가능하고 내비게이션 할 수 있어야 한다. 키보드 사용 보장 터치(touch) 기반 모바일 기기의 모든 컨트롤은 누르기 동작으로 제어할 수 있어야 한다. (모바일웹) 깜빡임과 번쩍임 사용 제한 제목 제공 적절한 링크 텍스트 원칙 3 이해의 용이성(Understandable) : 콘텐츠는 이해할 수 있어야 한다. 원칙 4 견고성(Robust) : 웹 콘텐츠는 미래의 기술로도 접근할 수 있도록 견고하게 만들어야 한다. 마크업 오류 방지 웹 애플리케이션 접근성 준수 웹 접근성 확인 가능한 웹사이트 W3C Markup Validation : 웹 접근성을 위한 HTML 유효성을 확인할 수 있다. W3C CSS Validation : 웹 접근성을 위한 CSS 유효성을 확인할 수 있다. 참고 http://www.wa.or.kr/m1/sub1.asp https://seulbinim.github.io/WSA/accessibility.html#%EC%9B%B9%EC%A0%91%EA%B7%BC%EC%84%B1%EC%9D%98-%EA%B0%9C%EC%9A%94 http://www.websoul.co.kr/accessibility/define.asp","link":"/2021/01/22/210122webAccessibility/"},{"title":"이클립스 svn 계정변경, 비밀번호 잊어버렸을 때 해결하기","text":"비번이 뭐더라…?이클립스에서 svn 계정을 변경해야할 상황이 생겼다.문제는 변경할 계정의 비밀번호가 기억이 안난다는 사실…그나저나 아이디는 뭐였더라? 아이디도 함께 찾아보자. svn 계정 아이디찾기먼저 실행 중인 이클립스를 종료한다.파일탐색기를 통해 C:\\Users\\[컴터아이디]\\AppData\\Roaming\\Subversion\\auth\\svn.simple 로 이동한다.폴더 안에는 계정정보가 담겨져있다.하단에 username을 통해 아이디를 찾을 수 있다!이제 비밀번호만 찾으면 된다! svn 계정 비밀번호찾기비밀번호를 찾는 방법보다 새로운 비밀번호로 설정하는 방법이 더 쉬워보였다.VisualSVN server를 통해 새로운 비밀번호를 설정할 수 있다.나는 svn서버를 관리하지않기때문에 서버관리자의 도움을 받아 비밀번호를 재설정했다. 이클립스 내 svn 계정 바꾸기이제 이클립스의 svn계정을 변경해보자 그럴려면 이클립스를 종료해야한다.파일탐색기를 통해 C:\\Users\\[컴터아이디]\\AppData\\Roaming\\Subversion\\auth\\svn.simple 로 이동한다.안의 파일들 중 svn주소가 일치하는 파일을 찾은 뒤 필요없는 username인 경우 해당 파일을 삭제한다.그리고 이클립스를 재접속하면 svn 로그인창이 열리고 새로 등록할 계정을 입력해주면 된다! 파일을 건드리지 않고 이클립스 설정에서 SNV 계정정보를 변경할 수도 있다. 해결!","link":"/2021/01/25/210125findSVNpw/"},{"title":"[오류일지]PatternSyntaxException 오류 해결","text":"문제상황파일 다운로드 클릭시 아래와 같은 콘솔에러가 발생했다. 12java.util.regex.PatternSyntaxException: Unexpected internal error near index 1\\ 해결순서파일을 업로드한 위치에 파일이 있는지 확인하기나는 아래의 파일에 다운로드 할 파일 원본이 있는지 확인해본다. 1D:\\\\workspace\\\\프로젝트명\\\\webapp\\\\upload FileController.java로 가서 해당 Mapping부분을 확인하기아래처럼 Mapping 부분을 체크해본다 12345678910111213@RequestMapping(value = \"/downloadn\", method = RequestMethod.GET)@AuthMappingpublic void downloadDo(){ if(savename != null &amp;&amp; !\"\".equals(savename)) { savename = savename.replaceAll(\"/\", \"\"); savename = savename.replaceAll(\"\\\\\", \"\"); } if(realname != null &amp;&amp; !\"\".equals(realname)) { realname = realname.replaceAll(\"/\", \"\"); realname = realname.replaceAll(\"\\\\\", \"\"); } //코드 생략} 이스케이프 문자 사용하기문자열을 다루는 메서드를 사용할 때는 \\를 주의해야한다.split이나 replace메서드의 인자로 들어가는 String 토큰이 regex 정규식이기 때문에 이스케이프 문자를 사용해야한다. \\이라면 \\\\로 사용해야한다.자세한 내용은 여기 split 메서드 사용시 실수하기 쉬운 것를 참고하자. 12345678910111213141516171819//수정전if(savename != null &amp;&amp; !\"\".equals(savename)) { savename = savename.replaceAll(\"/\", \"\"); savename = savename.replaceAll(\"\\\\\", \"\");}if(realname != null &amp;&amp; !\"\".equals(realname)) { realname = realname.replaceAll(\"/\", \"\"); realname = realname.replaceAll(\"\\\\\", \"\");}//수정후if(savename != null &amp;&amp; !\"\".equals(savename)) { savename = savename.replaceAll(\"/\", \"\"); savename = savename.replaceAll(\"\\\\\\\\\", \"\\\\\");}if(realname != null &amp;&amp; !\"\".equals(realname)) { realname = realname.replaceAll(\"/\", \"\"); realname = realname.replaceAll(\"\\\\\\\\\", \"\\\\\");} 파일 경로 자체의 문제위 방법으로 해결안된다면 파일 경로 자체의 문제일 수 있다.local.properties에서 file.base.path를 확인해본다.파일이 저장된 곳이랑 일치하는 지 확인한다.나의 경우 달랐기때문에 1번의 경로와 일치시켜주었다. 1file.base.path=D:\\\\workspace\\\\프로젝트명\\\\webapp\\\\upload 오류 해결!!문자열을 다루는 메서드를 사용할 때는 \\를 꼭 주의하자!","link":"/2021/01/25/210125fileDownloadError/"},{"title":"[오류일지]Error creating bean with name 에러 해결(이클립스, STS), lombok설치 후 오류","text":"Error creating bean with name “SiteMenuContentServiceImpl”프로젝트를 세팅하는 중에 Error creating bean with name &quot;SiteMenuContentServiceImpl&quot;에러를 만났다.ServiceImpl.java파일의 빈 생성이 왜 안될까? 원인 찾기 SiteMenuContentServiceImpl.java 파일로 이동한다.파일을 열어보니 lombok이 제대로 연결되어있지 않은채 빨간줄이 나타나있었다.나의 경우 lombok에러였고 대게 servlet-context.xml에 오류가 있는 경우 발생하는 에러이므로 servlet-context.xml에서 컴포넌트 추가를 통해 해결가능하다. STS도 이클립스기반이므로 전반적으로 해결 순서가 동일하다.하지만 설치과정에서 각각 다른 문제를 만났기에 나눠서 적어보려고한다. 이클립스 해결순서pom.xml에 lombok이 추가 되어 있는지 확인나의 경우 잘 추가되어있었다. 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.6&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; lombok.jar 설치 projectlombok 사이트에서 lombok을 다운로드해준 뒤 사용하는 IDE(이클립스, STS등등)경로를 지정하여 INSTALL을 해준다. 참고 링크 : 이미 다운로드 되어있는 lombok 위치 찾고 설치하는 방법 나의 경우 이미 다운로드 되어있었다.처음 다운로드 하는 경우에는 다운 후 롬북을 실행해야한다. eclipse.ini파일에 lombok을 추가해준다. eclipse.ini파일의 위치는 이클립스 설치한 폴더 안에 있다. 예시 : C:\\Users\\eclipse-jee-2020-06-R-win32-x86_64\\eclipse eclipse.ini에 아래 두 줄을 추가해준다 12-javaagent:lombok.jar-Xbootclasspath/a:lombok.jar IDE(이클립스, STS등)을 재시작한다. 다시 어노테이션 쓰기.4단계까지 했는데도 오류가 발생한다면 @Data, @Getter, @Setter등의 어노테이션을 지웠다가 다시 적어본다. STS 해결순서pom.xml에 lombok이 추가 되어 있는지 확인나의 경우 잘 추가되어있었다. 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.6&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; lombok.jar 설치 projectlombok 사이트에서 lombok을 다운로드해준 뒤 사용하는 IDE(이클립스, STS등등)경로를 지정하여 INSTALL을 해준다. 참고 링크 : 이미 다운로드 되어있는 lombok 위치 찾고 설치하는 방법 나의 경우 이미 다운로드 되어있었다. lombok.jar를 더블클릭했지만 실행이 되지않아 lombok이 프로젝트에 적용되지 않는 문제였다. lombok.jar 실행 안 될때 자바 설치 확인먼저 cmd에서 자바가 잘 설치되어있는지 확인한다. 1javac -version 자바가 없는 경우 JDK를 다운로드해야한다.나의 경우 1.8버전으로 잘 설치되어있었다. lombok.jar 더블클릭으로 실행더블클릭하면 바로 실행이 되어야하는데 되지를 않았다.jar 파일아이콘이 아닌 알집exe아이콘으로 표시되어있는 점이 수상했다.알집이나 반디집등의 환경설정에서 jar파일 체크를 해제해주면 된다.jar 파일 알집으로 실행되는 문제 해결 포스팅을그리고 더블클릭하니까 성공! lombok.jar cmd에서 실행cmd에서 명령어로 lombok.jar를 실행시키는 방법도 있다. 12//cmd 명령어java -jar lombok.jar SpringTools4.ini 또는 STS.ini 파일에 lombok을 추가해준다. 아래 두 줄을 추가해준다 12-javaagent:lombok.jar-Xbootclasspath/a:lombok.jar IDE(이클립스, STS등)을 재시작한다. 다시 어노테이션 쓰기.4단계까지 했는데도 오류가 발생한다면 @Data, @Getter, @Setter등의 어노테이션을 지웠다가 다시 적어본다.이렇게 나는 문제를 해결했다! lombok 설치 후에도 @Data가 적용안된다면?lombok을 설치하고 위에 ini파일에 추가를 해줘도 @Data가 적용되지 않는 문제가 발생했다.lombok 삭제했다가 재설치해보고 메이븐업데이트도 해보았지만 도무지 해결 될 기미가 안 보였다.혹시나 하는 마음에 파일명을 바꿔볼까하는 생각이 들었다. 기존 파일명 : SpringToolSuite4.exe, SpringToolSuite4.ini 바꾼 파일명 : sts.exe, sts.ini sts.ini 에다가 아래 코드도 잘 적어주고 STS를 재시작해보았다. 12-javaagent:lombok.jar-Xbootclasspath/a:lombok.jar 회색이었던 @Data가 파란색으로 정상 적용된 것을 확인할 수 있다!이제 Controller에서 get, set 메서드도 사용가능하다! 오늘도 해결!","link":"/2021/01/24/210125lombokerror/"},{"title":"[자바JAVA]190. Reverse Bits","text":"문제 190. Reverse Bits주어진 32비트 unsigned integer를 역순으로 만들어 리턴하는 문제이다.Reverse bits of a given 32 bits unsigned integer. Note:Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825. 입출력예시 123456789//예시1Input: n = 00000010100101000001111010011100Output: 964176192 (00111001011110000010100101000000)Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.//예시2Input: n = 11111111111111111111111111111101Output: 3221225471 (10111111111111111111111111111111)Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. 제약조건 : 길이32의 이진수만 입력값으로 가능하다. The input must be a binary string of length 32 unsigned integer란?자바에는 unsigned integer가 없다. 생소하기때문에 개념을 찾아보았다.unsigned와 signed integer가 있다. 여기서 sign은 부호를 뜻한다.int의 범위는 –2,147,483,648 ~ 2,147,483,647이다.unsigned integer는 음수를 가질 수 없다. 양수인 부분 즉, 0 ~ 2,147,483,647만을 unsigned integer라고 한다.단어가 생소해서 그렇지 그리 어려운 개념은 아니다. int and unsigned int are two distinct integer types. (int can also be referred to as signed int, or just signed; unsigned int can also be referred to as unsigned.)As the names imply, int is a signed integer type, and unsigned int is an unsigned integer type. That means that int is able to represent negative values, and unsigned int can represent only non-negative values.출처 : https://stackoverflow.com/questions/5739888/what-is-the-difference-between-signed-and-unsigned-int 비트 AND 와 SHIFT 연산자예를들어 00110이 있다면 11001을, 11100이면 00111을 리턴해줘야한다.비트가 나왔으니 비트연산자를 떠올려보자. 비트 AND 연산자 : 비트연산자 &amp;를 사용하면 같은 값이면 해당 값을 반환하고 다른 값이면 0을 반환환다. 비트 SHIFT 연산자 : &lt;&lt;n n만큼 왼쪽으로 이동한다. 이동하고 빈곳에는 0을 넣는다. 위 둘을 이용해 한 비트씩 계산할 수 있다. 비트 OR 연산자 : 두 비트가 모두 0일때만 0을 반환한다. 제일 오른쪽의 비트부터 AND연산시 0보다 숫자가 클 경우 OR연산자를 이용해 역으로 출력해준다. 코드123456789101112131415public class Solution { // you need treat n as an unsigned value public int reverseBits(int n) { int ans = 0; // 32비트 제약 for(int i=0; i&lt;32; i++){ ans = ans &lt;&lt;1; if((n &amp; 1) &gt;0){ ans = ans | 1; } n = n &gt;&gt;1; } return ans; }} 다른 문제 풀이가 보고싶다면? 모든 릿코드(LeetCode)(leetcode) java 풀이 참고 https://dojang.io/mod/page/view.php?id=174","link":"/2021/01/21/210122al-l0190/"},{"title":"JSP 페이지 등록일순 역순출력","text":"프로그래머는 매 순간 버그와의 싸움이다.한 번에 문제 원인을 찾고 해결하면 정말 좋겠지만 아직 나는 많이 부족하다.그렇게 될 수 있도록 문제상황에 어떻게 원인을 찾고 해결을 했는지 기록하고자 한다.기억보다 기록은 힘이 세다고 믿으니까. 문제상황리스트를 idx순으로 출력하는데 순번이상했다. 원인쿼리 먼저 돌려보면서 SELECT되는 데이터를 체크해보았다.DB를 테스트 한 뒤 테스트데이터를 삭제해야하는데 그 위에 타DB의 데이터를 이관하면서 DB의 INDEX순서와 게시글 등록순서가 아래 예시처럼 일치하지 않았다. 예시 idx reg_date 1 2021-01-20 2 2021-01-25 3 2020-12-10 4 2021-01-23 기존 코드 Mapper.xml 코드 12345678910111213&lt;select id=\"List\" parameterType=\"model\" resultType=\"model\" &gt; &lt;include refid=\"pagingStart\"/&gt; &lt;![CDATA[ SELECT ROW_NUMBER() OVER (ORDER BY IDX DESC) rn , IDX, NAME, REGDATE, CONTENT FROM 테이블명 ]]&gt; &lt;include refid=\"withSearchWhere\"/&gt; ORDER BY IDX DESC &lt;include refid=\"pagingEnd\"/&gt;&lt;/select&gt; view.jsp코드 1234567&lt;c:forEach var=\"result\" items=\"${pageInfo.data}\" varStatus=\"i\"&gt; &lt;tr&gt; &lt;td&gt;${result.idx}&lt;/td&gt; &lt;td&gt;${result.name}&lt;/td&gt; &lt;td&gt;&lt;c:if test=\"${not empty result.content}\"&gt;${result.content}&lt;/c:if&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; DB에서 순번을 가져오지말고 뷰단에서 직접 게시글을 카운팅해주는 것으로 해결 방향을 잡았다.${pageInfo.data} 가 어떤 데이터를 들고 오는 지 먼저 확인한 후 필요한 변수들을 체크했다.totalCount, pageIndex, pageSize를 사용할 수 있을 것 같아 가져왔다. 또한 DB데이터들 중 index 순서 대신 다른 정렬기준을 찾아야헸고 나는 REG_DATE를 선택했다. 수정한 코드 Mapper.xml 코드 12345678910111213&lt;select id=\"List\" parameterType=\"model\" resultType=\"model\" &gt; &lt;include refid=\"pagingStart\"/&gt; &lt;![CDATA[ SELECT ROW_NUMBER() OVER (ORDER BY IDX DESC) rn , IDX, NAME, REGDATE, CONTENT FROM 테이블명 ]]&gt; &lt;include refid=\"withSearchWhere\"/&gt; ORDER BY REGDATE DESC &lt;include refid=\"pagingEnd\"/&gt;&lt;/select&gt; view.jsp코드 총 게시글이 14개가 있고 한 페이지당 10개씩 보여준다고 설정했다고 하자.그렇다면 총 2페이지가 될 것이다.첫번째페이지에서는 14부터 5까지 출력되고 두번째페이지에서는 4부터 1까지 번호가 출력되어야한다.핵심은 2번째페이지이다. 두번째 페이지 번호가 4부터 출력되어야한다.총 14개 중에서 pageSize인 10을 빼야 4가 출력된다.이를 식으로 나타내면 (PageIndex - 1)*pageSize이다. 1234567891011121314151617&lt;c:set value=\"${pageInfo.totalCount}\" var=\"totalCountj_JO\" /&gt;&lt;c:set value=\"${pageInfo.pageIndex}\" var=\"PageIndex_JO\" /&gt;&lt;c:set value=\"${pageInfo.pageSize}\" var=\"pageSize_JO\" /&gt;&lt;% int cntJO = (int)pageContext.getAttribute(\"totalCountj_JO\");int PageIndex_JO = (int)pageContext.getAttribute(\"PageIndex_JO\");int pageSize_JO = (int)pageContext.getAttribute(\"pageSize_JO\");cntJO = cntJO - ((PageIndex_JO - 1)*pageSize_JO);%&gt; &lt;c:forEach var=\"result\" items=\"${pageInfo.data}\" varStatus=\"i\"&gt; &lt;tr&gt; &lt;td class=\"tit\"&gt;&lt;%=cntJO %&gt;&lt;/td&gt; &lt;% cntJO = cntJO - 1 ; %&gt; &lt;/tr&gt;&lt;/c:forEach&gt; EL과 JSTL, 스크립틀릿을 왔다갔다하면서 컨트롤러에서 처리한 데이터를 받을 때 익숙하지 않아서 많이 해맸다.처음에는 for문을 사용하려고 했으나 forEach문이 이미 있기에 코드가 복잡해졌다.더 좋은 코드가 있을 것 같은데 시간도 부족해서 cntJO = cntJO - 1;처럼 직관적으로 처리했다.코드 리팩토링을 생각해봐야겠다. 또 다른 문제 발생위에서 수정한 코드는 로그인 세션이 있을때는 정상출력되었지만 로그인 세션이 없는 경우 404페이지가 발생했다.DB에 바로 갈 수 없도록 해야했다.그래서 int cntJO = 0으로 초기화 먼저 한 후 if문 안에서 DB에서 데이터를 가져오는 변수를 생성했다. view.jsp코드 123456789&lt;% int cntJO = 0;if(request.getAttribute(\"conText\") != null){ cntJO = (int)pageContext.getAttribute(\"totalCountj_JO\"); int PageIndex_JO = (int)pageContext.getAttribute(\"PageIndex_JO\"); int pageSize_JO = (int)pageContext.getAttribute(\"pageSize_JO\"); cntJO = cntJO - ((PageIndex_JO - 1)*pageSize_JO); }%&gt; TA-DA 문제해결!","link":"/2021/01/28/210129PaginationInReverseOrder/"},{"title":"request.getParameter()시 null이 뜰때 해결방법, ModelAndView 넘겨받는 방법","text":"문제상황pdf.jsDB에서 param으로 page정보를 받아서 PDF파일의 특정 페이지로 바로 출력하고싶었다.request객체를 시도했는데 계속 null을 가져왔다.왜 실패했을까? 공통코드 Controller.java 코드 12345678@RequestMapping(value = \"/content/{path}\", method = {RequestMethod.GET, RequestMethod.POST}) public ModelAndView homeMain(HttpServletRequest request, HttpServletResponse response, @PathVariable String path) { ModelAndView model = new ModelAndView(); SiteMenuContent siteMenuContent = siteMenuContentService.getSiteMenuContent(path); model.addObject(\"siteMenuContent\", siteMenuContent); model.setViewName(\"/html\"); return model;} 입력값DB의 param컬럼에는 page=4가 들어있다. 1&lt;input id=\"param\" name=\"param\" value=\"\"&gt; 시도1 : request.getParameter() 사용request.getParameter() 를 사용했지만 null값이 나타났다.왜일까? 아직도 답을 모르겠다. 1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;%String pageParam = \"2\";if(request.getParameter(\"param\") != null){ pageParam = request.getParameter(\"param\");}%&gt;&lt;div class=\"pdf-box\"&gt; &lt;iframe id=\"docIframe\" src=\"/resources/js/jquery/pdfjs-dist/web/viewer.html?file=/upload/down/파일명.pdf#page=&lt;%=pageParam %&gt;\" width=\"100%\" height=\"860\"&gt;&lt;/iframe&gt;&lt;/div&gt; 헤결방법1 : request.getAttribute() 이용request.getParameter() 대신 request.getAttribute()를 사용했다.컨트롤러에서 request.setAttribute()을 하지 않으면 null값이 출력되기때문에 컨트롤러에서 set해줘야한다.하지만 컨트롤러의 소스코드를 바꾸고 싶지 않았으므로 이 방법을 사용하지않았다. Controller.java 코드 123456789101112@RequestMapping(value = \"/content/{path}\", method = {RequestMethod.GET, RequestMethod.POST}) public ModelAndView homeMain(HttpServletRequest request, HttpServletResponse response, @PathVariable String path) { ModelAndView model = new ModelAndView(); SiteMenuContent siteMenuContent = siteMenuContentService.getSiteMenuContent(path); model.addObject(\"siteMenuContent\", siteMenuContent); model.setViewName(\"/html\"); //set해준다. request.setAttribute(\"paramAttri\", siteMenuContent.getParam()); return model;} jsp코드 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;%String pageParam = \"2\";String paramFormC = (String) request.getAttribute(\"paramAttri\");if(paramFormC != null){ pageParam = paramFormC.split(\"=\")[1];}%&gt;&lt;div class=\"pdf-box\"&gt; &lt;iframe id=\"docIframe\" src=\"/resources/js/jquery/pdfjs-dist/web/viewer.html?file=/upload/down/파일명.pdf#page=&lt;%=pageParam %&gt;\" width=\"100%\" height=\"860\"&gt;&lt;/iframe&gt;&lt;/div&gt; getParameter()와 getAttribute()의 차이점 getParameter() getAttribute() 가져오는 값 웹브라우저에서 전송받은 request영역 setAttribute() 리턴타입 String Object 참고 : JSP - getParameter()와 getAttribute()의 차이점 시도2 : el태그 ${} 이용el태그를 사용할 경우 console에는 정상출력되지만 iframe안에서는 정상 출력이 되지않는다.왜일까…? 1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;div class=\"pdf-box\"&gt; &lt;iframe id=\"docIframe\" src=\"/resources/js/jquery/pdfjs-dist/web/viewer.html?file=/upload/down/파일명.pdf#page=${siteMenuContent.param }\" width=\"100%\" height=\"860\"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var $param = ${siteMenuContent.param }console.log($param )&lt;/script&gt; 해결방법2 : pageContext.getAttribute(); 이용따라서 jstl로 el태그를 스크립틀릿안으로 pageContext를 이용하여 불러왔다. 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;c:set value=\"${siteMenuContent.param }\" var=\"paramFormC\" /&gt;&lt;%String pageParam = \"2\";String paramFormC = (String) pageContext.getAttribute(\"paramFormC\");if(paramFormC != null){ pageParam = paramFormC.split(\"=\")[1];}%&gt;&lt;div class=\"pdf-box\"&gt; &lt;iframe id=\"docIframe\" src=\"/resources/js/jquery/pdfjs-dist/web/viewer.html?file=/upload/down/파일명.pdf#page=&lt;%=pageParam %&gt;\" width=\"100%\" height=\"860\"&gt;&lt;/iframe&gt;&lt;/div&gt; 성공!! 참고 https://stackoverflow.com/questions/19183747/modelandview-addobject-vs-model-addattribute","link":"/2021/01/29/210129pageContextNrequest/"},{"title":"페이스북 영구 토큰 발급하기","text":"[SNS연결하기] FACEBOOK 페이지의 게시글을 웹사이트에 불러오는 방법!구글링을 정말 많이 했으나 하나같이 제대로 적용되지않았다.결국 글에서 찾는 건 포기하고 stackoverflow의 댓글 하나하나를 읽으며 테스트했고 끝내 성공했다.댓글의 중요성을 배웠다. 앞으로는 이걸로 삽질하진 않겠지!!많은 분들이 나처럼 헤매지않았으면 좋겠다는 마음에서 기록을 남겨본다. FB 앱만들기 페이스북 디벨로퍼 https://developers.facebook.com/ 에 페이스북 아이디로 로그인하기 오른쪽 상단의 내 앱 탭 클릭하기 앱 만들기 버튼 클릭 → 비즈니스 통합관리하기 표시할 앱 이름 : 원하는 이름 기재 ex)testPermanentToken 앱 목적 : 회원님 또는 소유한 비즈니스 비즈니스 관리자계정 : 연결해도되고 안해도 됨 보안확인 : 로봇이 아닙니다 체크 후 제출 클릭 단기 토큰 생성하기 최상단 메뉴바의 도구 탭 클릭 → 그래프 API 탐색기 클릭 Facebook 앱 : 위에서 내가 만든 앱이름 클릭 사용자 또는 페이지 : 페이지 엑세스로 토큰받기 선택 토큰받기 클릭 페이지 액세스 토큰 받기 클릭 팝업창 Facebook으로 로그인 팝업창 활성화. 팝업창에서 000(페이스북 명의)으로 계속 클릭 연결을 원하는 페이지 선택 로그인한 페이스북 아이디로 운영중이 페이지가 있어야한다. 본 포스팅에서는 ipsi라는 테스트페이지를 만들어서 연결했다. 어떤 권한이 허용되었나요? : 관리 중인 페이지 리스트를 표시 : 예 페이지에 게시된 콘텐츠 읽기 : 예 Facebook에 앱이 연결되었습니다 → 확인 클릭 → 팝업 자동으로 닫힘 페이지용 액세스 토큰이 자동으로 생성 단기토큰을 장기토큰으로 만들기토큰을 발급하면 기본적으로 1시간짜리 단기 토큰이 발행된다.이를 60일짜리 장기토큰으로 만든 후 영구토큰으로 만들 수 있다. 엑세스 토큰 자동으로 생성완료 후 엑세스 토큰 도구열기 ! (1번) 클릭 엑세스 토큰 도구에서 열기 클릭 엑세스 토큰 디버거로 자동으로 이동 유형 : page 맞는 지 확인하기 만료일 : (약 1시간 이내) =&gt; 단기 토큰을 의미함. 액세스토큰 확장 버튼 클릭(1번) → 페이스북 비밀번호 입력 팝업창에 비밀번호 입력 페이지가 새로고침 되면서 장기토큰이 발행됨. 1번은 새로 발행된 장기 액세스 토큰임 디버그 버튼 클릭(2번) 새창에서 액세스 토큰 디버거가 열림 유형 : page 맞는 지 확인하기 만료일 : (약 2개월 이내) =&gt; 장기 토큰을 의미함. 1번 장기토큰을 메모장등에 복사해두기 2번 페이지 ID를 메모장등에 복사해두기 장기토큰을 영구토큰으로 만들기60일짜리 장기토큰을 영구 토큰으로 변경해보자.이 부분에서 엄청난 삽질을 했다…나의 삽질을 구원해준 건 stackoverflow의 댓글들이었다. 최상단 메뉴바의 내 앱 탭 클릭 → 도구 클릭 → 그래프 API 탐색기 클릭 액세스 토큰 토큰 : 기록해둔 장기 토큰을 1번에 붙여넣기 Facebook앱이 맞는지 확인한다. 내 앱이 여러 개인 경우 다른 앱이 선택되어있기도 함. 복사해둔_페이지아이디?fields=access_token를 기입한다. 제출 클릭 access_token의 값을 복사한다. =&gt; 이것이 영구토큰이다. 이렇게 쉽게????! 이 방법에 오기까지 며칠을 헤맸왔던가…진짜 영구 토큰이 맞을까? 의심-엑세스 토큰 디버거에서 확인해보자!5번의 영구토큰을 복사한 뒤 액세스 토큰 디버거로 이동한다.만료일에 날짜가 아닌 받지 않기가 있는 것을 확인해볼 수 있다! 성공! 참고 https://mixedanalytics.com/knowledge-base/import-facebook-page-data-to-google-sheets/ https://stackoverflow.com/questions/17197970/facebook-permanent-page-access-token","link":"/2021/01/31/210201facebookPermanentToken/"},{"title":"유튜브 맞춤동영상&#x2F;추천영상&#x2F;관련동영상 안뜨게 하기(ft. youtube API 사용법)","text":"웹 사이트에 iframe으로 유튜브 동영상을 연결을 하면 영상 재생이 끝나면 관련 동영상이 뜬다.유튜브API를 통해서 관련 동영상 사용 중지할 수 없지만 우회방법이 두 가지 있다. 반복재생을 통해서 관련 동영상 나올 틈을 주지 않는 방법 rel속성 설정으로 재생된 채널에서 관련 동영상을 가지고 오는 방법 아래 예시를 통해 유튜브 API의 다른 매개변수 사용방법도 익힐 수 있다. 유튜브 소스코드 복사하기연결을 원하는 유튜브 동영상에서 우클릭을 하여 소스 코드 복사를 클릭한다.아래처럼 기본 값이 복사된다. 1&lt;iframe width=\"1065\" height=\"599\" src=\"https://www.youtube.com/embed/영상코드\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt; 반복재생하는 방법src 뒤에 VIDEO_ID?version=3&amp;loop=1&amp;playlist=VIDEO_ID 속성을 이용하면 된다.loop 기본값은 0이고 1로 설정할 경우 반복재생된다.VIDEO_ID는 물음표앞의 VIDEO_ID와 동일하게 설정해주면 해당 동영상만 반복재생된다. 1&lt;iframe width=\"1065\" height=\"599\" src=\"https://www.youtube.com/embed/영상코드?version=3&amp;loop=1&amp;playlist=VIDEO_ID\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt; rel 매개변수로 동일 채널의 다른 동영상만 보여주는 방법src뒤에 VIDEO_ID?rel=1속성을 넣어주면 된다.이 방법은 사용자가 다른 채널로 유출되는 것을 방지한다. 1&lt;iframe width=\"1065\" height=\"599\" src=\"https://www.youtube.com/embed/영상코드?rel=1\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt; 참고 https://rubybox.tistory.com/25 https://developers.google.com/youtube/player_parameters?hl=ko","link":"/2021/01/31/210201youtubeAPI/"},{"title":"[자바JAVA]Picking Numbers 해커랭크","text":"Picking Numberslist의 모든 요소들의 절대편차(absolute difference) &lt;= 1 인 가장 긴 list의 길이를 출력하는 문제이다Given an array of integers, find the longest subarray where the absolute difference between any two elements is less than or equal to 1. 입출력예시1 12345//입력4 6 5 3 3 1//출력3 입출력예시2 12345//입력1 2 2 3 1 2//출력5 풀이문제의 조건에서 0 &lt; a[i] &lt; 100이므로 maxIndex는 100이다.0부터 99까지의 숫자배열 temp를 만든 뒤 a의 요소값과 동일한 temp인덱스에 1씩 카운트를 증가시킨다.예를 들어, a=[1,1,2,2,4,4,5,5,5]인 경우 temp[0]=0, temp[1]=2, temp[2]=2, temp[3]=0, temp[4]=2, temp[5]=3, temp[6]=0, temp[7]=0, … , temp[99]=0이다. temp[i]와 temp[i+1]의 합은 항상 절대편차가 &lt;= 1이다. 따라서 배열 전체를 반복문으로 돌려서 두 요소의 합의 최대값을 리턴하면 되는 문제이다.예를 들어, 0번1번 인덱스를 더하면 2가 되고, 1번2번 인덱스를 더하면 4, 2번3번인덱스의 합은 2, 3번4번 인덱스를 더하면 2, 4번5번 인덱스 합은 5, 5번6번 인덱스합은 3, 6번7번 인덱스합은 0, 7번8번인덱스합은 0, …, 98번99번 인덱스합은 0 처럼 바로 옆 인덱스의 값을 합해서 99까지 반복한다. 12345678910111213141516171819202122232425262728public class PickingNumbers { public static int pickingNumbers(List&lt;Integer&gt; a) { // 문제의 조건에서 0&lt; a[i] &lt;100이므로 maxIndex는 100이다. int maxIndex = 100; int[] temp = new int[maxIndex]; //0부터 99까지의 숫자배열에 a의 요소와 동일한 숫자가 있으면 1씩 카운트룰 증가시킨다. //예를 들어 a = [1,2,1]인경우 temp[1]=2이고 temp[2]=1이다. for (int number : a) { temp[number]++; } int result = 0; for (int i = 0; i &lt; maxIndex - 1; i++) { result = Math.max(result, temp[i] + temp[i + 1]); } return result; } public static void main(String[] args) { System.out.println(pickingNumbers(new ArrayList&lt;&gt;(Arrays.asList(1, 1, 2, 2, 4, 4, 5, 5, 5)))+\", ans: 5\"); System.out.println(pickingNumbers(new ArrayList&lt;&gt;(Arrays.asList(4, 6, 5, 3, 3, 1)))+\", ans: 3\"); System.out.println(pickingNumbers(new ArrayList&lt;&gt;(Arrays.asList(1, 2, 2, 3, 1, 2)))+\", ans: 5\"); System.out.println(pickingNumbers(Arrays.asList(98, 3, 99, 1, 97, 2)) == 2); System.out.println(pickingNumbers(Arrays.asList(1, 1, 1)) == 3); }} 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음","link":"/2021/02/17/210217al-hackerrank-Picking-Numbers/"},{"title":"[자바JAVA]Sherlock and Squares 해커랭크","text":"Sherlock and Squares주어진 수의 범위 안의 제곱근(square integer)의 갯수를 구하는 문제이다.Watson likes to challenge Sherlock’s math ability. He will provide a starting and ending value that describe a range of integers, inclusive of the endpoints. Sherlock must determine the number of square integers within that range.Note: A square integer is an integer which is the square of an integer, e.g. 1,4,9.16,25 입출력예시1 12345//입력3 9//출력2 입출력예시2 12345//입력17 24//출력0 풀이1234567891011121314151617181920212223public class SherlockandSquares { static int squares(int a, int b) { //sol1 int start = (int) Math.sqrt(a); int end = (int) Math.sqrt(b); start = (Math.pow(start, 2) &gt;= a) ? start-1 : start; return end - start; } public static void main(String[] args) { System.out.println(squares(24, 49) + \", ans: 3\"); System.out.println(squares(3, 9) + \", ans: 2\"); System.out.println(squares(17, 24) + \", ans: 0\"); System.out.println(squares(100, 1000) + \", ans: 22\"); System.out.println(squares(9, 16) + \", ans: 2\"); System.out.println(squares(11, 734) + \", ans: 24\"); System.out.println(squares(228, 919) + \", ans: 15\"); System.out.println(squares(71, 188) + \", ans: 5\"); //9 10 11 12 13 System.out.println(squares(4, 4) + \", ans: 1\"); }} 한 줄 풀이Math 적절히 사용하면 한 줄 코드로 문제 해결아 가능하다. 12345678910111213141516public class SherlockandSquares { static int squares(int a, int b) { //sol2. one line code return (int) Math.floor(Math.sqrt(b)) - (int) Math.ceil(Math.sqrt(a)) + 1; } public static void main(String[] args) { System.out.println(squares(24, 49) + \", ans: 3\"); System.out.println(squares(3, 9) + \", ans: 2\"); System.out.println(squares(17, 24) + \", ans: 0\"); System.out.println(squares(100, 1000) + \", ans: 22\"); System.out.println(squares(9, 16) + \", ans: 2\"); System.out.println(squares(11, 734) + \", ans: 24\"); }} 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음","link":"/2021/02/18/210218al-hakkerrank-Sherlock-and-Squares/"},{"title":"[자바JAVA]Between Two Sets 해커랭크","text":"Between Two Sets배열a와 배열b가 주어지고 a요소가 약수이면서 b요소가 배수인 숫자 X가 몇 개인 지 찾는 문제이다. There will be two arrays of integers. Determine all integers that satisfy the following two conditions: The elements of the first array are all factors of the integer being considered The integer being considered is a factor of all elements of the second array These numbers are referred to as being between the two arrays. Determine how many such numbers exist. 입출력예시1 123456//입력a = [2, 6]b = [24, 36]//출력2 입출력예시2 123456//입력a = [2, 4]b = [16, 32, 96]//출력3 풀이 int flag; : a의 요소가 current의 약수가 아니거나 b의 요소가 current의 배수가 아닌 경우 flag 1 대입 후 break -&gt; current를 1 더해준 뒤 다시 while문 반복 실행한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class BetweenTwoSets { public static int getTotalX(List&lt;Integer&gt; a, List&lt;Integer&gt; b) { int cnt = 0; int current = a.get(a.size() - 1); int flag; while (current &lt;= b.get(0)) { flag = 0; //a 요소가 current의 약수면 flag=0 유지 for (int i : a) { if (current % i != 0) { flag = 1; break; } } //b 요소가 current의 배수면 flag=0 유지 if (flag == 0) { for (int i : b) { if (i % current != 0) { flag = 1; break; } } } //위의 두 for문이 참이면 cnt 1씩 증가 if (flag == 0) { cnt++; } System.out.printf(\"cnt: %d, current: %d, flag: %d%n\", cnt, current, flag); current++; } return cnt; } //테스트케이스 public static void main(String[] args) { //test case 1 System.out.println(getTotalX( new ArrayList&lt;&gt;(Arrays.asList(2, 6)), new ArrayList&lt;&gt;(Arrays.asList(24, 36))) + \", ans: 2\"); //test case 2 System.out.println(getTotalX( new ArrayList&lt;&gt;(Arrays.asList(2, 4)), new ArrayList&lt;&gt;(Arrays.asList(16, 32, 96))) + \", ans: 3\"); }} test case 1번의 콘솔이 문제는 배열a와 배열b가 주어지고 a요소가 약수이면서 b요소가 배수인 숫자 X가 몇 개인 지 찾는 문제이다.flag가 0일때의 current값이 내가 찾던 x의 값이다.x는 6, 12 총 2개이다. 따라서 2를 리턴한다. 123456789101112131415161718192021//test case 1번의 콘솔cnt: 1, current: 6, flag: 0cnt: 1, current: 7, flag: 1cnt: 1, current: 8, flag: 1cnt: 1, current: 9, flag: 1cnt: 1, current: 10, flag: 1cnt: 1, current: 11, flag: 1cnt: 2, current: 12, flag: 0cnt: 2, current: 13, flag: 1cnt: 2, current: 14, flag: 1cnt: 2, current: 15, flag: 1cnt: 2, current: 16, flag: 1cnt: 2, current: 17, flag: 1cnt: 2, current: 18, flag: 1cnt: 2, current: 19, flag: 1cnt: 2, current: 20, flag: 1cnt: 2, current: 21, flag: 1cnt: 2, current: 22, flag: 1cnt: 2, current: 23, flag: 1cnt: 2, current: 24, flag: 12, ans: 2 test case 2번의 콘솔위의 설명과 동일하게 flag가 0일때의 current값이 내가 찾던 x의 값이다.x는 4, 8, 16으로 총 3개이다. 따라서 3를 리턴한다. 123456789101112131415//test case 2번의 콘솔cnt: 1, current: 4, flag: 0cnt: 1, current: 5, flag: 1cnt: 1, current: 6, flag: 1cnt: 1, current: 7, flag: 1cnt: 2, current: 8, flag: 0cnt: 2, current: 9, flag: 1cnt: 2, current: 10, flag: 1cnt: 2, current: 11, flag: 1cnt: 2, current: 12, flag: 1cnt: 2, current: 13, flag: 1cnt: 2, current: 14, flag: 1cnt: 2, current: 15, flag: 1cnt: 3, current: 16, flag: 03, ans: 3 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음 참고 https://www.youtube.com/watch?v=gtvE0vxuvy8","link":"/2021/02/14/210214al-hackerrank-between-two-sets/"},{"title":"SVN lock 해제하기, commit시 already lock 충돌 해결하기","text":"문제상황commit을 치는데 계속 svn 충돌문제가 발생했다. console을 확인해보니 already lock이라는 에러메세지가 보였다. 이로 인해 commit도 update도 되지 않았다.문제 발생 원인을 생각해보니 최근 소스파일을 수정하고 commit 명령어를 날렸는데 그 사이 svn서버가 재시작하게된 일이있었다.이때문에 commit은 svn서버에 정상반영되었으나 내 로컬에는 해당 commit이 반영되지않는 이상한 일있었다. svn의 모든 기능이 잠겨버리는 바람에 해결해야만했다.해결하고보니 간단한 문제였다. 미리 겁먹지말자! SVN official doc에는 Harry and Sally의 예시를 통해 어떤 경우에 LOCK이 발생하는 지 설명해놓았다.다양한 상황에 따라 LOCK발생하지만 딱 한마디로 요약해보자면 clashing commits(커밋충돌)을 방지하기 위해서이다. 해결방법 sqlite browser사이트에서 DB Browser for SQLite를 자신의 상황에 맞게 다운로드한다.나는 윈도우 64비트를 사용중이므로 가장 최신 버전중에 설치가 필요없는 파일을 다운로드했다. DB Browser for SQLite.exe 실행설치된 파일안의 DB Browser for SQLite.exe 파일을 실행한다. 데이터베이스 열기를 클릭 사용중인 프로젝트안의 wc.db 파일 열기나의 경우 D:\\workspace\\프로젝트명.svn 안의 wc.db 파일을 열었다. SQL실행 탭에서 unlock명령어 실행lock이 생성된 경우 데이터보기 탭에서 WC_LOCK 테이블과 WORK_QUEUE테이블에 데이터가 존재하는 것을 확인할 수 있다.svn에 이상이 없는경우 두 테이블에 데이터가 존재하지 않는다.두 테이블에 데이터가 존재하는 경우 SQL실행탭을 클릭하여 아래와 같이 명령어를 실행한다. 12DELETE FROM WC_LOCKDELETE FROM WORK_QUEUE; 이제 이클립스로 돌아가서 commit이나 update를 하면 svn이 정상적으로 작동된다.해결!","link":"/2021/02/23/210224svn-unlock/"},{"title":"[자바JAVA]문자열 내 p와 y의 개수 프로그래머스","text":"문자열 내 p와 y의 개수대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다.예를 들어 s가 “pPoooyY”면 true를 return하고 “Pyy”라면 false를 return합니다. 제한사항문자열 s의 길이 : 50 이하의 자연수문자열 s는 알파벳으로만 이루어져 있습니다. 입출력 예시1 12345//입력pPoooyY//출력true 입출력 예시2 12345//입력Pyy//출력false 코드1제일 처음 생각했던 방법이다. 12345678910111213141516static boolean solution(String s) {//sol1. score 1004, 평균 통과 (0.02ms, 51.8MB)int cntP = 0;int cntY = 0;for(char c : s.toCharArray()){ if(c == 'p' || c =='P'){ cntP ++; } if(c == 'y' || c == 'Y'){ cntY ++; }}return cntP == cntY;} 코드2int cnt를 하나로 가져가면서 toUpperCase 사용하는 방법이다.평균 통과 (0.04ms, 53.9MB) 12345678910111213static boolean solution(String s) {int cnt = 0; for(char c : s.toUpperCase().toCharArray()){ if(c == 'P'){ cnt ++; } if(c == 'Y'){ cnt --; } } return cnt == 0 ? true : false;} 코드3 : 람다식 사용평균 통과 (3.37ms, 53.3MB) 1234static boolean solution(String s) { s = s.toUpperCase(); return s.chars().filter( e -&gt; 'P'== e).count() == s.chars().filter( e -&gt; 'Y'== e).count();}","link":"/2021/02/27/210228al-programmers-The-Number-of-pandy-in-String/"},{"title":"[특강후기]JS로 디스코드 봇만들기","text":"좋은 기회로 디스코드 챗봇을 만드는 온라인 특강을 듣게되었다.정말 재미있었다! 순서vs code에 npm 설치하기 npm install: npm을 설치한다. npm run dev: 설치한 npm을 실행한다. 디스코드 디벨로퍼에서 챗봇등록하기 new appication 클릭 add bot 클릭 후 yes do it 후 토큰을 복사 토큰을 통해서 채팅을 CR할 수 있기때문에 실제 서버에 배포한다면 토큰은 절대 공개되서는 안된다. vs code의 터미널에서 config.json에 복사한 토큰을 붙여넣는다. 디스코드 디벨로퍼 포털에서 생성한 채널을 클릭한 뒤 General Information에서 CLIENT ID 토큰 복사 디스코드 permissions calculator에서 권한주기 add 클릭 → 승인 디스코드에서 채널이 생성된 것을 확인하기 vs code에서 코딩하기!투표를 이용해서 제목과 투표지를 띄어쓰기로 입력하면 해당 입력값으로 투표하기를 생성해주는 챗봇을 만들어보자. 123456789101112131415161718192021222324export default async function vote(message, args) { const voteEmojis = [\"1️⃣\", \"2️⃣\", \"3️⃣\", \"4️⃣\", \"5️⃣\"]; const question = args.shift(); if (args.length &lt; 1 || args.length &gt; 5) { message.reply(\"One to five options are required. 선택 항목은 1-5개만 지원합니다.\"); } const embed = new MessageEmbed(); let description = \"\"; args.forEach((arg, i) =&gt; { description += `${voteEmojis[i]}: ${arg}\\n`; }); embed.setTitle(\"🗳 \" + question); embed.setDescription(description); const vote = await message.reply(\"Vote\", { embed: embed }); args.forEach(async (arg, i) =&gt; { await vote.react(voteEmojis[i]); });} 전체 소스코드 웹소캣 vs HTTPHTTP의 경우 클라이언트의 요청이 없으면 서버는 먼저 말을 걸 수 없다.웹소켓은 서버가 클라이언트에게 먼저 말(메세지)을 걸수있다. 서버 확인하는 사이트서버가 정상적인지 확인하는 사이트 : https://isitup.org/","link":"/2021/03/25/210226JS-discordchatbot/"},{"title":"[자바JAVA]Separate the Numbers 해커랭크","text":"Separate the Numbers아래 제약사항을 충족하면 YES와 가장 작은 숫자를 리턴, 충족하지않으면 NO를 리턴한다. 다음요소는 이전요소보다 항상 1이 더 커야한다. 요소는 0로 시작해서는 안 된다. s안의 시퀀스를 재배열할 수 없다. A numeric string, s, is beautiful if it can be split into a sequence of two or more positive integers, a[1], a[2], …, a[n], satisfying the following conditions: each element in the sequence is 1 more than the previous element. No a[i] contains a leading zero. The contents of the sequence cannot be rearranged. 입출력예시1 1234567891011121314151617//입력12349101199100101103010203131//출력YES 1YES 9YES 99NONONONO 입출력예시2 1234567891011//입력9991000100178910119899100999100010001//출력YES 999YES 7YES 98NO 풀이1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SeparatetheNumbers { static void separateNumbers(String s) { String subStr = \"\"; boolean isVaild = false; //subString을 0부터 시작하니까 i는 1부터 시작하고 s 길이의 반을 넘을 수 없다. for (int i = 1; i &lt;= s.length() / 2; i++) { subStr = s.substring(0, i); Long num = Long.parseLong(subStr); //0부터 i까지 자른 String을 vaildStr변수에 담고 vaildStr를 1씩증가시킨값을 누적합한다. String vaildStr = subStr; while (vaildStr.length() &lt; s.length()) { vaildStr += Long.toString(++num); } //누적합한 vaildStr과 s를 비교하여 일치하면 isVaild= true바꿔주고 // 가장 작은 숫자를 리턴해야하기때문에 for문을 바로 종료한다. if (s.equals(vaildStr)) { isVaild = true; break; } } System.out.println(isVaild ? \"YES \" + subStr : \"NO\"); } public static void main(String[] args) { separateNumbers(\"1234\"); System.out.print(\"ans: YES 1\\n\"); separateNumbers(\"91011\"); System.out.print(\"ans: YES 9\\n\"); separateNumbers(\"99100\"); System.out.print(\"ans: YES 99\\n\"); separateNumbers(\"101103\"); System.out.print(\"ans: NO \\n\"); separateNumbers(\"010203\"); System.out.print(\"ans: NO \\n\"); separateNumbers(\"13\"); System.out.print(\"ans: NO \\n\"); separateNumbers(\"1\"); System.out.print(\"ans: NO \\n\"); }} 참고 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음","link":"/2021/03/01/210302al-hackerrank-Separate-the-Numbers/"},{"title":"[자바JAVA]Missing Numbers 해커랭크","text":"문제arr과 brr을 비교하여 brr에는 있지만 arr에는 없는 숫자(Missing Numbers)를 배열로 나타내는 문제. Given two arrays of integers, find which elements in the second array are missing from the first array. Function Description : Complete the missingNumbers function in the editor below. It should return a sorted array of missing numbers.missingNumbers has the following parameter(s): int arr[n]: the array with missing numbers int brr[m]: the original array of numbers Returns : int[]: an array of integers 입출력예시 12345678//입력10203 204 205 206 207 208 203 204 205 20613203 204 204 205 206 207 205 208 203 206 205 206 204//출력204 205 206 코드두 배열을 각각 HashMap에 담은 뒤 (brr 해쉬맵 - arr 해쉬맵)을 통해 빠진 숫자를 효율적으로 찾을 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MissingNumbers { static int[] missingNumbers(int[] arr, int[] brr) { HashMap&lt;Integer, Integer&gt; hashmapA = new HashMap&lt;Integer, Integer&gt;(); HashMap&lt;Integer, Integer&gt; hashmapB = new HashMap&lt;Integer, Integer&gt;(); //arr을 HashMap으로 만든 뒤 반복되는 숫자가 있으면 value값을 1 누적합한다. for (int i : arr) { if (hashmapA.containsKey(i)) { hashmapA.put(i, hashmapA.get(i) + 1); } else { hashmapA.put(i, 1); } } //brr을 HashMap으로 만든 뒤 반복되는 숫자가 있으면 value값을 1 누적합한다. for (int j : brr) { if (hashmapB.containsKey(j)) { hashmapB.put(j, hashmapB.get(j) + 1); } else { hashmapB.put(j, 1); } } //HashMapB - HashMapA한 값을 리스트 diff에 담는다. ArrayList&lt;Integer&gt; diff = new ArrayList&lt;Integer&gt;(); for (Integer i : hashmapB.keySet()) { if (hashmapA.get(i) == null || hashmapA.get(i) &lt; hashmapB.get(i)) { diff.add(i); } } //리스트를 배열로 만든다. int[] result = new int[diff.size()]; for (int i = 0; i &lt; diff.size(); i++) { result[i] = diff.get(i); } System.out.println(Arrays.toString(result)); return result; } public static void main(String[] args) { System.out.println(missingNumbers(new int[]{203, 204, 205, 206, 207, 208, 203, 204, 205, 206}, new int[]{203, 204, 204, 205, 206, 207, 205, 208, 203, 206, 205, 206, 204}) + \", ans: [204 205 206]\"); }} 참고 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음","link":"/2021/03/07/210307al-hackerrank-MissingNumbers/"},{"title":"[자바JAVA]Big Sorting 해커랭크","text":"문제String 타입의 정렬안된 배열을 숫자오름차순으로 숫자를 정렬하는 문제이다. Consider an array of numeric strings where each string is a positive number with anywhere from to digits. Sort the array’s elements in non-decreasing, or ascending order of their integer values and return the sorted array. 입출력예시1 12345//입력[1 200 150 3]//출력[1 3 150 200] 입출력예시2 12345678910111213141516//입력6 &lt;-길이31415926535897932384626433832795131035//출력13351031415926535897932384626433832795 입출력예시3 1234567891011121314151617181920//입력8 &lt;-길이121001230347984985734171834019237130841937410829373084193741082938111200//출력121001112003084193741082937308419374108293812303479849857341718340192371 첫 시도: NumberFormatException처음에는 String[]을 long[]로 바꾼 뒤 오름차순 정렬 후 다시 String[]로 만들어서 출력하고자했다.하지만 숫자가 long보다 더 커서 NumberFormatException이 발생했다. 12345678910111213141516171819202122232425262728public class BigSorting { static String[] bigSorting(String[] unsorted) { //String arr를 long arr로 바꾼다. long[] arr = new long[unsorted.length]; for (int i = 0; i &lt; unsorted.length; i++) { arr[i] = Long.parseLong(unsorted[i]); } //long 배열을 오름차순정렬한다. Arrays.sort(arr); //정렬한 long배열을 String 배열로 바꾼 뒤 리턴한다. String[] result = new String[unsorted.length]; for (int i = 0; i &lt; unsorted.length; i++) { result[i] = Long.toString(arr[i]); } System.out.println(Arrays.toString(result)); return result; } public static void main(String[] args) { System.out.println(bigSorting(new String[]{\"1\", \"200\", \"150\", \"3\"}) + \", ans: [1 3 150 200]\"); System.out.println( bigSorting(new String[]{\"31415926535897932384626433832795\", \"1\", \"3\", \"10\", \"3\", \"5\"}) + \", ans: [1 3 3 5 10 31415926535897932384626433832795]\"); }} 성공한 코드람다식을 활용하여 unsorted 배열을 정렬했다.x.compareTo(y)는 int를 리턴한다. x == y면 0을 출력, x &gt; y 면 1을 출력, x &lt; y 면 -1을 출력한다 리턴한 값을 기준으로 sort한다. 1234567891011121314151617181920212223242526272829303132public class BigSorting { static String[] bigSorting(String[] unsorted) { Arrays.sort(unsorted, (x, y) -&gt; { System.out.print(\"시작 arr: \"+Arrays.toString(unsorted) + \" x: \"+x+\" y:\"+y); if (x.length() == y.length()) { System.out.print(\" x.compareTo(y): \"+x.compareTo(y)+\"\\n\"); return x.compareTo(y); //자리수에 상관없이 첫째자리만 보고 오름차순 정렬 }else { System.out.print(\" x.length() - y.length(): \"+ (x.length() - y.length()) +\"\\n\"); return x.length() - y.length(); //자리수에 상관한 오름차순 정렬 } }); return unsorted; } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String[] arr = new String[n]; for (int i = 0; i &lt; n; i++) { arr[i] = sc.next(); } arr = bigSorting(arr); for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } sc.close(); }} arr, x, y를 출력하면 아래와 같다.근데 x.compareTo(y): 2가 어떻게 나왔는지 구글링을 해도 모르겠다… 왜 2가 나왔지?그래서 그냥 암기하기로했다….. 1234567891011시작 arr: [31415926535897932384626433832795, 1, 3, 10, 3, 5] x: 1 y:31415926535897932384626433832795 x.length() - y.length(): -31시작 arr: [31415926535897932384626433832795, 1, 3, 10, 3, 5] x: 3 y:1 x.compareTo(y): 2시작 arr: [1, 31415926535897932384626433832795, 3, 10, 3, 5] x: 3 y:31415926535897932384626433832795 x.length() - y.length(): -31시작 arr: [1, 31415926535897932384626433832795, 3, 10, 3, 5] x: 3 y:1 x.compareTo(y): 2시작 arr: [1, 3, 31415926535897932384626433832795, 10, 3, 5] x: 10 y:3 x.length() - y.length(): 1시작 arr: [1, 3, 31415926535897932384626433832795, 10, 3, 5] x: 10 y:31415926535897932384626433832795 x.length() - y.length(): -30시작 arr: [1, 3, 10, 31415926535897932384626433832795, 3, 5] x: 3 y:10 x.length() - y.length(): -1시작 arr: [1, 3, 10, 31415926535897932384626433832795, 3, 5] x: 3 y:3 x.compareTo(y): 0시작 arr: [1, 3, 3, 10, 31415926535897932384626433832795, 5] x: 5 y:3 x.compareTo(y): 2시작 arr: [1, 3, 3, 10, 31415926535897932384626433832795, 5] x: 5 y:31415926535897932384626433832795 x.length() - y.length(): -31시작 arr: [1, 3, 3, 10, 31415926535897932384626433832795, 5] x: 5 y:10 x.length() - y.length(): -1 참고 람다식 : https://codeman77.tistory.com/40 compareTo() : https://www.tutorialspoint.com/java/number_compareto.htm 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음","link":"/2021/03/07/210307al-hackkerrank-bigsorting/"},{"title":"[자바JAVA]Two Characters 해커랭크","text":"문제 : Two Characters주어진 String의 요소 2가지만을 추출하여 String을 만들때 가장 길이가 긴 String의 길이값을 리턴하는 문제이다.Given a string, remove characters until the string is made up of any two alternating characters. When you choose a character to remove, all instances of that character must be removed. Determine the longest string possible that contains just two alternating letters 입출력예시1 12345//입력beabeefeab//출력5 코드2차원 배열로 접근할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TwoCharacters { public static final int NUM_LETTERS = 26; static int alternate(int length, String s) { int maxPattern = 0; if(s.length() == 1)//Edge case where length is 1 { return maxPattern; } /* Create arrays representing the 26^2 subproblems */ int[][] pair = new int[NUM_LETTERS][NUM_LETTERS]; int[][] count = new int[NUM_LETTERS][NUM_LETTERS]; for (int i = 0; i &lt; length; i++) { char letter = s.charAt(i); int letterNum = letter - 'a'; /* Update row */ for (int col = 0; col &lt; NUM_LETTERS; col++) { if (pair[letterNum][col] == letter) { count[letterNum][col] = -1; } if (count[letterNum][col] != -1) { pair[letterNum][col] = letter; count[letterNum][col]++; } } /* Update column */ for (int row = 0; row &lt; NUM_LETTERS; row++) { if (pair[row][letterNum] == letter) { count[row][letterNum] = -1; } if (count[row][letterNum] != -1) { pair[row][letterNum] = letter; count[row][letterNum]++; } } } /* Find max in \"count\" array */ for (int row = 0; row &lt; NUM_LETTERS; row++) { for (int col = 0; col &lt; NUM_LETTERS; col++) { maxPattern = Math.max(maxPattern, count[row][col]); } } return maxPattern; } public static void main(String[] args) { System.out.println(alternate(10, \"beabeefeab\")+\", ans: 5\"); }} 참고 : https://studyalgorithms.com/string/hackerrank-two-characters/ 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음","link":"/2021/02/27/210228al-hackerrank-Two-Characters/"},{"title":"[자바JAVA]제일 작은 수 제거하기 프로그래머스","text":"문제 : 제일 작은 수 제거하기정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다. 입출력예시1 12345//입력[4,3,2,1]//출력[4,3,2] 입출력예시2 12345//입력[10]//출력[-1] 첫번째 시도 코드아래 코드는 프로그래머스에 코드실행 (테스트케이스)는 정상 실행되나 제출 후 채점하기에서 실패가 되었다.어떤 점이 문제인지 한참을 고민했다. 123456789101112131415161718192021222324252627282930313233public class quizprogrammersthesmallestnum { static int[] solution(int[] arr) { // 제일 작은 수 제거한 배열을 리턴하는 문제 if (arr.length &lt;= 1) { System.out.println(Arrays.toString(new int[] {-1})); return new int[] {-1}; } // 배열에서 가장 작은 수 찾기 int min = arr[0]; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; min) { min = arr[i]; } } // 찾은 가장 작은 수만 빼고 정답배열에 넣기 int[] answer = new int[arr.length - 1]; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] != min) { answer[i] = arr[i]; } } System.out.println(Arrays.toString(answer)); return answer; } public static void main(String[] args) { System.out.println(solution(new int[] {4, 3, 2, 1}) + \", ans: [4,3,2]\"); System.out.println(solution(new int[] {10}) + \", ans: [-1]\"); }} answer 배열의 index문제였다. 123456789(전략) // 찾은 가장 작은 수만 빼고 정답배열에 넣기 int[] answer = new int[arr.length - 1]; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] != min) { answer[i] = arr[i]; //여기가 수상하다. } }(하략) 제시된 두 테스트케이스는 제일 작은 수가 마지막에 위치해있기때문에 아무런 문제가 없으나 제일 작은 수가 배열의 중간에 위치한다면 answer의 index가 띄엄띄엄 되어버리는 문제가 발생하기때문이다.예를 들어 입력값이 [4, 1, 2, 3]인 경우 출력값은 가장 작은 숫자 1을 뺀 [4,2,3]이다. 위의 코드로 실행시켜보면 아래와 같이 ArrayIndexOutOfBoundsException가 발생한다. 1Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 3 그 이유는 코드에서 answer[1]이 1이기때문에 if문에 false가 되면서 다음 인덱스인 2로 넘어간다.answer[2]는 2이기때문에 min값과 달라서 if문이 true라 실행이되면서 answer[2] = arr[2]가 된다.그럼 answer 배열은 answer[1]이 없고 answer[3]가 생기면서 answer의 길이보다 1 많아지게 되면서 ArrayIndexOutOfBoundsException가 발생하게 되는 것이다. 이를 해결하기 위해서는 answer만의 index가 필요하다. 완성된 코드123456789101112131415161718192021222324252627282930public class quizprogrammersthesmallestnum { static int[] solution(int[] arr) { // 제일 작은 수 제거한 배열을 리턴하는 문제 if (arr.length &lt;= 1) { System.out.println(Arrays.toString(new int[] {-1})); return new int[] {-1}; } // 배열에서 가장 작은 수 찾기 int min = arr[0]; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; min) { min = arr[i]; } } // 찾은 가장 작은 수만 빼고 정답배열에 넣기 int idx = 0; //answer전용 index를 선언했다. int[] answer = new int[arr.length - 1]; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] != min) { answer[idx] = arr[i]; //answer전용 index를 사용 idx++; } } System.out.println(Arrays.toString(answer)); return answer; }} 향상된 코드 : Arrays.stream() 사용프로그래머스는 다른 사람의 풀이를 볼 수 있다.이는 아주 큰 장점인데 세상에 얼마나 많은 천재가 있는지 보여준다!그들의 풀이를 보면서 정말 많이 배운다! 1234567class Solution { public int[] solution(int[] arr) { if (arr.length &lt;= 1) return new int[]{ -1 }; int min = Arrays.stream(arr).min().getAsInt(); return Arrays.stream(arr).filter(i -&gt; i != min).toArray(); }} Arrays.stream()를 사용한 풀이는 정말 간결해서 놀라웠다. Arrays.stream() 개념과 예제Arrays.stream()란 자바 8부터 Arrays.stream()를 사용할 수 있는 메서드로 배열이나 컬렉션에서 for 또는 foreach 문 도는 것을 대신하여 사용할 수 있다.foreach문처럼 요소를 하나씩 참조하여 람다식으로 처리할 수 있다. 12345678910111213// 기본 배열과 리스트String[] strArr = {\"aaa\", \"bbb\", \"ccc\"};// 스트림 생성Stream&lt;String&gt; strStream1 = Arrays.stream(strArr);// 스트림 출력strStream1.sorted().forEach(System.out::println);//출력값aaabbbccc filter(): 주어진 조건(Predicate)에 맞지 않는 요소를 걸러낸다. 아래는 스트림으로 1부터 10까지를 만든 뒤 filter()를 이용하여 짝수만 찾아내는 예제이다. 123// filter()IntStream example2Stream = IntStream.rangeClosed(1, 10);example2Stream.filter(i -&gt; i%2 ==0).forEach(System.out::print); // 246810 참고 https://ryan-han.com/post/java/java-stream/","link":"/2021/03/07/210307al-programmers-thesmallestnum/"},{"title":"[자바JAVA]Grid Challenge 해커랭크","text":"문제: Grid Challenge주어진 그리드의 열이 사전순 정렬이면 YES를 출력하는 문제로 그리드의 행은 순서를 변경할 수 있다.Given a square grid of characters in the range ascii[a-z], rearrange elements of each row alphabetically, ascending. Determine if the columns are also in ascending alphabetical order, top to bottom. Return YES if they are or NO if they are not. 입출력예시1 12345//입력[\"abc\", \"ade\", \"efg\"]//출력YES 코드행을 사전순으로 정렬하는 것은 쉬웠지만 열이 사전순 정렬인지 확인하는 부분이 어려웠다. 123456789(생략)for (int i = 0; i &lt; grid[0].length(); i++) { for (int j = 0; j &lt; grid.length - 1; j++) { if (grid[j].charAt(i) &gt; grid[j + 1].charAt(i)) { return \"NO\"; } }}(후략) 위의 부분에서 입출력예시를 가지고 설명한다면, grid[j].charAt(i) &gt; grid[j + 1].charAt(i)이 부분은 먼저 grid[0].charAt(1) &gt; grid[1].charAt(1) 을 비교한다. 둘다 a 이기때문에 사전순을 만족한다. 이 부분을 반복하면 아래와 같다. 12345678910111213141516171819202122231. grid[0].charAt(0) &gt; grid[1].charAt(0) 을 비교a a =&gt; 사전순 맞음2. grid[1].charAt(0) &gt; grid[2].charAt(0) 을 비교a e =&gt; 사전순 맞음// 여기까지 첫번째 열 비교 완료// 두번째 열 비교 시작3. grid[0].charAt(1) &gt; grid[1].charAt(1) 을 비교b d =&gt; 사전순 맞음4. grid[1].charAt(1) &gt; grid[2].charAt(1) 을 비교d f =&gt; 사전순 맞음// 여기까지 두번째 열 비교 완료// 세번째 열 비교 시작5. grid[0].charAt(2) &gt; grid[1].charAt(2) 을 비교c e =&gt; 사전순 맞음6. grid[1].charAt(2) &gt; grid[2].charAt(2) 을 비교e g =&gt; 사전순 맞음 전체코드는 아래와 같다. 12345678910111213141516171819202122232425262728static String gridChallenge(String[] grid) { // 1. 행을 사전순 정렬하기 // String을 char로 변환하여 사전순으로 sort한 후 다시 grid[i]번째에 넣는다. for (int i = 0; i &lt; grid.length; i++) { char[] chars = grid[i].toCharArray(); Arrays.sort(chars); grid[i] = String.valueOf(chars); } // 2. 열이 사전순 정렬인지 확인하기 // 지금 열과 다음 열의 i번째를 비교하여 사전순이 아니면 NO를 출력 for (int i = 0; i &lt; grid[0].length(); i++) { for (int j = 0; j &lt; grid.length - 1; j++) { if (grid[j].charAt(i) &gt; grid[j + 1].charAt(i)) { return \"NO\"; } } } return \"YES\";}public static void main(String[] args) { System.out.println(gridChallenge(new String[]{\"abc\", \"ade\", \"efg\"}) + \", ans:YES\"); System.out.println(gridChallenge(new String[]{\"ebacd\", \"fghij\", \"olmkn\", \"trpqs\", \"xywuv\"}) + \", ans:YES\"); System.out.println(gridChallenge(new String[]{\"kc\", \"iu\"}) + \", ans:YES\"); System.out.println(gridChallenge(new String[]{\"uxf\", \"vof\", \"hmp\"}) + \", ans:NO\");} 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음","link":"/2021/03/13/210314al-HackerRank-Grid-Challenge/"},{"title":"[리액트] webpack과 hot reloading 설치하기","text":"webpack 개념 node : 자바스크립트 실행기일뿐 서버가 아니다. 바벨 종류 npm i -D @babel/명칭 : 바벨 설치하는 명령어 바벨종류 설명 @babel/core 바벨 기본적인 것 @babel/preset-env 브라우저에 맞게 옛날문법을 최신문법으로 바꿔줌(즉, 옛날 문법을 지원해줌)지원할 브라우저를 옵션으로 설정할 수 있다. 지원을 많이할수록 느려진다 @babel/preset-react jsx 지원 babel-loader 바벨과 웹팩을 연결해줌 @babel/plugin-proposal-class-properties state문법사용할 수 있게 만듦 webpack 만드는 순서 만든 파일 webpack으로 만들기 npm init npm install –save react react-dom npm i -D webpack webpack-cli npm i -D @babel/core @babel/preset-env @babel/preset-react babel-loader @babel/plugin-proposal-class-properties 위 4가지 설치 완료 후에 webpack.config.js 파일 생성 후 작성 entry파일 생성 -&gt; client.jsx Gugudan.jsx파일 생성 npm run dev 또는 npx webpack index.html 파일생성하여 webpack으로 만든 app.js 불러오기 webpack 데브 서버(dev server)와 핫 리로딩(hot reloading) 개념 설명 reloading 그냥 새로고침 hot reloading 기존데이터 유지하고 변경점만 바뀜 plugins 확장프로그램 react-refresh-webpack 설치하기 npm i react-refresh @pmmmwh/react-refresh-webpack-plugin -D 서버도 필요하기때문에 설치하기 변경점이 생기면 감지하여서 기존데이터 유지하면서 화면을 바꿔줌. dev-server 설치하기 npm i -D webpack-dev-server pakage.json scripts 수정 “dev”: “webpack serve –env development” webpack.config.js에서 수정 plugins추가123plugins[ new RefreshWebpackPlugin()]","link":"/2021/03/14/210314ReactLectureByZerocho/"},{"title":"[자바JAVA]Luck Balance 해커랭크","text":"문제 : Luck Balancecontests에서 각 대회가 중요하면 1이고 중요하지 않으면 0이다.k는 중요한 대회에서 질 수 있는 횟수이다.contests에서 지면 행운이 높아지고 이기면 행운이 낮아진다.최대 행운이 얼마인지 구하는 문제이다.Lena is preparing for an important coding competition that is preceded by a number of sequential preliminary contests. Initially, her luck balance is 0. She believes in “saving luck”, and wants to check her theory. Each contest is described by two integers, L[i] and T[i]: L[i] is the amount of luck associated with a contest. If Lena wins the contest, her luck balance will decrease by L[i]; if she loses it, her luck balance will increase by L[i]. T[i] denotes the contest’s importance rating. It’s equal to 1 if the contest is important, and it’s equal to 0 if it’s unimportant.If Lena loses no more than K important contests, what is the maximum amount of luck she can have after competing in all the preliminary contests? This value may be negative. 입출력예시 1234567//입력K=2L = [5,1,4]T = [1,2,0]//출력10 코드123456789101112131415161718192021222324252627282930313233343536373839static int luckBalance(int k, int[][] contests) { int maxLuck = 0; int important = 0; List&lt;Integer&gt; luckList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; contests.length; i++) { if (contests[i][1] == 1) { //중요한 대회면 luckList에 담기 important++; luckList.add(contests[i][0]); } else { //중요하지 않은 대회들은 바로 maxLuck에 누적합 maxLuck += contests[i][0]; } } //중요한대회만 luckList 오름차순으로 정렬 Collections.sort(luckList); //가장 낮은 행운을 가진 대회 maxLuck에서 빼준다. int ableToLose = important - k; for (int i = 0; i &lt; ableToLose; i++) { maxLuck -= luckList.remove(0); //가장 낮은 행운 빼기 } //가장 높은 행운을 가진 대회를 maxLuck에 더해준다. for (int i = 0; i &lt; luckList.size(); i++) { maxLuck += luckList.get(i); } return maxLuck;}public static void main(String[] args) { int[][] contests1 = {{5, 1}, {1, 1}, {4, 0}}; int[][] contests2 = {{5, 1}, {2, 1}, {1, 1}, {8, 1}, {10, 0}, {5, 0}}; System.out.println(luckBalance(2, contests1) + \", ans: 10\"); System.out.println(luckBalance(1, contests1) + \", ans: 8\"); System.out.println(luckBalance(3, contests2) + \", ans: 29\");} 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음","link":"/2021/03/13/210314al-HackerRank-Luck-Balance/"},{"title":"[자바JAVA] Maximum Perimeter Triangle 해커랭크","text":"문제 : Maximum Perimeter Trianglea non-degenerate triangle이 되는 가장 긴 둘레를 구하는 문제이다.a non-degenerate triangle란 무엇일까? 구글링해보니 아래 3가지 조건을 충족하는 삼각형이라고 한다. 한국어로 부르는 명칭은 찾을 수 없었다. 분명 있을텐데… a+b&gt;c a+c&gt;b b+c&gt;a Given an array of stick lengths, use 3 of them to construct a non-degenerate triangle with the maximum possible perimeter.Return an array of the lengths of its sides as 3 integers in non-decreasing order. If there are several valid triangles having the maximum perimeter: Choose the one with the longest maximum side. If more than one has that maximum, choose from them the one with the longest minimum side. If more than one has that maximum as well, print any one them.If no non-degenerate triangle exists, return [-1]. 입출력예시1 12345//입력[1, 2, 3, 4, 5, 10]//출력[3,4,5] 입출력예시2 12345//입력[1, 1, 1, 3, 3]//출력[1,3,3] 입출력예시3 12345//입력[1,1,1,2,3,5]//출력[1,1,1] 코드1234567891011121314151617181920212223242526272829303132333435static int[] maximumPerimeterTriangle(int[] sticks) { int answerArr[] = new int[3]; Arrays.sort(sticks); // non-degenerate triangle의 조건 만족하는 지 확인하기 // 반복문을 통해서 answerArr요소는 조건에 부합하는 가장 큰 숫자가 된다. 따라서 가장 긴 둘레 조건 충족된다. boolean isNonDegenerateTriangle = false; for (int i = 0; i &lt; sticks.length - 2; i++) { int a = sticks[i]; int b = sticks[i + 1]; int c = sticks[i + 2]; if ((a + b) &gt; c &amp;&amp; (a + c) &gt; b &amp;&amp; (b + c) &gt; a) { answerArr[0] = (int) a; answerArr[1] = (int) b; answerArr[2] = (int) c; isNonDegenerateTriangle = true; } } //a non-degenerate triangle 조건을 충족하지 못했으므로 -1 arr를 리턴한다. if (!isNonDegenerateTriangle) { return new int[]{-1}; } System.out.print(Arrays.toString(answerArr)); return answerArr; } public static void main(String[] args) { System.out.println(maximumPerimeterTriangle(new int[]{1, 2, 3, 4, 5, 10}) + \", ans: [3,4,5]\"); System.out.println(maximumPerimeterTriangle(new int[]{1, 1, 1, 3, 3}) + \", ans: [1,3,3]\"); System.out.println(maximumPerimeterTriangle(new int[]{1,1,1,2,3,5}) + \", ans: [1,1,1]\"); } 해커랭크의 다른 문제 풀이가 보고싶다면? 해커랭크(HackerRank) Easy Level java 풀이 모음","link":"/2021/03/13/210314al-HackerRank-Maximum-Perimeter-Triangle/"},{"title":"[오류일지]Error creating bean with name 에러 해결 PropertySourcesPlaceholderConfigurer","text":"문제 : PropertySourcesPlaceholderConfigurersvn에서 import한 프로젝트를 셋팅하는 과정에서 톰캣을 실행하니 아래와 같은 오류가 발생했다. Error creating bean with name ‘org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0’: Cannot resolve reference to bean ‘properties’ while setting bean property ‘properties’; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named ‘properties’ available at 원인과 해결properties를 찾지못해서 bean을 생성하지 못한 경우로 톰캣서버에 연결해줘서 환경별 설정이 가능하도록 해주면 된다. 톰캣서버를 더블클릭한 후 General Information 에서 아래 이미지처럼 Open launch configuration을 클릭한다 Arguments 탭에서 아래 부분을 복붙하여 넣어준 뒤 Apply하고 OK하면 끝! 1-Dspring.profiles.active=local 해결!","link":"/2021/03/14/210315springBeanerror/"},{"title":"[제코베ICT특강 후기]정규표현식 Python으로 톺아보기","text":"특강 소개 및 후기톺아보기란 샅샅이 더듬어 뒤지면서 찾아본다는 순 우리말이다.파이썬을 잘 알지는 못하지만 정규표현식을 배우고싶은 마음에 듣게 된 특강이다. 파이썬을 잘 몰라도 충분히 들을 수 있는 강의였다! 사실 정규식에 대한 자료는 인터넷에 참 많다.하지만 개발자로서 공부할 게 많다보니 정규식은 사용에 의해… 꼭 필요한 때만 급하게 공부하게 되어버린다.언젠가 공부해야지라고 생각만했었는데 이호준대표님의 특강덕분에 정규식에 한 발 가까워졌다.물론 자유자재로 사용하려면 한참 멀었지만 기초를 다질 수 있어 참 유익했다. 노션 교안 : https://www.notion.so/1c57fc683c33468d95e7a490b6f66c95교안 목차를 차근차근따라가다보면 어느새 카카오 코딩테스트와 비슷한 문제까지 풀어본 게 된다!정말 좋은 자료이다! 정규표현식 실습사이트: https://regexr.com/5nvc2이호준대표님이 미리 넣어주신 데이터를 가지고 정규표현식을 연습할 수 있는 실습사이트이다.왼쪽 메뉴바의 Cheatsheet을 통해서 각 정의 및 기능을 확인할 수 있다.교안의 실전부분을 실습사이트에서 직접 진행해보면서 정규표현식 기초를 익힐 수 있다. 팁강의 중의 기억하고싶은 팁들이다. /^문자/gm : 문자로 시작하는것 /문자$/gm : 문자로 끝나는것 /^문자$/gm 주로 위의 둘을 함께 사용한다. /... .../gm : 3글자와 띄어쓰고 그다음 3글자를 찾을 수 있다. /h[ea]llo/gm : 택일 기능으로 hello와 hallo 두 개 다 찾는다. [a-z].a: 총 3글자이고 첫번째글자는 a-z, 두번째는 모든 글자, 마지막글자는 a인 문자열을 찾는다 ?는 위치에 따라 의미가 다르다. 서브패턴제일 재미있던 부분은 서브패턴이었다. grouping 규칙 사용법 예시 (?:abc) 캐치는 되지만 그룹을 사용하지 않음 (?=abc) (Positive 매칭) 그룹으로 설정(Lookahead) hello(?=world)/gm 뒤에 world가 오는 hello를 찾음 (?!abc) (Negative 매칭) 그룹으로 설정(Lookbehind) hello(?!world)/gm 뒤에 world가 오지않는 hello를 찾음 Google Colab주실습은 코랩을 사용했다.코랩은 예전에 한국코드페어 특강때 잠깐 다뤄본 적이 있다.만약 파이썬을 아예 모른다면 자바스크립트를 이용하는 실습 방법도 노션 교안에 다 나와있다! 교안이 잘되어있었기에 따로 필기를 할 필요가 없었다. 세상친절! 팁강의 중의 기억하고싶은 팁들이다. 가장 많이 사용하는 메서드는 re.compile('패턴').findall(문자열) 이다. 정규식에 매칭되는 리스트를 반환한다. 교안의 연습문제 중 주사위문제가 2018년 카카오 코딩테스트와 비슷한 수준의 문제이다. 교안의 연습문제에 대한 답은 주피터노트북에 나와있다. 압축 문제재미있던 문제는 압축문제였다.for와 if를 이용하여 풀 수 있지만 정규표현식으로 더욱더 간단하게 풀 수 있었다.그리고 또 한 번 느끼는 건데 코테할때는 파이썬이 짱이다. 이렇게 간단할수가! 문제: aaabbccc는 a3b2c3로 압축된다. 압축된 문자열을 정규표현식을 사용하여 다시 풀어보시오 123456789101112131415//풀이1정규표현식 = re.compile('([a-z])([1-9])')문자열 = 'a3b2c3'결과 = 정규표현식.findall(문자열)결과s = ''for i, j in 결과 : s += i *int(j)print(s)//출력aaabbccc 위를 더 간단하게 한 줄로 풀수도 있다. 12345//풀이2 : 한줄버전 한줄버전''.join([i * int(j) for i, j in 결과])//출력aaabbccc 추가 자료정규표현식, 자주 사용하는 정규식","link":"/2021/03/16/210317pythonRegularExpression/"},{"title":"[리액트]컴포넌트 생명주기","text":"컴포넌트 라이프 사이클 순서는 아래와 같다. 컴포넌트 라이프 사이클 순서 constructor → componentWillMount → render → ref → componentDidMount componentWillMount 는 실무에서 잘 쓰지않는다.’ 위의 순서 끝난 뒤 setState/props 바뀌는 경우 → shouldComponentUpdate(true) → render → componentDidUpdate 부모컴포넌트가 나를 없앤 경우 → componentWillUnmount → 소멸 component함수 componentDidMount() : render가 처음 성공적으로 실행된 후 바로 componentDidMount() 가 실행된다. 리랜더링일땐 실행되지 않는다. 비동기 요청 eX) setInterval() componentDidUpdate() : 리랜더링된 후 실행. componentWillUnmount(): 컴포넌트가 제거되지 직전 비동기요청을 componentWillUnmount() 로 할 수 있다. 비동기 요청 정리 완료되지않은 비동기요청을 여기서 정리해줘야함. 12345678910111213141516171819202122232425262728293031323334353637383940//class버전interval; componentDidMount() { // 컴포넌트가 첫 렌더링된 후, 여기에 비동기 요청을 많이 해요 this.interval = setInterval(this.changeHand, 100); } componentWillUnmount() { // 컴포넌트가 제거되기 직전, 비동기 요청 정리를 많이 해요 clearInterval(this.interval); // 완료되지않은 비동기요청을 여기서 정리해줘야한다 }//Hooks버전const interval = useRef(); //useEffect는 componentDidMount, componentDidUpdate, componentWillUnmount에 대해 1대1대응은 아니지만 셋의 역할을 하나로 합쳤다고 할수있다. //componentDidMount, componentDidUpdate역할 useEffect(() =&gt; { interval.current = setInterval(changeHand, 100); //0.1초 return () =&gt; { //componentWillUnmount역할 clearInterval(interval.current); }; }, [imgCoord]); //빈 배열이면 componentDidMount역할만 수행//배열에 다시 실행 할 값을 넣어주면componentDidMount + componentDidUpdate역할//Hooks버전에서 componentDidMount만 사용하고 싶다면?useEffect(() =&gt; { //ajax }, []); //빈배열로 놔두기//Hooks버전에서 componentDidMount 말고 componentDidUpdate만 사용하고 싶다면?const mounted = useRef(fasle); useEffect(() =&gt; { if (!mounted.current) { mounted.current = true; } else { //ajax 처리 } }, []); //배열에는 바뀌는 값입력 참고 제로초 리액트 무료강좌(웹게임)","link":"/2021/03/22/210323React-componentLifeCycle/"},{"title":"[Hexo]헥소블로그 방문자수 조회수 간단하게 처리하기(초간단)","text":"블로그를 운영하다보면 조회수가 궁금해지기마련이다.구글서치콘솔로 조회수를 확인할 수 있지만 블로그에서 바로 확인하면 더욱 좋을 것이다. 헥소블로그는 지킬블로그보다 정보가 많이 없어서 구글링을 좀 많이 했다. 그랬더니 내가 쓰고 있는 hexo-icarus테마는 busuanzi플러그인을 통하여 초간단하게 조회수와 방문자수를 처리할 수 있었다. 사용중인 hexo테마 : icarus 조회수 기능 등록 방법busuanzi플러그인은 중국어지만 구글의 힘을 빌려서 사용가능하다. 간단하게 스크립트코드와 html태그를 넣어서 조회수를 처리할 수 있다.하지만 내가 사용중인 hexo icarus테마는 true/false만으로도 적용이 가능하다! 세상 간편!물론 커스텀하고 싶다면 공식사이트를 통해 원하는 대로 적용할 수 있다. 프로젝트에서 themes/hexo-theme-icarus/_config.yml 파일을 연다. busuanzi를 검색하여 false를 true로 변경해준다. 끝! 12345# BuSuanZi site/page view counter# https://busuanzi.ibruce.infobusuanzi: true# CNZZ statistics# https://www.umeng.com/web true로 바꿔주기만하면 블로그 footer에 전체 방문자수와 조회수가 출력될뿐아니라 각 포스팅의 조회수도 확인 가능하다! 초간단! 참고 https://blog.zhangruipeng.me/hexo-theme-icarus/Plugins/Analytics/icarus-user-guide-web-analytics-plugins/#BuSuanZi-Web-Counter","link":"/2021/03/22/210323hexo-visitcunt/"},{"title":"[오류일지]React에러 Warning: Failed prop type: The prop &#96;open&#96; is marked","text":"상황스프링부트와 리액트 MySQL를 사용하여 학사프로그램을 만들고 있다.리액트 작업 도중 Warning: Failed prop type: The prop open is marked as required in ForwarRef(Menu), but its value is undefined 에러가 계속 발생했다.Menu인 부분이 뭐있을까 검색하면서 찾아보니 정말 어이없는 실수를 발견했다. 원인 및 해결import시 @material-ui/icons/Menu를 해야했는데 @material-ui/core/Menu를 해놓은 것을 발견했다.core가 아닌 icons로 하니 에러가 더이상 발생하지 않았다.","link":"/2021/03/24/210325React-err-failedproptype/"},{"title":"JPA VS JDBC","text":"오늘 또 못알아듣고 말았습니다. 회의시간만되면 신입개발자인 나는 참 바쁘다. 모르는 용어들이 쏟아지기때문에 볼펜을 놓쳐선 안된다. 회의 중 모르는 용어들은 다 적어놨다가 회의가 끝나고 혼자 구글링해보곤한다. 그럴때마다 아 그렇구나하고 뒤돌아선 까먹기 일수!그래서 아예 포스팅을 하기로 했다. 역시 기억보단 기록이지!TAGS는 오늘또못알아듣고말았습니다로 정해봤다.언젠가 내가 회의를 다 알아들으며 주도하는 그 날이 올때까지 열심히 공부해야겠다. 💬오늘의 물음표신규프로젝트 회의 중에 팀장님이 말씀하셨다. JPA를 사용하면 비즈니스 로직이 복잡해져서 사용하지 않을거예요 이 말의 뜻을 이해하지 못했기에 회의끝나고 찾아볼 요량으로 회의 중에 후다닥 노트에 적었다. 😁JPA(Java Persistent API)란 뭘까? 그전에 역사부터!그 이름에 답이있다. Persistent(영속성)이란 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지않는 데이터의 특성이다. 기술은 발전된 순서로 공부하는 것이 이해하기 편하다.왜냐하면 이전 기술의 불편한 점을 보완하여 새로운 기술인 나왔기때문이다. 그래서 불편한 점이 무엇이었고 그것을 어떻게 해결했는지가 두 기술의 차이점이 된다.그럼 JPA전에는 뭐가 있었을까?바로 JDBC이다. 😮JDBC는 DB연결할때 쓰는 거아냐?JDBC(Java Database Connectivity)도 그 이름에 답이 있다. DB에 접근(Connectivity)할 수 있도록 Java에서 제공하는 API이다. JDBC API가 있고 JDBC DriverManager가 DB제품에 따른 드라이버를 생성하여 JDBC API에 맞게 동작할 수 있게 처리해준다.따라서 우리는 JDBC API 변경없이 JDBC 드라이버만 바꿔주면 어떤 제품의 DB든 연결할 수 있다. 위 사진처럼 쿼리를 실행하기 전과 후에 연결 생성, 명령문, ResultSet 닫기등과 같은 많은 코드를 작성해야한다.또 connection 관리, 예외처리등에 불편함이 있어 나온게 Spring JDBC이다. 코드 예시 123456789101112131415161718192021222324252627282930313233//1. 드라이브로드 &amp; 디비연결 : 로그인한 사용자의 정보를 가져오기final String DRIVER = \"com.mysql.jdbc.Driver\";final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";final String DBID = \"root\";final String DBPW = \"1234\";Class.forName(DRIVER);Connection con = DriverManager.getConnection(DBURL, DBID, DBPW);System.out.println(\"드라이브로드와 디비연결성공\");//2. SQL &amp; PSTMT &amp; 실행String sql = \"select * from itwill_member where id=?\";PreparedStatement pstmt = con.prepareStatement(sql);pstmt.setString(1, id);//3. 실행-&gt; rs에 결과저장 -&gt; 데이터처리ResultSet rs = pstmt.executeQuery();//지역변수초기화-자동으로 안됨.String name = \"\";int age = 0;String gender = \"\";String email = \"\";Timestamp reg_date = null; // Timestamp의 초기값은 null임if(rs.next()){ //id=rs.getString(\"id\"); 세션으로 가져와서 필요없음 name = rs.getString(\"name\"); age = rs.getInt(\"age\"); gender = rs.getString(\"gender\"); email = rs.getString(\"email\"); reg_date = rs.getTimestamp(\"reg_date\");} 😥Spring JDBC는 또 뭐야? 핵심 : JdbcTemplate Spring JDBC는 JDBC에서 DriveManager가 하는 일들을 JdbcTemplate에게 맡긴다. 따라서 개발자는 메서드에 쿼리를 직접 매핑한다.쿼리작성이 줄어들고(여전히 쿼리를 적지만…) 불편한 점들을 추상화시켜놓았다.SQL Query 직접 사용하여 데이터 조작하므로 JdbcTemplate은 SQL Mapper 중 하나이다 코드 예제코드 출처: Spring JDBC 참고 123456789101112// 여러 건 select하기List&lt;Actor&gt; actors = this.jdbcTemplate.query( \"select first_name, last_name from t_actor\", new RowMapper&lt;Actor&gt;() { public Actor mapRow(ResultSet rs, int rowNum) throws SQLException { Actor actor = new Actor(); actor.setFirstName(rs.getString(\"first_name\")); actor.setLastName(rs.getString(\"last_name\")); return actor; } }); 🤔SQL Mapper는 또 뭐야?SQL Mapper는 SQL 문장으로 직접 데이터베이스 데이터를 다룬다.그럼 직접 데이터를 다루지 않는 것도 있을까?직접 다루지 않는 것을 ORM(Object-Relational Mapping)이라고 부른다. 🆚SQL Mapper vs ORM SQL Mapper ORM SQL 문장으로 직접 데이터베이스 데이터를 조작함 객체를 통해 간접적으로 데이터베이스 데이터를 조작함 SQL Query 직접 사용하여 데이터 조작 SQL Query가 아닌 메서드로 데이터 조작 SQL이 java코드와 분리되어 있기 때문에 유지보수가 편하지만 분리되어있기에 객체와 쿼리문 모두 관리해주어야 함 객체 중심으로 개발가능 복잡한 쿼리, 다이나믹 쿼리 이점 프로시저등 복잡한 쿼리는 해결이 까다로움, 자동으로 생성되는 쿼리가 많기 때문에 성능저하의 가능성이 있어 최적화 필요 비슷한 쿼리 남발, 자주쓰는 CRUD 메소드를 직접 다 작성필수 CURD 메소드를 기본적으로 제공 특정 DB에 종속적 설정파일에서 어떤 DB를 사용하고 있는지 알려주기만 하면 얼마든지 DB를 변경가능 MyBatis, Spring JDBC JPA, Hibernate 🤔그럼 MyBatis는?MyBatis도 SQL Mapper 중 하나이다.MyBatis는 Plain JDBC의 문제점을 Spring JDBC와 다르게 보았다.MyBatis는 자바코드에서 SQL을 쓰는 것을 문제라고 생각했고 SQL을 분리하고자했다. 따라서 SQL쿼리를 Java에서 XML로 옮겼서 적는다. 코드예제EMemberVO.java 생성한 뒤 xml파일에서 MyBatis사용한 코드이다. 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- DTD지정 --&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- SQL 구문 작성후 사용 --&gt;&lt;mapper namespace=\"com.example.mappers.memberMapper\"&gt; &lt;select id=\"getTime\" resultType=\"string\"&gt; select now() &lt;/select&gt;&lt;/mapper&gt;&lt;!-- DAO패키지(com.itwillbs.persistence)와 연결 --&gt;&lt;context:component-scan base-package=\"com.example.persistence\" /&gt; MyBatis(iBatis) 적용순서 및 사용방법 3가지, 예시, 코드 예제 Mybatis는 쿼리가 수정되어 데이터 정보가 바뀌면 그에 사용되고있던 DTO와 함께 수정해주어야하는 불편함이 생긴다. 즉, 물리적으로 분리시켜놨지만 논리적으로는 서로 강한 의존관계가 있다.이 불편함을 해결하기 위해 나온 것이 ORM이다.ORM은 객체만 바꾸어주면 된다. 즉, 객체 중심으로 개발가능해진다. 😉SQL Mapper은 알았으니 이제 ORM이 뭔지 알려줘ORM(Object-Relational-Mapping)의 이름 그대로 객체와 관계형데이터베이스의 데이터를 자동으로 매핑(연결)해준다. ORM의 구조는 아래와 같다. ORM기준 표준인터페이스인 JPA(Java Persistence API)가 있고, 그 구현체로는 제일 유명한 Hibernate, EclipseLink, DataNucleus등이 있다.ORM의 핵심은 엔티티매니저이다. 😝드디어 JPA가 나오네직접적인 SQL 문을 사용하지 않고 자바 코드를 사용해서 DB에 접근, 조작할 수 있는 기술이다. JPA 역시 내부적으로 JDBC를 사용한다. 자바 ORM 기술에 대한 API 표준 명세로, Java에서 제공하는 API이다. 장점 SQL문을 직접 java application내에서 적을 경우가 적어짐 기본적인 CRUD 쿼리를 반복적으로 작성하지 않아도 됨 수정사항이 발생하였을 때 수정해야 할 코드가 적음 SQL구조를 java application내에서 적용하지 않아도 됨. 어노테이션을 사용한다 EX) @Id, @ManyToOne …등 -&gt; SQL 의존성 줄어듬. 객체지향적으로 데이터 관리 가능 단점 메서드 호출로 쿼리 실행은 직접 SQL을 호출하는 것보다 성능이 떨어질 수 있음 복잡한 통계 분석 쿼리를 메서드 호출로 처리하는 것음 어려움 -&gt; 로직이 복잡하거나 불필요한 쿼리가 발생할 수 있음 러닝커브가 높음 JPA를 쓰는데 EntityManager를 쓴 적 없다면 그것은 Spring Data JPA를 사용했기 때문일 것이다. 😳Spring Data JPA는 또 뭐야?Spring Data JPA는 JPA를 쓰기 편하게 만들어놓은 모듈이다.Spring Data JPA의 핵심은 Repository이다.이 JpaRepository를 뜯어보면 안에 EntityManager가 있다는 것을 알 수있다. 코드예제코드 출처: JPA - CRUD RestController 만들기 12345678910111213141516171819202122@RestController() public class BookController { @Autowired private BookRepository bookRepository; @PostMapping(\"/book\") public BookEntity createBook(@RequestBody BookEntity bookEntity) { BookEntity created = bookRepository.save(bookEntity); return created; } @GetMapping(\"/book\") public List&lt;BookEntity&gt; listAllBooks() { List&lt;BookEntity&gt; list = new ArrayList&lt;&gt;(); Iterable&lt;BookEntity&gt; iterable = bookRepository.findAll(); for (BookEntity bookEntity : iterable) { list.add(bookEntity); } return list; }} 📝분류 JDBC SQLMAPPER ORM JDBC API MyBatis JPA Spring JDBC Hibernate Spring JDBC/JPA 😎JPA를 쓰면 왜 비즈니스 로직이 복잡해질까?비즈니스 로직이란 업무에 필요한 데이터처리를 수행하는 것을 의미한다.예를 들어 DB에서 휴대전화 데이터를 가져와 웹에서 마스킹한 형태로 출력할 때 그 가공 과정을 비즈니스 로직이라고 한다. JPA를 사용하면 제공되는 메소드로 복잡한 SQL를 수행하려할때 비즈니스 로직이 길어질 수 밖에 없다. JPA는 통계 쿼리처럼 복잡한 SQL을 수행하기 힘들기 때문에, 비즈니스에 따라 Mybatis를 사용할 지 Hibernate를 사용할 지 상황에 맞는 선택이 중요할 것입니다.처음에 살펴본 구글 트렌드를 볼 때 우리나라는 대부분 Mybatis를 사용하고 있는데, 그 이유는 우리나라 시장 대부분이 SI, 금융 시장이기 때문입니다.비즈니스가 매우 복잡하고, 안정성을 중요시 하는 서비스일 경우에는 JPA보다 SQL을 작성하는 것이 더 좋다는 의도일 것입니다.이미 SQL을 사용하여 개발된 애플리케이션이라면 JPA로 바꾸는 일도 쉽지 않기 때문에, 우리나라에서는 JPA가 많이 사용되지 못하는 것 같습니다.출처: https://victorydntmd.tistory.com/195 참고 https://thefif19wlsvy.tistory.com/249 https://youtu.be/Ppqc3qN75EE https://gmlwjd9405.github.io/2018/12/25/difference-jdbc-jpa-mybatis.html https://youtu.be/mezbxKGu68Y https://velog.io/@seculoper235/DB-%EC%9E%91%EC%97%85-JDBC https://bk-investing.tistory.com/35","link":"/2021/03/22/210323jpaVSjdbc/"},{"title":"[리액트] Hooks API로 생명주기 관리","text":"Hooks 컴포넌트 상태관리 함수리액트에는 클래스형 컴포넌트와 함수형 컴포넌트가 있다. 클래스 컴포넌트는 state를 가지고 다니는 반면에 함수형 컴포넌트는 그렇지않다.리액트 Hooks를 통해 함수형 컴포넌트에서 상태관리를 할 수 있게 되었다.즉, 리액트 Hooks란 함수형 컴포넌트에서 생명주기 관리를 도와주는 기능이다. 기본적인 Hooks useState useEffect useContext 컴포넌트 상태 관리 컴포넌트가 렌더링될 때마다 어떠한 작업을 수행하도록 개입 컴포넌트 간의 전역 상태를 관리 - 클래스형컴포넌트의 componentDidMout+componentDidUpdate기능을 합친 형태 - 추가 HooksuseReducer state갯수를 줄여주는 역할 테이블구조에서 Td 넘겨줄 데이터가 많기 때문에 useReducer를 이용하여 한번에 넘겨줄 수 있다. state변경시 불변성이 중요하기때문에 얕은 복사를 사용한다. 1234567891011121314const initialState = { winner: \"\", turn: \"O\", tableData: [ [\"\", \"\", \"\"], [\"\", \"\", \"\"], [\"\", \"\", \"\"], ], recentCell: [-1, -1], //초기화는 없는 칸으로 설정};const TictactoeHooks = () =&gt; { const [state, dispatch] = useReducer(reducer, initialState);} useRef 일반 값을 기억 값이 바뀌어도 랜더링하고 싶지않은 값들은 useRef 넣어서 사용한다. -&gt; 성능 최적화. 값이 바뀌기는 하지만 화면에 영향을 미치지않을때 useRef 사용 useRef를 사용하면 변한 값이 저장은 되지만 랜더링 되지않는다 → useRef뒤에 setState()로 호출하는 순간 랜더링이 된다. useMemo 복잡한 함수 결과값(리턴값)을 기억 useCallback 함수 자체를 기억 함수 생성 자체가 비용이 클때 사용 함수 자체를 기억하기때문에 변경값이 있는 경우에 인지하지 못한다. 따라서 [] input에 변경되는 state를 넣어줘야 정상적으로 변경값을 인지한다. useEffect 과 useLayoutEffect 차이둘의 가장 중요한 차이는 실행시점이다. useEffect useLayoutEffect 컴포넌트 렌더링 → 화면 업데이트 → useEffect실행 컴포넌트 렌더링 → useLayoutEffect 실행 → 화면 업데이트 화면resize등 화면이 완전히 바뀌고 난 후에 실행 화면resize등 전에 실행 비동기적으로 실행됨 동기적으로 실행됨 렌더링 직후 DOM요소의 값을 읽을 때 유용함(scroll position등) DOM과 인터렉션이 없는 경우에 사용(대부분 경우) DOM을 mutate할 경우에 사용 but 실무에서 사용할 경우가 드물다 참고 리액트, 제대로 알고 개발하기 pt.2 ( Hooks는 쓰레기? ) 제로초 리액트 무료강좌(웹게임)","link":"/2021/03/23/210324React-Hooks/"},{"title":"[리액트] state나 props 변경시 성능향상 방법","text":"React어플리케이션 성능향상 방법React에서 state나 props가 변경되었을때 render가 진행되는데 값이 없는 setState() 호출에도 rendering이 된다.이게 쌓이면 성능이 저하된다. 이를 해결하는 방법을 알아보자. class인 경우state나 props가 변경되었을때 성능을 위해 shouldComponentUpdate(){} 또는 PureComponent를 쓸 수 있다.PureComponent란 shouldComponentUpdate()를 구현해놓은 컴포넌트이다.shouldComponentUpdate()는 배열이나 객체에 변경이 있는 경우 변경사항을 인지하지 못할 수 도 있다. → 새로운 배열을 만들고 싶다면 [...기존arr, 1] 복사해서 사용해야한다.따라서 shouldComponentUpdate()보다는 PureComponent 를 쓰는 것이 좋다. 123456shouldComponentUpdate(prevProps, prevState) { return this.props.data !== prevProps.data; }//더 편하게import React, { PureComponent } from 'react'; Hooks인 경우PureComponent와 shouldComponentUpdate가 없다. 그대신 memo(memoization의 약자)를 사용한다.훅스할때는 state들을 최상위로 빼야한다. 그렇지 않고 if조건문에 state를 넣으면 에러가 발생한다. 1234567891011121314151617181920212223//함수 컴포넌트. 이건 그냥 함수 컴포넌트import React, { memo } from \"react\";const Ball = memo(({ number }) =&gt; { let background; if (number &lt;= 10) { background = \"red\"; } else { background = \"green\"; }}//Hooks : useRef, useState, useCallback등을 사용하고 함수 컴포넌트인 것import React, { useRef, useState, useCallback } from \"react\"; const Ball = memo(({ number }) =&gt; { let background; if (number &lt;= 10) { background = \"red\"; } else { background = \"green\"; }}","link":"/2021/03/23/210324React-managementofcomponent/"},{"title":"[리액트] this.state 귀찮을땐 구조분해","text":"리액트를 클래스형 컴포넌트로 사용하게되면 계속 this.state를 써줘야하는 불편함이 있다.이를 구조분해문법으로 해결할 수 있다. 기존코드1234567//기존return ( &lt;&gt; &lt;h1&gt;{this.state.value}&lt;/h1&gt; &lt;h1&gt;{this.state.answer}&lt;/h1&gt; &lt;/&gt;) 구조분해문법사용 코드12345678//구조분해문법사용const { value, answer } = this.state;return ( &lt;&gt; &lt;h1&gt;{value}&lt;/h1&gt; &lt;h1&gt;{answer}&lt;/h1&gt; &lt;/&gt;) 참고 제로초 리액트 무료강좌(웹게임)","link":"/2021/03/29/210330React-Destructuringassignment/"},{"title":"컨테이너, 도커, 쿠버네티스","text":"새로운 프로젝트를 진행하면서 팀장급 회의가 있었다. 신규 프로젝트는 어떻게 구성하는 지, 의사결정은 어떻게 이루어지는 지 너무너무 궁금해서 팀장님들 회의에 서기로라도 참석하고싶었지만… 나는 신입이기때문에… 참여할 수 없었다. 하지만 팀전체에 공유된 회의 참고자료를 볼 수 있었고 내가 들어만 봤던 도커와 쿠버네티스라는 단어가 보였다. 이참에 완전히 정리해보려고한다. 컨테이너(Container)쿠버네티스를 알려면 도커를 알아야하고 그럴러면 컨테이너를 알아야한다. 컨테이너란 다양한 프로그램, 실행환경을 패키지로 묶어 추상화하여 격리 환경을 만드는 것 컨테이너를 통해 동일한 인터페이스를 제공할 수 있어 프로그램의 배포 및 관리를 단순하게 해준다.컨테이너는 가상머신(VM)과 비교할 수 있다. VM의 경우 Guest OS가 올라가기때문에 컨테이너보다 훨씬 무겁다. 가상머신 서버 컨테이너서버 가상 머신의 모든 자원을 사용 운영체제의 자원을 필요한 만큼 격리하여 컨테이너에 할당 도커(Docker) 컨테이너기반의 오픈소스 가상화 플랫폼 도커의 작동 순서 코드개발 Dockerfile 생성: Image파일만 생성하면 변경사항을 확인할 수 없기때문에 이미지내용을 코드화함 Dockerfile Image 생성: 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것을 이미지화한다.(Immutable) Container Orchestrator를 통한 배포 : Kubernetes, Docker Swarm, Rancher, Apache Mesos등의 컨테이너 오케스트레이션 툴을 사용 Container run Container image Push 쿠버네티스(Kubernetes) 컨테이너를 관리를 위해 나온 오픈소스 플랫폼컨테이너 역시 그 수가 많아지게 되면 관리와 운영에 있어서 어려움이 따르는데 이를 관리하고 조율하는 시스템 중 하나가 바로 쿠버네티스이다. 쿠버네티스 시작하기 - Kubernetes란 무엇인가? 참고참고라고 적어놓고 필독이라고 읽는다. 하나하나 꼭 읽어봐야한다.특히 Container 시리즈는 정말 주옥같다. Container 시리즈 전체 Docker와 쿠버네티스의 이해 Linux) Doker와 Container의 탄생과 설명, 차이점","link":"/2021/03/28/210329Container/"},{"title":"[리액트] 반복문map, import와 require차이, 자잘한 팁","text":"리액트의 자잘한 팁을 정리해보았다. 자잘한 팁 state에 객체 구조를 안쓰는 것이 좋다 render안에는 절대 setState()를 쓰지않는다 → setState()되면 랜더링이 실행되기때문에 랜더링이 실행되면 또 setState()가 실행되고 이 부분이 무한 반복되기때문. 부모한테서 받은 props를 바꾸고싶을때는 useState()를 이용하여 state로 만들고 그 state를 바꿔준다 → 자식이 props를 바꾸면 부모 props도 바뀌기때문. Props는 상속이다. Props를 보면 항상 그 부모 컴포넌트를 생각해야한다. 그 부모 컴토넌트의 조상 컴포넌트가 있을 수 있다. 리액트 용어정리 용어 설명 리액트 redux 리액트의 컴포넌트가 많아지면 컴포넌트간의 교류가 빈번해진다. 중앙에 데이터 저장소를 만들고 그 저장소의 데이터가 변경되면 관련된 모든 컴포넌트에 영향을 미친다. 리액트 server side rendering 서버쪽에서 웹페이지를 완성한 후에 클라이언트로 완성된 html 전송하는 걸로 애플리케이션 구동가능 → 초기구동시간 단축가능 + 로딩필요없는 애플리케이션 가능 + 검색엔진로봇이 웹페이지 분석가능 리액트 native 하나의 코드로 거의 모든 플랫폼에서 동작하는 애플리케이션을 만들 수 있다. 리액트의 반복문 리액트의 반복문은 map을 사용할 것배열을 1대1로 짝짓는 것이 map이다.map은 입력과 출력의 값이 동일해야한다 → 배열의 요소를 지우고 싶다면 filter를 써야한다. import와 require차이외부라이브러리를 불러오는 방법은 2가지가 있다.외부라이브러리인 MomentJS를 불러온다고 가정해보자. 1234567//1번방법//노드의 문법으로 require써야한다.const moment = require(\"moment\")//2번방법//바벨이 import 쓴 부분을 자동으로 require로 바꿔주기때문에 require와 import 리액트에서는 둘 다 쓸 수 있다import moment from \"moment\" require 방법 import 방법 NodeJS에서 사용되고 있는 CommonJS 키워드 ES6(ES2015)에서 새롭게 도입된 키워드 복수객체내보내기: exports.객체명 = 객체명 복수객체내보내기: export { 객체명 } 단일객체내보내기: module.exports = 객체명 단일객체내보내기: export default키워드사용 자바스크립트 CommonJS 모듈 내보내기/불러오기 (require) 예시 자바스크립트 ES6 모듈 내보내기/불러오기 (import) 예시 두 방법 중 실무에서 더 많이 사용하는 방법은 import 방법이다.아무래도 ES6 모듈 시스템이 좀 더 최신이므로 CommonJS 방식 대비 여러 강점이 있다. CommonJS 대비 ES6모듈 시스템의 강점 모듈관리 전용 키워드 사용(import,from,export,default)하여 코드 가독성 높음 비동기방식으로 성능과 메모리부분이 유리 Named Parameter기능지원 참고 제로초 리액트 무료강좌(웹게임) 제로초 ES2015(ES6) 모듈 시스템","link":"/2021/03/29/210330React-tip/"},{"title":"[리액트] reducer, action, dispatch의 관계","text":"리액트는 기본적으로 하나의 루트 컴포넌트(보통 App.js)에서 상태를 관리한다.리액트의 컴포넌트가 많아지면 컴포넌트간의 교류가 빈번해진다. 중앙에 데이터 저장소를 만들고 관리하면 더 편하다. 그것이 바로 Redux이다.리덕스의 데이터가 변경되면 관련된 모든 컴포넌트에 영향을 미친다. reducer, action, dispatch의 관계 state안에 데이터가 있다면 → 직접 수정 불가능 수정하고 싶으면 action을 만들어서 수정해야함 action을 만든 후 dispatch에 하면 state 수정가능 action은 기본적으로 대문자+스네이크표기법 사용 reducer : state를 어떻게 바꾸는 지를 switch 문을 사용하여 적으면 됨 Dispatch 방법 props 사용 단점 : 부모-자식 컴포넌트 구조에서는 계속 dispatch를 넘겨줘야하므로 번거롭다. 즉, List → Table → Tr → Td 구조에서 Td에서 dispatch를 사용하고 싶다면 불필요하게 Table, Tr에도 dispatch를 넘겨줘야한다. 12345678910111213//List에서 Td로 바로 dispatch넘겨줄수가 없으므로 Table로 넘겨주기&lt;Table dispatch={dispatch} /&gt;//Table에서 Tr로 넘겨주기&lt;Tr dispatch={dispatch} /&gt;//Tr에서 Td로 넘겨주고 &lt;Td dispatch={dispatch} /&gt;//Td에서 dispatch 사용하기const onClickForm = useCallback(() =&gt; { dispatch({ type: CLICK_CELL, row: rowIndex, cell: cellIndex }); }, []); context API사용 123456789101112131415161718192021222324252627//초기값export const TableContext = createContext({ tableData: [], halted: true, dispatch: () =&gt; {},});const Minesweeper = () =&gt; { const [state, dispatch] = useReducer(reducer, initialState); const value = useMemo(() =&gt; ({ tableData: state.tableData, dispatch }), [ state.tableData, ]); return ( // 자식컴포넌트들이 tableData와 dispatch에 접근 가능 &lt;TableContext.Provider value={value}&gt; &lt;Form /&gt; &lt;div&gt;{timer}&lt;/div&gt; &lt;Table /&gt; &lt;div&gt;{result}&lt;/div&gt; &lt;/TableContext.Provider&gt; );};// 자식 컴포넌트에서 사용하는 법const onClickBtn = userCallback(() =&gt; { dispatch({ type: START_GAME, row, cell, mine }); }, [row, cell, mine]); 참고 제로초 리액트 무료강좌(웹게임) 리덕스(Redux)를 왜 쓸까? 그리고 리덕스를 편하게 사용하기 위한 발악 (i)","link":"/2021/03/29/210330React-Redux/"},{"title":"JSON데이터를 어떻게 DB에 넣을까?","text":"오늘 또 못알아듣고 말았습니다. xAPI를 사용하기위해서는 JSON데이터를 LRS에 수집해야한다. JSON데이터를 어떻게 저장할 수 있을까?내가 알고있는 건 데이터 저장 = DB이기때문에 DB에 테이블을 생성하여 어떻게 JSON데이터의 KEY, VALUE, DEPTH를 잘 넣을 수 있는 지 고민했다.xAPI에서 필수적인 데이터들로만 이루어져있는 JSON데이터 예시가 있다.이 데이터를 어떻게 수집해야 추후에 편하게 DB분석하고 쿼리로 꺼내쓸 수 있을까? 123456789101112131415{ \"id\": \"12345678-1234-5678-1234-567812345678\", \"actor\":{ \"mbox\":\"mailto:xapi@adlnet.gov\" }, \"verb\":{ \"id\":\"http://adlnet.gov/expapi/verbs/created\", \"display\":{ \"en-US\":\"created\" } }, \"object\":{ \"id\":\"http://example.adlnet.gov/xapi/example/activity\" }} 일단은 DEPTH랑 상관없이 모든 키를 컬럼으로 만들면 어떨까 생각해보았다. 12컬럼id, actor, mbox, verb, id, display, en-US, object, id 그렇게되면 key가 추가되는 경우에는 어떻게 할까하는 생각이 들었다.xAPI는 구성요소의 유연성이 있기때문에 필요에 따라 Property가 추가 될 수 있어야했다. 💬오늘의 대화오늘 팀장님과의 대화를 요약했다. 이 대화에서 모르는 부분들을 속속들이 알아보자! 팀장님 나 팀장님 JSON데이터를 DB에 넣고싶은데 이러이러합니다. 괜찮을까요? 음 JSON 데이터는 한 컬럼에 집어 넣는게 좋습니다. 그럼 데이터타입이 엄청 커져야하지않을까요? 한 컬럼에 JSON데이터를 넣으면 최대값을 가뿐히 넘길 수도 있을 것 같은데 그럴경우 어떻게 해야할까요? VARCHAR말고 CLOB, BLOB같은 다른 데이터 타입을 알아보세요 하지만 해당 데이터타입은 쿼리짤때 상그러울수있어요. 마이그레이션하기도 골치아프고, 바이너리데이터가 들어가서 데이터 분석이 힘들기도하구요. ✍️배움포인트 MySQL기준 VARCHAR를 데이터타입으로 지정할때 최대값은 4000이다. 즉, VARCHAR(4000)까지 가능 CLOB, BLOB이란 DB 마이그레이션: 여러 DB를 하나의 DB로 합치거나, 기존의 DB를 다른 DB로 옮기는 경우 등 DB를 이동시키는 작업을 의미함. 바이너리데이터: 이진수로 표시한 데이터 🆚CLOB VS BLOB 차이 VARCHAR CLOB(Character Large Object) BLOB(Binary Large Object) 문자열을 표현할때 사용하는 데이터 타입 사이즈가 큰 데이터를 외부 파일로 저장하기 위한 데이터 타입 바이너리 데이터를 DB외부에 저장하기 위한 타입 최대 4000BYTE 문자열 -변환-&gt; CLOB타입 경우, 최대 길이: 외부 저장소에서 생성 가능한 파일 크기(최대 4GB) 문자열 -변환-&gt; BLOB타입 경우, 최대 길이: 외부 저장소에서 생성 가능한 파일 크기(최대 4GB) 가변길이 문자열 저장 가변길이 문자열 저장 가변길이 문자열 저장 큰 텍스트 데이터 ( text ) 용 바이너리 데이터 ( 비디오, 이미지, 문서, 기타 ) 용 SQL문에서 문자열 타입으로 입출력 값을 표현함 SQL문에서 비트열 타입으로 입출력 값을 표현함 🤔standard xAPI DB Architechture 나 schema가 있을까? 아니요, 표준 LRS데이터베이스 스키마가 없으며, LRS 구현자는 자신의 데이터 스토리지 아키텍처를 자유롭게 선택할 수 있습니다.보통은 아래 두 가지로 초기 LRS를 구현합니다. traditional relational structures를 사용하여 구현 NoSQL data stores를 사용하여 구현다행히도 xAPI를 사용하면 이기종간의 표준화된 데이터베이스 스키마가 필요하지 않습니다.xAPI 그 자체로도 LRS간의 pull 또는 push가 자유롭게 가능합니다답변의 출처 바로가기만약 xAPI를 처음 시작하는 개발자라면 스키마 구현이 어려울 수 있습니다. 파이썬을 활용한 예시(바로가기)를 참고하셔도 좋습니다.CouchDB를 backing store LRS로 고려해볼 수 있습니다. CouchDB는 NoSQL JSON document store로 http API가 내장되어있고 JS 함수(map, reduce 등)를 사용하여 쿼리를 만들 수 있습니다. 참고 https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#24-statement-properties https://jeonggi.tistory.com/45 https://m.blog.naver.com/PostView.nhn?blogId=rlasksdud53&amp;logNo=220595010315&amp;proxyReferer=https:%2F%2Fwww.google.com%2F https://lottoking.tistory.com/3938","link":"/2021/04/01/210402jsondataDBmodeling/"},{"title":"[스프링부트]Springboot REST API","text":"Springboot에서 REST API(REST API개념 바로가기)를 테스트해보자.스프링부트 프로젝트 기본설정은 아래와 같다. 스프링부트 기본 설정 Project: Gradle Project Spring Boot: 2.4.4 (SNAPSHOT)은 개발진행중인 베타버전을 뜻 함. (SNAPSHOT)없는 버전으로 선택하기 Language: Java Packaging: Jar Java: 8 Dependencies: Spring Web port바꾸기기존 포트는 80 또는 8080이다.이미 8080포트를 다른 프로젝트에서 사용중이라면 application.properties에서 손쉽게 포트를 변경할 수 있다.만약 포트를 9090으로 바꾸고 싶다면 아래처럼 설정해주면 된다. 1server.port=9090 RestAPI RestAPI를 공부하다보면 멱등성 지원해야한다고 등장하곤한다.멱등성이란 무엇일까? 멱등성: 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질 예를들어 아래와같은 PUT메서드 있다고 해보자. 1234567요청PUT /api/events/{id}{ &quot;type&quot;: : &quot;ACCEPT&quot; // ACCEPT/REJECT}응답200 OK 위 PUT메서드를 처음 호출해서 ACCEPT로 바꾼 뒤 한 번 더 호출했을때 이미 ACCEPT인데 ACCEPT요청이 중복이라고 에러가 발생한다면? 이건 멱등성을 지원하지 않는 것이다.멱등성 지원이 잘 된 경우에는 PUT메서드 호출시 이미 ACCEPT인 경우 그냥 200 OK로 응답하는 것을 말한다.이런 멱등성을 지켜줘야하는 메서드는 보통 POST메서드 빼고 다~ 멱등성있는 API를 지원해야한다. 파라미터종류 PathVariable 12345@GetMapping(\"/path-variable1/{name}\")public String pathVariable1(@PathVariable String name) { System.out.println(\"pathVariable1: \"+name); return name;} Query parameter 123456789// 파람이 3개이상되면 너무 많아지므로 DTO를 만들어서 처리하는 것이 좋다.@GetMapping(\"/query-param2\")public String queryParam2( @RequestParam String name, @RequestParam String email, @RequestParam int age ) { return name+\" / \"+email+\" / \"+age;} Data Body 1234 @PostMapping(\"/postdto\")public void postDTO(@RequestBody postDTO dto) { System.out.println(dto);} 사용한 어노테이션 어노테이션 설명 사용예시 @RestController 해당 class는 REST API 처리하는 Controller @Controller return값이 String인 경우 text가 아닌 해당 String값의 html파일을 찾아서 리턴함 @RequestMapping URI를 지정해주는 어노테이션으로 get/post/put/delete 다 작동함. method속성을 이용하여 한 가지방식을 선택할 수 있음, 옛날방식 @RequestMapping(path=”/hi”, method= RequestMethod.GET) @GetMapping, @PostMapping, @DeleteMapping, @PutMapping @RequestMapping의 최근방식 @GetMapping(“/hello”), @PostMapping(“”), @DeleteMapping(“/{userId}”), @PutMapping(“”) @RequestBody post보낼때 필수 @RequestBody postDTO dto @JsonProperty 1개의 변수를 다른 @JsonProperty(“phone_number”) @JsonNaming DTO 전체 JSON형태를 지정함SnakeCaseStrategy, UpperCamelCaseStrategy, @JsonNaming(value = PropertyNamingStrategy.SnakeCaseStrategy.class) @JsonInclude JSON데이터에 포함할 속성을 지정 @JsonInclude(JsonInclude.Include.NON_NULL) null값은 빼고 JSON데이터에 담음 UpperCamelCaseStrategy : “userName” would be converted to “UserName”. @RequestBody vs @RequestParam vs @PathVariable 구분 설명 주 사용처 URL ContentType @PathVariable URL경로에 변수를 넣는것 주로 Rest api에서 사용 http://localhost:8080/page/2 @RequestParam URL 파라미터로 값을 넘기는 방식 GET방식에서 주로 게시판 등에서 페이지 및 검색 정보를 함께 전달할 때 사용 http://localhost:8080/page?page=2&amp;pageIdx=77 application/x-www-form-urlencoded; charset=UTF-8 @RequestBody Body 자체를 넘기는 방식으로 POST 에서만 사용 가능함. JSON형태로 전달된 데이터를 해당 파라미터 타입에 자동으로 저장하기때문에 변수명 상관없음 POST방식으로 주로 객체단위로 사용 http://localhost:8080/page application/json; UTF-8; 추가자료: post요청과 content-type의 관계 GET RestAPI12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@RestController // 의미: 해당 class는 REST API 처리하는 Controller다.@RequestMapping(\"/api/get\") // URI를 지정해주는 어노테이션이다. get/post/put/delete다 작동함 public class GetAPIController { // @RequestMapping를 사용하면 get/post/put/delete 다 작동가능 // method속성을 이용하여 한 가지방식을 선택할 수 있음 =&gt; 옛날방식으로 요즘은 GetMapping을 사용함 @RequestMapping(path=\"/hi\", method= RequestMethod.GET) public String getHi() { return \"하이 getHi @RequestMapping사용\"; } // http://localhost:9090/api/get/hello @GetMapping(path=\"/hello\") public String getHello() { return \"헬로 getHello @GetMapping사용\"; } // PathVariable // http://localhost:9090/api/get/path-variable/{name} @GetMapping(\"/path-variable1/{name}\") public String pathVariable1(@PathVariable String name) { System.out.println(\"pathVariable1: \"+name); return name; } // PathVariable 이용시 이름 매칭이 어려울시 // PathVariable(name=\"\")속성을 이용하면 된다. // 기존에 받아와야할 인수명이 name인경우 PathVariable 이름과도 중복이 된다. // 이때 PathVariable(name=\"name\")속성을 이용하여 @GetMapping의 {name}과 동일하게 처리해준다. @GetMapping(\"/path-variable2/{name}\") public String pathVariable2(@PathVariable(name=\"name\") String pathName, String name) { System.out.println(\"pathVariable2: \"+pathName); return pathName; } // Query parameter // 주로 검색할때 사용하는 인자로 URL의 물음표(?)의 뒷부분으로 &amp;연산자를 기준으로 키=밸류 값이 이어진다. // @RequestParam을 꼭 붙여줘야한다. // http://localhost:9090/api/get/query-param?user=소원데브&amp;email=sowon-dev@이메일.com&amp;age=77 @GetMapping(\"/query-param\") public String queryParam(@RequestParam Map&lt;String, String&gt; queryParam) { StringBuilder sb = new StringBuilder(); // @RequestParam인자를 Map을 사용한 경우 아무 인자 다 받을 수 있어서 key값이 명시적인경우 get으로 이름을 지정해서 사용해야한다. // 이메일을 불러오는 경우 // queryParam.get(\"email\"); // 명시적인 인자의 경우 아래 queryParam2를 사용하는 것이 좋다 queryParam.entrySet().forEach( entry -&gt; { sb.append(entry.getKey() + \" : \" + entry.getValue()+\"\\n\"); System.out.println(sb.toString()); }); return sb.toString(); } // @RequestParam인자를 Map을 사용한 경우 아무 인자 다 받을 수 있어서 key값이 명시적인경우 // 받을 수 있는 인자가 명확하다면 아래처럼 명시적으로 인자를 받는 것이 좋다. // 명시적인 경우 int형에 문자열을 넣으면 에러 발생 -&gt; 클라이언트 에러인것을 확인할 수 있다. // 파람이 3개이상되면 너무 많아지므로 DTO를 만들어서 처리하는 것이 좋다. @GetMapping(\"/query-param2\") public String queryParam2( @RequestParam String name, @RequestParam String email, @RequestParam int age ) { return name+\" / \"+email+\" / \"+age; } // 가장 추천하는 방법 // 중요한 점은 @RequestParam를 붙이지 않는다 // http://localhost:9090/api/get/query-param3?name=소원데브&amp;email=sowon-dev@이메일.com&amp;age=77 @GetMapping(\"/query-param3\") public String queryParam2(userRequest user) { return user.toString(); } } Post RestAPI1234567891011121314151617181920@RestController // 의미: 해당 class는 REST API 처리하는 Controller다.@RequestMapping(\"/api/post\") // URI를 지정해주는 어노테이션이다. get/post/put/delete다 작동함 public class PostAPIController { // post로 보낼때는 바디에 데이터를 실어보낸다고 표현도 함 // post로 보낼때는 @RequestBody 꼭 붙여줘야함 // Map으로 받으면 어떤 데이터가 들어오는 지 한 눈에 확인이 불가능하기때문에 DTO를 사용하는 것이 좋다. @PostMapping(\"\") public void post(@RequestBody Map&lt;String, String&gt; requestData) { requestData.entrySet().forEach( stringObjectEntry -&gt; { System.out.println(stringObjectEntry.getKey() + \" : \"+ stringObjectEntry.getValue()); }); } @PostMapping(\"/postdto\") public void postDTO(@RequestBody postDTO dto) { System.out.println(dto); }} html페이지를 리턴하는 컨트롤러12345678910111213141516171819@Controller //html 리소스파일을 찾는 컨트롤러public class PageController { @RequestMapping(\"/main\") public String main() { return \"main.html\"; //@Controller을 사용하면 text가 아닌 해당 String값의 html파일을 찾아서 리턴한다. } //ResponseEntity @ResponseBody @GetMapping(\"/car\") public Car car() { Car car = new Car(); car.setCarName(\"마티즈\"); car.setCarNumber(123456); return car; } } carDTO12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.databind.PropertyNamingStrategy;import com.fasterxml.jackson.databind.annotation.JsonNaming;@JsonNaming(value = PropertyNamingStrategy.SnakeCaseStrategy.class)@JsonInclude(JsonInclude.Include.NON_NULL) //null값은 빼고 body에 담는다.public class Car { private String carName; private int carNumber; private Integer price; //int는 default값이 0이고 Integer는 null이다. //디폴트 생성자 public Car() { this.carName = null; this.carNumber = 0; this.price = null; } public Car(String carName, int carNumber, Integer price) { super(); this.carName = carName; this.carNumber = carNumber; this.price = price; } public Integer getPrice() { return price; } public void setPrice(Integer price) { this.price = price; } public String getCarName() { return carName; } public void setCarName(String carName) { this.carName = carName; } public int getCarNumber() { return carNumber; } public void setCarNumber(int carNumber) { this.carNumber = carNumber; } @Override public String toString() { return \"Car [carName=\" + carName + \", carNumber=\" + carNumber + \", price=\" + price + \"]\"; }} Response 내려주는 3가지 방법 text형태 json형태 ResponseEntity형태(권장방법) 1234567891011121314151617181920212223242526import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.example.demo.dto.putDTO;@RestController@RequestMapping(\"/api/put\") public class PutAPIController { @PutMapping(\"/{userId}\") public putDTO put(@RequestBody putDTO dto, @PathVariable(name=\"userId\") String id) { System.out.println(id); return dto; } // ResponseEntity형태(권장방법) @PutMapping public ResponseEntity&lt;putDTO&gt; putResponse(@RequestBody putDTO dto) { return ResponseEntity.status(HttpStatus.CREATED).body(dto); }} 참고패스트캠퍼스 초격차패키지 Java/Spring 웹개발 마스터 강의를 들으며 공부한 내용입니다.","link":"/2021/04/11/210412SpringBootAPI/"},{"title":"[자바JAVA]백준 10818 최소, 최대 풀이","text":"문제N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오. https://www.acmicpc.net/problem/10818 입출력예시 123456//입력520 10 35 30 7//출력7 35 풀이코드1: Math함수 사용하기 memory 116352 runtime 420 만약 br.close() 추가하면 memory 116588 runtime 404 123456789101112131415161718192021public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); StringTokenizer st = new StringTokenizer(br.readLine()); // sol1 Math함수 사용하기 // memory 116352 runtime 420 -&gt; br.close()하면 memory 116588 runtime 404 int min = Integer.parseInt(st.nextToken()); int max = min; for(int i=1; i&lt;n; i++){ //i가 0이 아닌 1인 이유는 min, max 선언할때 5개의 숫자중 첫번째 토큰을 사용했기때문 int num = Integer.parseInt(st.nextToken()); min = Math.min(min, (num)); max = Math.max(max, (num)); } br.close(); System.out.println(min+\" \"+max); }} 풀이코드2: 배열정렬로 풀기 memory 114572 runtime 1000 br.close()추가 하면 memory 115624 runtime 1016 123456789101112131415161718192021public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); StringTokenizer st = new StringTokenizer(br.readLine()); // sol2 배열정렬로 풀기 // memory 114572 runtime 1000 -&gt; br.close()하면 memory 115624 runtime 1016 int i = 0; int[] arr = new int[n]; while(st.hasMoreTokens()) { arr[i] = Integer.parseInt(st.nextToken()); i++; } Arrays.sort(arr); System.out.println(arr[0] + \" \" + arr[n-1]); }} 풀이코드3: 배열없이 받은 문자 즉시 비교하기123456789101112131415161718192021222324public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); StringTokenizer st = new StringTokenizer(br.readLine()); // sol3 배열없이 받은 문자 즉시 비교하기 // memory 107004 runtime 472 int max = -1000001; int min = 1000001; while(st.hasMoreTokens()) { int val = Integer.parseInt(st.nextToken()); if(val&gt;max) { max = val; } if(val&lt;min) { min = val; } } System.out.println(min + \" \" + max); }} 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/04/04/210404al-backjoon-10818/"},{"title":"[자바JAVA]백준 2562 최댓값 풀이","text":"문제9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 번째 수인지를 구하는 프로그램을 작성하시오.예를 들어, 서로 다른 9개의 자연수 3, 29, 38, 12, 57, 74, 40, 85, 61 이 주어지면, 이들 중 최댓값은 85이고, 이 값은 8번째 수이다. https://www.acmicpc.net/problem/2562 입출력예시 1234567891011121314//입력32938125774408561//출력858 풀이코드1 memory 11476 runtime 76 12345678910111213141516171819202122232425262728public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int max = 0; //자연수가 주어지므로 선언을 Integer.MIN_VALUE이 아닌 0으로 함 int i = 0; //인덱스값 int[] arr = new int[9]; //서로 다른 9개의 자연수를 넣을 배열 // sol1 memory 11476 runtime 76 //배열에 숫자넣기 -&gt; 배열이 있어야지 index값을 구할 수 있음 for(i=0; i&lt;arr.length; i++){ arr[i] = Integer.parseInt(br.readLine()); max = Math.max(arr[i], max); } //배열 인덱스 구하기 for(int j =0; j&lt;arr.length; j++){ if(arr[j] == max){ i = j+1; } } System.out.println(max); System.out.println(i); }} 풀이코드2 : for문 한번만 사용하기 memory 11444 runtime 76 123456789101112131415161718192021222324public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int max = 0; //자연수가 주어지므로 선언을 Integer.MIN_VALUE이 아닌 0으로 함 int i = 0; //인덱스값 int[] arr = new int[9]; //서로 다른 9개의 자연수를 넣을 배열 // sol2 for문 한번만 사용하기 // memory 11444 runtime 76 for(int j=0; j&lt;arr.length;j++) { arr[j] = Integer.parseInt(br.readLine()); if(max &lt; arr[j]) { max = arr[j]; i = j+1; } } System.out.println(max); System.out.println(i); }} 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/04/04/210404al-backjoon-2562/"},{"title":"[ITWILL : DB] DB전체목록List","text":"🌱리눅스와 SQL 간단 리눅스명령어(복붙포함), Oracle 명령어, DB작동방법, 접속순서 virtualBox로 가상컴퓨터만들어서 리눅스Linux 설치하기 CUI환경 VS GUI환경, 리눅스명령어자세히, vi단축키 SQL DEVELOPER사용방법 🌱DB와 SQL개념 DB기초이론, DBMS 데이터베이스기초활용 DDL vs DML vs DCL 제약조건의 컬럼레벨과 테이블레벨문법, 제약조건 5가지, 버퍼에 있는 자주 사용할 쿼리구문을 저장하는 방법 select as from where, order by, 동일유저 동시접속 가능, 트랜잭션 commit과 rollback 트랜잭션(Transaction), 치환변수, save명령어, 리소스부족에러발생시 Data Dictionary 🌱Select 구문 Select 구문을 사용한 데이터 검색, null VS 0 VS 공백, Distinct 테이블 전체목록조회, 테이블구조조회, WHERE(조건문)절 Order by 정렬 🌱단일행함수 단일행함수 : 문자함수 단일행함수 : 숫자함수, 날짜함수 단일행함수 : 변환함수, 일반함수 단일행함수 : 조건부 표현식 🌱여러행함수 여러행함수 : 그룹함수 여러행함수 : Group by절, Having절 🌱중요 구문 JOIN Subquery1: Subquery개념, 중첩Subquery Subquery2: Inlineview, Scalar Subquery Subquery3: exists연산자, not exists연산자 Subquery4: with절 SQL 기억해야 할 쿼리 Top-N분석 🌱데이터조작어 (DML) / 데이터정의어 (DDL) 데이터조작어DML : insert/update/delete구문 데이터정의어DDL : table 생성 table 복사, varchar2와 varchar와 char비교 데이터정의어DDL : 테이블수정(컬럼수정, 제약조건수정, 컬럼명수정, 제약조건명수정), 테이블명변경, 테이블삭제, 테이블절단, truncate과 delete과 drop차이 🌱SQL의 OBJECT 종류 SQL의 OBJECT종류 : view SQL의 OBJECT종류 : 시퀀스(Sequence) SQL의 OBJECT종류 : 인덱스(Index), 시노님(Synonym) 🌱DB구조 Oracle DB구조1 : Database Oracle DB구조2 : Instance의 SGA메모리구조 Oracle DB구조3 : Instance의 Background process Oracle DB구조4 : 구조 완벽정리, 상활별 오라클 DB 순서 🌱DB구현 및 관리 Oracle DB생성방법 2가지, Oracle DB Tool, Parameterfile 유형 오라클의 Database 켜고 끄기 오라클의 Datafile 관리하기 DB유저관리 : user 생성, 권한부여 데이터충돌, DeadLock DB fail 유형 Controlfile다중화, Redoligfile다중화, 데이터베이스로그모드 DB BACKUP DB 복구(Recovery)","link":"/2020/10/29/DBList/"},{"title":"[ITWILL : Android] Android전체목록List","text":"🍫안드로이드기초 안드로이드 다운로드, 기본개념, 프로젝트 기본순서, 액티비티생명주기, 로그캣 안드로이드 4대 컴포넌트 🍫화면구성 컴파운드버튼(체크박스,라디오버튼,스위치,토글버튼) 한눈에 비교하기 레이아웃종류 및 레이아웃 안에서 자주 사용되는 속성 고급위젯: 아날로그시계,디지털시계,크로노미터,타임피커,데이트피커,캘린더뷰,자동완성텍스트뷰와 멀티자동완성텍스트뷰 옵션메뉴, 컨텍스트메뉴, 토스트 🍫기능 안드로이드 파일처리 이미지파일 넣기","link":"/2020/10/29/androidList/"},{"title":"[자바JAVA]백준 1110 더하기 사이클 풀이","text":"문제0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다.위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오. https://www.acmicpc.net/problem/1110 입출력예시1 12345//입력26//출력4 입출력예시2 12345//입력55//출력3 입출력예시3 12345//입력1//출력60 입출력예시4 12345//입력0//출력1 풀이코드1: Scanner 사용 memory 18356 runtime 228 123456789101112131415161718192021222324252627282930public class Main { public static void main(String[] args) throws Exception { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 입력 수가 10미만이면 n에 10을 곱함 if (n &lt; 10) n *= 10; int 첫째자리수 = 0; int 둘째자리수 = 0; int cnt = 0; int sum = n; while (true) { 첫째자리수 = sum / 10; 둘째자리수 = sum % 10; sum = 첫째자리수 + 둘째자리수; sum = 둘째자리수 * 10 + sum % 10; // 10이상의 수가 나왔을때 마지막 자리 수로 해야하기 때문 cnt++; if (sum == n) break; } System.out.println(cnt); }} 풀이코드2: BufferedReader 사용 memory 11500 runtime 84 메모리와 런타임에서 모두 버퍼리더가 스캐너보다 효율적이다.앞으로 버퍼리더로만 문제를 풀어봐야겠다. 123456789101112131415161718192021222324252627public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int tens = 0; //십의 자리의 수 int units = 0; //일의 자리의 수 int sum = n; int cnt = 0; while(true){ tens = sum/10; units = sum%10; sum = tens + units; sum = units*10 + sum%10; cnt++; if(n == sum){ break; } } System.out.println(cnt); }} 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/04/04/210404al-backjoon-1110/"},{"title":"dataStructureList전체목록List","text":"🗃️생활코딩 자료구조 자료구조와 알고리즘 차이, 배열 🗃️ITWILL자료구조 자료구조1 : Collections Framwork(Set계열, List계열) 자료구조2 : Stack클래스, Queue인터페이스, Map인터페이스","link":"/2020/12/06/dataStructureList/"},{"title":"백앤드 개발시 유용한 사이트모음","text":"UML(Unified Modeling Language 클래스 다이어그램 만들 수 있는 사이트 이클립스 마켓플레이스 검색 - ObjectAid UML Explorer : 이클립스에서 바로 사용가능 starUML : 가장 유명. 최근버전은 유료이므로 이전버전사용가능 draw creately genmymodel 변수명짓기 https://www.curioustore.com/#!/util/naming 시스템 아키텍처, 스택 아키텍쳐 https://www.cloudcraft.co/ 한눈에 시스템 구성도를 볼 수 있도록 그릴 수 있음 Systemizer 분산시스템의 하이레벨 아키텍처 디자인을 쉽게 표현하기 위한 다이어그램 도구 오픈소스 ER 다이어그램 깔끔한 ER다이어그램 오픈 API 카카오 API 홈페이지 : https://developers.kakao.com 네이버 API 홈페이지 : https://developers.naver.com/ 구글 API 홈페이지 : https://console.developers.google.com 페이스북 API 홈페이지 : https://developers.facebook.com/ 공공데이터 포털 : https://www.data.go.kr/ 기능 대신하는 서비스 검색엔진 : https://www.algolia.com 유저 비밀번호 관리기능 https://auth0.com/ 로그인/로그아웃/소셜로그인연동이 쉽다 https://aws.amazon.com/ko/cognito/ 아마존에서 만든 유저인증기능 트랜잭션이메일서비스(트리거나 이벤트 후 발송하는 메일링서비스로 한달에 1만통 무료로 사용가능) : https://www.mailgun.com/ SMTP를 더이상 사용할 필요가 없다! 마케팅용 이메일서비스 : https://mailchimp.com 웹사이트 보안 SSL Certificate (http를 https로 만들고싶을때) : https://letsencrypt.org/ 에러 리포팅 : https://sentry.io 실시간 채팅 : https://pusher.com 푸쉬알림 : https://onesignal.com/ 피드 : https://getstream.io/ 클라이언트 REST API를 쉽게 테스트하고 문서화 할 수 있는 swagger : https://swagger.io/tools/swagger-ui/ REST API인 경우 : https://insomnia.rest GraphQL API인 경우 : https://altair.sirmuel.design 배포 배포를 대신 해주는 헤로쿠 : https://www.heroku.com/ 히로쿠 무료 서버로 스프링부트 앱 배포하기 How to Deploy From SpringBoot - GitHub - Heroku (DevOps Step by Step Tutorial) 1년무료로 사용가능한 아마존 : https://aws.amazon.com/ AWS를 쓸까? Heroku를 쓸까? 그 선택의 기준은? 서버리스 https://aws.amazon.com/lambda/ https://cloud.google.com/functions/ 데이터베이스 https://aws.amazon.com/dynamodb/ : 25GB 무료 제공 https://cloud.google.com/firestore/ : 1GB 무료 제공 https://www.mongodb.com/cloud/atlas : 512GB 무료 제공 https://fauna.com/ : FaunaDB는 graphQL 서버리스 데이터베이스로 100 MB storage 무료 제공 파일 업로드 https://cloud.google.com/storage/ : 5GB 무료 제공 https://cloudinary.com/ : 25GB 무료 제공 분석 https://analytics.google.com/analytics/web/provision/#/provision https://www.hotjar.com https://mixpanel.com/","link":"/2020/12/03/freeToolListForBack/"},{"title":"프론트앤드 개발시 유용한 사이트 모음","text":"프론트앤드 웹스킬 한방에 정리한 사이트 Web Skills HTML레이아웃 &amp; CSS https://aperitif.io/builder/? https://csslayout.io/patterns/ : css 템플릿 http://nthmaster.com/ : css선택자 http://flukeout.github.io/ : css선택자를 이용한 게임(움직이는 사물의 선택자이름을 작성하면 통과됨) w3school CSS 효과 소스(힌트)얻기 : 웹에서 볼 수 있는 다양한 예시들 소스(슬라이드쇼,아코디언,모달,…) w3school 속성별 예시 소스 w3school 개별요소에 w3c에서 만든 CSS를 그대로 적용하기 colorzilla : 그라데이션 css3generator 추천색상팔레트(이미지에서 색상 추출가능) CSS 라이브러리 https://tailwindcss.com https://bulma.io 부트스트랩 무료탬플릿 페이지부트스트랩과 foundation을 사용하면 웹사이트가 다 비슷비슷해보이기 때문에 추천하지 않는다.CSS라이브러리를 통해 나만의 사이트를 만들어보자. https://themehunt.com/ https://startbootstrap.com/ㄴ https://onepagelove.com/templates/portfolio-templates w3school Template (바로 적용해서 확인가능) Free 부트스트랩 탬플릿1 Free 부트스트랩 탬플릿2 Free 부트스트랩 탬플릿3 Free 부트스트랩 탬플릿4 홈페이지 템플릿 무료사이트 홈페이지 레퍼런스 우수 사이트 모음 이미지맵 소스 생성기 UI설계도구 UI목업툴 UI디자인툴 카카오 오븐: 프로토타이핑툴, QR코드 또는 URL로 공유가능 Figma 피그마 🌟 : 그래픽편집기, 프로토타이핑툴, 브라우저기반으로 실시간 협업가능 파워목업 : 파워포인트에 플러그인으로 목업 기능을 사용 가능 Sketch 스케치+Zeplin 제플린: 스케치는 맥 os기반 그래픽편집기, 프로토타이핑툴이기때문에 협업을 위해 제플린으로 파일공유해야하는 불편함있음 참고 : UI 디자이너 툴 총정리 참고 : Sketch에서 Figma로 환승 후기 서체 사이트 구글웹폰트 naver : 한글서체 많음 https://www.dafont.com/ https://www.1001fonts.com 이미지 무료사이트 https://pexels.com https://morguefile.com https://pixabay.com https://unsplash.com 🌟 호스팅 및 배포 사이트정적사이트 배포 https://pages.github.com/ GitHub와 Netlify를 이용한 쉽고 빠른 HTTPS 무료 호스팅 : https://www.netlify.com/ 추가 도움이 되는 영상 : 웹 서비스 구현의 모든 것! 무료 제작툴 39개 몽땅 알려드림! by 노마드코더","link":"/2020/07/14/freeToolListForFront/"},{"title":"기획시 유용한 사이트 모음","text":"서비스 기획 및 협업툴 Azure DevOps http://trello.com/ https://www.notion.so/ Chart, Diagram 만들기 Mermaid Live Editor 기술스택 stackshare: 회사별 기술스택을 확인할 수 있는 사이트. 벤치마킹용으로 추천 miro : 스택아키텍쳐를 쉽게 그릴 수 있는 사이트. 기타 : 무료 이북 WikiDocs 예제로 배우는 ORACLE 11g 온라인 책","link":"/2020/12/03/freeToolListForPM/"},{"title":"[ITWILL : JAVA] JAVA전체목록List","text":"🌳자바기초 컴퓨터와 자바 기초이론 자바접근자 public과 private, 자바 데이터 형태, 모든 연산자들, A++과 ++A의 차이, (조건)? TRUE:FALSE Scanner라이브러리와 equals()를 이용한 사칙연산계산기, if문과 switch문 변환 예시, 반복문과 break Method, 변수와 상수, 배열 Array, new키워드 기본 반복문암기, String인지 체크(typeof), N개의 양수를 받아 최대값 출력, char와 String의 차이점 산술연산자 리터럴(literal), byte + byte가 왜 에러날까, int VS Integer, void와 int차이 비트연산자, 이진수와 십진수 변환 자바포맷스트링, Random 숫자 뽑기, 상황별 반복문 추천(for, while, do~while) 369게임만들기 배열과 함께쓰는 메서드 🌳클래스 객체지향언어, 클래스 : 멤버변수vs지역변수 클래스 : 메서드, 객체생성(객체화 = 인스턴스화), 오버로딩(overloading) 클래스 : 생성자, new역할, this키워드용법 클래스 : 매개변수위치에 따른 차이(생성자 vs 메서드), private멤버변수 getter와 setter로 가져다쓰기 클래스 : 상속, 메서드 오버라이딩, super() 클래스 : 다형성(Polymorphism) 클래스 : 패키지, 임포트, 접근제어자, 데이터 은닉과 보호, 싱글턴디자인패턴 🌳기본클래스 이외에 자바 구성요소 기본클래스 이외에 자바 구성요소1 : 추상클래스, 인터페이스 기본클래스 이외에 자바 구성요소2 : enum 기본클래스 이외에 자바 구성요소3 : annotation, generic 🌳자바개념 예외처리 로깅, 디버깅 내부클래스 람다식개념, 인터페이스 Comparator 람다식을 이용한 함수형 프로그래밍1 : 계열 람다식을 이용한 함수형 프로그래밍2 : 메서드 🌳java.lang패키지 java.lang패키지1 : Object클래스의 메서드(equals(), hashcode(), clone(), getClass() java.lang패키지2 : System클래스의 메서드 java.lang패키지3 : String클래스의 메서드, StringBuffer와 StringBuilder 클래스의 메서드 java.lang패키지4 : Math클래스, Wapper클래스 🌳유용한 클래스 날짜 및 시간 처리하는 클래스의 변천사 포맷팅클래스 : StringTokenizer, DecimalFormat, SimpleDateFormat, MessageFormat 정규표현식, 자주 사용하는 정규식 숫자처리클래스 : java.util.Random, java.math.BigInteger, java.math.BigDecimal 🌳컬렉션 프레임워크 컬렉션 프레임워크1: Set과 List계열 예시위주 컬렉션 프레임워크2: Map계열 자세히, 예시 🌳I/O I/O1: 스트림개념, 노드스트림 I/O2: 노드스트림 - 파일기반 입/출력처리 I/O3: 보조스트림 I/O3: NIO 🌳멀티스레드 프로그래밍 멀티스레드프로그래밍1 : 멀티스레드프로그래밍1 : 개념, 용어정리, 스래드 상태와 제어 멀티스레드프로그래밍2 : 풍선게임 멀티스레드프로그래밍3 : 멀티스레드의 문제점과 해결 멀티스레드프로그래밍4 : 스레드 풀을 활용한 구구단 🌳스트림 API 스트림 API 개념","link":"/2020/09/07/javaList/"},{"title":"[스프링SPRING]MAVEN REPOSITORY, My(i)Batis설치","text":"Maven(메이븐) 빌드도구 중의 하나 필요한 라이브러리 코드들을 아래 공식 메이븐레파지토리에서 복사한 뒤 pom.xml에 붙여넣어서 사용 및 관리 메이븐 공식 레파지토리(MAVEN REPOSITORY) 사이트에 접속한 뒤 검색해서 원하는 것을 클릭한 후 코드를 복사해서 pom.xml의 test주석부분의 &lt;dependencies&gt;태그 안에 붙여넣기하면 된다 검색한 뒤 어떤 버전을 쓸지 모르겠다면? Usages가 가장 많은 것을 받으면 된다. 라이브러리 에러 해결방법 두 가지 프로젝트 우클릭 &gt; Maven &gt; project update (해당 파일 동기화) C:\\Users\\ITWILL.m2\\repository 폴더에 저장 되고 프로젝트 (강제로 삭제후 STS 재실행) MyBatis(iBatis)란 SQL MAPPER 라이브러리 스프링 프레임워크와 같이 활용하여 효율적인 SQL 처리 반복되는 try~catch 구문, pstmt, rs 객체를 대신 처리 코드양이 줄어드는 장점 XML/애노테이션 형태로 SQL구문 사용가능 하지만 보통 XML로 쿼리구문작성한다. 스프링과 자동으로 연동되어 처리되는 라이브러리를 제공한다. 장점 : 동적 SQL문 사용가능 동적 SQL구문이란 SQL구문안에 반복문과 조건문 사용가능한 형태 MyBatis(iBatis) 사용 방법 2가지 MyBatis 설치메이븐 레포지토리에서 아래와 같이 4개의 라이브러리 코드를 복붙한다. 메이븐 레포지토리에서 mybatis의 코드 복사하여 pox.xml에 붙여넣기 메이븐 레포지토리에서 mybatis-spring의 코드 복사하여 pox.xml에 붙여넣기 스프링과 마이바티스를 연결하는 라이브러리 메이븐 레포지토리에서 Spring-JDBC의 코드 복사하여 pox.xml에 붙여넣기 스프링과 JDBC를 연결하는 라이브러리 1234567891011121314151617181920212223242526272829&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;//위의 코드 두 개를 버전 수정 &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${org.springframework-version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${org.springframework-version}&lt;/version&gt; &lt;/dependency&gt; 메이븐 레포지토리에서 Spring-test의 코드 복사하여 pox.xml에 붙여넣기 스프링과 마이바티스의 연결을 확인하는 라이브러리 (Junit의 역할) MyBatis로 DB연결위의 4가지 라이브러리를 설치 후 root-context.xml에 속성을 처리해준다. 아래 사진처럼 root-context.xml의 Namespaces속성에 위에서 추가한 라이브러리들을 tick한다. 이제 root-context.xml에 DB연결객체를 생성하여 DB를 연결할 수 있다. SqlSessionFactory 객체 : Connection을 생성하고 사용하는 객체 + MyBatis설정까지 가능한 객체 SqlSessionFactoryBean 클래스를 사용해야함 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:mybatis-spring=\"http://mybatis.org/schema/mybatis-spring\" xsi:schemaLocation=\"http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.3.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\"&gt; &lt;!-- Root Context: defines shared resources visible to all other web components --&gt; &lt;!-- DataSource 정보를 가지고 있는 DriverManagerDataSource 객체를 생성 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/springdb?useSSL=false\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"1234\" /&gt; &lt;/bean&gt; &lt;!-- SqlSessionFactory 객체 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 위에서 생성된 객체를 주입하기 위해서는 value가 아니라 ref를 통해서 주입해야한다 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"configLocation\" value=\"classpath:/Mybatis-config.xml\" /&gt; &lt;/bean&gt;&lt;/beans&gt;","link":"/2020/10/11/201012spring/"},{"title":"Servlet관리자용주문목록2 : 고객주문목록","text":"AdminOrderFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 123456// 주소에 따른 처리 구분 (주소 매핑후 이동)if(command.equals(\"/AdminOrderList.ao\")){ action = new AdminOrderListAction(); try{ forward = action.execute(request, response); }catch(Exception e) {e.printStackTrace();}} AdminOrderListAction.java 생성 if(id == null || id.equals(“admin”)) 에서 null을 먼저 비교해야한다. id.equals(&quot;admin&quot;) 비교하는 경우 id가 null일때 id.equals(null)이 실행되면서 에러가 발생한다. 따라서 id == null을 먼저 비교해야한다. 12345678910111213141516171819202122232425262728public class AdminOrderListAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { // 한글처리 request.setCharacterEncoding(\"UTF-8\"); // 관리자 ID해당하는 세션값 제어 HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null || !id.equals(\"admin\")){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } // AdminOrderDAO 객체 생성 -&gt; 저장 한 줄 코딩 AdminOrderDAO aodao = new AdminOrderDAOImpl(); //업캐스팅 request.setAttribute(\"AdminOrderList\", aodao.getAdminOrderList()); // 페이지 이동 forward.setPath(\"./adminorder/admin_order_list.jsp\"); forward.setRedirect(false); return forward; }} AdminOrderDAOImpl.java에 getAdminOrderList()메서드 코드 추가12345678910111213141516171819202122232425262728293031323334353637// 주문목록 가져오기@Overridepublic List getAdminOrderList() { List AdminOrderList = new ArrayList(); try { getCon(); sql=\"select o_trade_num,o_g_name,o_g_amount,o_g_size,o_g_color,\" + \"sum(o_sum_money) as o_sum_money,\" + \"o_trade_type,o_trans_num,o_date,o_status,o_m_id \" + \"from itwill_order \" + \"group by o_trade_num \" + \"order by o_trade_num\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); while(rs.next()){ OrderDTO odto = new OrderDTO(); odto.setO_date(rs.getDate(\"o_date\")); odto.setO_g_amount(rs.getInt(\"o_g_amount\")); odto.setO_g_color(rs.getString(\"o_g_color\")); odto.setO_g_name(rs.getString(\"o_g_name\")); odto.setO_g_size(rs.getString(\"o_g_size\")); odto.setO_trade_num(rs.getString(\"o_trade_num\")); odto.setO_trans_num(rs.getString(\"o_trans_num\")); odto.setO_sum_money(rs.getInt(\"o_sum_money\")); odto.setO_status(rs.getInt(\"o_status\")); odto.setO_trade_type(rs.getString(\"o_trade_type\")); odto.setO_m_id(rs.getString(\"o_m_id\")); AdminOrderList.add(odto); } }catch(Exception e){ e.printStackTrace(); } finally { closeDB(); } return AdminOrderList;}//end of getAdminOrderList() admin_order_list.jsp 생성 if-else보다 swith가 더 효율적이다. if-else는 모든 연산을 다 해야하니까 if-else를 쓸꺼면 꼭 else를 챙겨야한다. 모든 예외상황을 다 관리해야하니까 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%System.out.println(\"V : 관리자 주문목록 처리 페이지\");List&lt;OrderDTO&gt; adminOrderList = (List&lt;OrderDTO&gt;) request.getAttribute(\"adminOrderList\");%&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;주문번호&lt;/td&gt; &lt;td&gt;주문자&lt;/td&gt; &lt;td&gt;결재방법&lt;/td&gt; &lt;td&gt;주문금액&lt;/td&gt; &lt;td&gt;주문상태&lt;/td&gt; &lt;td&gt;주문일시&lt;/td&gt; &lt;td&gt;수정 / 삭제&lt;/td&gt; &lt;/tr&gt; &lt;% for(OrderDTO odto:adminOrderList){ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=odto.getO_trade_num() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto.getO_m_id() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto.getO_trade_type() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto.getO_sum_money() %&gt;&lt;/td&gt; &lt;% // if-else보다 swith가 더 효율적이다. if-else는 모든 연산을 다 해야하니까 // if-else를 쓸꺼면 꼭 else를 챙겨야한다. 모든 예외상황을 다 관리해야하니까 String status = \"\"; if(odto.getO_status() == 0){ status=\"대기중\"; } else if(odto.getO_status() == 1){ status=\"발송준비\"; } else if(odto.getO_status() == 2){ status=\"발송완료\"; } else if(odto.getO_status() == 3){ status=\"배송중\"; } else if(odto.getO_status() == 4){ status=\"배송완료\"; } else if(odto.getO_status() == 5){ status=\"주문취소\"; } else{ status=\"문제발생\"; } %&gt; &lt;td&gt; &lt;%=status %&gt; &lt;/td&gt; &lt;td&gt; &lt;%=odto.getO_date() %&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=\"button\" class=\"btn\" value=\"수정\" onclick=\"location.href='./AdminOrderModify.ao?trade_num=&lt;%=odto.getO_trade_num()%&gt;'\" &gt; / &lt;input type=\"button\" class=\"btn\" value=\"삭제\" onclick=\"location.href=\" &gt; &lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt;&lt;/table&gt;&lt;input type=\"button\" class=\"btn\" value=\"메인페이지로\" onclick=\"location.href='./Main.me'\"&gt;","link":"/2020/09/22/200923jspi-1/"},{"title":"JS에서 테이블만들기, 자식태그, 2차원배열, 2차원배열클릭이벤트, forEach","text":"웹 게임을 만들며 배우는 JS : 틱택토JS에서 테이블만들기, 자식태그, 2차원배열, 2차원배열클릭이벤트, forEach 1. JS에서 테이블과 HTML태크 만들기123456789101112131415161718192021222324252627틱택토용으로 3x3 테이블은 한번에 만드는 코드는 table&gt;(tr&gt;td*3)*3 이다그러면 아래와 같이 자동으로 아래 코드가 생성된다 &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;위 코드만 치면 테이블이 모습을 나타내지 않기에 style을 넣어줘야한다. &lt;style&gt; td{ border: 1px solid black; width: 80px; height: 80px; } &lt;/style&gt; 이것을 그대로 JS로 구현할 수 있다. 1234567891011var 바디 = document.body;var 테이블 = document.createElement('table'); for (let i=1; i&lt;4; i+=1){ var 행 = document.createElement('tr'); for(let j=1; j&lt;4; j+=1){ var 열 = document.createElement('td'); 행.appendChild(열); } 테이블.appendChild(행); } 바디.appendChild(테이블); 직장생활팁 : 실무에서는 무조건 html로 작성해야한다. 그게 더 효율적임. js로 나타낼 수 있다는 걸 알기만 하면 됨. 2. JS에서 HTML 태크 만들기1&lt;div&gt;태그만들기&lt;/div&gt; 을 js에서 만들려면 아래와 같이 만들면 된다. 123var div태그 = document.createElement('div'); //div태그를 만드는 것div태그.textContent = '태그만들기'; // 만든 태그에 내용을 적는 것document.body.append(div태그); // 만든 태그를 body에 표현하는 것. 이걸 꼭 해야함. 3가지가 세트라고 생각하면 됨. 3종세트! 3. 자식태그만들기123&lt;div&gt;태그만들기 &lt;button&gt;버튼&lt;/button&gt;&lt;/div&gt; 을 js에서 만들려면 방법2가지가 있다. 123456789방법 1 : append 쓰기var div태그 = document.createElement('div'); div태그.textContent = '태그만들기'; document.body.append(div태그);var 버튼태그 = document.createElement('button'); 버튼태그.textContent = '등록'; div태그.append(버튼태그); //div태그(부모태그)안에 자식태그로 넣는 것. 123456789방법 2 : appendChild 쓰기var div태그 = document.createElement('div'); div태그.textContent = '태그만들기'; document.body.append(div태그);var 버튼태그 = document.createElement('button'); 버튼태그.textContent = '등록'; div태그.appendChild(버튼태그); //div태그(부모태그)안에 자식태그로 넣는 것. 둘 다 잘 작동한다 그렇다면 둘의 차이점은 무엇일까? 4. .append와 .appendChild의 차이점123&lt;div&gt;태그만들기 &lt;button id='비교해보자'&gt;등록&lt;/button&gt;&lt;/div&gt; 기존 js 12345678var div태그 = document.createElement('div'); div태그.textContent = '태그만들기'; document.body.append(div태그);var 버튼태그 = document.createElement('button'); 버튼태그.textContent = '등록'; 버튼태그.id = '비교해보자'div태그.append(버튼태그); //div태그(부모태그)안에 자식태그로 넣는 것. 위와 같이 이미 만들어져있는 HTML에서 ‘버튼’뒤에 string을 추가하고 싶다. 이때 2가지 비교해보자. 1234방법 1 : append 쓰기기존 js의 아래부분에 추가한다document.getElementById('비교해보자').append(\" 이건 어팬드\"); 버튼안에 ‘버튼 이건 어팬드’라고 출력되며 잘 작동한다 두번째 appendChild쓰면 어떨까? 12345방법 2 : appendChild 쓰기기존 js의 아래부분에 추가한다document.getElementById('비교해보자').appendChild(\" 이건 어팬드차일드\");//TypeError: Failed to execute 'appendChild' on 'Node': parameter 1 is not of type 'Node'. 타입에러가 난다. 왜일까? appendChild는 element가 필요하기 때문. 따라서 아래와 같이 적어야한다. 12345678방법 2-1 : appendChild 쓰기기존 js의 아래부분에 추가한다var 어팬드차일드 = document.createElement('text');또는var 어팬드차일드 = document.createElement('span');어팬드차일드.textContent = ' 이건 어팬드차일드'document.getElementById('비교해보자').appendChild(어팬드차일드); 버튼안에 ‘버튼 이건 어팬드차일드’라고 출력되며 잘 작동한다 만약 버튼 안의 text를 아예 바꾸고 싶다면 appendChild와 innerHTML를 세트로 사용하면 된다! 1234567방법 2-2 : appendChild + innerHTML 세트로 쓰기//이 방법은 기존js에서 수정이 필요하다//div태그.append(버튼태그);에서 appendChild로 수정이 필요하다 div태그.appendChild(버튼태그); document.getElementById('비교해보자').innerHTML =' 이건 어팬드차일드'; 딱 2줄 바꿨다. 근데 이건 버튼태그안의 내용에 추가하는 게 아니라 내용 자체를 변경하는 것이다 따라서 버튼태그안의 text인 ‘등록’은 없어지고 ‘ 이건 어팬드차일드’만 남는다. 결론 결론적으로 appendChild사용할 수 있는 모든 경우는 append 사용이 가능하지만, 그 반대는 아니다. appendChild + innerHTML 세트로 사용하면 내용 변경에 유용하다 참고링크 : https://rpubs.com/raulUbiqum/append 5. 2차원배열3x3칸을 만들었다면 그 안에 O,X 배열을 넣어야 게임을 만들 수 있다. 그것을 2차원 배열이라고 하는데 아래처럼 보이게 만들고 싶다. 12345열들 = [ [첫칸, 두칸, 세칸] [첫칸, 두칸, 세칸] [첫칸, 두칸, 세칸]] 어떻게 하면 될까? 2차원 배열을 만드는 방법 첫번째 스탭은 123456789101112131415161718//틱택토게임STEP1. JS로 3X3테이블만들기var 바디 = document.body;var 테이블 = document.createElement('table');var 행들 = [];var 열들 = []; for (let i=1; i&lt;4; i+=1){ var 행 = document.createElement('tr'); 행들.push(행); 열들.push([]); //빈 배열 3개를 만듬 즉, 행 3개를 만듬 console.log(행들, 열들); for(let j=1; j&lt;4; j+=1){ var 열 = document.createElement('td'); 행.appendChild(열); } 테이블.appendChild(행); } 바디.appendChild(테이블); 콘솔로그를 확인하면 빈 배열 3개가 생겼으므로 그 배열에 2차원 배열을 넣어야한다. 두번째 스탭은 1234567891011121314151617//틱택토게임STEP1. JS로 3X3테이블만들기var 바디 = document.body;var 테이블 = document.createElement('table');var 열들 =[]; for (let i=1; i&lt;4; i+=1){ var 행 = document.createElement('tr'); 열들.push([]); //빈 배열 3개를 만듬 즉, 행 3개를 만듬 for(let j=1; j&lt;4; j+=1){ var 열 = document.createElement('td'); 열들[i-1].push(열); //왼쪽상단제일첫번째칸에 열을 넣는 것. 행.appendChild(열); } 테이블.appendChild(행); } 바디.appendChild(테이블);console.log('행들' , 행들, '열들', 열들); 콘솔로그를 확인하면 짜잔- 2차원 배열 완성! 6. 2차원배열 클릭이벤트이벤트리스너로 만든 2차원배열을 클릭할때마다 O,X를 나타나게끔 구현 3번의 들여쓰기가 있기에 코딩격언에 따라 ㅋㅋㅋ 변수에 function을 넣는다. 12345678910111213141516171819202122232425262728293031//틱택토게임STEP2. 2차원배열에 클릭하면 O,X 구현 var 턴 = 'X';var 비동기콜백 = function (이벤트){ console.log(이벤트.target); //열을 지목 console.log(이벤트.target.parentNode); //부모코드를 지목(=여기선 행) console.log(이벤트.target.parentNode.parentNode); //조부모코드를 지목(=여기선 테이블) var 몇번행 = 행들.indexOf(이벤트.target.parentNode); //인덱스오브로 몇줄인지 찾을 수 있음 console.log('몇줄', 몇번행); var 몇번열 = 열들[몇번행].indexOf(이벤트.target); console.log('몇칸', 몇번열); // if(열들[몇번행][몇번열].value !== '') 여기서는 밸류가 아니라 텍스트콘텐트다 //input의 값이 value이고 //태그 안 글자는 textContent if (열들[몇번행][몇번열].textContent !== ''){ //칸이 이미 채워져있는 경우 console.log('빈칸아닙니다') }else{ console.log('빈칸입니다') 열들[몇번행][몇번열].textContent = 턴; if (턴 === 'X'){ 턴 = 'O'; }else { 턴 = 'X'; } }};바디.append(결과); 이벤트.target = 열을 지목하는 것 이벤트.target.parentNode = 부모코드를 지목하는 것. 여기선 행으로 지정해놓았다 배열.indexOf(‘이거’) = 배열안에 ‘이거’가 몇번째에 있는지 순서를 알려준다. 참고 : https://www.w3schools.com/jsref/jsref_indexof_array.asp 2차원 배열을 클릭하면 X나O로 배열안의 내용을 바꿔주고 싶을 때는 .value가 아니라 .textContent이다. 12열들[0][1].value = 'X' 여기서는 error 뜸 열들[0][1].textContent = 'X' 여기서는 배열의 0번째행 1번째열이 'X'로 변경됨. input의 값은 .value를 사용하고 태그 안 글자는 .textContent를 사용한다 7. 테이블의 3칸이 다 X거나 O로 채워졌는 지 구현12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var 결과 = document.createElement('div');//틱택토게임STEP3. 3칸이 다 X거나 O로 채워졌는 지 구현 var 다참 = false; //가로줄검사 if(열들[몇번행][0].textContent === 턴 &amp;&amp; 열들[몇번행][1].textContent === 턴 &amp;&amp; 열들[몇번행][2].textContent === 턴){ 다참 = true; } //세로줄검사 if(열들[0][몇번열].textContent === 턴 &amp;&amp; 열들[1][몇번열].textContent === 턴 &amp;&amp; 열들[2][몇번열].textContent === 턴){ 다참 = true; } //대각선검사 if(몇번행 - 몇번열 === 0){ if(열들[0][0].textContent === 턴 &amp;&amp; 열들[1][1].textContent === 턴 &amp;&amp; 열들[2][2].textContent === 턴){ 다참 = true; }} if(Math.abs(몇번행-몇번열)===2){ if(열들[0][2].textContent === 턴 &amp;&amp; 열들[1][1].textContent === 턴 &amp;&amp; 열들[2][0].textContent === 턴){ 다참 = true; }} //다 찼으면 if (다참){ 결과.textContent = 턴 +'님의 승리!'; console.log(턴 + '님의 승리!') //승리한 뒤에는 초기화가 되어야한다. 아래는 초기화하는 코드. 턴 = 'X'; 열들.forEach(function (행){ //1차원으로 행을 먼저 선택한 후 행.forEach(function(열){ //2차원으로 선택된 행에서의 열을 함께 선택함. 열.textContent = ''; }); }); }else{ if (턴 === 'X'){ 턴 = 'O'; }else { 턴 = 'X'; } } }}; 2차원 배열이니까 반복문 2번씩 사용된다. 3차원배열이면 3번씩 사용됨. 중첩문을 줄이는게 코딩을 잘 하는 것. 8. 배열.forEach(function(){ })123456789[1,2,3,4,5].forEach(function(엘리먼트){ //배열안의 것들을 요소(element)라고 부름 console.log(엘리먼트);});//output =&gt;12345 참고 : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach","link":"/2019/09/06/190907/"},{"title":"Math.random(), Math.floor&#x2F;ceil&#x2F;round, forEach와map, for반복문과while반복문사용차이, .sort(오름차순정렬) setTimeout(function (){} , 밀리초)","text":"웹 게임을 만들며 배우는 JS : 로또추첨기Math.random(), Math.floor/ceil/round, forEach와map, for반복문과while반복문사용차이, .sort(오름차순정렬) setTimeout(function (){} , 밀리초)1. Math.random()랜덤한 수를 뽑는 매서드이다. 123456Math.random() 에서 * n을 하면, n전까지의 숫자가 random으로 나온다.보기쉽게 소수점첫째자리 버림 하는 함수인 Math.floor()와 함께 주로 사용한다.예를들어Math.floor(Math.random()*5)//=&gt; 0,1,2,3,4 숫자들이 랜덤으로 출력됨. 2. Math.floor()와 Math.ceil()와 Math.round()세가지의 차이점은 123Math.floor() : 소수점 버림. 정수로 반환. Math.ceil() : 소수점 올림. 정수로 반환.Math.round() : 소수점 반올림. 정수로 반환. 3. .forEach(function(){})와 .map(function(){})STEP1. 로또 숫자 만들기(1~45까지) 123456789101112var 후보군 = Array(45); //empty가 45개 생기고 empty의 특징은 foreach반복문 적용 불가.var 필 = 후보군.fill(); //필을 해줘야 45개의 emtpy에서 undefined가 된다.empty가 아니기에 forEach반복문 실행가능해짐.//forEach를 사용해서 억지로 숫자를 넣을 수 있다.필.forEach(function(요소,인덱스) { 필[인덱스] = 인덱스 + 1; });console.log(필);//=&gt; (45) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45] 더 좋은 방법이 있다. 바로 maping이다..map(function(){})은 array 요소와 1대1로 mapping이 된다. 12345678var 후보군 = Array(45); var 필 = 후보군.fill(); var 맵 = 필.map(function(요소, 인덱스){ return 인덱스 + 1});console.log(맵);//=&gt; (45) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45] 굳이 변수를 3개씩 많이 지정할 필요가 없다. 위의 전체를 변수 1개로 그리고 단 세 줄로 나타낼 수 있다. 12345var 후보군 = Array(45).fill().map(function(요소, 인덱스){ return 인덱스 + 1});console.log(후보군);//=&gt; (45) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45] 세상 깔~끔! 4. for반복문과 while반복문 사용차이STEP2. 숫자를 랜덤하게 섞고 총7개 숫자를 뽑기 숫자를 랜덤하게 섞은 뒤 7가지의 숫자를 뽑고자 한다면 흔히 for문을 먼저 생각할 것이다. 1234567891011121314var 셔플 = [];for (var i=0; i&lt;후보군.length; i+=1){ var 이동값 = 후보군.splice(Math.floor(Math.random()*후보군.length), 1)[0]; 셔플.push(이동값);} console.log('---')console.log('후보군길이: '+후보군.length); //=&gt;22개console.log('셔플길이: '+셔플.length); //=&gt;23개// 후보군길이 + 셔플길이 = 45 개 된다. // 즉, 기존 후보군길이 45개에서 셔플로 23개 빠지고 나머지 22개만 남게된다.console.log('후보군: '+후보군.sort(function(p, c){ return p-c;})); console.log('셔플숫자: '+셔플.sort(function(p, c){ return p-c;})); 하지만 for반복문을 못 쓰지 못한다. 후보군길이 + 셔플길이 = 45 개 된다. 즉, 기존 후보군길이 45개에서 셔플로 23개 빠지고 나머지 22개만 남게된다. 후보군.length가 45개에서 22개로 줄어들면 우리가 원하는데로 45개에서 랜덤숫자 7개를 뽑을 수 없다. 지금 23개에서 랜덤숫자 7개 뽑는 꼴이 되버림. 따라서 이럴 때는 while을 쓴다. 12345678910111213while (후보군.length&gt;0){ var 이동값 = 후보군.splice(Math.floor(Math.random()*후보군.length), 1)[0]; 셔플.push(이동값);}console.log('---')console.log('후보군길이: '+후보군.length); //=&gt; 0개console.log('셔플길이: '+셔플.length); //=&gt; 45개// 후보군길이 + 셔플길이 = 45 개 된다. // 즉, 기존 후보군길이 45개에서 셔플로 45개 빠지고 나머지 0개만 남게된다.console.log('후보군: '+후보군.sort(function(p, c){ return p-c;})); console.log('셔플숫자: '+셔플.sort(function(p, c){ return p-c;})); for반복문은 내가 몇번 반복해야할 지 정확히 알 때 사용하면 좋고, while반복문은 내가 몇번 반복해야할 지 모를 때, 그리고 기준값이 계속 변경될때 사용하면 좋다. 여기서 기준값은 후보군.length다. 이렇게 뽑은 랜덤한 7개의 숫자는 아직 console.log를 통해 볼 수 밖에 없다. 따라서 화면에 구현하는 방법은 html로 결과창태그를 만든 뒤 js상으로 결과창태그를 불러와서 뽑은 랜덤당첨숫자들이 결과창태그의 자식태그로 들어가면 된다. 123&lt;div id='결과창'&gt; &lt;div&gt;여기에 각 당첨숫자태크가 갯수만큼 자동으로 생겨야함&lt;div&gt; //그렇다면 for문이겠지?&lt;/div&gt; 123456789//1.html상의 결과창태그를 js로 가져오는 방법은 두가지이며 아래 5번에서 자세히 설명함!var 결과창 = document.getElementById('결과창');//2.뽑힌 숫자들을 결과창태그의 자식태그로 넣기for(let i=0; i&lt;당첨숫자들.length; i+=1){ var 공 = document.createElement('div'); //i번만큼의 div태크 만들고 공.textContent = 당첨숫자들[i]; //div태크안에는 뽑힌 당첨숫자들을 하나씩 넣고 결과창.appendChild(공); //결과창태크의 자식태그로 넣는다} 5. JS에서 html태그를 불러오는 2가지 방법첫번째, getElementById 와 getElementsByClassName 를 이용하기 두번째, querySelector 와 querySelectorAll를 이용하기(권장) 1234567&lt;body&gt; &lt;div&gt;당첨 숫자는? ㄷㄱㄷㄱㄷㄱ&lt;/div&gt; &lt;div id='결과창'&gt;&lt;/div&gt; &lt;div&gt;보너스숫자&lt;/div&gt; &lt;div class='보너스'&gt;&lt;/div&gt; &lt;script src = \"로또추첨기.js\"&gt;&lt;/script&gt; &lt;/body&gt; 이 태그들 중 결과창과 보너스를 js로 가져오는 방법은 1234567//첫번째 방법사용var 결과창 = document.getElementById('결과창'); var 칸 = document.getElementsByClassName('보너스')[0]; //class의 경우 여러개 사용이 가능해서 꼭 뒤에 [n] 몇번째 클래스인지 적어줘야함//두번째 방법사용var 결과창 = document.querySelector('#결과창'); //id일 경우 #var 칸 = document.querySelector('.보너스'); //class일 경우 . 끝!이렇게 가지고 와서 원하는 방향으로 사용하면 된다! 6. .sort와 .sort(function(p, c){ return p-c;})123.sort() : 숫자 정렬예를들어 [2,15,4,7,27].sort();//=&gt; [15,2,27,4,7] . 뭔가 이상한데? 첫째자리 수를 기준으로 숫자 오름차순이라서 그렇다. 15에 1이 먼저 있기때문에 15가 제일 첫번째로 정렬되었다. 우리가 원하는 오름차순은 아래와 같다. 내림차순은 덤으로 공부! 1234567.sort(function(p, c){ return p-c;}) : 숫자오름차순 정렬예를들어 [2,15,4,7,27].sort(function(p, c){ return p-c;})//=&gt; [2,4,7,15,27].sort(function(p, c){ return c-p;}) : 숫자내름차순 정렬예를들어 [2,15,4,7,27].sort(function(p, c){ return c-p;})//=&gt; [27,15,7,4,2] 어떠한 원리로 정렬이 되는 걸까? 123456789101112131415161718[25,1,12].sort(function(p, c){ return p-c;})//=&gt; p-c가 0보다 크면 둘의 정렬순서를 바꿔주는 원리.p - c25 - 1 = 24 //=&gt;이건 0보다 크므로 [1,25,12]로 정렬순서가 바뀐다. // 그리고 바뀐 정렬순서에서 다시 실행.p - c 25 - 12 = 13 //=&gt;이건 0보다 크므로 [1,12,25]로 정렬순서가 바뀐다.//그리고 처음부터 다시 실행.p - c1 - 12 = -11 //=&gt;이건 0보다 작으므로 순서를 바꾸지 않는다//그 다음 계속 실행p - c12 - 25 = -13 //=&gt;이건 0보다 작으므로 순서를 바꾸지 않는다//다 돌았으므로 정렬 끝 = [1,12,25] 숫자뿐만 아니라 문자도 비슷한 원리로 정렬이 된다고 한다. 7. setTimeout(function (){} , 밀리초)STEP3. 화면에 로또숫자를 긴장감있게 나타내기 랜덤 숫자들이 화면에 한꺼번에 보여지는 게 아니라 시간차를 두고 나타나게 하고 싶다면 setTimeout(function (){} , 밀리초) 을 사용하면 된다. 12345setTimeout(function(){ var 공 = document.createElement('div'); 공.textContent = 당첨숫자들[0]; //for문사용시 클로저문제가 발생하므로 당첨숫자들[0] ~ 당첨숫자들[5]까지 각각 적어준다. 결과창.appendChild(공);}, 1000); //밀리초라고해서 1000 = 1초임 for문사용시 클로저문제가 발생하므로 당첨숫자들[0] ~ 당첨숫자들[5]까지 각각 적어준다. 나는 쪼랩이라 아직 클로저문제 해결법을 안 알려준다고 한다ㅋㅋㅋㅋ 나중에 중급강의에 알려준다고 하니 그때 해야지. 그럼 어떻게 하느냐? for문을 안 쓰면 된다 당첨숫자들[0] ~ 당첨숫자들[5]까지 각각 적어준다. 만약 클로저를 이용해서 푼다면 아래와 같다 12345678for(var i=0; i&lt;당첨숫자들.length; i+=1){ function 클로저(j){ setTimeout(function(){ 공색칠하기(당첨숫자들[j], 결과창); },(j+1) * 1000); } 클로저(i);} 이걸 더 짧게 줄일 수가 있는데 바로 즉시실행코드를 이용하면 된다 function을 괄호로 감싸면 즉시실행코드가 된다 1234567for(var i=0; i&lt;당첨숫자들.length; i+=1){ (function 클로저(j){ setTimeout(function(){ 공색칠하기(당첨숫자들[j], 결과창); },(j+1) * 1000); })(i);}","link":"/2019/09/11/190912/"},{"title":"[ITWILL : java]Scanner라이브러리와 equals()를 이용한 사칙연산계산기, if문과 switch문 변환 예시, 반복문과 break","text":"ITWILL학원 : 3강 JAVA BY 윤미영강사1. Scanner 라이브러리기능 : 키보드로부터 데이터를 받아온다.java.util 패키기에 있는 중요한 라이브러리이므로 사용법은 암기필수. 1234567891011121314151617181920212223242526272829//1. 선언import java.util.Scanner;// import라는 예약어는 // 단축키는 ctrl + shift + O 누르면 자동으로 import 생성됨Scanner sc = new Scanner(System.in); // 의미는 나는 이제부터 스캐너라이브러리를 변수명(ex: sc)이라는 이름으로 불러서 사용하겠다는 의미// System.in 자바의 표준입력으로 키보드를 의미한다. 즉 키보드로부터 데이터를 받아오겠다라는 의미System.out.println(\"단어를 입력하세요\");//2. 변수 s에 저장String s = sc.next();// 콘솔창에 입력한 것들이 변수 s에 저장된다.//3. 출력System.out.println(s);//4. 예시System.out.println(\"이름을 입력해주세요\");String s = sc.next(); System.out.println(\"연락처를 -없이 입력해주세요\");int i = sc.nextInt(); System.out.println(\"입력하신 \"+ s +\"님의 휴대폰번호 0\"+ i +\" 가 맞습니까?\"); 다른 명령어들은 아래와 같다 12345678sc.nextInt()//키보드로부터 정수데이터를 가지고 옴sc.next()//키보드로부터 string(한단어)를 가지고 옴sc.nextLine()//키보드로부터 string(공백을 포함한 한줄전체)를 가지고 옴 2. Scanner 라이브러리를 이용한 사칙연산계산기 만들기처음 떠오른 코드는 아래와 같다. 12345678Scanner sc = new Scanner(System.in);System.out.println(\"원하는 사칙연산 수식을 입력하세요\");int data1 = sc.nextInt();String operator = sc.next();int convertOper = int(operator);int data2= sc.nextInt();System.out.println(\"입력하신 \" + data1 + operator + data2 +\"의 값은 \"+ (data1 + convertOper+ data2)+\"입니다\") 그런데 string으로 연산자를 받으니까 연산이 되지않으니까 int로 형을 바꿀려고했는데 Cannot cast from String to int 에러가 났다. 사칙연산자들의 데이터타입이 무엇인지 구글링했는데 그래도 잘 모르겠어서강사님께 여쭈어보니 string을 int로 받아도 해결할 수 없다고 한다. if문을 써서 equals()를 쓰는게 낫다고 했다equals()를 어떻게 쓰는지 찾아본 뒤 바로 적용해보았다 1234567891011121314151617Scanner sc = new Scanner(System.in);System.out.println(\"원하는 사칙연산 수식을 입력하세요\");int data1 = sc.nextInt();String operator = sc.next();int data2= sc.nextInt();if(\"+\".equals(operator)){ System.out.println(\"입력하신 \" + data1 + operator + data2 +\"의 값은 \"+ (data1 + data2)+\"입니다\");}else if(\"-\".equals(operator)){ System.out.println(\"입력하신 \" + data1 + operator + data2 +\"의 값은 \"+ (data1 - data2)+\"입니다\");}else if(\"*\".equals(operator)){ System.out.println(\"입력하신 \" + data1 + operator + data2 +\"의 값은 \"+ (data1 * data2)+\"입니다\");}else if(\"/\".equals(operator)){ System.out.println(\"입력하신 \" + data1 + operator + data2 +\"의 값은 \"+ (data1 / data2)+\"입니다\");}else{ System.out.println(\"또 잘못입력함? 다시 입력해주세요\")} 작동 잘된다! 역시 가르쳐주는 사람이 있으니까 좋다switch문으로 바꾸어보자 1234567891011switch(operator){case \"+\" : System.out.println(\"덧셈결과는 \" + (data1+data2));break;case \"-\" : System.out.println(\"뺄샘결과는 \" + (data1-data2));break;case \"*\" : System.out.println(\"곱셈결과는 \" + (data1*data2));break;case \"/\" : System.out.println(\"나눗셈결과는 \" + (data1/data2));break;default : System.out.println(\"또 잘못입력함? 다시 입력해주세요\");} 3. 제어문 종류 조건문 if(조건문) switch(값) 반복문 for(반복횟수) while(조건식) 4. 조건문 : Switch문정수식안에는 변수, 숫자, 문자, 조건들이 들어갈 수 있다.case안의 값에는 and연산자, Boolean, 실수는 아예 들어갈 수 없다.break;문이 없을 경우 다음 break;를 찾을때까지 모든 문장을 실행한다.default문은 가장 마지막 작업으로 위의 case 이외의 값인 경우 default문은이 출력되고 Switch문은 끝난다 123456789switch( 정수식 ){ //숫자,문자 case 값 : 출력값1; break; case 값 : 출력값2; break; case 값 : 출력값3; break; default : 출력값4;} 예시 123456789101112131415161718switch(season){case \"spring\" : System.out.println(\"봄 사랑 벚꽃 말고 by 아이유\"); break;case \"summner\" : System.out.println(\"party by 소녀시대\"); break;case \"autumn\" : case \"fall\" : System.out.println(\"11:11 by 태연\"); break;case \"winter\" : System.out.println(\"Santa tell me by Ariana grande\"); break;default : System.out.println(\"잘못입력하셨거나 스페..펠..ㄹ..잉 틀리셨나봐요?\");} 5. 조건문 : switch문과 if문 비교임의의 노래방 점수를 터미널에 입력하면 점수대별로 아래 문구를 출력하고싶다. 100점의 문구 : 실화냐? 가수다! 가수가 나타났다! 80 ~ 99점의 문구 : 노래실력이 아주 좋으신데요~ 40 ~ 79점의 문구 : 매력이~ 넘쳐요 40점미만의 문구 : 노ㄹ..아니 박수실력이 나날이 늘어가네요!그외의 점수들 : 잘못된 숫자를 입력하셨습니다.다시 입력해주세요 if일때 123456789101112131415Scanner sc = new Scanner(System.in);System.out.println(\"점수를 입력하세요\");int inputScore = sc.nextInt(10);if (inputScore == 100){ System.out.println(\"WOW \" + inputScore + \"점 실화냐? 가수다! 가수가 나타났다!\");}else if(inputScore &gt;= 80 &amp;&amp; inputScore &lt; 100 ){ System.out.println(inputScore + \"점! 노래실력이 아주 좋으신데요~\");}else if(inputScore &gt;= 40 &amp;&amp; inputScore &lt; 80 ){ System.out.println(\"내 노래 점수는 \" + inputScore + \"점! 매력이~ 넘쳐요\");}else if(inputScore &lt; 40 &amp;&amp; inputScore &gt;= 0){ System.out.println(inputScore + \"점! 노ㄹ..아니 박수실력이 나날이 늘어가네요!\");}else{ System.out.println(\"잘못된 숫자를 입력하셨습니다.다시 입력해주세요\");} switch일때 12345678910111213141516171819202122switch(inputScore/10){case 10 : System.out.println(\"100점 실화냐? 가수다! 가수가 나타났다!\"); break;case 9 :case 8 : System.out.println(\"노래실력이 아주 좋으신데요~\"); break;case 7 : case 6 : case 5 : ystem.out.println(\"매력이~ 넘쳐요\"); break;case 4 : case 3 :case 2 : case 1 : System.out.println(\"노ㄹ..아니 박수실력이 나날이 늘어가네요!\"); break;default : System.out.println(\"잘못된 숫자를 입력하셨습니다.다시 입력해주세요\");} 6. 반복문 : for문for문의 기본은 아래와 같다 123for(int i=0; 조건식; 증감식){ 출력값} 간단한 예시를 보면서 어떻게 컴파일이 되는지 순서를 보자 123for(int i=1; i&lt;10; i++){ System.out.println(\"Hi\");} 조건문 확인 : i는 1이고 10보다 작다 -&gt;true 괄호안의 코드출력 증감식 확인 : 이제 i는 2 조건문 확인 : i는 2이고 10보다 작다 -&gt;true 괄호안의 코드출력 증감식 확인 : 이제 i는 2 계속반복 조건문 확인 : i는 10이고 10보다 작다 -&gt; false for문 종료 7. 반복문 : break반복문에서 break를 사용하면 반복문이 바로 종료된다. 구구단 3단 예시를 들어보자 12345678int multiply;int result;multiply = 3;for(int x=1; x&lt;=9; x++){ result = multiply * x; System.out.print(result + \",\");}//출력값 : 3,6,9,12,15,18,21,24,27, 출력값의 마지막 컴마를 없애고 싶다.어떻게 하면 좋을까? if와 break를 사용해보자. 123456789101112int multiply;int result;multiply = 3;for(int x=1; x&lt;=9; x++){ result = multiply * x; if(x==9){ System.out.println(result); break; } System.out.print(result + \",\");}//출력값 : 3,6,9,12,15,18,21,24,27 break를 입력하면 if조건이 만족되는 순간 바로 반복문이 종료된다아래 예시는 구구단 3단 나타내지만 if조건문을 5까지 입력했다즉 3*5까지 진행하는 구구단이다. 123456789101112int multiply;int result;multiply = 3;for(int x=1; x&lt;=9; x++){ result = multiply * x; if(x==5){ System.out.println(result); break; } System.out.print(result + \",\");}//출력값 : 3,6,9,12,15 x가 6,7,8,9가 남았지만 if조건을 만족하고 break때문에 반복문이 종료된다.","link":"/2020/06/03/200604javai/"},{"title":"제약조건문법(컬럼레벨&#x2F;테이블레벨), 제약조건 5가지, 버퍼에 있는 자주 사용할 쿼리구문을 저장하는 방법","text":"제약조건명 생성시 문법 2가지제약조건명 생성시 oracle에서 권장하는 이름작성 방법이 두가지(컬럼레벨문법과 테이블레벨문법)가 있다. Column-level 문법 Not Null 제약조건사용시 column-level문법으로 작성해야한다! 나머지 4종류의 제약조건은 레벨문법 둘 중 하나만 쓰면 된다 기본형 : 테이블명약자_컬럼명약자_제약조건유형약자 예시 :제약조건 2개 이상 작성하고 싶다면 스페이스누르고 constraint 적은 뒤 다시 제약조건을 적으면 된다. 12345create table title_copy( copy_id number(10),title_id number(10) CONSTRAINT tc_tid_fk REFERENCES title(title_id),rating VARCHAR2(4) CONSTRAINT tc_ra_nn not null CONSTRAINT tc_ra_ck check (rating in ('G', 'PG', 'R', 'NC17', 'NR')); Table-level 문법 기본형 : 테이블명약자_컬럼명약자_제약조건유형약자(컬럼명) 예시 :PK를 두 컬럼에 하려면 테이블레벨문법으로 작성해야한다. 1234create table title( copy_id number(10),title_id number(10) constraint t_tid_nn not null,constraint t_id_pk primary key (copy_id, title_id)); 제약조건 5가지 Not null (NN) 컬럼레벨문법만 가능 빈 값(null값)이 컬럼에 삽입될 수 없다. 테이블안의 여러컬럼에 선언 가능 예를들어, 회원가입테이블에서 이름과 전화번호가 필수인 경우 Not Null 제약조건을 걸어서 필수사항을 꼭 기입하도록 하는 조건이다 주로 사용하는 약자 nn 예시 : 12345create table test1(id number(10) constraint t1_id_nn not null,name varchar2(30) constraint t1_name_nn not null,email varchar2(20),start_date date); Unique (UK) 고유한 값만 가능하다. (중복불가) 테이블안의 여러컬럼에 선언 가능 예시 : 12345create table test2(id number(10) CONSTRAINT t2_id_nn not null CONSTRAINT t2_id_uk unique,email VARCHAR2(20),start_date date,CONSTRAINT t2_email_uk unique(email)); Primary key (PK) Not null과 Unique성격을 동시에 가진다. 테이블안의 한번만 선언 가능. 테이블에서 선언시 한 번에 여러 컬럼에 선언하면 됨 나중에 다른 테이블과 join시 여러 컬럼의 조합값으로 join됨 어떤 컬럼을 Primary key 조건을 걸면 좋을까? 개인의 선택이지만 지극히 개인정보는 선택하면 안된다 예를들어 사원테이블에서 사원주민번호를 Primary key를 설정하면 주민번호가 대표key이므로 이곳 저곳에 데이터가 불려다니게 되므로 정보유출이 될 수 있다. (보안에 취약) 따라서 사원 주민번호보단 사원번호를 Primary key를 설정하는 것이 좋다 예시1 :copy_id, title_id의 조합값에 pk를 걸 수 있다. 1234create table title( copy_id number(10),title_id number(10) constraint t_tid_nn not null,constraint t_id_pk primary key (copy_id, title_id)); 예시2 : Foreign Key (FK) 자기 자신 테이블이나 다른 테이블의 특정 컬럼(PK, UK)를 참조하는 제약조건 아무컬럼이나 참조할 수 있는 것은 아니고 PK조건이나 UK조건이 있는 컬럼만 FK로 참조할 수 있다 FK가 지정되어있으면 해당컬럼이 자식컬럼이 되고 참조한 PK이나 UK조건컬럼이 부모컬럼이 된다. 테이블안의 여러컬럼에 선언 가능 자식컬럼이 있는한 부모컬럼은 삭제되지않는다. 부모컬럼에 있는 내용만 자식컬럼에 들어올 수 있다. BUT null 유일하게 부모컬럼에 없는 null은 자식컬럼에 허용한다 null이란 zero도 아니고 공백도 아닌 특수한 값으로 아직 정의되지않은 값을 의미한다. 부모컬럼에 없는 null이 자식컬럼에 들어올 수 있다 컬럼레벨 FK 예시 : 1234create table test4(id number(10) CONSTRAINT t3_id_pk primary key,email VARCHAR2(20),department_id number(10) CONSTRAINT t4_dept_fkdept_fk references departments(department_id)); 테이블레벨 FK 예시 : 12345create table test4(id number(10) CONSTRAINT t3_id_pk primary key,email VARCHAR2(20),department_id number(10), CONSTRAINT t4_dept_fk FOREIGN KEY (department_id) references departments(department_id)); Check (CK) 해당 컬럼이 만족해야하는 조건들을 자유자재로 지정하는 제약 조건 테이블안에 여러컬럼에 선언 가능 컬럼레벨로 선언했을때와 테이블레벨로 선언했을때의 차이가 없는 유일한 제약조건이다 예시1 : 컬럼레벨과 테이블레벨 차이점 예시Salary라는 컬럼은 급여데이터이기때문에 CHECK (salary &gt; 0)으로 제약조건을 걸수있다. 컬럼레벨 : 12345678910111213141516171819202122salary number(2), ... constraint emp_salary_min CHECK (salary &gt; 0), ...``` - 테이블레벨 : 위와 비교해서 알 수 있듯이 다른 제약조건들과 달리 두 레벨의 차이점이 없는 것이 특징이다 ```bashsalary number(2), ... constraint emp_salary_min CHECK (salary &gt; 0), ...``` - - 예시2 : 길이조건```bash주민번호 varchar2(13) constraint 000 check (length(주민번호) = 13), ...``` - 예시3 : 성별조건아래 두 문장은 동일한 결과값을 가진다.```bash성별 varchar2(10) constraint 000 check (성별 = '여' or 성별 = '남' ), ...성별 varchar2(10) constraint 000 check (성별 in ('여','남')), ... 제약조건 전체 예시위에서 배운 제약조건들을 다 넣은 예시룰 보자 사원번호는 주로 PK제약조건을 사용하기때문에 PK제약조건을 사용했다 이름에 공백에 있으면 안되므로 NN제약조건을 사용했다 number(8,2)는 전체 데이터는 8byte이고 소수점 둘째자리까지 나타낸다는 의미이다 CHECK제약조건을 사용하여 급여는 0보다 커야한다는 제약을 걸었다 내 테이블안의 FK제약조건을 사용했다 부모칼럼 : employees1 테이블의 employee_id 칼럼 자식칼럼 : employees1 테이블의 manager_id 칼럼 다른 테이블을 가져와서 FK제약조건을 사용했다 부모컬럼 : departments 테이블의 department_id 칼럼 자식컬럼 : employees1 테이블의 department_id 칼럼 제약조건 확인하는 방법DB사전에서 찾아보면 테이블에 선언된 제약조건을 확인할 수 있다 select 명령어를 통해 제약조건_이름과 제약조건_타입, C가 not null인지 checnk조건인지 서치, 래퍼런스가있으면 그이름 가져오기 from user_constraints 은 DB사전안에 제약조건을 확인할 수 있는 곳이다 where table_name = 테이블명을 적어줘야하는데 아무명이나 들어갈 수 있도록 &amp;tablename으로 설정한다 -&gt; 추후 sql쿼리문을 저장하기 위해서 테이블명을 항상 대문자로 적어야한다 데이터가 출력되었으나 보기 좋게 출력되지 않았다. 데이터를 가독성있게 작성해보자 not null과 check는 둘다 C라고 뜬다 따라서 search를 꼭 입력해줘야 그 뒤의 결과값으로 두가지가 구분 가능하다.search_condition으로 C가 not null조건인지 check조건인지 알수있다. col 원하는컬럼이름 format a원하는크기 : col은 컬럼의 약어로 col이 나타나는 형식을 바꿔서 가독성을 높이는 명령어이다 컬럼포맷 여기서 col은 끝에 ;(세미콜론)을 넣지않았다. 이건 시스템언어이기때문이다 컬럼아래의 점선의 한 점이 1byte라고 생각하면 된다 따라서 글씨크기는 보통 a20해주면 깔끔 enter value for tabkename: 테이블명은 항상 대문자로 적어준다 짜잔- 가독성있게 데이터가 잘 출력되었다. 제약조건을 확인하는 쿼리만들기1234567col column_name format a15col constraint_name format a15col r_constraint_name format a20select a.column_name, a.constraint_name, b.constraint_type, b.search_condition, b.r_constraint_namefrom user_constraints b join user_cons_columns aon a.constraint_name = b.constraint_namewhere lower(a.table_name) = lower('&amp;table_name') 버퍼에 있는 자주 사용할 쿼리구문을 저장하는 방법 버퍼에 있는 쿼리구문이 앞으로 자주 사용될 것같다는 판단이 들면 버퍼가 덮어씌어지기전에 따로 저장해놓으면 된다 쿼리구문이 들어가 있는 파일을 저장하려면 무조건 확장자는 .sql로 저장해야한다 현재 버퍼의 쿼리구문 확인 현재 버퍼에 어떤 퀴리구문이 남아있는지 확인하는 명령어는 l이다. 버퍼로 들어가지않고도(ed) 버퍼에 남은 마지막 퀴리구문이 뭔지 확인하는 명령어이다. -&gt; l에서 빠져나오려면 / + enter 하면 된다. 쿼리구문 저장하기 명령어는 save 저장경로/저장하고픈 파일명.sql 이다 home 안에 있는 oracle에 cons.sql이라고 저장해보려면 아래의 문구를 쓰면 된다.1save /home/oracle/cons.sql 저장한 쿼리파일 실행하기 명령어는 @/저장경로/저장하고픈 파일명.sql 위에 저장했더 경로의 파일을 그대로 불러오면된다1@/home/oracle/cons.sql 테이블이름 입력에 확인하고싶은 테이블이름을 무조건 대문자로 입력한다아래 5번에 제약조건쿼리구문이 실행된 것을 확인할 수 있다.","link":"/2020/06/07/200608dbi/"},{"title":"[자바]객체지향언어란, 클래스란, 멤버변수vs지역변수","text":"클래스 class : 실생활에서 도면에 해당하는 것, 객체를 만드는 원판 객체 object=instance : 도면을 이용해서 찍어내는 제품, 원판을 통해 만들어진 객체 인스턴스화 : 클래스 - 인스턴스화(=객체화=객체생성=메모리에 객체가 생성됨)-&gt; 객체 객체지향언어객체는 예약어로 따지자면 class다.객체를 프로그램에 포함하기위해서는 내가 필요한 기능만 뽑는 즉, 추상화과정이 필요하다. 객체지향언어의 특징 : 모듈화 객체지향의 큰 특징 중 하나는 모듈화이다. 모듈은 재사용이 가능하다록 조립된 블록이고 모듈화란 모듈 형식으로 작업을 진행하는 것을 말한다. 추가/수정/삭제가 쉽다. 재사용이 가능하다. 이미 검증된 모듈을 사용할 경우 신뢰도가 높다. 객체지향언어 vs 절차지향언어(기능위주언어)두 언어 모두 function이 있지만 객체지향언어는 객체단위로이루어져있다 객체지향언어논리적 흐름에 따라 위에서 쭉 코드를 작성해나가는 탑다운 방식을 사용한다.즉,자바는 객체지향 프로그래밍언어로 함수보다는 클래스객체를 만들어 문제를 해결해나간다예를들어 사칙연산프로그램을 만든다면 +클래스, *클래스, *클래스, /클래스를 만든다. 절차지향언어위에서 쭉 코드를 작성해나가는 것보다 기능중심의 함수를 정의해 문제를 해결해나간다.절차지향언어 예로는 파이썬이 있는데 워낙 인기가 많고 쉽게 사용하다보니 java도 버전9부터 람다를 만들어서 기능/함수위주의 언어로 가기 위해 노력하고있다. 클래스(객체)자바는 모든 코드가 클래스에 담겨 있는 100% 객체지향언어이다.클래스란, 객체를 정의하는 틀이다.클래스의 형태는 아래와 같다클래스안의 변수들은 멤버변수라고 부른다. 12345class 클래스명{ int 멤버변수; String 멤버변수; 실행코드;} 하나의 클래스를 생성해놓았다면 꼭 객체생성을 해야쓸 수 있다.왜냐하면 객체생성을 해주지않으면 메모리에 올라가지않는다. 접근지정자 class 클래스명{ 실행코드 }접근지정자는 접근허용한도를 정해주는 키워드이다. public : 누구나 접근 가능하다 protected : 같은 패키지 내에 있거나 상속받은 자손클래스에서만 졉근가능 default(package-private) : 아무런 접근 제어자를 적어주지 않을 때이며, package-private라고도 불린다. 같은 패키지 내에 있을 때만 접근 가능하다. private : 해당 클래스 내에서만 접근 가능하다. 123접근지정자 class 클래스명{ 실행코드 } 접근지정자 범위 public &gt; protected &gt; 기본접근지정자(디폴트) &gt; private public이 가장 넓은 범위이다. 매서드오버라이딩시 접근지정자는 슈퍼클래스의 메서드보다 범위가 줄어들어서는 안된다. 커지는 건 가능. 클래스(객체) 구성요소하나의 클래스는 필드(Field), 생성자(Constructor), 메소드(Method)로 구성된다. 필드 =&gt; 객체의 속성 필드는 멤버변수(=필드변수, 인스턴스 변수)라고 하며 class내부에 선언되는 변수이다. 변수는 선언의 위치에 따라 멤버변수와 지역변수로 나누어진다. 멤버변수는 클래스변수와 인스턴스 변수로 나누어진다. 생성자 =&gt; 멤버변수를 초기화 메서드 =&gt; 객체의 기능 변수변수는 변수의 타입에 따라 기본형과 참조형으로 구분할수있고 또한 변수의 선언 위치에 따라 변수의 종류를 구분할 수도 있다. 선언위치 변수명 변수종류 특징 클래스내부선언 멤버변수 클래스멤버변수 static키워드사용(객체생성필요X, 객체가 메모리에 자동생성) 클래스내부선언 멤버변수 인스턴스멤버변수 static키워드없음(객체생성필요O) 메소드나 생상자에서 생성 지역변수(=로컬변수) 로컬변수 메소드나 생상자에서 생성 지역변수(=로컬변수) 파라미터 변수 메서드 파라미터 참고로 파라미터변수는 지역변수소속이므로 지역변수이다. 멤버변수 VS 지역변수자바는 선언위치에 따라 크게 두 종류의 변수로 나눠진다. 멤버변수 : 클래스변수, 지역변수 class내부에 선언되는 변수 자동으로 초기화됨(주로 0) 지역변수 : 로컬변수, 파라미터변수 메소드나 생성자, 초기화블록처럼 class영역 내에 있는 또 다른 블록 내부에 선언된 변수 메서드가 종료되면 자동소멸된다. 자동으로 초기화안됨. -&gt; 명시적인 초기화가 필요하다. 클래스멤버변수 vs 인스턴스멤버변수이제 멤버변수안에 있는 두가지 변수를 비교해보자클래스멤버변수 = static 멤버변수.static변수은 정적이라는 의미이다. static변수는 객체생성필요없이 사용가능하다. 그럼 객체생성할 필요없는 static멤버변수를 쓰면 편한데 왜 굳이 객체생성까지해야하는 인스턴스멤버변수를 사용할까?자바에서는 static키워드를 사용한다는 것은 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 것을 의미한다.메모리를 많이 잡아먹기때문에 필요한 것들만 사용하는 인스턴스멤버변수를 사용하는 것이 메모리 효율에 좋다. 참고링크 : static변수와 static메소드 static이 붙고 안붙고의 차이를 아래 예시의 출력값으로 비교해보자. 1234567891011121314151617181920public class Person { String name; //인스턴스멤버변수 int age; //인스턴스멤버변수 static int a; //클래스멤버변수}public static void main(String[] args) { Person.a =0; Person p1 = new Person(); //객체생성 -&gt;객체생성을 하지않으면 메모리에 올가가지않기에 객체생성을 꼭해야한다. p1.name = &quot;홍길동&quot;; p1.a = 100; Person p2 = new Person(); //객체생성 p2.name = &quot;이순신&quot;; p2.a = 200; System.out.println(p1.name + &quot; : &quot;+p1.a); //홍길동 : 200 System.out.println(p2.name + &quot; : &quot;+p2.a); //이순신 : 200} 출력값의 차이를 보자인스턴스멤버변수인 name의 경우 홍길동, 이순신 각각 잘 출력되었지만클래스멤버변수인 a의 경우 p1.a =100;이라고 선언해도 탑다운방식으로 출력문전에 200으로 바뀌었으므로 둘다 200으로 출력된다. 전역변수변수를 공부하다가 생각난 변수가 있는데 바로 전역변수이다.자바에는 전역변수가 없나생각했는데 nope!!자바에서는 클래스를 기준으로 사용하므로 클래스안에 있는 멤버변수가 전역변수이다!클래스즉 멤버변수 = 전역변수 = 필드변수라고도한다","link":"/2020/06/24/200625javai/"},{"title":"[패스트캠퍼스python] 세션session, 로그인화면만들기","text":"파이썬 인강 자기계발 챌린지 33회차 미션 1. 세션 Session웹사이트 로그인 기능을 만들기위해 꼭 필요하면서도 중요한 개념인 세션에 대해 알아보자. 구조 설명 클라이언트 웹브라우저 쿠키 서버별 저장소 서버 서버 데이터베이스 클라이언트별 저장소 웹브라우저안에 쿠키라는 저장공간이 있다. 이를 통해 데이터를 유지할수있다.이제 화살표이 흐름을 알아보자. 처음 웹사이트(alghost.com)에 접속한 클라이언트는 아무런 쿠키를 가지고있지않다. 클라이언트는 쿠키없이 서버에 요청을 한다 ex)www.naver.com 서버는 요청을 가지고 쿠키 키를 만든 뒤 헤더위치에 넣어서 클라이언트에게 응답한다. 서버는 만든 쿠키키를 데이터베이스에 저장한다. 클라이언트는 서버로부터 응답을 받으면서 쿠키를 쿠기저장소에 저장을 한다. 쿠키를 저장할때 각 웹사이트별로 나눠서 저장한다. 클라이언트는 두번째 요청부터 모든 요청에 가지고있는 쿠키를 함께 보낸다. 서버는 쿠키정보를 보고 “아 아까 그 클라이언트구나!”를 알게되고 데이터베이스에서 기존 쿠키를 꺼내 빠르게 응답할수있다. 이를 통해 서버는 클라이언트를 구분해서 인지할 수 있다. 세션은 처음에 어렵게 느껴질 수 있지만 Django를 이용하면 세션을 알아서 해주기때문에 편하다. 2. 로그인화면만들기회원가입페이지에 이어 로그인페이지를 만들어보자. 1. HTML파일로 화면그리기먼저 html파일로 간단한 틀을 만들 수 있다.로그인페이지는 사용자명과 비밀번호입력창과 로그인버튼만 있으면 되기때문에 회원가입페이지보다 간단하게 만들 수 있다. error비밀번호가 일치하지 않는 경우 에러문구를 알려주는 코드이다.div태그를 감싸서 에러문구가 나오길 원하는 곳에 위치시켜주면된다. csrf_token크로스도메인을 막기위해 암호화키이다. 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; &lt;h1&gt;로그인&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; {{ error }} &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-12\"&gt; &lt;form method=\"POST\" action=\".\"&gt; {% csrf_token %} &lt;div class=\"form-group\"&gt; &lt;label for=\"username\"&gt;사용자이름&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"username\" placeholder=\"사용자 이름\" name=\"username\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"password\"&gt;비밀번호&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"password\" placeholder=\"비밀번호\" name=\"password\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;로그인&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 2. view.py에 비밀번호일치여부체크 함수구현하기회원가입 페이지를 만들었던것처럼 먼저 views.py에 함수를 선언한다.한꺼번에 모든 기능을 구현하는 것이 아니라 기본 기능부터 차근차근 구현하면서 코드를 진화시켜나가는 것이 좋다.먼저 만들어 볼 기능은 가장 간단한 기능으로 아이디와 비밀번호가 다 입력되었는지 체크하고 입력되어있으면 비밀번호느 일치하는 지에 대한 함수를 코드로 구현할 것이다. render에 html파일 연결하기method는 get방식을 이용한뒤 render에는 위에서 만들었던 login.html을 연결해준다. if조건문 : get방식모든 데이터가 다 있을 경우 get방식으로 바로 login.html파일로 render한다. if조건문 : post방식post방식일 경우에는 데이터가 없으므로 데이터를 입력하라고 해야한다.이때 비밀번호 일치여부도 함께 확인한다. 모든값이 입력되었는지 확인 -&gt; 비밀번호일치하는 지를 체크하느 순서대로 코드를 짠다. 1234567891011121314151617181920def login(request): if request.method == \"GET\": return render(request, 'login.html') elif request.method == \"POST\": username = request.POST.get('username', None) password = request.POST.get('password', None) res_data = {} #불일치할때 데이터를 res_data라는 변수에 담는다. if not (username and password ): res_data['error'] = '모든 값이 입력되지 않았습니다' else: #회원가입시 객체로 만들어놓은 fcuser의 데이터와 일치하는 지 확인 fcuser = Fcuser.objects.get(username=username) #(필드명=지정한값) if check_password(password, fcuser.password): # 리다이렉트 # 세션 pass else: res_data['error'] = '비밀번호를 틀렸습니다' return render(request, 'login.html', res_data) 일부러 번호를 틀리면 아래와 같이 비밀번호를 틀렸습니다라는 error메세지가 제대로 출력되는 것을 확인 할수 있다. 3. view.py에 리다이렉트 함수구현하기위에서 비밀번호일치여부까지 확인했다.로그인할때를 떠올려보자.비밀번호가 일치하고 난 뒤 계속 로그인페이지에 머무느 것이 아니라 main 콘텐츠가 있는 페이지로 자동이동이된다. 이를 redirect라고 한다. import redirect 하기리다이렉트를 사용하기 위해서는 import를 먼저 해줘야한다.장고숏컷 밑에 위치하고있기에 거기서 impor해주면된다. 1from django.shortcuts import render, redirect return redirect(‘url’)redirect뒤에는 주소값을 입력해주면 된다.만약 ('http://naver.com)을 입력하면 로그인을 하고나면 네이버페이지로 이동하는 것이다.보통은 홈으로 이동을 하기때문에 아래와 같이 사용한다./는 홈으로 가는 코드이다. 123456if check_password(password, fcuser.password): # 세션 #리다이렉트 return redirect('/') #홈으로이동else: res_data['error'] = '비밀번호를 틀렸습니다' sessionrequest객체안에 sesssion이라는 변수가 있다. 딕셔너리처럼 이용하면 된다.user라는 키에다가 fufuser.id라는 값을 저장해주기만 하면 끝이다! 1234567if check_password(password, fcuser.password): # 세션 request.session['user']=fcuser.id #리다이렉트 return redirect('/') #홈으로이동else: res_data['error'] = '비밀번호를 틀렸습니다' 4. home 간단히 표현하기root에 연결하기전에 home을 간단히 만들어 로그인뒤 잘 넘어가는지 확인해봐야한다.fcuser 하위의 views.py에 아래 코드를 입력한다. 123456789def home(request): user_id = request.session.get('user') if user_id: #로그인되었으면 로그인한 유저네임출력 fcuser = Fcuser.objects.get(pk=user_id) #pk는 기본키라는 의미 return HttpResponse(fcuser.username) #로그인을 안했다면 그냥 홈 텍스트만 출력 return HttpResponse('home!') 5. root설정이제 기능들을 연결해줄 root를 설정해야한다.어디다 설정하면 될까? 1번선택 : fc_community 하위의 urls.py 2번선택 : fcuser 하위의 urls.py 정답은 바로 1번이다!fuuser 하위의 views.py에서 함수를 만들었지만 root연결은 fcuser상위폴더인 fc_community에 해야한다. fc_community 하위의 urls.py에 아직 만들지않았지만 곧 만들 home을 import 해준 뒤 path('/', home)를 추가한다. 1234567from fcuser.views import home #추가urlpatterns = [ path('admin/', admin.site.urls), path('fcuser/', include('fcuser.urls')) path('', home) #추가]","link":"/2020/06/25/200626python/"},{"title":"[자바JAVA]클래스 : 상속, 메서드 오버라이딩, super()","text":"상속 정의상속은 객체간의 관계를 표현하는 것.상속을 왜 사용할까?프로그램에서 상속은 기존 클래스의 멤버변수와 메서드을 다른 클래스에서 재사용하기 위한 것이다. 상속의 관계에서 물려주는 클래스 : 슈퍼클래스 = 조상클래스 = 모부클래스 = 상위클래스 상속의 관계에서 물려받는 클래스 : 서브클래스 = 자손클래스 = 자식클래스 = 하위클래스 상속 사용방법은 아래와 같다. extends 슈퍼클래스이름으로 작성해주면된다. 1class 서브클래스이름 extends 슈퍼클래스이름 상속 특징 상속의 장점 서브클래스는 멤버변수와 메서드를 자신의 것처럼 사용할 수 있기 때문에 코드 절감 효과. 슈퍼클래스의 코드를 변경하면 모든 서브 클래스들에게도 적용되므로 유지보수성 향상. 상속의 특징 : 단일 상속만 가능 프로그램복잡도를 줄이기 위해서 JAVA는 다중상속을 지원하지않는다. 상속을 여러 슈퍼클래스에서 받을 수 없다. 상속범위 상속대상 : 멤버변수, 메서드 상속제외대상 : 생성자, 초기화블록 생성자는 상속하지않고 super()를 통해 호출한다. 명시적으로 super()를 이용해서 다른 생성자를 호출하는 코드가 없다면 컴파일러는 언제나 슈퍼클래스의 기본 생성자를 호출하는 super()를 생성해 첫 행에 삽입하게 된다. 결론적으로 최상위의 객체인 Object까지 모든 조상객체가 다 만들어지는 구조가 된다. Object 라이브러리 Object는 자바에서 아주 중요한 클래스이며 최상위클래스이다. Object 클래스는 모든 클래스의 조상 클래스로 만약 클래스 선언부에 extends Object생략 가능하다. 메서드 오버라이딩(Method overriding) 슈퍼클래스에서 정의된 기능을 서브 클래스에 적합하게 수정해서 재정의하는 것. 서브클래스의 메서드 오버라이딩을 하면 슈퍼클래스의 메서드를 은닉하고 재정의한다. 은닉한 슈퍼클래스의 메서드에 접근할수있을까? YES!어떻게? super.메서드명();하면된다 메서드 오버라이딩시 똑같아야 하는 것 메서드의 이름은 슈퍼클래스의 메서드 이름과 같아야한다. 매개변수의 개수, 타입, 순서는 슈퍼클래스의 메서드와 같아야한다. 리턴타입은 슈퍼 클래스의 메서드와 같아야한다. 메서드 오버라이딩시 달라도 되는 것 메서드 오버라이딩시 달라도 되는 것 접근지정자 : public &gt; protected &gt; 기본접근지정자(디폴트) &gt; private 하지만 접근지정자가 작아지면 안된다. 메서드오버로딩과 용어헷갈리지않도록 주의! 오버로딩(Overloading) : 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술 오버라이딩(Overriding) : 상속관계일때 사용하며 같은 이름의 메서드를 가진다. 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용 아래는 Person 클래스이다. 123456public class Person{ String name; public void jump(){ System.out.println(\"사람 : 뛰기\"); }} 아래는 spider 클래스이다. 12345public class Spider { public void jump(){ System.out.println(\"스파이터 : 점프\"); }} 이제 오버라이딩해 볼 SpiderMan2 클래스이다.SpiderMan2는 Person클래스를 상속하고 있다. 12345678910111213141516171819public class SpiderMan2 extends Person{ Spider spider = new Spider(); boolean isSpider; @Override //애노테이션 public void jump(){ if(isSpider){ spider.jump(); }else{ System.out.println(\"스파이더맨2 : 뛰기\"); } }}//출력값거미모드로 변신스파이터 : 점프사람모드로 변신스파이더맨2 : 뛰기 애노테이션(Annotation) @Override 컴파일러등을 위한 주석으로 ‘이 메서드는 재정의한 메서드이니까 메서드 오버라이딩 규칙에 맞지 않으면 오류를 발생시켜라’라는 정보를 컴파일러에게 전달한다. 애노테이션 생략가능. super키워드 생성자를 만들면 항상 super()로 먼저 슈퍼클래스를 실행한 뒤에 서브클래스를 실행한다. 하나의 파일안에 여러 class를 둘 수 있지만 이럴땐 두가지 규칙이 있다. 파일명과 동일한 class에만 public을 붙일 수 있다. 파일명과 동일한 class에만 메인메서드를 넣을 수 있다. 보통 실무에서는 하나의 파일에는 하나의 class만 만든다. 구분하기 편하기때문에. super()는 두가지 기능을 한다. 조상멤버변수와 메서드를 참조. 조상의 생성자를 호출. 조상클래스의 생성자를 호출하기 위해 super()가 사용된다.명시적으로 super()를 이용해서 다른 생성자를 호출하는 코드가 없다면 컴파일러는 언제나 슈퍼클래스의 기본 생성자를 호출하는 super()를 생성해 첫 행헤 삽입하게 된다.이는 결론적으로 최상위의 객체인 Object까지 모든 조상객체가 다 만들어지는 구조가 된다. this와 super의 차이점super()와 this()는 둘다 반드시 첫번째 문장에 와야한다.따라서 둘이 함께 쓰지 못한다.둘 중 하나만 쓸 수 있다. this가 현재 객체를 참조(나자신) super는 조상 객체를 참조(부모객체) super예시 : this와 super의 차이점super()와 this()는 모두 참조변수이다.아래는 this와 super의 차이점을 설명해주는 super키워드를 사용한 예시이다.Child는 두개의 멤버변수를 가진다 Parent클래스의 x와 Child클래스의 x. 123456789101112131415161718192021222324252627class Parent{ String x = \"슈퍼클래스의 멤버변수\";}class Child extends Parent { String x = \"서브클래스의 멤버변수\"; void method(){ String x = \"지역변수\"; System.out.println(\"x : \" + x); System.out.println(\"this.x : \" + this.x); System.out.println(\"super.x : \" + super.x); }}public class ScopeTest { public static void main(String[] args) { Child child = new Child(); child.method(); }}//출력값x : 지역변수this.x : 서브클래스의 멤버변수super.x : 슈퍼클래스의 멤버변수 super예시 : 순서아래 코드의 출력값의 순서는 어떻게 될까? 출력값의 순서 main클래스에 따라 MyStudent 클래스를 먼저 실행하는데 extends되어있다 -&gt; MyStydent생성자안에 super()가 생략되어있다. super()인 Student클래스가 먼저 실행되고 난 후 MyStudent생성자의 println이 실행된다. 파라미터가 있는 생성자를 쓰게 된다면 super()가 에러나지않도록 항상 디폴트생성자를 기재해야한다! 1234567891011121314151617181920212223242526class Student{ public Student(){} //디폴트생성자 public Student(int a) { //생성자 System.out.println(\"슈퍼생성자\"); } }public class MyStudent extends Student{ public MyStudent(){ //super(); 자동생성되며 생략됨 System.out.println(\"서브생성자\"); }}public class Test { public static void main(String[] args) { MyStudent ms = new MyStudent(); //객체생성 }}//출력값슈퍼생성자서브생성자 혹시 아래 코드처럼 super()를 밑에 작성해도 같은 결과가 나올까? 123456public class MyStudent extends Student{ public MyStudent(){ System.out.println(\"서브생성자\"); super(); }} 아랫줄에 작성하면 에러Constructor call must be the first statement in a constructor가 발생한다.super()는 항상 생성자 구현부의 첫번째줄에 있어야한다. Student 생성자의 생략된 super()는 Object를 상속받고있다.모든 클래스는 Object를 상속받는다.","link":"/2020/07/05/200706javai/"},{"title":"[ITWILL : JSP]JDBC활용 - 회원정보수정페이지만들기","text":"ITWILL학원 : 21강 JSP기초 BY 정규태강사JDBC JDBC활용 - import쓰는 이유, form페이지로 받은 데이터를 DB에 insert하는 방법 JDBC활용 - JAVA에서 DB 정보 지우기 2가지방법 JDBC활용 - DB에서 고객정보를 불러와서 HTML테이블에 담기 JDBC활용 - TIMESTAMP주의점, JDBC에서 데이터처리 JDBC활용 - 회원정보수정페이지만들기 JDBC활용 - 회원목록출력하는데 관리자는 빼고 출력하기, 자바 에러 두종류 사용자가 로그인한 뒤 자신의 정보를 수정할 수 있는 마이페이지를 만들어보자. 회원정보를 수정할 수 있는 전제는 로그인이다.로그인이 되어있지않다면 로그인페이지로 이동시켜야한다.로그인이 되어있는 사용자는 사용자정보를 DB에서 불러와서 화면에 각 요소를 출력한다 -&gt; 원하는 정보를 수정한 뒤 다시 DB에 업데이트해야한다. 1. 회원정보수정폼 페이지만들기로그인한 사용자에 한하여 DB에 저장되어있는 해당 회원정보를 FORM형식으로 나타내주는 updateForm.jsp 페이지를 만들어보자. 다음은 회원정보수정폼 작성 순서이다. 1-1. 로그인여부를 먼저 체크. &amp; 한글처리 &amp; 변수로딩 로그인이 되어있지않다면 로그인페이지로 이동 id값을 가져올 수 있는 방법이 여기서는 두가지이다, 기본 방식은 파라미터로 가져오거나 = request.getParameter(“id”) session을 이용했기에 세션활용. 세션값은 object이기에 String으로 형변환필수 = (String) session.getAttribute(“id”) 1-2.드라이브로드 &amp; DB를 연결.DB에 저장된 회원정보를 사용해야함으로 드라이브로드 &amp; DB를 연결해야한다. 1-3. SQL 구문작성 &amp; pstmt select구문으로 해당 id에 관한 모든 정보를 DB에서 불러온다 많은 컬럼중에 왜 하필 id일까? =&gt; id가 primary key이기 때문이다. primary key를 기준으로 where조건문을 걸어 DB에서 데이터를 select하면 된다. select쿼리이므로 executeQuery()와 executeUpdate()중 executeQuery()를 사용하면 된다. select쿼리이므로 pstmt는 int형 변수에 저장해서 사용하면 된다. 1-4. 실행 -&gt; rs에 결과저장 -&gt; 데이터처리 지역변수에 데이터를 넣어서 사용할 수 있다. 지역변수는 멤버변수처럼 자동으로 초기화되지 않는다. 따라서 직접해줘야한다 지역변수의 초기화값은 데이터타입에 따라 다르다. 초기화값은 보통 0이나 null임. 실무에선 String 초기화시 null보단 “”로 사용한다. 데이터타입 초기화값 int 0 String “”(공백) 배열 0 참조형(Timestamp등) null 1-5. 비밀번호를 입력받은 뒤 사용자가 입력한대로 데이터수정하기 -&gt; updatePro.jsp에서 진행12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;%//1. 로그인여부체크 (로그인x-&gt;로그인페이지로이동)request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\"); //object이기에 형변환필수if(id == null){ //로그인페이지이동 response.sendRedirect(\"loginForm.jsp\");} //2. 드라이브로드 &amp; 디비연결 : 로그인한 사용자의 정보를 가져오기final String DRIVER = \"com.mysql.jdbc.Driver\";final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";final String DBID = \"root\";final String DBPW = \"1234\";Class.forName(DRIVER);Connection con = DriverManager.getConnection(DBURL, DBID, DBPW);System.out.println(\"드라이브로드와 디비연결성공\");//3. SQL &amp; PSTMT &amp; 실행String sql = \"select * from itwill_member where id=?\";PreparedStatement pstmt = con.prepareStatement(sql);pstmt.setString(1, id);//4. 실행-&gt; rs에 결과저장 -&gt; 데이터처리ResultSet rs = pstmt.executeQuery();//지역변수초기화-자동으로 안됨.String name = \"\";int age = 0;String gender = \"\";String email = \"\";Timestamp reg_date = null; // Timestamp의 초기값은 null임if(rs.next()){ //id=rs.getString(\"id\"); 세션으로 가져와서 필요없음 name = rs.getString(\"name\"); age = rs.getInt(\"age\"); gender = rs.getString(\"gender\"); email = rs.getString(\"email\"); reg_date = rs.getTimestamp(\"reg_date\");}//4. gender를 입력안하고 회원가입한경우 if(gender == null){ gender=\"여\"; }//5. 비밀번호를 입력받은 뒤 수정하기 -&gt;updatePro.jsp에서 진행%&gt;&lt;fieldset&gt;&lt;legend&gt;회원정보수정&lt;/legend&gt; &lt;form action=\"updatePro.jsp\" method=\"post\" name=\"fr\"&gt; 아이디 &lt;input type=\"text\" name=\"id\" value=\"&lt;%=id %&gt;\" readonly&gt;&lt;br&gt; 비밀번호 &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; 이름 &lt;input type=\"text\" name=\"name\" value=\"&lt;%=name %&gt;\"&gt;&lt;br&gt; 나이 &lt;input type=\"text\" name=\"age\" value=\"&lt;%=age %&gt;\"&gt;&lt;br&gt; 성별 &lt;input type=\"radio\" name=\"gender\" value=\"여\" &lt;% if(gender.equals(\"여\")){ %&gt; checked &lt;%}%&gt; &gt; 여성 &lt;input type=\"radio\" name=\"gender\" value=\"남\" &lt;% if(gender.equals(\"남\")){ %&gt; checked &lt;%}%&gt; &gt; 남성&lt;br&gt; 이메일 &lt;input type=\"text\" name=\"email\" value=\"&lt;%=email %&gt;\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"회원정보수정하기\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 2. 회원정보수정페이지의 데이터처리페이지만들기아래는 회원정보폼에 수정을 하면 update구문을 실행하는 updatePro.jsp 코드이다. 2-1. 로그인여부를 먼저 체크 로그인이 되어있지않다면 로그인페이지로 이동 id값을 가져올 수 있는 방법이 여기서는 두가지이다, 기본 방식은 파라미터로 가져오거나 = request.getParameter(“id”) session을 이용했기에 세션활용. 세션값은 object이기에 String으로 형변환필수 = (String) session.getAttribute(“id”) 2-2. 한글처리 &amp; 변수가져오기변수에 전달된 정보를 저장(아이디,비번,이름,나이,성별,이멜)한다 2-3. 드라이브로드 &amp; DB를 연결.2-4. SQL 구문작성 &amp; pstmt수정하고자하는 id정보가 DB에 있는지 select구문으로 판단 2-5. 실행 -&gt; rs에 결과저장 -&gt; 데이터처리 아이디,비번 동일한 경우 =&gt; 입력받은 데이터를 DB에 update. 비밀번호오류 =&gt; 에러메세지 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;%//1.로그인여부체크 -&gt;로그인페이지이동String id = (String) session.getAttribute(\"id\");if (id == null) { response.sendRedirect(\"loginForm.jsp\");}//2. 한글처리 &amp; 변수 : 전달된 정보를 저장(아이디,비번,이름,나이,성별,이멜)request.setCharacterEncoding(\"UTF-8\");//String id = request.getParameter(\"id\"); 세션으로 이미가져왔음String pw = request.getParameter(\"pw\");String name = request.getParameter(\"name\");int age = Integer.parseInt(request.getParameter(\"age\"));String email = request.getParameter(\"email\");String gender = request.getParameter(\"gender\");//3. 드라이버로드 &amp; DB연결final String DRIVER = \"com.mysql.jdbc.Driver\";final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";final String DBID = \"root\";final String DBPW = \"1234\";Class.forName(DRIVER);Connection con = DriverManager.getConnection(DBURL, DBID, DBPW);System.out.println(\"updatePro : 드라이브로드와 디비연결성공\");//4. SQL구문 &amp; pstmt실행 &amp; 실행-&gt;rs저장// 4-1 sql구문 : 수정하고자하는 사람의 정보가 있는지 판단 후 selectString sql = \"select pw from itwill_member where id=?\";PreparedStatement pstmt = con.prepareStatement(sql);pstmt.setString(1, id);//5. 데이터처리 // 아이디,비번 동일한 경우 =&gt; 수정// 비밀번호오류 =&gt; 에러메세지ResultSet rs = pstmt.executeQuery();if(rs.next()){ //아이디있는 경우 if(pw.equals(rs.getString(\"pw\"))){// 비밀번호 일치하는 경우 sql = \"update itwill_member set name=?,age=?,gender=?,email=?\" +\"where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, name); pstmt.setInt(2, age); pstmt.setString(3, gender); pstmt.setString(4, email); pstmt.setString(5, id); pstmt.executeUpdate(); System.out.println(\"회원정보수정완료\"); response.sendRedirect(\"main.jsp\"); }else{ // 비밀번호 불일치하는 경우 %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"비밀번호오류로 수정불가\") history.back(); //뒤로가기. &lt;/script&gt; &lt;% System.out.println(\"비밀번호오류로 수정불가\"); }}else{ //아이디없는 경우 %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"비회원입니다\") history.back(); //뒤로가기. &lt;/script&gt; &lt;% System.out.println(\"아이디오류\");}%&gt;","link":"/2020/07/06/200707jspi/"},{"title":"[자바JAVA]클래스 : 다형성(Polymorphism)","text":"캐스팅은 OOP(객체지향프로그래밍) 에서 매우 중요하다.왜냐하면 캐스팅은 OOP의 다형성과 관련이 있기 때문이다. 다형성java에서 기본형이 아닌 참조형데이터일때, 그리고 상속관계에 있을 때에 한정해서 슈퍼클래스 타입으로 서브클래스 객체를 레퍼런스할 수 있는 성질. 동일한 형태의 구성으로 다양한 결과를 사용하는 것 인터페이스에서 다형성 사용하는 이유 : 하위클래스들 작성시 동일한 구조를 강요하기위해서(=통일성) 사용하기 위해서 request,response 정보를 사용하기 위해서 캐스팅종류(casting, 형변환)캐스팅은 크게 자동 형변환, 명시적 형변환으로 나뉜다.또 데이터 타입에 따라 다르다. 데이터타입 캐스팅종류 기본형 자동 형변환 기본형 명시적 형변환 (상속관계의) 참조형 자동 형변환(UpCasing) (상속관계의) 참조형 명시적 형변환(DownCasing) 상속관계일때 캐스팅은 크게 두가지로 나뉜다.두 캐스팅의 전제조건은 상속이다. 참고링크 : JAVA - UpCasting(업캐스팅) UpCasting(업캐스팅 = 자동형변환) : 서브클래스가 슈퍼클래스로 형변환 되는 것. 슈퍼클래스의 레퍼런스에 서브클래스의 인스턴스(객체)를 저장. 컴파일러가 자동으로 형변환 업캐스팅을 하면 상속 받은 멤버(멤머변수,메서드)만 쓸 수 있다. 업캐스팅을 참조영역이 감소했다고 표현한다 WHY? 원래 Child는 Parent와 Child을 둘 다 쓸 수 있었는데 업캐스팅때문에 상속받은 것만 쓸 수 있게 됨 업캐스팅하는 3가지방법 123456Parent p = new Parent();Child c = new Child();Parent p1 = (Parent) new Child(); //업캐스팅 1번방법Parent p2 = new Child(); //업캐스팅 2번방법Parent p3 = c; //업캐스팅 3번방법 DownCasting(다운캐스팅 = 명시적 형변환) : 슈퍼클래스가 서브클래스로 형변환 되는 것. 다운캐스팅은 컴파일러가 자동으로 형변환 X =&gt; WHY? 해당객체가 존재하지 않을 수도 있기때문에 따라서 개발자가 직접 타입을 구현해야한다. =&gt; 예외가 발생한다고 표현함. UpCasting이 일어난 값에 한해서만 DownCasting이 가능하다. 서브클래스의 레퍼런스에 슈퍼클래스의 인스턴스(객체)를 저장. 123456789101112131415161718192021Parent p = new Parent();Child c = new Child();//아래 코드 네줄은 컴파일 에러가 발생한다. = Error//Type mismatch: cannot convert from Parent to ChildChild c1 = new Parent();c1.슈퍼클래스메서드명();c1.서브클래스메서드명();Child c2 = p;//아래 코드 네줄은 예외가 발생한다. = Exception//Exception in thread \"main\" java.lang.ClassCastException//업캐스팅을 안해서 다운캐스팅을 할수없다 heap메모리에는 은닉된 Childrk c2가 없음.Child c2 = (Child) new Parent();c1.슈퍼클래스메서드명();c1.서브클래스메서드명();Child c2 = p;//업캐스팅한 뒤 다운캐스팅이 가능하다Parent pp = new Child(); //업캐스팅Child c3 = pp; 다형성이 왜 필요할까? 다형성과 참조형 객체의 형변환 insteadof 연산자 참조변수의 레벨에 따른 객체멤버 연결 공변 리턴 타입 다형성과 참조형 객체의 형변환자바의 데이터타입은 크게 두가지로 나뉜다. 기본형데이터(8가지) : 기본 데이터형에서의 캐스팅은 원칙적으로 데이터손실을 막고자 한다. 종류 : 자동 형변환, 명시적 형변환.아래는 double형을 int형으로 형변환한 코드이다. 1int a = (int)1.0; 참조형데이터 종류 : 자동 형변환, 명시적 형변환. 조건 : 상속관계일때 성립.아래 예시를 보자.슈퍼클래스인 Parent와 서브클래스 Child가 있다.서브클래스 Child의 데이터양은 슈퍼클래스인 Parent보다 항상 많다.서브클래스가 슈퍼클래스를 포함하기때문이다. 기본적으로 같은 타입을 한 배열에 넣을 수 있다. 12345Person[] p = {new Person, new Person};SpiderMan[] sp = {new SpiderMan, new SpiderMan};AquaMan[] aq = {new AquaMan, new AquaMan}; 하지만 spiderMan과 AquaMan은 person에 포함된다고 볼 수 있다. 타입이 다른 참조형데이터를 하나의 배열에 넣을 순 없을까?할 수 있다!다형성을 적용하여 형변환을 하면 된다.상속관계인 경우에만 타입이 다른 참조형데이터를 하나의 배열에 묶을 수 있다. 123456789101112131415//배열선언 2가지 방법 : 1번과2번은 동일한 값을 가진다//1번째방법 : 업캐스팅Person[] p = new Person[3]p[0] = new Person();p[1] = new SpiderMan();p[2] = new AquaMan();//다운캐스팅Person pp = (Person) p[0];SpiderMan sp = (SpiderMan) p[1];AquaMan ap = (AquaMan) p[2];//2번째방법 : 업캐스팅 형변환Person[] p = {new Person. new SpiderMan, new AquaMan} instanceof 연산자슈퍼타입을 언제나 형변환 연산자를 통해 서브타입으로 변경할 수는 없다.먼저 메모리에 있는 객체가 형변환을 위한 충분조건을 갖추고 있는지 확인해봐야한다.이때 사용할 수 있는 연산자가 instansof이다. 실제 메모리에 있는 특정 클래스 타입인지를 boolean타입으로 리턴한다.따라서 결과가 true일때 형변환 처리하면 된다. 1234567891011121314151617class Person {}class SpiderMan extends Person {}Person p = new Person();if( p instanceof SpiderMan) //=&gt; 변수p가 SpiderMan타입인가? 거짓if( p instanceof Person) =&gt; 참if( p instanceof Object) =&gt; 참Person p2 = new SpiderMan(); if( p2 instanceof SpiderMan) // =&gt; 변수p2가 SpiderMan타입인가? 참if( p2 instanceof Person) =&gt; 참if( p2 instanceof Object) =&gt; 참SpiderMan s = new SpiderMan();if( s instanceof SpiderMan) // =&gt; 변수s가 SpiderMan타입인가? 참if( s instanceof Person) =&gt; 참if( s instanceof Object) =&gt; 참 참조변수의 레벨에 따른 객체멤버 연결상속을 이용하면 조상의 멤버들을 그대로 물려받으며 필요할 때 자손은 그 멤버들을 재정의할 수 있다.아래 코드를 보고 답변해보자 SubClass의 멤버변수는 몇개인가? SubClass의 메서드는 몇개인가? main메서드 실행 값은 순서대로 어떻게 될 것인가? 1234567891011121314151617181920212223242526272829303132class SuperClass{ String x = \"super\"; //멤버변수 public void method(){ System.out.println(\"super클래스메서드\"); }}class SubClass extends SuperClass{ String x =\"sub\"; //멤버변수 public void method(){ //메서드이름이 슈퍼클래스와 동일 = 메서드오버라이딩 System.out.println(\"sub클래스메서드\"); } }public class SuperSubTest { public static void main(String[] args) { SubClass sub = new SubClass(); //객체생성 System.out.println(sub.x); sub.method(); SuperClass super1 = sub; //업캐스팅 System.out.println(super1.x); super1.method(); }}//출력값subsub클래스메서드supersub클래스메서드 SubClass의 멤버변수는 2개 SubClass의 메서드는 오버라이딩되었기때문에 메서드는 1개다. 애노테이션(Annotation)이 있으면 구분이 쉬우니 꼭 적자. =&gt; 애노테이션위치는 subClass의 멤버변수와 메서드 사이에 위치! 다이나믹바인딩때문에 super클래스의 메서드가 아니라 sub클래스의 메서드이다. 그래서 sub에서 재정의된 메서드가 실행된다. 공변 리턴 타입원래 메서드 오버라이딩시 서브메서드의 리턴 타입은 슈퍼클래스의 리턴 타입과 같아야 한다.하지만 공변 리턴타입는 슈퍼클래스의 리턴 타입을 서브 클래스 범위 안에서 다양하게 사용할 수 있다.리턴타입이 변화되기때문에 오버라이딩 규칙에 위배되지만 JDK 1.5버전부터는 예외로 허용하고있다. 주의점 : 상속관계상의 서브클래스에서만 가능. 장점 : 형변환의 번거로움을 많이 줄일 수 있다. 참고링크 : Covariant return types","link":"/2020/07/07/200708javai/"},{"title":"[ITWILL : JSP]Javabean 3 : 회원정보조회&#x2F;수정 페이지만들기","text":"ITWILL학원 : 24강 JSP기초 BY 정규태강사자바빈 프로젝트 1 : 회원가입페이지만들기자바빈 프로젝트 2 : 로그인 및 로그아웃페이지만들기자바빈 프로젝트 3 : 회원정보조회 및 수정페이지만들기 1. 메인페이지 main.jsp에서 버튼 추가메인페이지에 회원정보조회 버튼을 만든다 123456789101112131415&lt;%//1.한글처리, 파라미터 (세션생성)request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅String name = request.getParameter(\"name\");//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동if(id == null){ response.sendRedirect(\"loginForm.jsp\");}%&gt;&lt;h2&gt;&lt;%=id %&gt;님 환영합니다.&lt;/h2&gt;&lt;input type=\"button\" value=\"회원정보조회\" onclick=\"location.href='memberinfo.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" onclick=\"location.href='updateForm.jsp'\"&gt;&lt;input type=\"button\" value=\"로그아웃\" onclick=\"location.href='logout.jsp'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" onclick=\"location.href='deleteForm.jsp'\"&gt; 2. 회원정보조회페이지 memberinfo.jsp 생성회원정보를 DB에서 가져와서 출력하는 memberinfo.jsp를 만든다 순서 한글설정 &amp; 변수생성 1-1. id값확인 -없으면 로그인페이지로 이동 MemberDAO객체 생성 -&gt; 회원정보 가져오는 메서드생성 MemberBean import하기 MemberBean 데이터타입 mb변수로 메서드정보 담아오기 데이터처리 : 테이블에 담기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//1. 한글설정 &amp; 변수생성String id = (String) session.getAttribute(\"id\");//object이기에 형변환필수//1-1.id값확인 -없으면 로그인페이지로 이동if(id == null){ response.sendRedirect(\"loginForm.jsp\");}//2. 멤버DAO객체 생성 -&gt; 회원정보 가져오는 메서드생성MemberDAO mdao = new MemberDAO();MemberBean mb = mdao.getMember(id);//3. 데이터처리 : 테이블로 표현if(mb != null){%&gt;&lt;h2&gt;마이페이지&lt;/h2&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;&lt;%=mb.getId() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;&lt;%=mb.getPw() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;&lt;%=mb.getName() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;나이&lt;/td&gt; &lt;td&gt;&lt;%=mb.getAge() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;성별&lt;/td&gt; &lt;td&gt;&lt;%=mb.getGender() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;이메일&lt;/td&gt; &lt;td&gt;&lt;%=mb.getEmail() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;회원가입일&lt;/td&gt; &lt;td&gt;&lt;%=mb.getReg_date() %&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;% } %&gt;&lt;hr&gt;&lt;input type=\"button\" value=\"뒤로가기\" onclick=\"location.href='main.jsp'\"&gt; 3. DAO에서 getMember()메서드만들기회원정보 가져오는 메서드 getMember()로 회원정보 전부 리턴 -&gt; 테이블에 추가해야한다. 순서 드라이브로드 &amp; 디비연결 SQL 구문 작성 &amp; pstmt 생성 실행 -&gt; rs저장 데이터처리 : DB에 있는 회원정보 저장 후 memberinfo페이지로 전달 4-1. MemberBean mb = null; //객체 레퍼런스 생성 4-2. rs.next() : DB의 컬럼명과 일치해야함! 자원해제 1234567891011121314151617181920212223242526272829303132333435363738public MemberBean getMember(String id){ MemberBean mb = null; //객체 레퍼런스 생성 //왜 null인가? 정보가 생성되는 시점은 rs에 있을때이다. //따라서 rs가 없을땐 굳이 만들필요가 없다. try{ //5-1. 드라이브로드 디비연결 con = getCon(); //5-2. SQL &amp; pstmt 생성 sql = \"select * from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); //5-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //5-4. 데이터처리 : DB에 있는 회원정보 저장 후 memberinfo페이지로 전달 //5-4-1. MemberBean mb = null; //객체 레퍼런스 생성 //DB의컬럼명을 입력할 것 if(rs.next()){ mb = new MemberBean(); mb.setId(rs.getString(\"id\")); mb.setPw(rs.getString(\"pw\")); mb.setName(rs.getString(\"name\")); mb.setAge(rs.getInt(\"age\")); mb.setEmail(rs.getString(\"email\")); mb.setGender(rs.getString(\"gender\")); mb.setReg_date(rs.getTimestamp(\"reg_date\")); System.out.println(\"회원정보저장완료\"); } System.out.println(\"sql구문실행완료\"); }catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { //5-5. 자원해제 closeDB(); } return mb;} 4. 회원정보수정페이지 updateForm.jsp 생성순서 한글처리 &amp; 세션변수 1-1. 로그인여부체크 (로그인x-&gt;로그인페이지로이동) //object-&gt;string 형변환필수 드라이브로드 &amp; 디비연결 = 멤버DAO객체 생성 -&gt; getMember()메서드호출 로그인한 사용자의 정보를 가져오기 getMember()를 이용해서 id에 해당하는 회원정보 가져오기 데이터처리 : 테이블형식으로 출력 비밀번호를 입력받은 뒤 수정하기 -&gt;updatePro.jsp에서 진행 12345678910111213141516171819202122232425262728293031323334353637&lt;%//1.로그인여부체크 (로그인x-&gt;로그인페이지로이동)request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object이기에 형변환필수if(id == null){ response.sendRedirect(\"loginForm.jsp\");} //2. 드라이브로드 &amp; 디비연결 : 로그인한 사용자의 정보를 가져오기MemberDAO mdao = new MemberDAO();MemberBean mb = mdao.getMember(id);//3. 데이터처리 : 테이블형식으로 출력//4. 비밀번호를 입력받은 뒤 수정하기 -&gt;updatePro.jsp에서 진행%&gt;&lt;fieldset&gt;&lt;legend&gt;회원정보수정&lt;/legend&gt; &lt;form action=\"updatePro.jsp\" method=\"post\" name=\"fr\"&gt; 아이디 &lt;input type=\"text\" name=\"id\" value=\"&lt;%=mb.getId() %&gt;\" readonly&gt;&lt;br&gt; 비밀번호 &lt;input type=\"password\" name=\"pw\" placeholder=\"비밀번호를 입력하세요\" required&gt;&lt;br&gt; 이름 &lt;input type=\"text\" name=\"name\" value=\"&lt;%=mb.getName() %&gt;\"&gt;&lt;br&gt; 나이 &lt;input type=\"text\" name=\"age\" value=\"&lt;%=mb.getAge() %&gt;\"&gt;&lt;br&gt; 성별 &lt;input type=\"radio\" name=\"gender\" value=\"여\" &lt;% if(mb.getGender().equals(\"여\")){ %&gt; checked &lt;%}%&gt; &gt; 여성 &lt;input type=\"radio\" name=\"gender\" value=\"남\" &lt;% if(mb.getGender().equals(\"남\")){ %&gt; checked &lt;%}%&gt; &gt; 남성&lt;br&gt; 이메일 &lt;input type=\"text\" name=\"email\" value=\"&lt;%=mb.getEmail() %&gt;\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"회원정보수정하기\"&gt; &lt;/form&gt;&lt;/fieldset&gt;&lt;button onclick=\"location.href='main.jsp'\"&gt;뒤로가기&lt;/button&gt; 5. 회원정보수정페이지 updatePro.jsp 생성순서 로그인여부체크 -&gt;로그인페이지이동 액션태그사용 : 전달된 정보를 저장(아이디,비번,이름,나이,성별,이멜) = jsp:useBean2-1. 파라미터 값 저장 = jsp:setProperty MeberDAO객체 생성 -&gt; updateMember()메서드 호출 데이터처리 : 1-수정완료, 0-비번오류, -1-아이디없음 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%//1. 한글처리 &amp; 로그인여부체크 -&gt;로그인페이지이동request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");if (id == null) { response.sendRedirect(\"loginForm.jsp\");}%&gt;&lt;!-- 2. 액션태그사용 : 전달된 정보를 저장(아이디,비번,이름,나이,성별,이멜) --&gt;&lt;jsp:useBean id=\"mb\" class=\"com.itwillbs.member.MemberBean\" /&gt;&lt;!-- 2-1. 파라미터 값 저장 --&gt;&lt;jsp:setProperty property=\"*\" name=\"mb\"/&gt;&lt;%//3. MeberDAO객체 생성MemberDAO mdao = new MemberDAO();//4. 데이터처리 : 1-수정완료, 0-비번오류, -1-아이디없음int result = mdao.updateMember(mb);if(result == 1){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"회원정보수정 성공\"); &lt;/script&gt; &lt;% System.out.println(\"회원정보수정성공\"); response.sendRedirect(\"main.jsp\");}else if(result == 0){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"비밀번호오류로 회원정보수정실패\"); history.back(); &lt;/script&gt; &lt;%}else{ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"존재하지않는 아이디입니다.\"); history.back(); &lt;/script&gt; &lt;%}%&gt; 6. DAO에서 updateMember()메서드만들기회원정보 수정 메서드 순서 드라이브로드 &amp; 디비연결 SQL 구문 작성 &amp; pstmt 생성 2-1. select 사용해서 id가 있는지 체크 실행 -&gt; rs저장 데이터처리 : DB에 있는 회원인 경우 4-1. DB에 있는 회원 -&gt; 비번체크 : 비번일치(-&gt;수정) 비번불일치(-&gt;에러) 비번일치하는 경우 : SQL 구문작성 &amp; pstmt 생성 -&gt; 실행 4-2. DB에 없는 회원 -&gt; 에러 자원해제 1234567891011121314151617181920212223242526272829303132333435363738394041public int updateMember(MemberBean mb){ int result = -1; try { //6-1. 드라이브로드 디비연결 con = getCon(); //6-2. SQL 구문작성 &amp; pstmt 생성 sql = \"select pw from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, mb.getId()); //6-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //6-4. 데이터처리 : DB에 있는 회원인 경우 수정 아닌 경우 에러 if(rs.next()){//DB에 있는 회원 if(mb.getPw().equals(rs.getString(\"pw\"))){//비번일치 //6-5. 비번일치하면 정보수정 작업 //6-5-1. SQL 구문작성 &amp; pstmt 생성 sql = \"update itwill_member set name=?, age=?, gender=?, email=? \" + \"where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, mb.getId()); //6-5-2. 실행 pstmt.executeUpdate(); System.out.println(\"회원정보수정성공\"); result = 1; }else{ result = 0; System.out.println(\"아디일치,비번불일치 - 회원정보수정실패\"); } }else{ //DB에 없는 회원 result = -1; System.out.println(\"존재하지않는아이디 - 회원정보수정실패\"); } } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } finally{ closeDB(); } return result;}//updateMember닫힘","link":"/2020/07/13/200714jspi2/"},{"title":"[ITWILL : JSP]자료구조1 : Collections Framwork(Set계열, List계열)","text":"ITWILL학원 : 26강 JSP기초 BY 정규태강사 1. 컬렉션 클래스의 제네릭 (Collections.Generic) 컬렉션프레임워크 또는 컬렉션 클래스 또는 컨테이너라고도 부른다. 즉 값을 담는 그릇이라는 의미이다. 그런데 그 값의 성격에 따라서 컨테이너의 성격이 조금씩 달라진다. 자바에서는 다양한 상황에서 사용할 수 있는 다양한 컨테이너를 제공하는데 이것을 컬렉션즈 프래임워크라고 부른다. 참고링크 : 생활코딩 컬렉션즈프레임워크 JDK5 버전이후부터 사용가능 자료구조 학문을 구현한 클래스이다. 요소라는 데이터를 가변인자의 객체에 저장하는 형태이다. 컬렉션 클래스들은 Collections 인터페이스의 하위 클래스/인터페이스이다. Collections인터페이스의 상위클래스는 Object클래스(최상위객체)이다. 컬렉션 클래스들은 toString()메서드가 구현되어있다. 공통 장점 : 데이터의 삽입, 삭제, 검색기능이 뛰어남. 주요 종류 : Set List Map(Table포함) 공통메서드 : 변수명.add : 데이터저장 변수명.get(index) : 배열의 index에 위치해 있는 값 출력 변수명.set(idx, 변경값) : 데이터변경 변수명.size() : 길이를 반환 iterator() 2. Iterator Iterator는 반복자, 즉 반복문의 동작을 할 수 있는 인터페이스이다. 해당 컬렉션에서 현재위치, 다음단계로의 이동동작을 반복가능하게 한다. 모든 컬렉션클래스들은 슈퍼클래스의 iterator()메서드를 모두 사용가능하다. Iterator 패턴 : 디자인패턴중의 하나로 중급개발자로 가는 길목에 이다. [디자인패턴](https://gmlwj d9405.github.io/2018/07/06/design-pattern.html)은 필수이므로 꼭 따로 학습 해볼것 3. Set계열의 컬렉션 클래스 서로 다른타입의 데이터를 저장가능함. why? Object로 업캐스팅을 할 것이기때문에! 순서를 포함하지 않음 데이터 중복을 허용하지 않음. Set계열은 중복x, 순서정보가 없기때문에 반복문을 사용할 수가 없다 -&gt; 반복문 대신 interator 사용 예 : HashSet 클래스 : Set 인터페이스를 구현한 서브클래스이다. 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) { // TODO Auto-generated method stub //Set&lt;E&gt; //Set set = new Set(); //인터페이스는 객체를 생성할 수 없다 Set set = new HashSet(); //업캐스팅(HashSet -&gt; Set) System.out.println(\"요소의 갯수 : \"+set.size()); set.add(\"하나\"); set.add(\"2\"); set.add(\"3.14\"); set.add(\"c\"); set.add(5); set.add(5); set.add(5); System.out.println(\"요소의 갯수 : \"+set.size()); System.out.println(set); System.out.println(\"ㅡㅡㅡㅡㅡSet계열 반복문사용\"); //Set계열은 중복x, 순서정보가 없기때문에 반복문을 사용할 수가 없다 //이때 사용하는 것이 interator이다 Iterator is = set.iterator(); while(is.hasNext()){ System.out.println(is.next()); }}//출력값요소의 갯수 : 0요소의 갯수 : 5 //중복을 허용하지않는다.[2, c, 5, 3.14, 하나] //중복을 허용하지않는다. 내가 넣은 순서대로 출력되지않는다.ㅡㅡㅡㅡㅡSet계열 반복문사용2c53.14하나 4. List계열의 컬렉션 클래스 서로 다른타입의 데이터를 저장가능함. why? Object로 업캐스팅을 할 것이기때문에! 순서가 저장됨 how? 저장할때 요소의 위치(index)값을 사용하기때문에! 요소의 위치는 배열처럼 0부터 접근하면 됨 데이터 중복 허용 Set계열보다 List계열을 더 많이 사용함 예 : ArrayList, Vector, Stack, LinkedList 4-1. ArrayList 장점 : 고정길이 배열의 단점을 보완. 저장공간의 크기가 필요에 따라 자동으로 증가함.가장 많이 사용한다. 예시 : ArrayList 데이터 입력 및 출력 123456789101112131415161718ArrayList list = new ArrayList();list.add(\"하나\");list.add(\"2\");list.add(\"3.14\");list.add(\"c\");list.add(5);list.add(5);list.add(5);System.out.println(\"요소의 갯수 : \"+ list.size());System.out.println(list);System.out.println(list.get(3));//출력값요소의 갯수 : 7[하나, 2, 3.14, c, 5, 5, 5]c 예시 : ArrayList 반복문사용순서(index)값이 저장되기때문에 Iterator가 아닌 반복문을 사용할 수 있다.전체 데이터를 출력하는 반복문이다. System.out 대신 System.err 입력하면 에러형태(빨간글자)로 콘솔에 출력된다 123456789101112131415161718192021222324252627282930System.out.println(\"ㅡㅡㅡㅡㅡfor문\");for(int i=0; i&lt;list.size(); i++){ System.out.println(list.get(i));}System.out.println(\"ㅡㅡㅡㅡㅡ확장for문\");//확장 for문 for-each//for(해당 타입의 요소 변수명 : 반복할배열/컬렉션){}for(Object i : list){ //System.err.println(i); 에러형태(빨간글자)로 콘솔에 출력 System.out.println(i);}//출력값ㅡㅡㅡㅡㅡfor문하나23.14c555ㅡㅡㅡㅡㅡ확장for문하나23.14c555 예시 : index활용 1234567891011121314151617181920System.out.println(\"ㅡㅡㅡㅡㅡindexof 사용\");System.out.println(list.indexOf(5)); System.out.println(\"ㅡㅡㅡㅡㅡindex활용한 add/set\");//기존데이터System.out.println(list);//데이터추가list.add(3, \"안녕하세요\");System.out.println(list);//데이터변경list.set(3, \"하이\");System.out.println(list);//출력값ㅡㅡㅡㅡㅡindexof4ㅡㅡㅡㅡㅡindex활용한 add[하나, 2, 3.14, c, 5, 5, 5][하나, 2, 3.14, 안녕하세요, c, 5, 5, 5][하나, 2, 3.14, 하이, c, 5, 5, 5] 예시 : 조건에 따른 데이터변경(반복문 사용)배열에 “2”가 있는 경우 “two”로 변경해보자 내코드 123456789//내코드for(int i=0; i&lt;list.size(); i++){ if(list.get(i) == \"2\"){ list.set(i, \"two\"); }}System.out.println(list);//출력값[하나, two, 3.14, 하이, c, 5, 5, 5] 강사님코드 indexOf()는 데이터가 존재할 경우 index값을 출력하고 없는 경우 -1을 출력한다. 12345678910//강사님코드System.out.println(list.indexOf(\"2\")); //\"2\"의 index위치찾기int value = list.indexOf(\"2\");if(value != -1){ //데이터가 존재할 경우 list.set(value, \"two\");}System.out.println(list);//출력값1[하나, two, 3.14, 하이, c, 5, 5, 5] 비교 : 조건에 따른 데이터변경(Iterator사용) 다음요소를 가지고있으면 true-&gt;반복문실행 없으면 false-&gt;반복문종료 12345//list객체를 반복할 수 있도록 iterator 객체로 변환Iterator iter = list.iterator();while(iter.hasNext()){ //다음요소를 가지고있으면 true-&gt;반복문실행 없으면 false-&gt;반복문종료 System.out.println(iter.next());} 4-2. Vector Vector : 자동으로 길이가 늘어나는 가변list ArrayList - 동기화 기능 X : 상대적으로 클라이언트측에서 많이 사용함 Vector - 동기화 기능 O : 상대적으로 서버측에서 많이 사용함 거의 대부분이 ArrayList를 쓰는 상황이다. 주니어레벨에서는 잘 모르겠다싶으면 ArrayList를 사용하면 됨. 1234567891011121314151617181920212223242526272829303132//1. Vector 생성// Vector생성시 4칸짜리 배열생성 후 필요시마다 3칸씩 추가됨 -&gt; 효율적사용가능Vector vec = new Vector(4,3);//2. Vector 크기체크System.out.println(\"백터의 크기 : \"+vec.size());//3 Vector 용량체크System.out.println(\"백터의 용량 : \"+vec.capacity());//4.실무에서 더미데이터를 담을때 for문을 주로 사용한다for(int i=0; i&lt;5; i++){ vec.add(i*10);}System.out.println(vec);System.out.println(\"백터의 크기 : \"+vec.size());System.out.println(\"백터의 용량 : \"+vec.capacity());System.out.println(\"백터첫번째요소 : \"+vec.firstElement());System.out.println(\"백터두번째요소 : \"+vec.get(1));//System.out.println(\"백터마지막요소 : \"+vec.lastElement());//출력값백터의 크기 : 0 =&gt; //출력값이 4가 아니라 0인 이유는? size는 요소의 값이다. 요소가 없으면 값은 0이 출력된다. 0 백터의 용량 : 4[0, 10, 20, 30, 40]백터의 크기 : 5백터의 용량 : 7백터첫번째요소 : 0백터두번째요소 : 10백터마지막요소 : 40 4-3. 배열을 생성해보자 내코드내코드는 for문을 사용했다. 12345678910111213System.out.println(\"ㅡㅡㅡㅡㅡ 배열생성\");//대괄호안에 인자를 넣으면 에러가 발생함. 대괄호안에 숫자 넣으면 안됨!//주로 안드로이드에서 아래의 배열생성방식을 사용함.double[] arr = new double[]{1.1,1.2,1.3,1.4,1.5,1.6,1.7};Vector vec2 = new Vector(5,5); //백터생성//내코드for(int i=0; i&lt;arr.length; i++){ vec2.add(arr[i]);}System.out.println(vec2);//출력값//[1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7] 강사님코드강사님은 for-each를 사용한 코드이다. 123456789double[] arr = new double[]{1.1,1.2,1.3,1.4,1.5,1.6,1.7};Vector vec2 = new Vector(5,5); //백터생성//강사님코드for(double d : arr){ vec2.add(d);}System.out.println(vec2);//출력값//[1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7] 4-4. 요소검색1234567891011121314151617181920212223242526272829303132333435System.out.println(\"ㅡㅡㅡㅡㅡ요소검색\");//[1.5]요소가 있으면 해당요소의 위치출력, 없으면 -1출력int result = vec2.indexOf(1.5);if(result != -1){ System.out.println(\"검색성공 : \"+result);}else{ System.out.println(\"검색실패 : \"+result);}System.out.println(\"ㅡㅡㅡㅡㅡ요소삭제1 : indexOf사용\");//[1.6]요소가 있으면 해당요소를 삭제int result2 = vec2.indexOf(1.7);if(result2 != -1){ vec2.remove(result2); System.out.println(\"삭제성공 : \"+vec2);}else{ System.out.println(\"삭제실패 : \"+result2);}System.out.println(\"ㅡㅡㅡㅡㅡ요소삭제2 : contains\");double delValue = 45.6;if(vec2.contains(delValue)){ //괄호한의 delValue가 포함되어 있으면 true vec2.remove(delValue); System.out.println(\"삭제성공 : \"+vec2);}else{ System.out.println(\"삭제실패 : \"+vec2);}//출력값ㅡㅡㅡㅡㅡ요소검색검색성공 : 4ㅡㅡㅡㅡㅡ요소삭제1 : indexOf사용삭제성공 : [1.1, 1.2, 1.3, 1.4, 1.5, 1.6]ㅡㅡㅡㅡㅡ요소삭제2 : contains삭제실패 : [1.1, 1.2, 1.3, 1.4, 1.5, 1.6]","link":"/2020/07/15/200716jspi2/"},{"title":"[ITWILL : JSP]Javabean 6 : 게시판만들기(글쓰기)","text":"ITWILL학원 : 27강 JSP기초 BY 정규태강사1. 웹 개발의 기초 : CRUD 기본 로직 : 게시판 글쓰기 = 데이터입력 글 리스트 = 데이터검색 글 본문보기 = 데이터검색 글 수정 = 데이터 수정 글 삭제 = 데이터 삭제 추가할 로직 : 답글쓰기 (댓글과 다른 답글기능) 파일업로드 / 썸네일 위와 같은 두 개의 로직은 요구사항분석이라고도 부른다 1-1. 개발순서 사용자 요구사항 분석 데이터 테이블 설계 = DB 테이블생성 테이블명 itwill_board 글번호 : bno 글쓴이 : name 글 비밀번호 : pw 글 제목 : subject 글 내용 : content 조회수 : readcount 답글 : re_ref, re_lev, re_seq 글쓴날짜 : date 파일 : file varchar(200)를 쓰는 이유는 글쓴이의 IP주소 : ip writeForm.jsp 작성 writePro.jsp 작성 BoardBean.java 생성 BoardDAO.java 에서 getCon() DB연결메서드 구현 BoardDAO.java 에서 insertBoard() 글쓰기메서드 구현 1-2. 데이터 테이블 설계 = DB테이블생성 테이블명 itwill_board을 생성한 뒤 아래처럼 컬럼을 작성한다. 글번호 : bno - INT NOT NULL, PRIMARY KEY (bno) 글번호는 AI(Auto Increment)를 해야한다 말아야한다는 의견이 분분하다. 실습에선 AI없이 진행. 글쓴이 : name - VARCHAR(45) NOT NULL 글 비밀번호 : pw - VARCHAR(45) NOT NULL 글 제목 : subject - VARCHAR(45) NOT NULL 글 내용 : content - VARCHAR(2000) NOT NUL 조회수 : readcount - INT NULL 답글 : re_ref, re_lev, re_seq - 세 컬럼 다 INT NULL 글쓴날짜 : date - DATE NULL 파일 : file - VARCHAR(200) NULL varchar(200)를 쓰는 이유는 파일은 DB가 아닌 서버에 저장되고 DB는 이름만 저장해놓기때문. 글쓴이의 IP주소 : ip - VARCHAR(45) NULL 1-3. writeForm.jsp 작성123456789101112&lt;fieldset&gt;&lt;legend&gt;게시판 글쓰기&lt;/legend&gt; &lt;form action=\"writePro.jsp\" method=\"post\" name=\"fr\"&gt; 글쓴이 : &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; 제목 : &lt;input type=\"text\" name=\"subject\"&gt;&lt;br&gt; 내용 : &lt;br&gt; &lt;textarea rows=\"10\" cols=\"35\" name=\"content\" placeholder=\"여기에 작성해주세요\"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"글쓰기\"&gt; &lt;button type=\"reset\"&gt;초기화&lt;/button&gt; &lt;/form&gt;&lt;/fieldset&gt; 1-4. writePro.jsp 작성글쓰기를 처리하는 페이지이다.입력창에서 받은 데이터를 DB로 이동시킨 뒤 사용자는 글목록페이지로 이동 jsp:setProperty 의 동작방식 String name = request.getParameter(“bno”) bb.setbno(bno) 모든 변수에 위의 1번,2번동작을 처리 전달정보 확인위한 출력 System.out.println(bb) System.out.println(bb.toString()) 위의 두 코드는 동일한 출력값을 가진다. 로그인한사람만 글쓸수있게 처리 1234567891011121314151617181920212223242526272829303132333435&lt;%//1. 한글처리request.setCharacterEncoding(\"UTF-8\");%&gt;//6. 로그인한사람만 글쓸수있게처리String id = (String) session.getAttribute(\"id\");if( id == null){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"로그인 후 이용가능합니다\"); history.back(); &lt;/script&gt; &lt;%}&lt;!-- 2. 액션태그사용 : 전달된 정보를 저장(bno, name, pw 등등) - 자바빈객체에 저장--&gt;&lt;jsp:useBean id=\"bb\" class=\"com.itwillbs.board.BoardBean\" /&gt;&lt;!-- 2-1. 파라미터 값 저장 : jsp:setProperty --&gt;&lt;jsp:setProperty property=\"*\" name=\"bb\"/&gt;&lt;%//2-2. 전달정보 확인위한 출력 : null인 값들은 별로도 추가해줘야한다.System.out.println(bb); //bb.toString()과 동일한 동작//2-3. IP정보를 추가System.out.println(request.getRemoteAddr());bb.setIp(request.getRemoteAddr());System.out.println(bb);//2-4. date정보//3. 디비처리작업진행 : boardDAO객체 생성BoardDAO bdao = new BoardDAO();//4. 데이터처리 : BoardDAO객체 안의 메서드 중 글스기 기능을 하는 메서드 호출bdao.insertBoard(bb);// 5. 글목록 페이지로 이동response.sendRedirect(\"boardList.jsp\"); 1-5. BoardBean.java 생성1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//1번규칙만족 : 클래스는 publicpublic class BoardBean { //2번규칙만족 : 멤버변수선언 private private int bno; private String name; private String pw; private String subject; private String content; private int readcount; private int re_ref; private int re_lev; private int re_seq; private Date date; private String file; private String ip; //4번규칙만족 : 기본생성자존재하지만 생략됨 //public BoardBean(){} //3번규칙만족 : 멤버변수마다 별도의 get/set메소드가 존재해야한다. public int getBno() { return bno; } public void setBno(int bno) { this.bno = bno; } public String getName() { return name; } public void setName(String name) { this.name = name; } //(중략) public String getIp() { return ip; } public void setIp(String ip) { this.ip = ip; } //5. toString() @Override public String toString() { return \"BoardBean [bno=\" + bno + \", name=\" + name + \", pw=\" + pw + \", subject=\" + subject + \", content=\" + content + \", readcount=\" + readcount + \", re_ref=\" + re_ref + \", re_lev=\" + re_lev + \", re_seq=\" + re_seq + \", date=\" + date + \", file=\" + file + \", ip=\" + ip + \"]\"; } 1-6. BoardDAO.java 에서 getCon() DB연결메서드 구현드라이브로드, DB연결 메서드인 getCon()구현 getCon() 작성순서 : 리턴값없이 진행 라이브러리설치 (WEB-INF, LIB에 추가) /META-INF/context.xml 파일생성 /WEB-INF/web.xml 파일수정 DAO 처리 예외처리 throws 방법 : 메서드를 호출하는 시점에 예외처리를 함 1234567891011121314151617181920212223242526272829303132333435public class BoardDAO { Connection con = null; String sql = \"\"; PreparedStatement pstmt = null; ResultSet rs = null; //DB연결메서드 구현 private void getCon() throws Exception{ //Context 객체 생성 //Context인터페이스이기때문에 직접객체생성할 수 없어서 InitialContext클래스를 사용해서 객채생성 //예외처리 : throws사용하는 방법 Context init = new InitialContext(); //업캐스팅 //디비연결정보를 불러오기 -&gt;DataSource 타입으로 저장 // 고정문구\"java:comp/env/다른문구context파일의 name값입력\" DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/mysqlDB\"); //ds 사용해서 연결 //멤버변수는 static이 아니기때문에 new BoardDAO();객체생성 후에 멤버변수들이 생성된다. //그리고 getCon()메서드를 하면 멤버변수 con에 데이터(ds.getConnection();)가 담기게 된다. //따라서 이때 return하지 않고 써도된다. con = ds.getConnection(); System.out.println(\"디비연결성공 + con\"); }//getCon닫음 //자원해제 메서드 구현 public void closeDB(){ try{ if(rs != null) rs.close(); if(pstmt != null) pstmt.close(); if(con != null) con.close(); } catch (SQLException e) { e.printStackTrace(); } }//closeDB닫음 }BoardDAO클래스닫음 1-7. BoardDAO.java 에서 insertBoard() 글쓰기 메서드 구현insertBoard()메서드 구현 if(rs.next())가 끝나는 종료되는 순간은? 글이 없으면 null인데 어떻게 조건문이 true가 되어 구현될수있을까? rs가 faluse가 되는 시점은 EOF만나는 순간이다. 즉, NULL이 있어도 진행된다. getInt()사용법 두가지 getInt(컬럼명)사용 : num = rs.getInt(“max(bno)”)+1; getInt(idx)사용 : 둘다 동일한 결과. idx사용하면 컬럼명보다 데이터 처리속도도 빠르다- /getInt =&gt; 데이터 값을 리턴, 값이 SQL-NULL경우 0리턴 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//글쓰기 메서드 구현public void insertBoard(BoardBean bb){ //글번호를 저장하는 변수 생성 int num = 0; try { //1. 디비연결 getCon(); //2. SQL구문작성 &amp; pstmt //3. 글번호계산 : 지금 있는 글 번호중 가장 큰 번호가 뭔지 확인하기만 하면 되니까 sql = \"select max(bno) from itwill_board\"; pstmt = con.prepareStatement(sql); //4. 글번호계산한거 실행 rs = pstmt.executeQuery(); //5. 데이터처리(글번호 계산) if(rs.next()){ //글이 없으면 null이 어떻게 조건문을 돌수있을까? rs가 faluse가 되는 시점은 EOF만나는 순간이다. //즉, NULL이 있어도 진행된다. //getInt(컬럼명)사용 : num = rs.getInt(\"max(bno)\")+1; //getInt(idx)사용 : 둘다 동일한 결과. idx사용하면 컬럼명보다 데이터 처리속도도 빠르다 //getInt =&gt; 데이터 값을 리턴, 값이 SQL-NULL경우 0리턴 num = rs.getInt(1)+1; } System.out.println(\"글번호 : \"+num); //6. 글쓰기(저장) : 실무에서는 물음표가 기본 20개이상이다. 5개씩 잘라서 String연결하면 헷갈리지않는다. //Date는 now()메서드를 이용한다. //now() : 자동으로 SQL구문 실행시 시스템시간 정보를 불러옴 sql = \"insert into itwill_board value(\" +\"?,?,?,?,?,\" +\"?,?,?,?,now(),\" +\"?,?)\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, num);//bno는 가지고있는게 아니라 계산해서 만든것이므로 num사용 pstmt.setString(2, bb.getName()); pstmt.setString(3, bb.getPw()); pstmt.setString(4, bb.getSubject()); pstmt.setString(5, bb.getContent()); pstmt.setInt(6, 0);//조회수는 글쓰지마자 올라가지않는다. 글쓰는 당시에는 조회수가 0이니까 초기화한다. pstmt.setInt(7, num);//답변글 그룹번호이므로 일반글번호와 동일하다. pstmt.setInt(8, 0);//답변글 들여쓰기(처음 작성하는 일반 글의 들여쓰기는 0이므로 초기화한다) pstmt.setInt(9, 0);//답변글순서(처음 작성하는 일반글이므로 일반글 제일위쪽(0)으로 초기화한다) pstmt.setString(10, bb.getFile()); pstmt.setString(11, bb.getIp()); //7. 실행 pstmt.executeUpdate(); System.out.println(\"게시판글쓰기 성공\"); } catch (Exception e) { // TODO Auto-generated catch block System.out.println(\"게시판글쓰기 실패\"); e.printStackTrace(); } finally { //자원해제 closeDB(); }} //insertBoard메서드닫음 2. 예외처리 차이점(try catch와 throws) try catch 방법 throws 방법 자바 예외처리(try catch, throws)try catch는 예외를 직접 처리하기 때문에 메서드를 호출해도 더 이상 예외처리를 할 필요가 없습니다.하지만 throws같은 경우는 호출하는 쪽에다가 예외처리를 맡겨버리는(?) 느낌?그래서 호출하는 메소드에 throws가 있으면호출하는 쪽에서도 예외처리를 다시 해줘야되요!","link":"/2020/07/19/200720jspi2/"},{"title":"데이터정의어DDL : table 생성 table 복사, varchar2와 varchar와 char비교","text":"Table 생성테이블 생성시 규칙이 있다. 테이블이름 작성규칙 이름시작시 : 반드시 문자로 시작 (숫자,특수문자로 시작할수없음) 30byte까지만 작성가능 포함가능 : 특수문자는 (_ , # , $)만 포함가능 포함불가능 : 공백 컬럼의 데이터타입 가변길이문자열 : varchar2(컬럼사이즈) 고정길이문자열 : char(컬럼사이즈) 숫자 : Number(p, s) p는 정수자리수 s는 소수점이하 자리수 (ex) number(4) =&gt; 0 ~ 9999 (음수포함) (ex) number(4,2) =&gt; 0 ~ 9999.99 (음수포함) 날짜 : date 컬럼사이즈없음 varchar2와 varchar와 char비교데이터를 저장할때 두가지 크게 고정길이와 가변길이 형식으로 쓸 수 있다공간효율 : 메모리가 아니고 디스크의 물리적 공간을 의미. char : 고정길이 문자열 형식예를 들어 char(20)는 20byte를 가지는 문자열 형식이 있다여기에 ninano라는 6자짜리 문자열을 넣으면 남은 공간인 14byte는 공백으로 채워 총 20byte를 사용한다따라서 고정길이가 정확한 문자열에만 사용해야한다 아니면 공간의 낭비가 발생할 수 있다 장점 : 성능 상대적으로 좋음. 즉,데이터입력속도가 빠름 (고정길이기때문에 길이계산할 필요가 없다) 단점 : 공간효율이 안좋음. (고정길이기때문에 공간을 다 쓰지않아도 공간을 잡고있음) varchar2 : 가변길이 문자열 형식길이정보도 같이 저장되는 문자열 형식이다.예를들어 varchar2(20)일때 ninano라는 6자짜리 문자열을 넣으면 6byte + 길이정보저장공간 1byte까지 총 7byte만 사용한다.공간을 적게 차지할 수 있기에 보통 varchar2를 이용한다 장점 : 공간효율이 좋음 (가변길이기때문에 필요한만큼만 공간을 잡음) 단점 : 성능이 상대적으로 안좋음 상황에 맞게 char나 varchar2를 선택해서 사용하면되지만 오라클의 권장사항은 varchar2이다. why? 성능차이가 크게 나지않지만 공간효율의 차이는 티가 확난다. 참고로 varchar1은 없다. varchar와 varchar2만 있을뿐…ㅋㅋㅋㅋㅋ varchar와 char 비교링크 옵션 : default값, 제약조건 테이블생성시 필수가 아님. default값이 선언되어있는 폴더는 insert나 update시 null값이 아닌 자동으로 기본값이 입력된다. 컬럼마다 차이가 있지만 보통 컬럼명과 제약조건 사이에 작성한다 디폴트값작성위치에 따라 오류가 나타날 수 있다. 예시 : 123456create table dept(deptno number(2), dname varchar2(14), loc varchar2(13), join_date date CONSTRAINT mk_jd_nn not null default sysdate);//출력값ORA-00907: 누락된 우괄호 - \"missing right parenthesis\" 이때 디폴트값을 제약조건앞에 위치하게 하면 에러가 해결된다 123456create table dept(deptno number(2), dname varchar2(14), loc varchar2(13), join_date date default sysdate CONSTRAINT mk_jd_nn not null);//출력값테이블생성완료 테이블생성 및 테이블복사 명령어 테이블생성 1234567create table 테이블명컬럼명 컬럼데이터타입(컬럼사이즈) constraint 제약조건명 제약조건 //예시create table employee (employee_id number(6) constraint emp_emp_id_pk privary key,first_name varchar2(20)); 테이블복사 (서브쿼리구문 사용) : 기존테이블을 복사한 테이블을 생성할 수 있다. 주 사용처 : 백업 테스트 : 뭔가를 테스트하고싶을 때 원본테이블을 복사한 뒤 복사본에 테스트를 하여 안전성을 높인다. * : 전체 컬럼과 그 안의 데이터 전체를 복사함. 컬럼명설정 : 원하는 컬럼과 그 안의 데이터만 복사함. 테이블을 복사하면 제약조건도 같이 복사될까? NOPE. NOT NULL 제약조건만 복사되고 나머지 제약조건은 필요시 직접 추가해야한다. 12345678910//서브쿼리 구문을 사용한 테이블 생성create table 테이블명as select 원하는컬럼명 또는 *from 복사하고싶은테이블//서브쿼리 구문을 사용하는데 데이터는 빈채로 틀만 가져오고싶을때create table 테이블명as select *from 복사하고싶은테이블where 1 = 2; //항상 거짓이기때문에 컬럼틀만 복사되고 안의 데이터는 복사되지않는다. 예시 : 123456//서브쿼리 구문을 사용한 테이블 생성create table dept80as select employee_id, last_name, salary*12 annsal, hire_datefrom employeeswhere department_id = 80; 제약조건 테이블에 부정확한 데이터 입력 방지를 위해 필수! 제약조건명 제약조건 작성시 필수 입력 제약조건명은 중복불가 제약조건 사용처 : 제약조건 정보 확인할때, 해당 제약조건삭제할때. 의미있는 제약조건명필수 오라클 권장 : 테이블명약자_컬럼명약자_제약조건유형약자 ex) emp_empid_pk ex) dept_dname_nn ex) emp_mgrid_fk ex) sal_ck ex) emp_email_uk 제약조건명을 꼭 적야아할까? NOPE! 생략가능. 생략하면 oracle이 자동으로 고유한 제약조건명 지정 ex) sys_cXXXXX(X는 숫자) : 이런 패턴의 제약조건명을 자동으로 지정 하지만 전혀의미없는 제약조건명이므로 제약조건명 지정 권장! 제약조건 선언하는 시기 테이블 생성 시 : 일반사용 서브쿼리구문 사용 : 기존테이블을 복사한 테이블을 생성할 수 있다. 주 사용처 : 백업 테스트 : 뭔가를 테스트하고싶을 때 원본테이블을 복사한 뒤 복사본에 테스트를 하여 안전성을 높인다. * : 전체 컬럼과 그 안의 데이터 전체를 복사함. 컬럼명설정 : 원하는 컬럼과 그 안의 데이터만 복사함. 12create table 테이블명컬럼명 컬럼데이터타입(컬럼사이즈) constraint 제약조건명 제약조건 예시 : 123create table employee (employee_id number(6) constraint emp_emp_id_pk privary key,first_name varchar2(20)); 테이블 성성 후 : 문법이 두가지이다. : 테이블레벨문법과 컬럼레벨문법 1234567//테이블레벨 문법alter table 테이블명add constraint 고유한제약조건명 제약조건유형(컬럼명);//컬럼레벨 문법alter table 테이블명modify 컬럼명 contsraint 고유한제약조건명 제약조건유형; 제약조건문법 2가지 Column-level 문법 Not Null 제약조건사용시 column-level문법으로 작성해야한다! 예시123create table employee (employee_id number(6) constraint emp_emp_id_pk_ privary key,first_name varchar2(20)); Table-level 문법 예시1234create table employee (employee_id number(6),first_name varchar2(20),constraint emp_emp_id_pk_ privary key(employee_id)); 참고링크 : 제약조건문법 2가지 제약조건종류 5가지 참고링크 : 제약조건 5가지 제약조건 확인하는 쿼리 저장해놓고 필요시에 불러서 사용가능. 저장시 파일확장자는 .sql 123select constraint_name, constraint_type, search_condition, r_constraint_namefrom user_constraintswhere lower(table_name) = lower( '&amp;table_name');","link":"/2020/07/20/200721dbi/"},{"title":"[ITWILL : JSP]Javabean 7 : 게시판만들기(글 총갯수, 글목록, 페이징처리)","text":"ITWILL학원 : 28강 JSP기초 BY 정규태강사1. 순서 디비에서 전체 글목록을 읽어서 가져오기 글을 읽어오는 작업은 많은 리소스를 필요로한다. BoardList.jsp 생성 BoardDAO.java에 getBoardCount() 메서드 생성 디비에 글이 있는지 확인 후 있으면 글 모두 가져오기, 없으면 가져오지않기 BoardDAO.java에 getBoardList() 메서드 생성 최신 글이 위로 오게 정렬 (쿼리이용) 데이터역순정렬의 방법은 두가지 쿼리단계에서 가져올때부터 역순: 더욱 효율적 쿼리로 가져와서 화면에 뿌릴때 역순 페이징처리하기 페이지블럭 만들기 2. BoardList.jsp생성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;%//1. 디비에서 전체 글목록을 읽어서 가져오기//2. BoardDAO 객체생성BoardDAO bdao = new BoardDAO();//3. 디비에 글이 있는지 확인 후 있으면 글 모두 가져오기,없으면 가져오지않기 : getBoardCount()int cnt = bdao.getBoardCount();//7. 페이징처리 (이미 유명한 알고리즘 공식, 사용법만 알면 됨)//7-1. 한 페이지에서 보여줄 글의 개수 설정(5개, 변경가능)int pageSize = 5; //7-2. 지금 내가 몇페이지에 있는 확인//페이지번호는 숫자인데 왜 String으로 하는지 ? =&gt; 연산을 할 것이 아니라서 String이 편함String pageNum = request.getParameter(\"pageNum\");//7-3. 페이지번호정보가 없을 경우 내가 보는 페이지가 첫페이지가 되도록if(pageNum == null){ pageNum =\"1\";}//7-4. 시작행번호계산//10개씩 컬럼 나누고 2페이지에서 시작행이 11이되고 3페이지에서 시작행이 21이 되게끔 만들기int currentPage = Integer.parseInt(pageNum); //String을 integer로 변환int startRow = (currentPage-1)*pageSize + 1;//currentPage가 2인경우, (2-1)x10+1 = 11//currentPage가 3인경우, (3-1)x10+1 = 21//7-5. 끈행번호계산int endRow= currentPage * pageSize;//currentPage가 2인경우, 2*10 = 20//currentPage가 3인경우, 3*10 = 30//4. 게시판 글의 수를 화면에 데이터 출력//게시판 총 글의 수 : cnt개//5. getBoardList() 메서드생성System.out.println(bdao.getBoardList());ArrayList boardList = null;if(cnt != 0){ //일반적인 리스트호출방법, 아래는 페이징처리한 리스트호출방법 //boardList = bdao.getBoardList(); //7-6. 페이징 처리한 리스트 호출 =&gt; getBoardList()메서드만들기(메서드 오버로딩) boardList = bdao.getBoardList(startRow, pageSize);} //6. 게시판 모든 내용을 화면에 출력%&gt;&lt;fieldset&gt;&lt;legend&gt;땡땡게시판&lt;/legend&gt; &lt;div id=\"contents\"&gt; 게시판 총 글의 수 : &lt;%=cnt %&gt; 개 &lt;input id=\"writebtn\" type=\"button\" value=\"글쓰기\" onclick=\"location.href='writeForm.jsp'\"&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;글번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;th&gt;작성일&lt;/th&gt; &lt;th&gt;IP&lt;/th&gt; &lt;/tr&gt; &lt;%//반복문 //ArrayList는 가변배열이므로 length가 없고 size가 존재한다. //size()메서드는 배열의 요소의 갯수를 리턴 for(int i=0;i&lt;boardList.size(); i++){ //ArrayList 한칸의 정보 -&gt;BoardBean 객체 하나로 이동 BoardBean bb = (BoardBean) boardList.get(i); %&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=\"content.jsp?bno=&lt;%=bb.getBno()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;\"&gt;&lt;%=bb.getSubject() %&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getSubject() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getReadcount() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getDate() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getIp() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;/table&gt; &lt;/div&gt;&lt;/fieldset&gt;&lt;%//8. 페이지 이동버튼if(cnt != 0){ //cnt는 전체 글 갯수 //8-1. 페이지갯수처리 //전체페이지 50개이고 화면에 10개씩 출력 =&gt; 5페이지만 있으면됨 //전체페이지 57개이고 화면에 10개씩 출력 =&gt; 6페이지만 있으면됨 //삼항연산자로 처리 int pageCount = cnt/pageSize + (cnt%pageSize == 0? 0:1); //8-2. 화면에 보여줄 페이지번호의 갯수(페이지블럭) int pageBlock = 3; //페이지에 10개 페이지갯수 보여줌 //8-3. 페이지블럭의 시작페이지번호 //현재 11페이지면, (11-1)/10 * 10 + 1 = 11 int startPage = ((currentPage-1)/pageBlock) * pageBlock + 1; //8-4. 페이지블럭의 끝페이지번호 int endPage = startPage + pageBlock - 1; if(endPage &gt; pageCount){ endPage = pageCount; } //8-5. 이전, 숫자, 다음처리 // 이전 %&gt; &lt;div id=\"pageBlock\"&gt; &lt;% if(startPage &gt; pageBlock){ %&gt; &lt;a href=\"boardList.jsp?pageNum=&lt;%=startPage-pageBlock%&gt;\"&gt; 이전 &lt;/a&gt; &lt;% } //숫자 for(int i=startPage; i&lt;=endPage; i++){ %&gt; &lt;a href =\"boardList.jsp?pageNum=&lt;%=i%&gt;\"&gt; &lt;%=i%&gt; &lt;/a&gt; &lt;% } //다음 if(endPage &lt; pageCount){ %&gt; &lt;a href =\"boardList.jsp?pageNum=&lt;%=startPage+pageBlock%&gt;\"&gt; 다음 &lt;/a&gt; &lt;% } %&gt; &lt;/div&gt; &lt;% }%&gt; 3. BoardDAO.java에 getBoardCount() 메서드생성BoardDAO.java에 getBoardCount() 메서드 생성 12345678910111213141516171819202122232425public int getBoardCount(){ int count = 0; try { //디비연결 getCon(); //sql작성, pstmt sql = \"select count(*) from itwill_board\"; pstmt = con.prepareStatement(sql); //실행 -&gt; rs저장 rs = pstmt.executeQuery(); //데이터처리 if(rs.next()){ count = rs.getInt(1); // 데이터가 없으면 null이고 return 0값이 된다. //count = rs.getInt(\"count(*)\"); 위와 동일한 결과 System.out.println(\"게시판 글 갯수 확인 :\"+ count); } } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return count;}//getBoardCount닫기 4. BoardDAO.java에 getBoardList() 메서드생성BoardDAO.java에 getBoardList() 메서드 생성 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//DB에서 게시글 전체 가져오는 메서드 구현public ArrayList getBoardList(){ //가변길이 배열 생성 ArrayList boardList = new ArrayList(); try { //1. 디비연결 getCon(); //2. sql작성, pstmt //sql = \"select * from itwill_board\"; //정렬(최신글이 가장 위쪽으로 보이게) : re_ref(그룹번호) 내림차순 sql = \"select * from itwill_board order by re_ref desc\"; pstmt = con.prepareStatement(sql); //3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //4. 데이터처리 //정보의 갯수가 몇개인지 모르기때문에 while 반복문을 사용 while(rs.next()){ //4-1.BoardBean 객체생성해서 그 안에 rs데이터 저장 BoardBean bb = new BoardBean(); bb.setBno(rs.getInt(\"bno\")); bb.setContent(rs.getString(\"content\")); bb.setDate(rs.getDate(\"date\")); bb.setFile(rs.getString(\"file\")); bb.setIp(rs.getString(\"ip\")); bb.setName(rs.getString(\"name\")); bb.setPw(rs.getString(\"pw\")); bb.setRe_lev(rs.getInt(\"re_lev\")); bb.setRe_ref(rs.getInt(\"re_ref\")); bb.setRe_seq(rs.getInt(\"re_seq\")); bb.setReadcount(rs.getInt(\"readcount\")); bb.setSubject(rs.getString(\"subject\")); //여기까지가 한 행의 데이터를 저장한 것임. while로 모든 행을 반복 //가변배열(ArrayList)에 위의 데이터 저장 //즉 배열 한칸에 회원 1명의 정보를 저장함. boardList.add(bb); //업캐스팅 } } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return boardList; }//getBoardcontent닫기 5. 페이징처리 : BoardDAO.java에 getBoardList(int startRow, int pageSize) 오버로딩 메서드 만들기getBoardList(int startRow, int pageSize) 오버로딩 메서드만들고 sql구문 변경하기 1234567891011121314151617181920212223//DB에서 게시글 전체 가져오는데 페이징처리한 메서드 구현 (메서드 오버로딩)public ArrayList getBoardList(int startRow, int pageSize){ //가변길이 배열 생성 ArrayList boardList = new ArrayList(); try { //1. 디비연결 getCon(); //2. sql작성, pstmt //게시판의 데이터 목록중에서 10개씩 정렬해서 가져오기 //re_ref(그룹번호) 내림차순 + re_seq(답글순서결정)오름차순으로 정렬 //데이터 짤라서 가져오기 limit 시작행-1, 페이지갯수 =&gt; 해당 위치부터 개수만큼 가져오기 sql = \"select * from itwill_board order by re_ref desc, re_seq asc\" +\"limit ?,?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, startRow-1); pstmt.setInt(2, pageSize); //3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); while(rs.next())이후로 getBoardList()와 동일 }}","link":"/2020/07/20/200721jspi/"},{"title":"[ITWILL : JSP]Javabean 8 : 게시판만들기(글내용보기, 글수정하기)","text":"ITWILL학원 : 29강 JSP기초 BY 정규태강사1. 순서 content.jsp 생성 html 테이블작성 boardDAO.java에 updateReadCount(int bno)메서드 생성 boardDAO.java에 getBoard(int bno)메서드 생성 글수정할 수 있는 updateForm.jsp 생성 글수정할 수 있는 updatePro.jsp 생성 boardDAO.java에 updateBoard(bb)메서드 생성 2. content.jsp 생성글목록에서 제목을 눌렀을때 컨텐츠를 볼 수 있게 만드는 페이지이다. 목록으로 되돌아가는 버튼 만들때 주의점 location.href=boardList.jsp만 하면 5페이지보고있다가 다시 1페이지로 돌아가버린다 이때 historyback하면 조회수가 올라가지않는다. 따라서 pageNum을 가져와서 사용하면된다 location.href=boardList.jsp?pageNum=&lt;%=pageNum%&gt;으로 해줘야한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;%//1. html테이블작성//글번호(pk제약조건의 컬럼필수)에 해당하는 글의 정보를 가져오기//2. 전달된 데이터 저장(bno, pageNum)int bno = Integer.parseInt(request.getParameter(\"bno\"));String pageNum = request.getParameter(\"pageNum\");//3. DAO객체생성BoardDAO bdao = new BoardDAO();//4. 글의 조회수정보를 1증가 : DB에서처리 -&gt; DAO객체에 updateReadCount(bno)메서드 생성bdao.updateReadCount(bno);//5. 화면(테이블)에 출력 (getBoard(bno))// DAO객체에 글정보를 가져오는 메서드 생성BoardBean bb = bdao.getBoard(bno);//System.out.println(bdao.getBoard(bno));%&gt;&lt;fieldset&gt;&lt;legend&gt;글 내용 보기&lt;/legend&gt; &lt;table border=\"solid,1px\"&gt; &lt;tr&gt; &lt;th&gt;글번호&lt;/th&gt; &lt;td&gt;&lt;%=bno%&gt;&lt;/td&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;td&gt;&lt;%=bb.getReadcount()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;td&gt;&lt;%=bb.getName() %&gt;&lt;/td&gt; &lt;th&gt;작성일&lt;/th&gt; &lt;td&gt;&lt;%=bb.getDate() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;제목&lt;/th&gt; &lt;td colspan=\"3\"&gt;&lt;%=bb.getSubject() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;첨부파일&lt;/th&gt; &lt;td colspan=\"3\"&gt;&lt;%=bb.getFile() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;내용&lt;/th&gt; &lt;td colspan=\"3\" height=\"300px\"&gt;&lt;%=bb.getContent() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"4\" style=\"text-align:center\"&gt; &lt;input type=\"button\" value=\"글수정\" class=\"btn\" onclick=\"location.href='updateForm.jsp?bno=&lt;%=bb.getBno()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;'\"&gt; &lt;input type=\"button\" value=\"글삭제\" class=\"btn\"&gt; &lt;input type=\"button\" value=\"답글쓰기\" class=\"btn\"&gt; &lt;input type=\"button\" value=\"목록으로\" class=\"btn\" onclick=\"location.href='boardList.jsp?pageNum=&lt;%=pageNum%&gt;'\"&gt; &lt;!-- location.href='boardList.jsp만 하면 5페이지보고있다가 다시 1페이지로 돌아가버린다 이때 historyback하면 조회수가 올라가지않는다. 따라서 pageNum을 가져와서 사용하면된다 --&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/fieldset&gt; 3. boardDAO.java에 updateReadCount(int bno)메서드 생성조회수 올리는 메서드를 생성하자 1234567891011121314151617181920public void updateReadCount(int bno){ try { //1. 디비연결 getCon(); //2. sql작성 &amp; pstmt생성 //select를 안하는 이유? 기존의 데이터를 굳이 가져올 필요가 없기 때문 sql = \"update itwill_board set readcount=readcount+1 where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); //3. 실행 pstmt.executeUpdate(); System.out.println(\"조회수 1증가 완료\"); } catch (Exception e) { System.out.println(\"조회수 1증가 실패\"); e.printStackTrace(); } finally { //4. 자원해제 closeDB(); }} 4. boardDAO.java에 getBoard(int bno)메서드 생성글 내용을 다 가져와서 오는 메서드를 만들어보자이는 글제목을 클릭시 화면에 내용을 보여줄때 사용된다. 내코드 123456789101112131415161718192021222324252627282930313233343536373839public BoardBean getBoard(int bno){ BoardBean bb = new BoardBean(); try { //1. 디비연결 getCon(); //2. sql작성, pstmt //sql = \"select * from itwill_board\"; sql = \"select * from itwill_board where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); //3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //4. 데이터처리 if(rs.next()){ //4-1.BoardBean 객체생성해서 그 안에 rs데이터 저장 bb.setBno(rs.getInt(\"bno\")); bb.setContent(rs.getString(\"content\")); bb.setDate(rs.getDate(\"date\")); bb.setFile(rs.getString(\"file\")); bb.setIp(rs.getString(\"ip\")); bb.setName(rs.getString(\"name\")); bb.setPw(rs.getString(\"pw\")); bb.setRe_lev(rs.getInt(\"re_lev\")); bb.setRe_ref(rs.getInt(\"re_ref\")); bb.setRe_seq(rs.getInt(\"re_seq\")); bb.setReadcount(rs.getInt(\"readcount\")); bb.setSubject(rs.getString(\"subject\")); //여기까지가 한 행의 데이터를 저장한 것임 } } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return bb;}//getBoard닫음 강사님코드 BoardBean객체를 언제 생성하는 지가 내 코드와 달랐다. BoardBean객체를 미리 생성할 필요가 없었다. try catch로 예외가 발생하거나, rs에 데이터가 없는 경우에는 객체를 생성할 필요가 없기 때문이다. 글정보 저장완료 후 리턴값 bb정보를 습관적으로 확인하자. 123456789101112131415161718192021222324252627282930313233343536373839//글 정보를 가져오는 메서드구현public BoardBean getBoard(int bno){ //rs에 데이터가 없으면 객체생성할 필요가 없음. 따라서 객채생성안하고 null함. BoardBean bb = null; try { //1. 디비연결 getCon(); //2. sql작성, pstmt //sql = \"select * from itwill_board\"; sql = \"select * from itwill_board where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); //3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //4. 데이터처리 if(rs.next()){ //4-1.BoardBean 객체생성해서 그 안에 rs데이터 저장 // 글내용에서 보이지 않는 컴럼들도 만들어야할까? // 만들기를 추천함 why? 매개변수인 bno자체가 pk를 가졌다. // 지금뿐만아니라 다음 기능이 필요할때 불러와서 사용할 수 있다. // 재사용성 bb = new BoardBean(); bb.setBno(rs.getInt(\"bno\")); (중략) bb.setSubject(rs.getString(\"subject\")); //여기까지가 한 행의 데이터를 저장한 것임 } //글정보 저장완료 후 정보확인 System.out.println(\"해당 글 저장 완료\"); System.out.println(bb); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return bb;}//getBoard닫음 5. updateForm.jsp생성글을 수정할수있는 페이지를 만들어보자. 아래 태그 두개는 동일할까? &lt;input type=&quot;button&quot; value=&quot;목록으로&quot; class=&quot;btn&quot; onclick=&quot;location.href='boardList.jsp?bno=&lt;%=bno%&gt;'&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;목록으로&quot; class=&quot;btn&quot; onclick=&quot;location.href='boardList.jsp?bno=&lt;%=bb.getBno()%&gt;'&quot;&gt; YES! 동일하다! 인풋 히튼타입 : 화면에는 보이지않지만 데이터 저장 및 전달이 가능해서 데이터 이동용으로 주로 사용 BoardBean안에 포함되지 않는 pageNum 변수등은 어떻게 전달할까? 액션페이지 주소줄에 get방식으로 전달 만약 (BoardBean에 포함되지않은) 전달될 데이터가 개인정보등 중요한 데이터라면 get방식으로 전달해선 절대 안된다(=&gt;정보유출문제발생) 그럼 중요한 정보들은 전달할수없는걸까? CAN! 1. 클로저이용 또는 2.BoardBean구조자체를 변경 결론: 가능하면 BoardBean형태의 데이터만 저장해서 처리할 수 있도록 해야한다. 123456789101112131415161718192021222324&lt;%//1. 파라미터저장int bno = Integer.parseInt(request.getParameter(\"bno\"));String pageNum = request.getParameter(\"pageNum\");BoardDAO bdao = new BoardDAO();BoardBean bb = bdao.getBoard(bno);%&gt;&lt;fieldset&gt;&lt;legend&gt;게시판 글쓰기&lt;/legend&gt; &lt;form action=\"updatePro.jsp?pageNum=&lt;%=pageNum %&gt;\" method=\"post\" name=\"fr\"&gt; &lt;!-- 인풋 히튼타입 : 화면에는 보이지않지만 데이터 저장 및 전달이 가능해서 데이터 이동용으로 주로 사용 --&gt; &lt;input type=\"hidden\" name=\"bno\" value=\"&lt;%=bb.getBno() %&gt;\"&gt; 글쓴이 : &lt;input type=\"text\" name=\"name\" required value=\"&lt;%=bb.getName() %&gt;\"&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\" required &gt;&lt;br&gt; 제목 : &lt;input type=\"text\" name=\"subject\" required value=\"&lt;%=bb.getSubject() %&gt;\"&gt;&lt;br&gt; 내용 : &lt;br&gt; &lt;textarea rows=\"10\" cols=\"35\" name=\"content\" placeholder=\"여기에 작성해주세요\" required&gt; &lt;%=bb.getContent() %&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"수정하기\" class=\"btn\"&gt; &lt;button type=\"reset\" class=\"btn\"&gt;초기화&lt;/button&gt; &lt;input type=\"button\" value=\"목록으로\" class=\"btn\" onclick=\"location.href='boardList.jsp'\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 6. updatePro.jsp생성1234567891011121314151617181920212223242526272829303132333435&lt;%//1. 한글처리request.setCharacterEncoding(\"UTF-8\");//2. 파라미터저장(액션태그사용 &amp; pageNum은 파라미터로) String pageNum = request.getParameter(\"pageNum\");%&gt;&lt;jsp:useBean id=\"bb\" class=\"com.itwillbs.board.BoardBean\"&gt;&lt;/jsp:useBean&gt;&lt;jsp:setProperty property=\"*\" name=\"bb\"/&gt;&lt;% //3. DAO생성BoardDAO bdao = new BoardDAO();//4. 정보수정메서드 updateBoard(bb) // -&gt; 결과를 정수형 데이터로 리턴 (1=&gt;정상처리, 0=&gt;비번오류, -1=&gt;해당글없음)int result = bdao.updateBoard(bb);if( result == 1){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"글 수정 완료!\"); location.href=\"boardList.jsp?pageNum=&lt;%=pageNum%&gt;\"; &lt;/script&gt; &lt;%}else if(result == 0){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"비번이 일치하지않습니다\"); history.back(); &lt;/script&gt; &lt;%}else{ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"존재하지 않는 글입니다\"); history.back(); &lt;/script&gt; &lt;%}%&gt; 7. boardDAO.java에 updateBoard(bb)메서드 생성123456789101112131415161718192021222324252627282930313233343536373839404142434445public int updateBoard(BoardBean bb){ int result = 0; try { //DB연결 getCon(); System.out.println(\"디비연결완료\"); //sql &amp; pstmt sql = \"select pw from itiwill_board where bno=?\"; pstmt = con.prepareStatement(sql); System.out.println(\"pstmt 객체생성완료\"); pstmt.setInt(1, bb.getBno()); rs = pstmt.executeQuery(); System.out.println(\"pstmt 실행\"); if(rs.next()){ //비번비교 후 일치하면 update 쿼리실행 if(bb.getPw().equals(rs.getString(\"pw\"))){ sql=\"update itwill_board set name=?, subject=?, content=? where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, bb.getName()); pstmt.setString(2, bb.getSubject()); pstmt.setString(3, bb.getContent()); pstmt.setInt(4, bb.getBno()); pstmt.executeUpdate(); System.out.println(\"글수정완료 - 비번일치\"); //리컨값 변경 result =1; }else{//비번불일치 System.out.println(\"글수정실패 - 비번불일치\"); result = 0; } }else{ System.out.println(\"글수정실패 - 해당글없음\"); result = -1; } } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { closeDB(); } return result; }//updateBoard닫음","link":"/2020/07/21/200722jspi/"},{"title":"[ITWILL : JSP]Javabean 9 : 게시판만들기(글삭제하기)","text":"ITWILL학원 : 30강 JSP기초 BY 정규태강사1. 글삭제하기기능구현 순서 deleteForm.jsp 작성 deletePro.jsp 작성 BoardDAO.java에서 bdao.deleteBoard(bno, pw)메서드 생성 기존의 boardList.jsp에 id가 있을 경우 추가 기존의 content.jsp 로그인상태에 따라 다르게 보이는 버튼 추가 2. deleteForm.jsp 작성123456789101112131415161718&lt;%//1. 한글처리request.setCharacterEncoding(\"UTF-8\");//2. 파라미터저장int bno = Integer.parseInt(request.getParameter(\"bno\"));String pageNum = request.getParameter(\"pageNum\");%&gt;&lt;fieldset&gt; &lt;legend&gt;게시글 삭제&lt;/legend&gt; &lt;form action=\"deletePro.jsp?pageNum=&lt;%=pageNum%&gt;\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"bno\" value=\"&lt;%=bno%&gt;\"&gt; 비밀번호 : &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"글삭제하기\" class=\"btn\"&gt; &lt;input type=\"button\" value=\"뒤로가기\" class=\"btn\" onclick=\"history.back()\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 3. deletePro.jsp 작성1234567891011121314151617181920212223242526272829303132333435&lt;%//1. 한글처리request.setCharacterEncoding(\"UTF-8\");//2. 파라미터저장(액션태그사용 &amp; pageNum은 파라미터로) int bno = Integer.parseInt(request.getParameter(\"bno\"));String pageNum = request.getParameter(\"pageNum\");String pw = request.getParameter(\"pw\");//3. DAO생성BoardDAO bdao = new BoardDAO();//4. 정보수정메서드 updateBoard(bb) // -&gt; 결과를 정수형 데이터로 리턴 (1=&gt;정상처리, 0=&gt;비번오류, -1=&gt;해당글없음)int result = bdao.deleteBoard(bno, pw);if(result == 1){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"정상적으로 글 삭제되었습니다\"); location.href=\"boardList.jsp\"; &lt;/script&gt; &lt;% }else if(result == 0){ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"비밀번호 오류\"); history.back(); &lt;/script&gt; &lt;% }else{ %&gt; &lt;script type=\"text/javascript\"&gt; alert(\"존재하지않는 게시글입니다\"); history.back(); &lt;/script&gt; &lt;%}%&gt; 3. BoardDAO.java에서 bdao.deleteBoard(bno, pw)메서드 생성123456789101112131415161718192021222324252627282930313233public int deleteBoard(int bno, String pw){ int result = -1; try { getCon(); sql=\"select pw from itwill_board where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); rs = pstmt.executeQuery(); if(rs.next()){ if(pw.equals(rs.getString(\"pw\"))){ sql=\"delete from itwill_board where bno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bno); pstmt.executeUpdate(); System.out.println(\"글삭제 성공\"); result = 1; }else{ result = 0; System.out.println(\"글삭제 중 비번오류\"); } }else{ result = -1; System.out.println(\"글삭제 중 select오류\"); } } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { closeDB(); } return result;}//deleteBoard()닫음 4. 기존의 main.jsp에 게시판바로가기 버튼 추가글삭제의 경우 아무나 할 수 없어야한다.따라서 로그인한 사람만이 글을 쓰고 글을 삭제할 수 있도록 구현해보자.이전에 구현했던 main.jsp에 게시판글바로볼 수 있는 버튼을 추가하고 location.href='../board/boardList.jsp을 연결해보자. 1234567891011121314151617181920212223242526&lt;%//1.한글처리, 파라미터 request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅String name = request.getParameter(\"name\");//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동if(id == null){ response.sendRedirect(\"loginForm.jsp\");}%&gt;&lt;h2&gt;&lt;%=id %&gt;님 환영합니다.&lt;/h2&gt;&lt;%=name %&gt;&lt;br&gt;&lt;input type=\"button\" value=\"ITWILL게시판가기\" class=\"btn\" onclick=\"location.href='../board/boardList.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보조회\" class=\"btn\" onclick=\"location.href='memberinfo.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" class=\"btn\" onclick=\"location.href='updateForm.jsp'\"&gt;&lt;input type=\"button\" value=\"로그아웃\" class=\"btn\" onclick=\"location.href='logout.jsp'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" class=\"btn\" onclick=\"location.href='deleteForm.jsp'\"&gt;&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id != null){ if(id.equals(\"admin\")){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" class=\"btn\" onclick=\"location.href='memberList.jsp'\"&gt;&lt;% }}%&gt; 5. 기존의 boardList.jsp에 id가 있을 경우 추가 id가 없을 경우 : 로그인버튼만 표시 id가 있을 경우 : 로그아웃, 글쓰기버튼 표시 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;fieldset&gt;&lt;legend&gt;땡땡게시판&lt;/legend&gt; &lt;div id=\"contents\"&gt; 게시판 총 글의 수 : &lt;%=cnt%&gt; 개 &lt;% if(id == null){ %&gt; &lt;input class=\"btn\" type=\"button\" value=\"로그인\" onclick=\"location.href='../member/main.jsp'\"&gt; &lt;% }else if( id != null){ %&gt; &lt;input class=\"btn\" type=\"button\" value=\"로그아웃\" onclick=\"location.href='../member/logout.jsp'\"&gt; &lt;input class=\"btn\" type=\"button\" value=\"글쓰기\" onclick=\"location.href='writeForm.jsp'\"&gt; &lt;% } %&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;글번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;th&gt;작성일&lt;/th&gt; &lt;th&gt;IP&lt;/th&gt; &lt;/tr&gt; &lt;%//반복문 //ArrayList는 가변배열이므로 length가 없고 size가 존재한다. //size()메서드는 배열의 요소의 갯수를 리턴 for(int i=0;i&lt;boardList.size(); i++){ //ArrayList 한칸의 정보 -&gt;BoardBean 객체 하나로 이동 BoardBean bb = (BoardBean) boardList.get(i); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=bb.getBno()%&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"content.jsp?bno=&lt;%=bb.getBno()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;\"&gt;&lt;%=bb.getSubject()%&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getName()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getReadcount()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getDate()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getIp()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;/table&gt; &lt;/div&gt;&lt;/fieldset&gt; 6. 기존의 content.jsp 로그인상태에 따라 다르게 보이는 버튼 추가 아이디가 있을 경우 로그아웃버튼, 글쓰기버튼이 보임 글 수정 및 삭제, 답글쓰기 버튼 보임 아이디가 없을 경우 로그인버튼만 보임. 로그아웃,글쓰기버튼 안보임 글 수정 및 삭제, 답글쓰기버튼 안보임 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;fieldset&gt;&lt;legend&gt;글 내용 보기&lt;/legend&gt; &lt;table border=\"solid,1px\"&gt; &lt;tr&gt; &lt;th&gt;글번호&lt;/th&gt; &lt;td&gt;&lt;%=bno%&gt;&lt;/td&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;td&gt;&lt;%=bb.getReadcount()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;td&gt;&lt;%=bb.getName()%&gt;&lt;/td&gt; &lt;th&gt;작성일&lt;/th&gt; &lt;td&gt;&lt;%=bb.getDate()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;제목&lt;/th&gt; &lt;td colspan=\"3\"&gt;&lt;%=bb.getSubject()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;첨부파일&lt;/th&gt; &lt;td colspan=\"3\"&gt;&lt;%=bb.getFile()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;내용&lt;/th&gt; &lt;td colspan=\"3\" height=\"300px\"&gt;&lt;%=bb.getContent()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"4\" style=\"text-align:center\"&gt; &lt;% //현재페이지에 로그인 정보가 없거나 글쓴이 이름과 아이디가 다를 경우 수정,삭제버튼을 숨긴다 //1.세션값 가져오기 String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅 //2. 아이디가 존재하면서 이름과 아이디가 같은 경우 if( id != null &amp;&amp; id.equals(bb.getName())){ %&gt; &lt;input type=\"button\" value=\"글수정\" class=\"btn\" onclick=\"location.href='updateForm.jsp?bno=&lt;%=bb.getBno()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;'\"&gt; &lt;input type=\"button\" value=\"글삭제\" class=\"btn\" onclick=\"location.href='deleteForm.jsp?bno=&lt;%=bb.getBno()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;'\"&gt; &lt;input type=\"button\" value=\"답글쓰기\" class=\"btn\" onclick=\"location.href='reWriteForm.jsp?bno=&lt;%=bb.getBno()%&gt;&amp;re_ref=&lt;%=bb.getRe_ref() %&gt;&amp;re_lev=&lt;%=bb.getRe_lev()%&gt;&amp;re_seq=&lt;%=bb.getRe_seq()%&gt;'\"&gt; &lt;% } %&gt; &lt;input type=\"button\" value=\"목록으로\" class=\"btn\" onclick=\"location.href='boardList.jsp?pageNum=&lt;%=pageNum%&gt;'\"&gt; &lt;!-- location.href='boardList.jsp만 하면 5페이지보고있다가 다시 1페이지로 돌아가버린다 이때 historyback하면 조회수가 올라가지않는다. 따라서 pageNum을 가져와서 사용하면된다 --&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/fieldset&gt;","link":"/2020/07/22/200723jspi/"},{"title":"[ITWILL : JSP]Javabean 14 : 게시판만들기(ServletContext사용하여 파일업로드와 다운로드)","text":"ITWILL학원 : 32강 JSP기초 BY 정규태강사UTF-8인코딩을 기본으로 ServletContext이용하여 가상경로에 파일을 저장하는 파일업로드와 다운로드기능 구현 1. webcontent 하위 새로운 폴더 2개 생성 : fileuputf, upload앞으로 파일다운로드기능구현시 생성되는 jsp, html페이지를 이 폴더(fileuputf)안에 생성한다.업로드되는 파일들은 upload라는 폴더안에 들어가게 된다.=&gt; 가상경로라고 부른다. 2. fileUploadForm.jsp 생성12345678&lt;fieldset&gt; &lt;form action=\"fileUploadPro.jsp\" method=\"post\" enctype=\"multipart/form-data\"&gt; 작성자 : &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt; 제목 : &lt;input type=\"text\" name=\"subject\"&gt;&lt;br&gt; 파일 : &lt;input type=\"file\" name=\"file\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"파일업로드\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 3. fileUploadPro.jsp 생성 가상경로 MultipartRequest객체생성 : request정보를 직접 가져올 수 없고 multi를 통해서 가져올 수 있다. Enumeration : 다음 요소가 있으면 반환해주는 인터페이스. 참고링크1 : Enumeration 참고링크2 : Enumeration 참고링크3 : Enumeration 파일업로드 기능은 예외가 많이때문에 예외처리를 해야한다 사용자가 입력한 데이터를 fileCheck.jsp로 전달하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!-- 파일 업로드 처리 --&gt;&lt;%//1. 파일 저장 위치 (가상경로) 만들기// D:\\workspace_jsp7\\.metadata\\.plugins\\org.eclipse.wst.server.core\\tmp0\\wtpwebapps\\fileUpload/upload//System.out.println(\"가상경로 : \"+request.getRealPath(\"/upload\"));String uploadPath = request.getRealPath(\"/upload\");//2. 저장 크기 지정 (10MB)int maxSize = 10 * 1024 * 1024;//3. 정보를 저장하는 변수 만들기String name =\"\";String subject =\"\";String filename = \"\"; //서버에 올라갈 파일명String OFilename = \"\"; //오리지널 파일명//6. 예외처리try{//4. MultipartRequest 객체생성//4-1. cos 라이브러리 추가//4-2. 객체 생성//request정보를 직접가져올 수 없고 multi를 통해서 가져올 수 있다.MultipartRequest multi = new MultipartRequest(request, uploadPath, maxSize, \"UTF-8\", new DefaultFileRenamePolicy());//5. 파일업로드완료//5-1. 전달되는 이름, 제목 저장name = multi.getParameter(\"name\");subject = multi.getParameter(\"subject\");//5-2. 전달된 파일의 이름 확인Enumeration files = multi.getFileNames(); //업캐스팅String file1 = (String) files.nextElement(); //위의 업캐스팅한 걸 다운캐스팅//5-3. 서버에 저장되는 파일 이름filename = multi.getFilesystemName(file1);System.out.println(\"filename : \"+filename);//5-4. 원래 파일이름OFilename = multi.getOriginalFileName(file1);System.out.println(\"OFilename : \"+OFilename);//여기까지 업로드 기능 구현 완료! =&gt; 6. 파일업로드는 예외가 많이때문에 예외처리를 해야한다}catch(Exception e){ e.printStackTrace();}%&gt;&lt;!-- 데이터를 전달하기enctype안적어도 될까? 업로드 유무로 판단!업로드할꺼면 필요, 업로드하지않을거면 필요하지않다아래처럼 input type을 text로 그냥 가져가면 중요한 정보들이 유출될 수있다.보안을 위해 2가지 방법이 있다.1안은 submit버튼사용 2안은 a태그사용한 방법이다. 편한 걸로하면되지만 보통 2안으로 많이한다--&gt;&lt;%-- &lt;form action=\"fileCheck.jsp\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\" value=\"&lt;%=name %&gt;\" readonly&gt;&lt;br&gt; &lt;input type=\"text\" name=\"subject\" value=\"&lt;%=subject %&gt;\"&gt;&lt;br&gt; &lt;input type=\"text\" name=\"filename\" value=\"&lt;%=filename %&gt;\"&gt;&lt;br&gt; &lt;input type=\"text\" name=\"ofilename\" value=\"&lt;%=OFilename %&gt;\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"확인하기\"&gt;&lt;/form&gt; --%&gt;&lt;!-- 1안 : form태그는 보여주지않는 않고 fileCheck에서 출력할 것이므로 hidden으로 type을 지정 후 submit버튼 이용--&gt;&lt;form action=\"fileCheck.jsp\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"name\" value=\"&lt;%=name %&gt;\" readonly&gt;&lt;br&gt; &lt;input type=\"hidden\" name=\"subject\" value=\"&lt;%=subject %&gt;\"&gt;&lt;br&gt; &lt;input type=\"hidden\" name=\"filename\" value=\"&lt;%=filename %&gt;\"&gt;&lt;br&gt; &lt;input type=\"hidden\" name=\"ofilename\" value=\"&lt;%=OFilename %&gt;\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"올린 파일 정보하기\"&gt;&lt;/form&gt;&lt;!-- 2안 : hidden때문에 생성된 submit버튼 위의 빈칸이 신경쓰이면 a태그를 이용가능.a태그를 이용하여 post방식 어떻게 데이터를 전달할수있을까? 이때 js를 사용한다 onclick=\"javascript:filecheck.submit\" --&gt;&lt;form action=\"fileCheck.jsp\" method=\"post\" name=\"filecheck\"&gt; &lt;input type=\"hidden\" name=\"name\" value=\"&lt;%=name%&gt;\"&gt;&lt;br&gt; &lt;input type=\"hidden\" name=\"subject\" value=\"&lt;%=subject%&gt;\"&gt;&lt;br&gt; &lt;input type=\"hidden\" name=\"filename\" value=\"&lt;%=filename%&gt;\"&gt;&lt;br&gt; &lt;input type=\"hidden\" name=\"ofilename\" value=\"&lt;%=OFilename%&gt;\"&gt;&lt;br&gt; &lt;/form&gt;&lt;a href=\"#\" onclick=\"javascript:filecheck.submit();\"&gt;업로드 확인 및 다운로드 페이지로 이동&lt;/a&gt; 4. fileCheck.jsp생성 사용자가 입력한 정보를 체크하고 파일명을 눌렀을때 다운로드 가능하도록 file_down.jsp로 이동하는 기능 구현 서버에 저장된 파일명의 a태그에서 get방식으로 파라미터로 정보를 전달한다. 1234567891011121314151617&lt;h2&gt;업로드하지 않고 확인용으로 전달받은 데이터 화면에 출력&lt;/h2&gt;&lt;%request.setCharacterEncoding(\"UTF-8\");String name = request.getParameter(\"name\");String subject = request.getParameter(\"subject\");String filename = request.getParameter(\"filename\");String ofilename = request.getParameter(\"ofilename\");%&gt;&lt;fieldset&gt;&lt;legend&gt;업로드 정보 확인용&lt;/legend&gt; 작성자명 : &lt;%=name %&gt;&lt;br&gt; 제목 : &lt;%=subject %&gt;&lt;br&gt; 서버에 저장된 파일명 : &lt;a href=\"file_down.jsp?file_name=&lt;%=filename %&gt;\"&gt; &lt;%=filename %&gt;&lt;/a&gt;&lt;br&gt; 원본파일명 : &lt;%=ofilename %&gt;&lt;br&gt;&lt;/fieldset&gt; 5. file_down.jsp 생성 servletContext : 지금 쓰고있는 내 프로젝트 정보. MIME타입 : 클라이언트에게 전송되는 데이터(문서)를 다양하게 처리 가능하도록 하는 메커니즘웹에서 파일의 확장자는 큰 의미가 없음(스트림형태로 데이터가 전달) -&gt; 스트림형태일때는 데이터 구분못함.따라서 각 데이터(문서)에서 올바른 형태의 데이터를 전달하도록 MIME 타입을 지정브라우저들이 응답정보(리소스)를 받았을때 어떤 형태로 처리해야하는지 판단하는 기준마임타입을 가져오는 방법은 getServletContext().getMimeType()으로 가능 브라우저에 따른 데이터 처리(대응) 왜 인터넷익스플로러를 기준으로 나눌까? 인터넷익스폴러는 다운로드시 한글파일이 깨짐 -&gt; 따라서 파일을 인코딩해서 다운로드함 이때 공백문자가 플러스(+)기호로 나옴 -&gt; 이걸 %20으로 변경 인터넷익스플로러인지 아닌지는 어떻게 구분할까? 접속한 사용자정보(User-Agent)를 불러와서 indexOf사용하여 MSIE이나 Trident이 들어가 있으면 익스플로러이다.123String agent = request.getHeader(\"User-Agent\");System.out.println(\"agent : \"+ agent);boolean ieBrowser = agent.indexOf(\"MSIE\") &gt; -1 || agent.indexOf(\"Trident\") &gt; -1; 데이터다운로드 처리 브라우저가 응답정보를 읽어서(해석) 처리시 “Content-Disposition” 설정값이 “attachment;” 모든 데이터 다운로드 처리한다. 만약 설정안하게되면 어떻게 될까? 브라우저의 기본값에 의해 처리한다. 데이터 출력(다운로드) flush() : 데이터가 담긴 배열이 꽉 차지 않았을때는 데이터를 출력하지않는다. 이때 flush가 배열의 빈 공간을 공백으로 채워서 데이터 출력되도록 만들어준다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;%@page import=\"java.net.URLEncoder\"%&gt;&lt;%@page import=\"javax.activation.MimeType\"%&gt;&lt;%@page import=\"java.io.FileInputStream\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //1. 전달받은 데이터 저장String filename = request.getParameter(\"file_name\");System.out.println(\" 전달된 파일 명 : \"+filename);//2. 파일 다운로드할 위치(= 파일 업로드 위치) =&gt;가상경로//savepath는 저장되는 폴더명String savepath = \"upload\";//3. 내 프로젝트 정보(ServletContext)안에서 가상경로를 실제경로로 계산해줘야한다.//3-1. 서버안에 있는 물리적 위치 확인ServletContext context = getServletContext();String DownloadPath = context.getRealPath(savepath);System.out.println(\"DownloadPath : \"+DownloadPath);//3-2. 다운로드할 파일의 전체 경로//역슬러시 두개는 이스케이프문자로서 역슬러시 1개만 표현됨String FilePath = DownloadPath+\"\\\\\"+filename;//여기까지다운로드기능완료//4. 데이터 응답처리를 다운로드 형태로 구현//4-1. 파일을 한번에 처리하기위한 배열byte[] b = new byte[4069];//4-2. 파일입출력을 처리하는 파일 입력 스트림 객체생성(즉, 파일을 읽어오는 통로만들기)FileInputStream fis = new FileInputStream(FilePath);//4-3. 다운로드할 파일의 마임타입 확인(mime) //=&gt; 클라이언트에게 전송되는 데이터(문서)를 다양하게 처리 가능하도록 하는 메커니즘String MimeType = getServletContext().getMimeType(FilePath);System.out.println(\"Mime type: \"+MimeType);if(MimeType == null){ //기본값 지정 - 이진파일을 처리하기위한 기본타입 //-&gt; 잘 알려지지 않은 파일을 의미하기때문에 //-&gt; 브라우저는 보통 자동실행을 안하고 대화상자를 이용하여 사용자에게 실행할지 질문함 MimeType = \"application/octet-stream\";}//4-4내 응답정보를 마임타입으로 지정response.setContentType(MimeType);//5. 브라우저에 따른 데이터 처리(대응)//왜 인터넷익스플로러를 기준으로 나눌까?//인터넷익스폴러는 다운로드시 한글파일이 깨짐 -&gt; 따라서 파일을 인코딩해서 다운로드함 //이때 공백문자가 플러스(+)기호로 나옴 -&gt; 이걸 %20(공백)으로 변경//익스인지 아닌지는 어떻게 알까? String agent = request.getHeader(\"User-Agent\");System.out.println(\"agent : \"+ agent);boolean ieBrowser = agent.indexOf(\"MSIE\") &gt; -1 || agent.indexOf(\"Trident\") &gt; -1; if(ieBrowser){ // IE 일때 : +를 %20(공백)으로 변경 filename = URLEncoder.encode(filename, \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");}else{ // IE 아닐때 : 데이터인코딩(한글깨짐방지) filename = new String(filename.getBytes(\"UTF-8\"), \"iso-8859-1\");}//6. 데이터다운로드 처리//브라우저가 응답정보를 읽어서(해석) 처리시 //\"Content-Disposition\" 설정값이 \"attachment;\" 모든 데이터 다운로드 처리 response.setHeader(\"Content-Disposition\", \"attachment; filename=\"+filename);//7. 데이터출력(다운로드)ServletOutputStream out2 = response.getOutputStream();//7-1. 데이터출력 통로 생성int data = 0;while((data = fis.read(b,0,b.length)) != -1){ //데이터출력시 파일이 있을동안 계속 진행 out2.write(b,0,data); //배열에다가 data를 담아서 출력 out2.flush();}//8. 자원해제out2.close();fis.close();//9. java.lang.IllegalStateException://이 응답을 위해 getOutputStream()이 이미 호출되었습니다.// =&gt; JSP-&gt;Servlet 변환시 out 객체가 자동생성, 추가로 OutputStream 객체 생성시// 오류 메세지 출력( 다운로드 문제 X, 서버에 에러 메세지 로그 쌓임)out.clear();out = pageContext.pushBody();%&gt; 5-1. java.lang.IllegalStateException에러java.lang.IllegalStateException: 이 응답을 위해 getOutputStream()이 이미 호출되었습니다. jsp가 실행될때 java파일로 변환되어 실행되고 그 바뀌는 걸 servlet이라고 한다.이 변환시에 out이라는 객체가 자동 생성된다.만약 추가로 OutputStream 객체생성시 IllegalStateException에러가 발생한다. 다운로드기능에는 문제가 없으나 에러가 실행될때마다 서버에 에러 메세지 로그 쌓이기때문에 처리해야한다. 12out.clear();out = pageContext.pushBody();","link":"/2020/07/27/200728jspi/"},{"title":"[ITWILL : JSP]홈페이지만들기2 : 아이디중복체크 포함한 회원가입기능 구현","text":"ITWILL학원 : 34강 JSP기초 BY 정규태강사1. 회원가입기능 구현1-1. joinForm.jsp 추가작성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;body&gt;&lt;div id=\"wrap\"&gt;&lt;!-- 헤더들어가는 곳 --&gt;&lt;jsp:include page=\"../inc/top.jsp\"&gt;&lt;/jsp:include&gt;&lt;!-- 헤더들어가는 곳 --&gt;&lt;!-- 본문들어가는 곳 --&gt;&lt;!-- 본문메인이미지 --&gt;&lt;div id=\"sub_img_member\"&gt;&lt;/div&gt;&lt;!-- 본문메인이미지 --&gt;&lt;!-- 왼쪽메뉴 --&gt;&lt;nav id=\"sub_menu\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;회원가입&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;개인정보취급방침&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;!-- 왼쪽메뉴 --&gt;&lt;!-- 본문내용 --&gt;&lt;article&gt;&lt;h1&gt;Join Us&lt;/h1&gt;&lt;form action=\"joinPro.jsp\" method=\"post\" id=\"join\" name=\"fr\" onsubmit=\"return check();\"&gt;&lt;!-- 필수입력사항 --&gt;&lt;fieldset&gt;&lt;legend&gt;필수입력사항&lt;/legend&gt; &lt;label&gt;아이디&lt;/label&gt; &lt;input type=\"text\" name=\"id\" class=\"id\"&gt; &lt;input type=\"button\" value=\"중복확인\" class=\"dup\" onclick=\"winopen()\"&gt;&lt;br&gt; &lt;label&gt;비밀번호&lt;/label&gt; &lt;input type=\"password\" name=\"pw\" placeholder=\"영문숫자조합 4자리이상\" required&gt;&lt;br&gt; &lt;label&gt;비밀번호확인&lt;/label&gt; &lt;input type=\"password\" name=\"pass2\" required&gt;&lt;br&gt; &lt;label&gt;이름&lt;/label&gt; &lt;input type=\"text\" name=\"name\" required&gt;&lt;br&gt; &lt;label&gt;이메일&lt;/label&gt; &lt;input type=\"email\" name=\"email\" placeholder=\"예시 : funweb@funweb.com (@포함기입)\" required&gt;&lt;br&gt; &lt;label&gt;생년월일&lt;/label&gt; &lt;input type=\"text\" name=\"birth\" placeholder=\"예시 : 801231 (6자리)\" maxlength=\"6\" required&gt;&lt;br&gt; &lt;label&gt;성별&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" value=\"f\"&gt;여 &lt;input type=\"radio\" name=\"gender\" value=\"m\"&gt;남&lt;br&gt;&lt;/fieldset&gt;&lt;!-- 선택입력사항 --&gt;&lt;fieldset&gt;&lt;legend&gt;선택입력사항&lt;/legend&gt;&lt;label&gt;주소&lt;/label&gt;&lt;!-- &lt;input type=\"text\" name=\"address\"&gt;&lt;br&gt; --&gt;&lt;input type=\"text\" id=\"sample4_postcode\" placeholder=\"우편번호\"&gt;&lt;input type=\"button\" onclick=\"daumPostcode()\" value=\"우편번호 찾기\"&gt;&lt;br&gt;&lt;label&gt;도로명주소(자동입력)&lt;/label&gt;&lt;input type=\"text\" name=\"addr\" id=\"sample4_roadAddress\" placeholder=\"우편번호찾기를 이용해주세요\" readonly&gt;&lt;br&gt;&lt;input type=\"hidden\" id=\"sample4_jibunAddress\" placeholder=\"지번주소\"&gt;&lt;span id=\"guide\" style=\"color:#999;display:none\"&gt;&lt;/span&gt;&lt;input type=\"hidden\" id=\"sample4_extraAddress\" placeholder=\"참고항목\"&gt;&lt;label&gt;휴대폰번호&lt;/label&gt;&lt;input type=\"text\" name=\"mobile\" placeholder=\"예시 : 010-1234-5678\" maxlength=\"13\"&gt;&lt;br&gt;&lt;/fieldset&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;div id=\"buttons\"&gt;&lt;input type=\"submit\" value=\"회원가입\" class=\"submit\"&gt;&lt;input type=\"reset\" value=\"초기화\" class=\"cancel\"&gt;&lt;/div&gt;&lt;/form&gt;&lt;/article&gt;&lt;!-- 본문내용 --&gt;&lt;!-- 본문들어가는 곳 --&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;!-- 푸터들어가는 곳 --&gt;&lt;jsp:include page=\"../inc/bottom.jsp\"&gt;&lt;/jsp:include&gt;&lt;!-- 푸터들어가는 곳 --&gt;&lt;/div&gt;&lt;script src=\"https://t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js\"&gt;&lt;/script&gt;&lt;!-- 유효성체크 : 데이터 빈공백체크(id와 성별) --&gt;&lt;script type=\"text/javascript\"&gt;function check(){ //아이디가 입력이 안되어있을 경우 아이디입력하라는 메세지 출력 if(document.fr.id.value == \"\" || document.fr.id.value.length &lt; 0){ alert(\"아이디를 입력해주세요\") history.back() document.fr.id.focus(); return false; } if(document.fr.gender[0].checked == false &amp;&amp; document.fr.gender[1].checked == false){ alert(\"성별을 확인해주세요\") history.back() document.fr.id.focus(); return false; }}&lt;!-- 아이디중복체크 --&gt;function winopen(){ //새창을 열어서 페이지를 오픈 후 -&gt; 회원아이디정보를 가지고 중복체크 //아래 2-1에 구현}//도로명주소 카카오API사용function daumPostcode() { new daum.Postcode({ (생략) }).open();}&lt;/script&gt;&lt;/body&gt; 1-2. joinPro.jsp 추가작성123456789101112131415161718192021222324&lt;%//1. 한글처리 request.setCharacterEncoding(\"UTF-8\");%&gt;&lt;!-- 2. 전달되는 데이터 입력(저장) =&gt; 자바빈 객채, 액션태그사용--&gt;&lt;jsp:useBean id=\"mb\" class=\"com.itwillbs.member.MemberBean\" /&gt;&lt;jsp:setProperty property=\"*\" name=\"mb\"/&gt;&lt;%//3. 현재 날짜정보저장(또는 DAO에서 sql구문 작성시 now()를 이용해서 현재시각을 DB에 바로 담을 수 있다.)mb.setRe_date(new Date(System.currentTimeMillis()));//4. MemberDAO객체생성 -&gt; 전달받은 정보 모두 저장MemberDAO mdao = new MemberDAO();//5. 회원 가입 메서드 (insertMember())mdao.insertMember(mb);%&gt;//6. 회원가입 완료시 로그인페이지로 이동&lt;script type=\"text/javascript\"&gt;alert(\"회원가입성공\")location.href=\"loginForm.jsp\";&lt;/script&gt; 1-3. MemberDAO에 insertMember()메서드생성 매개변수 6개 이상이면 성능이 급격하게 떨어진다는 연구결과가 있음 매개변수가 6개이상일때는 javabean을 이용하여 받아오는 것이 성능에 좋다 123456789101112131415161718192021222324252627282930//회원가입메서드private void insertMember(MemberBean mb){ try { con = getCon(); sql = \"insert into fun_member values (?,?,?,?,?, \" +\"?,?,?,?)\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, mb.getId()); pstmt.setString(2, mb.getPw()); pstmt.setString(3, mb.getName()); pstmt.setString(4, mb.getEmail()); pstmt.setInt(5, mb.getBirth()); pstmt.setString(6, mb.getGender()); pstmt.setString(7, mb.getAddr()); pstmt.setString(8, mb.getMobile()); pstmt.setDate(9, mb.getRe_date()); pstmt.executeUpdate(); System.out.println(\"회원가입성공\"); } catch (NamingException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } catch (Exception e) { System.out.println(\"회원가입성공\"); e.printStackTrace(); } finally { closeDB(); }}//insertMember메서드닫음 2. 아이디중복체크 구현2-1. joinForm.jsp 추가작성 input태그에 onclick=”winopen()”을 설정해준 뒤 아래 winopen()함수를 생성한다. 요즘은 버튼을 클릭하는 대신 제이쿼리의 ajax라이브러리를 사용하여 keydown이나 keyup function을 이용한 비동기처리방식을 사용한다 예시 : 네이버회원가입 참고링크 : 동기와 비동기처리방식 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 필수입력사항 --&gt;&lt;fieldset&gt;&lt;legend&gt;필수입력사항&lt;/legend&gt; &lt;label&gt;아이디&lt;/label&gt; &lt;input type=\"text\" name=\"id\" class=\"id\"&gt; &lt;input type=\"button\" value=\"중복확인\" class=\"dup\" onclick=\"winopen()\"&gt;&lt;br&gt; &lt;label&gt;비밀번호&lt;/label&gt; &lt;input type=\"password\" name=\"pw\" placeholder=\"영문숫자조합 4자리이상\" required&gt;&lt;br&gt; &lt;label&gt;비밀번호확인&lt;/label&gt; &lt;input type=\"password\" name=\"pass2\" required&gt;&lt;br&gt; &lt;label&gt;이름&lt;/label&gt; &lt;input type=\"text\" name=\"name\" required&gt;&lt;br&gt; &lt;label&gt;이메일&lt;/label&gt; &lt;input type=\"email\" name=\"email\" placeholder=\"예시 : funweb@funweb.com (@포함기입)\" required&gt;&lt;br&gt; &lt;label&gt;생년월일&lt;/label&gt; &lt;input type=\"text\" name=\"birth\" placeholder=\"예시 : 801231 (6자리)\" maxlength=\"6\" required&gt;&lt;br&gt; &lt;label&gt;성별&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" value=\"f\"&gt;여 &lt;input type=\"radio\" name=\"gender\" value=\"m\"&gt;남&lt;br&gt;&lt;/fieldset&gt;&lt;!-- 아이디중복체크 --&gt;function winopen(){ //새창을 열어서 페이지를 오픈 후 -&gt; 회원아이디정보를 가지고 중복체크 //1. 아이디가 없으면 알림창과 진행x if(document.fr.id.value ==\"\" || document.fr.id.value.length &lt; 0){ alert(\"아이디를 먼저 입력해주세요\") document.fr.id.focus(); }else{ //2. 회원정보아이디를 가지고 있는 지 체크하려면 DB에 접근해야한다. //자바스크립트로 어떻게 DB에 접근할까? =&gt; 파라미터로 id값을 가져가서 jsp페이지에서 진행하면 된다. window.open(\"joinIdCheck.jsp?userid=\"+document.fr.id.value,\"\",\"width=500, height=300\"); }} 2-2. joinIdCheck.jsp생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;%@page import=&quot;com.itwillbs.dao.MemberDAO&quot;%&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;아이디중복체크&lt;/h2&gt;&lt;%//1. 한글처리 &amp; 받아온 파라미터 변수화request.setCharacterEncoding(&quot;UTF-8&quot;);String id = request.getParameter(&quot;userid&quot;);//2. MemberDAO객체생성 -&gt; 전달받은 정보 모두 저장MemberDAO mdao = new MemberDAO();//3. joinIdCheck(ID)메서드int result = mdao.joinIdCheck(id);if (result == 1){ out.print(&quot;사용가능한 아이디입니다&quot;); //5. 아이디사용하기버튼추가 =&gt; 동기방식사용 but 요즘은 비동기방식을 더 많이사용한다 %&gt; &lt;input type=&quot;button&quot; value=&quot;아이디 사용하기&quot; onclick=&quot;result();&quot;&gt; &lt;% }else if(result == 0){ out.print(&quot;중복된 아이디입니다&quot;);}else{ out.print(&quot;에러 발생!!!(-1)&quot;); }%&gt;&lt;!-- 4.팝업창구현 --&gt;&lt;fieldset&gt; &lt;!-- &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; action속성에 값이 없으면 기본적으로 자기자신을 불러오지만 중복확인 버튼을 클릭했을때 변경되지않는다.--&gt; &lt;form action=&quot;joinIdCheck.jsp&quot; method=&quot;post&quot; name=&quot;wfr&quot;&gt; ID : &lt;input type=&quot;text&quot; name=&quot;userid&quot; value=&quot;&lt;%=id%&gt;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;중복 확인&quot;&gt; &lt;/form&gt;&lt;/fieldset&gt;&lt;!-- 6. 선택된아이디는 중복확인창에서 회원가입 페이지로 정보전달 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; function result(){ //팝업창의 아이디정보를 회원가입창에 아이디정보로 전달 //팝업창은 기존창과 종속관계를 가지고 있으므로 opener를 이용하면 된다. //alert(&quot;팝업창의 id값&quot;+document.wfr.userid.value + &quot;, 회원가입창의 id값 : &quot; +opener.document.fr.id.value) //6-1. 회원가입페이지의 id값에 아이디중복으로 선택된 id값을 대입. opener.document.fr.id.value = document.wfr.userid.value; //6-3. 회원가입창 제어 //readonly 속성제어(커멜표기가 아닐때는 제어가 안됨 신기하네 ㅋㅋㅋ) opener.document.fr.id.readOnly=true; //6-2. 창닫기 window.close(); } &lt;/script&gt;&lt;/body&gt; 2-3. MemberDAO.java에 joinIdCheck()메서드 구현rs데이터 처리 1 - 사용 가능한 아이디 0 - 사용 불가능한 아이디 -1 -&gt; 에러 발생 12345678910111213141516171819202122232425262728293031//아이디중복체크 메서드public int joinIdCheck(String id){ int result = -1; try { //1. DB연결 con = getCon(); //2. sql 구문 &amp; pstmt생성 sql = \"select id from fun_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); //3. 실행 -&gt; select -&gt; rs저장 rs = pstmt.executeQuery(); //4. 데이터처리 if(rs.next()){ result = 0; }else{ result = 1; } System.out.println(\"아이디 중복체크결과 : \"+result); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { closeDB(); } return result;}//joinIdCheck 메서드닫음","link":"/2020/07/29/200730jspi/"},{"title":"홈페이지만들기4 : 게시판글쓰기구현","text":"top.jsp수정 ../center/notice.html 을 ../center/notice.jsp로 변경 123456789101112131415161718192021222324252627282930&lt;% //화면상단에 위치하는 메뉴바 처리페이지String id = (String)session.getAttribute(\"id\"); //다운캐스팅 Object -&gt; String%&gt;&lt;header&gt;&lt;div id=\"login\"&gt; &lt;%if(id == null){ %&gt; &lt;div id=\"login\"&gt;&lt;a href=\"../member/loginForm.jsp\"&gt;로그인&lt;/a&gt; | &lt;a href=\"../member/joinForm.jsp\"&gt;회원가입&lt;/a&gt;&lt;/div&gt; &lt;% }else if(id != null){ %&gt; &lt;div id=\"login\"&gt;&lt;%=id %&gt;님 환영합니다 | &lt;a href=\"../member/logout.jsp\"&gt;로그아웃&lt;/a&gt;&lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;!-- 로고들어가는 곳 --&gt;&lt;div id=\"logo\"&gt;&lt;img src=\"../images/logo.gif\" width=\"265\" height=\"62\" alt=\"Fun Web\"&gt;&lt;/div&gt;&lt;!-- 로고들어가는 곳 --&gt;&lt;nav id=\"top_menu\"&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"../index.jsp\"&gt;홈&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"../company/welcome.html\"&gt;회사소개&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;솔루션&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"../center/notice.jsp\"&gt;게시판&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;무엇이든 물어보세요&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;&lt;/header&gt; notice.jsp생성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;body&gt;&lt;div id=\"wrap\"&gt;&lt;!-- 헤더들어가는 곳 --&gt; &lt;jsp:include page=\"../inc/top.jsp\" /&gt;&lt;!-- 헤더들어가는 곳 --&gt;&lt;!-- 본문들어가는 곳 --&gt;&lt;!-- 메인이미지 --&gt;&lt;div id=\"sub_img_center\"&gt;&lt;/div&gt;&lt;!-- 메인이미지 --&gt;&lt;!-- 왼쪽메뉴 --&gt;&lt;nav id=\"sub_menu\"&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=\"writeForm.jsp\"&gt;글쓰기&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;글 목록 보기&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;파일업로드/다운로드&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;Service Policy&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;&lt;!-- 왼쪽메뉴 --&gt;&lt;!-- 게시판 --&gt;&lt;article&gt;&lt;h1&gt;게시판&lt;/h1&gt;&lt;table id=\"notice\"&gt;&lt;tr&gt;&lt;th class=\"tno\"&gt;No.&lt;/th&gt; &lt;th class=\"ttitle\"&gt;Title&lt;/th&gt; &lt;th class=\"twrite\"&gt;Writer&lt;/th&gt; &lt;th class=\"tdate\"&gt;Date&lt;/th&gt; &lt;th class=\"tread\"&gt;Read&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;15&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;14&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;13&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;11&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;9&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td class=\"left\"&gt;Vivanus viveer portitor commodo.&lt;/td&gt; &lt;td&gt;Host Admin&lt;/td&gt;&lt;td&gt;2012.11.06&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&lt;div id=\"table_search\"&gt;&lt;input type=\"text\" name=\"search\" class=\"input_box\"&gt;&lt;input type=\"button\" value=\"search\" class=\"btn\"&gt;&lt;/div&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;div id=\"page_control\"&gt;&lt;a href=\"#\"&gt;Prev&lt;/a&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;a href=\"#\"&gt;4&lt;/a&gt;&lt;a href=\"#\"&gt;5&lt;/a&gt;&lt;a href=\"#\"&gt;6&lt;/a&gt;&lt;a href=\"#\"&gt;7&lt;/a&gt;&lt;a href=\"#\"&gt;8&lt;/a&gt;&lt;a href=\"#\"&gt;9&lt;/a&gt;&lt;a href=\"#\"&gt;10&lt;/a&gt;&lt;a href=\"#\"&gt;Next&lt;/a&gt;&lt;/div&gt;&lt;/article&gt;&lt;!-- 게시판 --&gt;&lt;!-- 본문들어가는 곳 --&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;!-- 푸터들어가는 곳 --&gt; &lt;jsp:include page=\"../inc/bottom.jsp\" /&gt;&lt;!-- 푸터들어가는 곳 --&gt;&lt;/div&gt;&lt;/body&gt; writeForm.jsp생성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;body&gt;&lt;div id=\"wrap\"&gt;&lt;!-- 헤더들어가는 곳 --&gt; &lt;jsp:include page=\"../inc/top.jsp\" /&gt;&lt;!-- 헤더들어가는 곳 --&gt;&lt;!-- 본문들어가는 곳 --&gt;&lt;!-- 메인이미지 --&gt;&lt;div id=\"sub_img_center\"&gt;&lt;/div&gt;&lt;!-- 메인이미지 --&gt;&lt;!-- 왼쪽메뉴 --&gt;&lt;nav id=\"sub_menu\"&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=\"#\"&gt;글쓰기&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"notice.jsp\"&gt;글 목록 보기&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;파일업로드/다운로드&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#\"&gt;Service Policy&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;&lt;!-- 왼쪽메뉴 --&gt;&lt;!-- 게시판 --&gt;&lt;article&gt;&lt;h1&gt; 게시판 글쓰기 &lt;/h1&gt; &lt;!-- 로그인 한 사용자만 글쓰기 가능 로그인한 사람의 ID값을 글쓴이로 지정 --&gt; &lt;% // 세션ID값을 사용해서 글쓴이 지정 // 로그인 x -&gt; 로그인 페이지로 이동 String id = (String) session.getAttribute(\"id\"); if(id == null){ response.sendRedirect(\"../member/loginForm.jsp\"); } %&gt; &lt;form action=\"writePro.jsp\" method=\"post\" name=\"fr\"&gt; &lt;table id=\"notice\"&gt; &lt;tr&gt; &lt;td&gt;글쓴이&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"name\" value=\"&lt;%=id%&gt;\" readonly&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;글 비밀번호&lt;/td&gt; &lt;td&gt; &lt;input type=\"password\" name=\"pass\" &gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;제목&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"subject\" &gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;내용&lt;/td&gt; &lt;td&gt; &lt;textarea rows=\"10\" cols=\"20\" name=\"content\"&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=\"table_search\"&gt; &lt;input type=\"submit\" value=\"글쓰기\" class=\"btn\"&gt; &lt;/div&gt; &lt;div class=\"clear\"&gt;&lt;/div&gt; &lt;/form&gt;&lt;div id=\"page_control\"&gt;&lt;/div&gt;&lt;/article&gt;&lt;!-- 게시판 --&gt;&lt;!-- 본문들어가는 곳 --&gt;&lt;div class=\"clear\"&gt;&lt;/div&gt;&lt;!-- 푸터들어가는 곳 --&gt; &lt;jsp:include page=\"../inc/bottom.jsp\" /&gt;&lt;!-- 푸터들어가는 곳 --&gt;&lt;/div&gt;&lt;/body&gt; writePro.jsp생성하기 전에 해야할 세가지 DB테이블 생성 BoardBean객체 필요 BoardDAO객체필요 writePro.jsp생성 DB테이블 생성 BoardBean.java생성123456789101112131415161718192021222324252627282930public class BoardBean { private int bno; private String name; private String pw; private String subject; private String content; private int readcount; private int re_ref; private int re_seq; private int re_lev; private Date date; private String ip; private String file; public int getBno() { return bno; } public void setBno(int bno) { this.bno = bno; } (중략) @Override public String toString() { return \"BoardBean [bno=\" + bno + \", name=\" + name + \", pw=\" + pw + \", subject=\" + subject + \", content=\" + content + \", readcount=\" + readcount + \", re_ref=\" + re_ref + \", re_seq=\" + re_seq + \", re_lev=\" + re_lev + \", date=\" + date + \", ip=\" + ip + \", file=\" + file + \"]\"; }} BoardDAO.java생성 DB연결메서드 생성 자원해제메서드 생성 insertBoard 메서드 생성 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Connection con = null;String sql = \"\";PreparedStatement pstmt = null;ResultSet rs = null;private Connection getCon() throws Exception { Context init = new InitialContext(); DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/webpro\"); con = ds.getConnection(); System.out.println(\"디비연결성공\"); return con;} //자원해제메서드public void closeDB(){ try{ if(rs != null) rs.close(); if(pstmt != null) pstmt.close(); if(con != null) con.close(); } catch (SQLException e) { e.printStackTrace(); } }//글쓰기메서드public void insertBoard(BoardBean bb){ int num = 0; try { // 디비연결 con = getCon(); // sql(1) 글번호 계산,(2) 글정보를 저장 sql = \"select max(bno) from fun_board\"; pstmt = con.prepareStatement(sql); // 실행 rs = pstmt.executeQuery(); if(rs.next()){ num = rs.getInt(1)+1; } System.out.println(\"저장될 글번호 : \"+num); // (2) 글정보를 저장 // sql sql = \"insert into fun_board (bno,name,pw,subject,content,\" + \"readcount,re_ref,re_lev,re_seq,date,ip,file) \" + \"values(?,?,?,?,?,?,?,?,?,now(),?,?)\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, num); pstmt.setString(2, bb.getName()); pstmt.setString(3, bb.getPw()); pstmt.setString(4, bb.getSubject()); pstmt.setString(5, bb.getContent()); pstmt.setInt(6, 0); //readcount pstmt.setInt(7, num); // re_ref (답글 그룹번호 == 글번호) pstmt.setInt(8, 0); // re_lev 일반글 0 pstmt.setInt(9, 0); // re_seq 일반글 0 pstmt.setString(10, bb.getIp()); pstmt.setString(11, bb.getFile()); // 실행 pstmt.executeUpdate(); System.out.println(num+\"번 글쓰기 완료!\"); } catch (Exception e) { e.printStackTrace(); }finally { closeDB(); }}//insertBoard닫음 writePro.jsp 생성1234567891011121314151617181920&lt;%request.setCharacterEncoding(\"UTF-8\");//1. DB테이블 생성//2. BoardBean객체 필요//3. BoardDAO객체필요%&gt;&lt;!-- 4. BoardBean 객체 저장(액션태그) --&gt;&lt;jsp:useBean id=\"bb\" class=\"com.itwillbs.bean.BoardBean\"/&gt;&lt;jsp:setProperty property=\"*\" name=\"bb\"/&gt;&lt;%//5. ip정보 추가bb.setIp(request.getRemoteAddr());//6. BoardDAO객체생성BoardDAO bdao = new BoardDAO();bdao.insertBoard(bb);//7. 페이지이동response.sendRedirect(\"notice.jsp\");%&gt;","link":"/2020/08/02/200803jspi/"},{"title":"[jQuery] JQuery 사용설정, 선택자, css()","text":"JQuery JQuery : 자바스크립트의 라이브러리 언어 (자주 사용하는 기능만 모아놓은 언어) 공부할 주요 내용은 아래 세가지 : 선택자, Ajax, Json js쓰면 되는데 왜 굳이 JQuery를 쓸까? js보다 페이지 호환성이 우수하기때문 JQuery document JQuery 다운로드 JQuery 사이트 방문 &gt; download 탭 선택 Download the compressed, production jQuery 3.5.1 클릭 &gt; 다른 이름으로 바탕화면에 저장 Download the uncompressed, development jQuery 3.5.1 클릭 &gt; 다른 이름으로 바탕화면에 저장 Download the compressed, production jQuery 3.5.1 slim build 클릭 &gt; 다른 이름으로 바탕화면에 저장 Download the uncompressed, development jQuery 3.5.1 slim build 클릭 &gt; 다른 이름으로 바탕화면에 저장 다운로드 받은 파일들의 차이점 이름에 min 유무 : 원본에서 주석없애고 압축해서 만든 파일이 min파일이다. min파일은 데이터를 읽어들이는 속도가 상대적으로 빠르다 그럼 무조건 min을 써야할까? NOPE! 하고있는 작업에 따라 다르다. 초단위로 속도가 중요한 프로젝트면 min을 써야한다 이름에 slim 유무 : min에서 더 slim하게 만든 파일. JQuery를 내 프로젝트에 연결하는 두 가지 방법 내 로컬에서 제이쿼리 라이브러리 추가 : 직접 다운로드해서 연결 네트워크 전송방식 라이브러리 추가 : Google CDN &gt; 3.x snippet 코드를 복붙 네트워크상황이 안 좋을 경우 에러가 발생할 수 있으므로 보통으 라이브러리를 직접 다운로드해서 사용한다. 12345&lt;!-- 라이브러리추가방법 첫번째 : 내 컴퓨터에 있는 제이쿼리 라이브러리 추가 --&gt;&lt;script type=\"text/javascript\" src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;!-- 라이브러리추가방법 두번째 : 네트워크 전송방식 라이브러리 추가(구글 CDN사용) --&gt;&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\"&gt;&lt;/script&gt; 프로젝트 생성하기 새로운 dynamic web project생성 생성한 프로젝트 우클릭 &gt; properties &gt; java build path &gt; add library &gt; server runtime &gt; Tomcat설정하기 JQuery 라이브러리 다운로드 받기 : 보통은 jquery-3.5.1.min.js을 사용한다. 프로젝트 &gt; webcontent &gt; js 폴더를 생성하고 다운로드 받은 JQuery라이브러리를 넣는다. webcontent에 test.jsp생성 후 script태그로 연결하기 프로젝트 우클릭 &gt; 설정 &gt; tern &gt; modules &gt; JQuery 두 개 클릭 후 저장 이제 Test1.jsp페이지 생성 후 코딩하면 됨! 제이쿼리 사용법 총 3가지 방법이 있다. 실무에선 주로 첫번째방법과 두번째방법을 사용한다. 제이쿼리와 자바스크립트 코드가 있다면 실행순서는 자바스크립트 먼저이다. 실행순서 : 자바스크립트 HTML 제이쿼리 123456789101112131415161718&lt;script type=\"text/javascript\"&gt; //첫번째 제이쿼리사용방법 $(document).ready(function(){ alert(\"제이쿼리사용1\") }); //도큐먼트안의 ready()펑션을 실행 -&gt; 그 안에 실행문넣기 //두번째 제이쿼리사용방법 $(function(){ alert(\"제이쿼리사용2\") }); //세번째 제이쿼리사용방법 jQuery(document).ready(function(){ alert(\"제이쿼리사용3\") }); alert(\"자바스크립트 사용\")&lt;/script&gt; 제이쿼리 선택자 선택자 : 특정 동작이 적용될 대상 선택자 종류 : 직접선택자, 속성탐색선택자 직접선택자 전체 선택자종류 선택자 예시12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!-- 제이쿼리 라이브러리연결 --&gt;&lt;script type=\"text/javascript\" src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //자바스크립트 - 본문 실행전에 실행됨 $(function(){ //제이쿼리 - 본문 실행후에 실행됨 //대상.동작메서드(); //선택자 : //1. 직접선택자 : [*]-전체, [태그]-해당태그요소, [#id]-id요소만,[.class]-class요소 //* : 모든 요소(전체) $('*').css('color', 'green'); //태그 : 특정 태그만 $('h1').css('color', 'red'); //id값 : 특정 요소중 id값에 해당하는 요소만 $('#t1').css('color', 'red'); $('h1#t1').css('color', 'orange'); //명확하게 표시. 추천 //class값 : 특정 요소중 class값에 해당하는 요소만 $('.c1').css('color', 'blue'); //태그선택자임. //$('input').val('홍길동'); //2. 속성탐색 선택자 : 속성을 가지고 탐색해서 처리함 //요소[속성=값] //$('input[name=id]').val('홍길동'); //요소[속성^=값] : 해당 값으로 시작하는 요소를 찾아서 지정 $('input[name^=i]').val('홍'); $('input[type=password]').val('1234'); //요소[속성$=값] : 해당 값으로 끝나는 요소를 찾아서 지정 $('input[type$=t]').val('테스트'); $('input[name$=d]').val('테테'); //3. 위치 탐색 선택자 // 요소의 태그:first (첫번째) // 요소의 태그:last (마지막) $('tr:first').css('background', 'yellow'); $('tr:last').css('background', 'lightblue'); // 요소의 태그:odd (홀수) // 요소의 태그:even (짝수) // * 테이블 0번부터 시작 $('tr:odd').css('background', 'powderblue'); $('tr:even').css('background', 'aquamarine'); //코드가 순차적으로 진행되기때문에 첫번째선택요소를 위치변경해주면 된다. $('tr:first').css('background', 'yellow'); });&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;WebContent/jq/Test2.jsp&lt;/h2&gt;&lt;h1 id=\"t1\"&gt;제목1&lt;/h1&gt;&lt;h1 class=\"c1\"&gt;제목2&lt;/h1&gt;&lt;h1 class=\"c1\"&gt;제목3&lt;/h1&gt;&lt;h1&gt;제목4&lt;/h1&gt;&lt;hr&gt;내용&lt;hr&gt;아이디 : &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt;비밀번호 : &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt;&lt;hr&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;혈액형&lt;/td&gt; &lt;td&gt;지역&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;사용자1&lt;/td&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;부산&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;사용자2&lt;/td&gt;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;서울&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;사용자3&lt;/td&gt;&lt;td&gt;O&lt;/td&gt;&lt;td&gt;대구&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;사용자4&lt;/td&gt;&lt;td&gt;AB&lt;/td&gt;&lt;td&gt;제주&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 제이쿼리 css함수사용12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- 제이쿼리 라이브러리연결 --&gt;&lt;script type=\"text/javascript\" src=\"../js/jquery-3.5.1.min.js\"&gt; &lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function(){ //1. 태그의 속성값을 가져오기 //rgb(0,0,0)-검정 rgb(255,255,255)-흰색 let c1 = $('h2').css('color'); console.log(\"색상변경전 : \"+c1); //출력값 색상변경전 : rgb(0, 0, 0) //h2태그의 글자색 변경 //$('h2').css('color', 'dodgerBlue'); let c2 = $('h2').css('color'); console.log(\"색상변경후 : \"+c2); //출력값 색상변경후 : rgb(30, 144, 255) //2.index이용 : 같은 태그가 여러개면 내부적으로 요소를 구분할 수 있도록 index가 0부터 붙는다 //컬러 정보를 저장하는 배열 준비 let col = ['dodgerBlue', 'orange', 'darkgreen', 'tomato']; $('h2').css('color',function(index){ alert(index+\"!!!!\"); return col[index]; }) //3.한번에 속성 여러개 사용 =&gt; 중괄호사용해서 여러개 동시처리 $('h2').css({ color:'tomato', backgroundColor: \"gray\" }); //4. 속성을 한 번에 처리 : 글자색 - 검정, 배경색 - col배열사용해서 지정 $('h2').css({ color:'black', backgroundColor: function(index){return col[index]} }) });&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;WebContent/jq/Test3.jsp&lt;/h1&gt;&lt;h2&gt; head-0 &lt;/h2&gt;&lt;h2&gt; head-1 &lt;/h2&gt;&lt;h2&gt; head-2 &lt;/h2&gt;&lt;h2&gt; head-3 &lt;/h2&gt;&lt;h2&gt; head-4 &lt;/h2&gt;","link":"/2020/08/03/200804jspi2/"},{"title":"Ajax : Ajax특징, XMLHttpRequest클래스, txt 페이지 처리","text":"Ajax ( Asynchronous Javascript and Xml) 특징 비동기방식의 데이터 처리 빠른 페이지 구성을 하기 위해 구현된 기술 페이지 전체를 로드하지않고 페이지 일부부만 로드해서 처리가능하기때문에 빠르다. 백그라운드 영역에서 서버와 통신한 뒤 -&gt; 페이지 일부분에 표시한다. 처리할 수 있는 데이터 형태 : XML, HTML, TXT, JSON Ajax 프레임워크 : JQuery 프레임워크를 사용해서 주로 구현 장점 : 전체 데이터 로드 없이 일부분만 로드 가능. 페이지 로드 완료시에도 서버로 데이터전송/데이터받기 가능. 페이지가 깔끔해진다. 단점 : Ajax동작도 페이지 이동을 하는 것이므로 많으면 처리가 느려짐. 클라이언트풀링 방식 사용 : 클라이언트가 서버에 데이터를 요청하는 방식. 따라서 서버푸시방식의 실시간 데이터 처리는 불가능. 클라이언트풀링 : 사용자가 원하는 정보를 서버에 요청해서 해당정보를 받는 방식 서버푸시 : 사용자가 원하지않아도 서버가 자동으로 특정 정보를 제공하는 방식 바이너리데이터(이진데이터) 전달 불가. Ajax스크립트가 포함되어있지 않은 서버로 요청 보낼수없음. 클라이언트 로컬PC로 요청보낼 수 없음. 동기방식의 데이터처리 vs 비동기방식의 데이터처리동기방식 : 데이터를 전달/처리하기 위해선 페이지 이동이 필요하다 (화면전환발생) 페이지이동 하면서 서버갔다가 화면도 바뀜 서버에 신호를 보내고(요청) 응답을 받아야지만 데이터 처리가능 동기방식 :http 프로토콜은 기본적으로 클라이언트 쪽에서 request를 보내고 server의 response를 받으면 이어졌던 연결이 끊기게 설계가 되어 있습니다.그래서 화면의 내용을 갱신하기 위해서는 다시 request를 하고 response로 페이지 전체를 다시 받게 됩니다.하지만 페이지 내용을 일부만을 업데이트 하고자 하는데 페이지 전체를 다시 로드하게 된다면 자원 낭비겠죠?Ajax는 html페이지 전체가 아니라 필요한 부분만을 갱신할 수 있도록 XMLHttpRequset 객체를 통해서 요청합니다.Json이나 xml 형태로 최소한의 필요한 데이터만 받아서 갱신하게 됨으로 자원낭비가 그만큼 줄어들기에 더 나은 서비스를 구현할 수 있습니다출처 : Ajax란 무엇인가 비동기방식 : 데이터를 전달/처리하기 위해선 페이지 이동이 필요없음 (화면전환발생X) 페이지이동은 하면서 서버갔지만 화면이 바뀌지않음 서버에 신호를 보내고(요청) 응답결과와 상관없이 데이터 처리가능 XMLHttpRequest 객체 비동기방식으로 데이터 전송/수신 하는 객체 Ajax방식의 데이터처리를 하는 핵심 객체 대부분의 브라우저들이 지원하는 객체 (크롬 사파리 오페라, IE …) 참고링크 : MDN XMLHttpRequest.onreadystatechange 속성 이벤트 핸들러로 readyState 프로퍼티 전달함 통신상태가 변경될대마다 호출되는 이벤트핸들러 이 속성이 왜 필요할까? Ajax처리 방식은 서버의 응답시간을 알수 없기 때문에 서버의 응답을 처리해주는 이벤트 객체가 필요하기때문!. XMLHttpRequest.readyState 속성 http 통신 결과에 따라서 5가지 형태 결과 return 0 : 초기화가 안된 상태(open 메서드 호출 안 한 상태) return 1 : 로드 중(open메서드 호출O, send메서드호출X) return 2 : 로드 완료(open메서드 호출O, send메서드호출O, 응답status/header 미처리) return 3 : 일부 응답처리가 완료(응답status/header 처리O, 본문 미처리) return 4 : 모든 응답 처리 완료 XMLHttpRequest.status 속성 Http 통신의 상태를 표시하는 코드값 return 200 : OK (정상처리) return 401 : Unauthorized(인증 필요) return 403 : Forbidden(액세스 거부) return 404 : Not Found(페이지 요청 자원 없음) return 505 : Internal Server Error(서버 내부 에러) 참고링크1 : http 응답코드 참고링크2 : http 응답코드 XMLHttpRequest.responseText 속성 : 서버에 요청하여 응답으로 받은 데이터를 문자열로 반환합니다. XMLHttpRequest.open() : 메서드 처리방식(get/post), URL, 동기(false)/비동식(true) Ajax를 사용한 화면이동 방식 예시 : txt파일버튼을 하나 생성해서 버튼 클릭시 서버에 있는 특정 파일의 정보를 불러와서 원하는 위치에 화면 전환없이 내용을 추가해보기 임의의 sample.txt파일을 생성한다. Ajax코드를 작성할 html파일을 생성한다. 지역변수 선언 후 XMLHttpRequest객체생성함수 생성 서버를 통해서 데이터 가져오기 : 방식에 따른 open()과 send() 파라미터값 GET방식 : 주소줄에 파라미터값 가지고 이동 xhttp.open(“GET”,”URL?name=홍길동&amp;age=10”,true); xhttp.send(null); POST방식 : 본문에 파라미터값 가지고 이동 GET방식과 달리 한글이 깨질 수 있으므로 setRequestHeader()사용 xhttp.open(“POST”, “URL”, true); xhttp.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”); xhttp.send(“name=홍길동&amp;age=10”); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script type=\"text/javascript\"&gt;//비동기방식의 처리해야함 =&gt; XMLHttpRequest 객체 필요(Ajax처리, 데이터 송수신처리하는 객체)let xhttp; //1.지역변수 //2.XMLHttpRequest객체생성함수function createHttpRequest(){ xhttp = new XMLHttpRequest(); //변수에 객체생성 }function mySend(){ //3. createHttpRequest()함수 호출해서 XMLHttpRequest객체생성하기. createHttpRequest(); //4. 서버이 응답처리 : onreadystatechange 프로퍼티 //callFunc은 readyState상태값4, status값200일때 정상처리진행 xhttp.onreadystatechange = callFunc; //6.원하는 파일을 읽어서 데이터 처리 : open() //open() 이 끝이 아니라 send()로 실제 페이지 요청해야함 //6-1.get방식 //send가 null인 이유는 get방식이기때문 xhttp.open(\"GET\",\"URL?name=홍길동&amp;age=10\",true); xhttp.send(null); //6-2.post방식 xhttp.open(\"POST\", \"URL\", true); xhttp.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); xhttp.send(\"name=홍길동&amp;age=10\"); }//mySend함수닫음//5.서버와 클라이언트간의 통신을 완료한 시점을 결정하는 함수function callFunc(){ //5-1. onreadystatechange 리턴값 4 &amp;&amp; 상태정보(status) 200일때 해당 //sample.txt파일을 읽어와서 태그에 내용을 추가 //5-2.응답데이터형식은 responseText 프로터티를 사용해서 일반 텍스트 파일의 값을 읽어오기 if(xhttp.readyState == 4){ if(xhttp.status == 200){ var responseData = xhttp.responseText; //5-3.div태그에 전달받은 값추가 document.getElementById(\"result\").innerHTML = responseData; } }}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 버튼을 하나 생성해서 버튼 클릭시 서버에 있는 특정 파일의 정보를 불러와서 원하는 위치에 내용을 추가해보기 (화면 전환 X) --&gt;&lt;input type=\"button\" value=\"파일 가져오기\" onclick=\"mySend()\"&gt;&lt;div id=\"result\"&gt;&lt;/div&gt; Ajax를 사용한 화면이동 방식 예시Ajax를 사용한 화면이동방식이 복잡하때문에 JQuery로 조금은 간단하게 나타낼 수 있다. 사용형태 : $.ajax(‘주소’, 옵션); $.ajax(옵션); 주로 이걸 사용함 형태 예시 : 1234567891011121314151617181920212223//1번방법 예시$.ajax('string1.jsp',{ success : function(data){ //alert(\"jsp페이지에서 갔다가 돌아옴 = 성공\") //data라는 매개변수안에 string1.jsp정보를 다 가져온다 //alert(data); //string1.jsp페이지에서 가져온 정보들 본문 body에 추가하기 $('body').append(data); }})//ajax닫음 //2번방법 기본형$.ajax({url:\" 이동할 페이지 \",type:\" 전송방식(GET/POST)\",data:\" 전송할 데이터\",dataType:\" 요청한 데이터 타입 (주로 html, xml, text, json)\",success:function(data){ 데이터 전송 성공시 실행할 코드(즉 페이지 이동하고 돌아왔을때 실핼할 코드)},error:function(){ 데이터 전송 실패시 실행할 코드(주로 alert확인)} 아래는 ajax()사용해서(비동기방식) string1.jsp페이지 정보 불러오기예제이다. 임의의 데이터를 불러올 string1.jsp페이지생성 string1.html페이지생성하여 제이쿼리 작성할 준비하기 $.ajax(‘주소’, 옵션)방식으로 비동기페이지 처리하기 $.ajax(옵션)방식으로 비동기페이지 처리하기 12345678910111213141516171819202122232425262728293031323334353637&lt;script src=\"../js/jquery-3.5.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" &gt;$(document).ready(function(){ //ajax()사용해서(비동기방식) string1.jsp페이지 정보 불러오기 //3. $.ajax('주소', 옵션); $.ajax('string1.jsp',{ success : function(data){ //alert(\"jsp페이지에서 갔다가 돌아옴 = 성공\") //3-1. data라는 매개변수안에 string1.jsp정보를 다 가져온다 //alert(data); //3-2. string1.jsp페이지에서 가져온 정보들 본문 body에 추가하기 $('body').append(data); } })//ajax닫음 //4. $.ajax(옵션); let id = \"admin\"; $.ajax({ url:\"string1.jsp\", type:\"POST\", data: {name: id+\"재무팀\"}, dataType:\"text\", success:function(data){ $('body').append(data); }, error:function(){ alert(\"비동기 데이터처리 실패\") } })//에이젝스닫음 });//제이쿼리닫음&lt;/script&gt;&lt;/head&gt;&lt;body&gt;여긴 html페이지.&lt;img src=\"../jq/4.jpg\" width=\"200\"&gt;&lt;/body&gt;","link":"/2020/08/06/200807jspi2/"},{"title":"JSTL과 EL : CORE 라이브러리(set), 페이지실행순서","text":"CORE 라이브러리 변수선언, 조건문, 반복문 처리 가능 페이지 이동처리 가능 페이지실행순서 JSP(JAVA) -&gt; JSTL -&gt; HTML -&gt; Javascript -&gt; JQuery 순서 차이? Javascript -&gt; HTML -&gt; JQuery HTML -&gt; Javascript -&gt; JQuery 가 기본순서이고 구동방식에 따라 Javascript -&gt; HTML -&gt; JQuery 처럼 순서가 변경될수도있다. 기본순서를 외워두자. JSTL에서는 JS값을 받아올 수 있을까? NOPE! JS에서는 JSTL값을 사용할 수 있을까? YES! set 태그 변수선언 123456789101112131415&lt;h2&gt;JSTL 사용 변수 선언&lt;/h2&gt;&lt;!-- 변수를 가져와서 연산처리하고 출력할때 EL표현식 사용해야함 --&gt;&lt;!-- EL로 표현하지 않으면 인용부호 에러가 난다 --&gt;&lt;c:set var=\"num3\" value=\"30\"/&gt;&lt;c:set var=\"num4\" value=\"40\"/&gt;&lt;c:set var=\"result\" value=\"${num3+num4}\" /&gt;&lt;c:out value=\"${result}\"/&gt;&lt;br&gt;//출력값30JSTL 사용 변수 선언70HTML: 30 + 40 = 70JSTL: 30 + 40 = 70JSTL: 30 + 40 = 70 변수를 가지고 페이지를 이동하기 기존방식 : request 영역에 저장된 값을 받아서 출력 변수값을 일일히 저장하지 않더라고 출력할 수 없을까? JSTL사용해서 다른페이지 변수를 값을 받지않아도 바로 출력가능! HOW? EL태그안에는 requestScope.name사용하면 됨! requestScope : EL표현식에서 사용하는 내장객체 JSTL 사용해서 변수 선언시 특정 영역을 지정 가능 페이지를 두 개를 생성한다. set1.jsp와 set2.jsp 페이지 이동시 데이터를 request 영역에 저장된 값을 받는 것 대신 그냥 바로 출력하는 방법 페이지 이동시 jsp:forward 액션태그사용 스코프 12345678910111213141516171819202122&lt;%//기존방식 : request 영역에 저장된 값을 받아서 출력String name = (String)request.getAttribute(\"name\");//다운캐스팅%&gt;&lt;h2&gt; set1.jsp 에서 전달된 name : &lt;%=name %&gt;&lt;/h2&gt;&lt;!-- 변수값을 일일히 저장하지 않더라고 출력할 수 없을까? JSTL사용해서 다른페이지 변수를 값을 받지않아도 바로 출력가능 HOW? el태그안에는 requestScope.name사용하면 됨! requestScope는 el표현식에서 사용하는 내장객체 아래 두 코드는 동일한 결과값을 나타내는 동일한 코드이다.--&gt;&lt;h1&gt;여기는 set2.jsp&lt;/h1&gt;&lt;h2&gt;변수 가져와서 출력&lt;/h2&gt;&lt;h3&gt;이름 : ${name }&lt;/h3&gt;&lt;h3&gt;이름 : ${requestScope.name }&lt;/h3&gt;//출력값여기는 set2.jsp변수 가져와서 출력이름 : 아이티윌이름 : 아이티윌 객체를 가지고 페이지이동하기set2.jsp페이지 생성 객체를 가지고 페이지 이동시 데이터를 표시한 페이지를 생성한다. 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!--2-1.태그라이브러리추가 --&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;객체정보 가져와서 출력&lt;/h2&gt;&lt;!-- 2.JSTL 사용 변수에 저장후 호출 2-2. 태그라이브러리 출력방식 --&gt;&lt;c:set var=\"itwill\" value=\"${requestScope.ib }\" /&gt;&lt;h3&gt;이름 : ${itwill.name }&lt;/h3&gt;&lt;h3&gt;나이 : ${itwill.age }&lt;/h3&gt;&lt;h3&gt;연락처 : ${itwill.tel }&lt;/h3&gt;&lt;/body&gt;//출력값객체정보 가져와서 출력ID : 고양이PW : cat이름 : 고영희나이 : 10연락처 : 010-1 ItwillBean.java 자바빈객체생성12345678910111213141516171819202122public class ItwillBean { private String id; private String pw; private String name; private int age; private String tel; public String getId() { return id; } public void setId(String id) { this.id = id; } (생략) @Override public String toString() { return \"ItwillBean [id=\" + id + \", pw=\" + pw + \", name=\" + name + \", age=\" + age + \", tel=\" + tel + \"]\"; }} ItwillServlet.java 생성 ItwillServlet에 HttpServlet에 extends(상속)한다. 자바코드는 웹페이지에서 볼수없고 콘솔에서만 볼 수 있다. 이때 HttpServlet를 상속함으로써 웹페이지에서 java코드를 볼 수 있다. 웹페이지 처리를 위해 doGet() 오버라이딩 (alt + shift + s + v) doGet(): 페이지 처리방식이 GET방식일 때 사용 doPost(): 페이지 처리방식이 POST방식일 때 사용 @WebServlet 어노테이션 추가 @WebServlet(“주소”): 클래스에 접근가능한 주소를 지정. itwill 주소 입력시 – forward –&gt; set2.jsp화면 출력하기 forward는 jsp액션태그이다. jsp:forward태그를 java에서 사용하려면 어떻게 해야할까? RequestDispatcher 객체사용! RequestDispatcher는 포워딩 처리가능한 객체 request내장객체로부터 전달받아서 사용 정보를 저장해서 set2.jsp로 이동 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.itwill.ex;import java.io.IOException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//3. @WebServlet 어노테이션 추가 -&gt; 실행 -&gt; 404페이지가 안뜨고 성공적@WebServlet(\"/itwill\")public class ItwillServlet extends HttpServlet { //1. 웹페이지 처리를 위해 오버라이딩 alt + shift + s + v @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //2. 화면출력 -&gt; 404에러 -&gt; 해결방법은 3번 System.out.println(\"doGet() 호출\"); //5. 객체정보를 저장해서 set2.jsp로 이동 //5-1.변수사용해서 저장 request.setAttribute(\"name\", \"아이티윌\"); //5-2.객체사용해서저장(ItwillBean 객체 생성 후 전달) ItwillBean ib = new ItwillBean(); //객체에 정보가 없으니 정보를 객체에 저장 ib.setId(\"고양이\"); ib.setPw(\"cat\"); ib.setAge(10); ib.setTel(\"010-1\"); ib.setName(\"고영희\"); //객체정보 request로 전달 request.setAttribute(\"ib\", ib); //4. itwill 주소 입력시 -- forward --&gt; set2.jsp화면 출력하기 //&lt;jsp:forward&gt;태그를 java에서 사용하려면 어떻게 해야할까? =&gt; RequestDispatcher 객체사용. //request내장객체로부터 전달받아서 사용 //4-1.request내장객체로부터 전달 RequestDispatcher dis = request.getRequestDispatcher(\"/core/set2.jsp\"); //4-2.포워딩 dis.forward(request, response); } } 객체 여러개(리스트계열)를 가지고 페이지이동하기set2.jsp페이지 생성1234567891011121314151617181920&lt;h2&gt;벡터에 저장된 정보를 가져와서 출력&lt;/h2&gt;&lt;h3&gt;ID : ${requestScope.vec[0].id }, ${requestScope.vec[1].id }&lt;/h3&gt;&lt;h3&gt;PW : ${vec[0].pw }, ${vec[1].pw }&lt;/h3&gt;&lt;!-- 벡터 전체 저장 --&gt;&lt;c:set var=\"v\" value=\"${requestScope.vec }\" /&gt;&lt;h3&gt;이름 : ${v[0].name }, ${v[1].name }&lt;/h3&gt;&lt;h3&gt;나이 : ${v[0].age }, ${v[1].age }&lt;/h3&gt;&lt;!-- 벡터의 0번만 저장 --&gt;&lt;c:set var=\"v0\" value=\"${requestScope.vec[0] }\" /&gt;&lt;h3&gt;연락처 : ${v0.tel }&lt;/h3&gt;//출력값벡터에 저장된 정보를 가져와서 출력ID : 고양이, 강아지PW : cat, dog이름 : 고영희, 강하지나이 : 10, 100연락처 : 010-1 ItwillBean.java 자바빈객체생성위의 4-2와 동일하므로 코드생략 ItwillServlet.java 생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546//3. @WebServlet 어노테이션 추가 -&gt; 실행 -&gt; 404페이지가 안뜨고 성공적@WebServlet(\"/itwill\")public class ItwillServlet extends HttpServlet { //1. 웹페이지 처리를 위해 오버라이딩 alt + shift + s + v @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //2. 화면출력 -&gt; 404에러 -&gt; 해결방법은 3번 System.out.println(\"doGet() 호출\"); //5. 객체정보를 저장해서 set2.jsp로 이동 //5-1. 첫번째 객체 생성 ItwillBean ib = new ItwillBean(); ib.setId(\"고양이\"); ib.setPw(\"cat\"); ib.setAge(10); ib.setTel(\"010-1\"); ib.setName(\"고영희\"); //5-2. 두번째 객체 생성 ItwillBean ib2 = new ItwillBean(); //객체에 정보가 없으니 정보를 객체에 저장 ib2.setId(\"강아지\"); ib2.setPw(\"dog\"); ib2.setAge(100); ib2.setTel(\"011-111\"); ib2.setName(\"강하지\"); //6.List 컬렉션 사용 : vector객체 Vector vec = new Vector(); vec.add(ib); //백터에 ib객체 담음 vec.add(ib2); //백터에 ib2객체 담음 //6-1순서 : 배열에서 객체를 꺼내고 &gt; requestScope이용해서 객체안의 데이터 꺼내고 &gt; set2.jsp페이지에 출력 request.setAttribute(\"vec\", vec); System.out.println(\"벡터저장완료\"); //4. itwill 주소 입력시 -- forward --&gt; set2.jsp화면 출력하기 //&lt;jsp:forward&gt;태그를 java에서 사용하려면 어떻게 해야할까? =&gt; RequestDispatcher 객체사용. //request내장객체로부터 전달받아서 사용 //4-1. request내장객체로부터 전달 RequestDispatcher dis = request.getRequestDispatcher(\"/core/set2.jsp\"); //4-2포워딩 System.out.println(\"/core/set2.jsp로 포워딩완료\"); dis.forward(request, response); } 특정영역에 저장된 값 삭제 : &lt;c:remove /&gt; &lt;c:remove /&gt; : 사용해서 값 삭제 set2.jsp페이지에서 처리 123&lt;!-- request 영역에 있는 name값을 삭제 --&gt;&lt;c:remove var=\"name\" scope=\"request\"/&gt;&lt;h3&gt;이름 : ${name }&lt;/h3&gt;","link":"/2020/08/10/200811jspi2/"},{"title":"컬렉션 프레임워크2: Map계열 자세히, 예시","text":"Collections 프레임워크 컬렉션 프레임워크: java.util에 있는 클래스들로 자료구조를 담당한다. 자료구조: 대량의 데이터를 효율적으로 이용할 수 있도록 컴퓨터에서 데이터를 추가,조회,수정,삭제(CRUD)하는 방식. 자료구조 개념1 : Collections Framwork(Set계열, List계열) 자료구조 개념2 : Stack클래스, Queue인터페이스, Map인터페이스 개념은 위의 링크로 대체하고 이 글에서는 응용이나 예시위주로 확인해보려고한다. Map계열 Map&lt;K,V&gt;는 컬렉션 프레임워크에 포함되어있지만 Collections을 상속받지 않는다. 따라서 Collections 메서드를 사용할 수없고 고유의 메서드가 있다. Map, table 접미어가 붙은 자료구조이다. Map&lt;K,V&gt;는 키와 벨류를 의미하며 데이터저장시 (키, 데이터)쌍으로 저장하여 사용하는 구조 key 중복 불가 value 중복 가능 Entity를 추가할때 key가 중복디면 기존값을 덮어써버린다. 즉 추가와 수정메서드가 동일하다 Entry&lt;K,V&gt;타입은 key와 value를 쌍으로 가진 타입이다. map은 인터페이스이므로 객체생성을 할수없지만 구현을 통해서 생성가능하다 가장 많이 사용하는 구현체 : HashMap&lt;K,V&gt; Hashtable&lt;K,V&gt; 클래스 : 맵인터페이스를 구현한 클래스. 멀티스레드에 안전하지만 성능은 좋지 않은 과거버전이다. Hashtable&lt;K,V&gt;보다 HashMap&lt;K,V&gt;을 사용하자 장점 : 키값을 사용해서 검색 인덱스생성 -&gt; 데이터 검색시간이 짧음. HashMap&lt;K,V&gt; 전화번호 관리 어플리케이션 예시 HashMap&lt;K,V&gt; 특징 순서가 없음 default정렬기준은 키값 아래 예시는 가장 많이 사용하는 방식으로 꼭 암기할 것. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class HashMapTest { Map&lt;String, String&gt; hMap = new HashMap&lt;&gt;(); private void addMethod(){ System.out.println(\"추가 결과 확인: \"+hMap.put(\"강대표\", \"1234\")); System.out.println(\"추가 결과 확인: \"+hMap.put(\"서회장\", \"4567\")); hMap.put(\"하지\", \"4567\"); hMap.put(\"우나\", \"9999\"); } private void retreveMethod(){ System.out.println(\"총 entity 개수: \"+hMap.size()); Set&lt;String&gt; keys = hMap.keySet(); for(String key : keys){ System.out.println(\"키: \"+key+\"값: \"+hMap.get(key)); } String targetNumber = \"4567\"; Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hMap.entrySet(); for(Map.Entry&lt;String, String&gt; entry : entrySet){ if(entry.getValue().equals(targetNumber)){ System.out.println(\"번호가 \"+targetNumber+\"인 사람: \"+entry.getKey()); } } System.out.println(\"휘슬의 전화번호가 있는가? \"+hMap.containsKey(\"휘슬\")); } private void removeMethod(){ hMap.remove(\"하지\"); System.out.println(hMap); } public static void main(String[] args) { HashMapTest hmt = new HashMapTest(); hmt.addMethod(); System.out.println(hmt); hmt.retreveMethod(); hmt.removeMethod(); }}//출력값추가 결과 확인: null추가 결과 확인: null총 entity 개수: 4키: 우나, 값: 9999키: 하지, 값: 4567키: 서회장, 값: 4567키: 강대표, 값: 1234번호가 4567인 사람: 하지번호가 4567인 사람: 서회장휘슬의 전화번호가 있는가? false{우나=9999, 서회장=4567, 강대표=1234} TreeMap&lt;K,V&gt; 개념과 그룹화와 정렬예시 Map계열에도 Set계열처럼 정렬이 지원되는 TreeMap&lt;K,V&gt;가 존재한다. Key값을 이용해 내부에 저장된 Entry들을 정렬시킨다. 정렬방식 : TreeSet과 동일. 123456789101112131415161718192021222324252627282930public class TreeMapTest { private static Map&lt;String, String&gt; initMap(Map&lt;String, String&gt; map){ map.put(\"떡볶이\", \"4000원\"); map.put(\"순대\", \"4000원\"); map.put(\"만두튀김\", \"500원\"); map.put(\"야채튀김\", \"500원\"); return map; } public static void main(String[] args) { Map&lt;String, String&gt; map = initMap(new HashMap&lt;&gt;()); System.out.println(\"HashMap의 정렬 상태1: \"+map); Map&lt;String, String&gt; tmap = initMap(new TreeMap&lt;&gt;()); System.out.println(\"TreeMap의 정렬 상태2: \"+tmap); if(tmap instanceof NavigableMap&lt;?, ?&gt;){ NavigableMap&lt;String, String&gt; navMap = (NavigableMap&lt;String, String&gt;) tmap; System.out.println(\"Nav맵의 맨 처음 요소: \"+navMap.firstEntry()); System.out.println(\"Nav맵의 내림차순 정렬: \"+navMap.descendingMap()); } Map&lt;String, String&gt; tmap2 = initMap(new TreeMap&lt;&gt;(new StringLengthComparator())); System.out.println(\"TreeMap글자길이 정렬 상태3: \"+tmap2); }}//출력값HashMap의 정렬 상태1: {만두튀김=500원, 야채튀김=500원, 순대=4000원, 떡볶이=4000원}TreeMap의 정렬 상태2: {떡볶이=4000원, 만두튀김=500원, 순대=4000원, 야채튀김=500원}Nav맵의 맨 처음 요소: 떡볶이=4000원Nav맵의 내림차순 정렬: {야채튀김=500원, 순대=4000원, 만두튀김=500원, 떡볶이=4000원}맵의 정렬 상태3: {순대=4000원, 떡볶이=4000원, 만두튀김=500원} HashMap&lt;K,V&gt; 로또게임 예시 고급스러운 예시를 보자. 100만 번 랜덤한 숫자를 발생시킨 후 뽑힌번호를 키로, 빈도수를 값으로 Map&lt;K,V&gt;에 저장해놓고 빈도수를 기준으로 상위1~6번까지 뽑힌번호를 당첨번호, 보너스는 7번째번호를 출력하는 로또게임 예시 compare() : Entry&lt;K,v&gt;를 정렬하기 위해 Comparator&lt;&gt;를 사용. 1차 정렬 : 값을 사용하고 내림차순을 위해 -1 곱함 2차 정렬 : 만약 1차정렬에서 동일한 값이 나온 경우 key를 이용하고 내림차순을 위해 -1 곱함. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class LottoEntryComparator implements Comparator&lt;Entry&lt;Integer, Integer&gt;&gt; { @Override public int compare(Entry&lt;Integer, Integer&gt; arg0, Entry&lt;Integer, Integer&gt; arg1) { int result = arg0.getValue().compareTo(arg1.getValue()) * -1; if(result == 0){ //1차정렬값이 동일한 경우 result = arg0.getKey().compareTo(arg1.getKey()) * -1; } return result; }}public class MapLottoTest { public static void main(String[] args) { Map&lt;Integer, Integer&gt; lottoMap = new HashMap&lt;&gt;(); Random rd = new Random(); for(int i=0; i&lt;100000; i++){ int num = rd.nextInt(45)+1; //1부터 46까지의 숫자 if(lottoMap.containsKey(num)){ lottoMap.put(num, lottoMap.get(num)+1); }else{ lottoMap.put(num, 1); } } sortLottoByV(lottoMap); } public static void sortLottoByV(Map&lt;Integer, Integer&gt; map){ TreeSet&lt;Map.Entry&lt;Integer, Integer&gt;&gt; sortedEntries = new TreeSet&lt;&gt;(new LottoEntryComparator()); sortedEntries.addAll(map.entrySet()); String pattern = \"{0}번호: {1}\\t(총 누적:{2})\"; for (int i=0; i&lt;7; i++){ Entry&lt;Integer, Integer&gt; first = sortedEntries.pollFirst(); String msg = null; if(i == 6){ msg = MessageFormat.format(pattern, \"보너스\", first.getKey(), first.getValue()); }else{ msg = MessageFormat.format(pattern, \"당첨\", first.getKey(), first.getValue()); } System.out.println(msg); } }}//출력값당첨번호: 38 (총 누적:2,336)당첨번호: 1 (총 누적:2,328)당첨번호: 5 (총 누적:2,321)당첨번호: 28 (총 누적:2,316)당첨번호: 29 (총 누적:2,292)당첨번호: 27 (총 누적:2,283)보너스번호: 45 (총 누적:2,268) Properties&lt;K,V&gt; 어플리케이션의 환경 설정 파일에 데이터를 읽고 쓰는 기능 일반적으로 확장자를 .properties로 작성. Entry형태로 값을 여러개 저장 가능. 예제 : 속성저장하고 읽기. 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PropertiesTestWithFile { private final static String PROP_FILE_PATH=\"./config.properties\"; private static void saveToFile(){ Properties props = new Properties(); props.setProperty(\"id\", \"joji_K\"); props.setProperty(\"pw\", \"1234\"); props.setProperty(\"addr\", \"192.168.0.2\"); props.setProperty(\"이름\", \"민지\"); System.out.println(\"속성확인: \"+props); try(FileWriter output = new FileWriter(PROP_FILE_PATH)){ props.store(output, \"System Config\"); }catch(Exception e){ e.printStackTrace(); } } private static void loadFromFile(){ Properties props = new Properties(); try(FileReader input = new FileReader(PROP_FILE_PATH)){ props.load(input); Set&lt;String&gt; keys = props.stringPropertyNames(); for(String key:keys){ System.out.println(key+\" : \"+props.getProperty(key)); } }catch(Exception e){ e.printStackTrace(); } } public static void main(String[] args) { saveToFile(); loadFromFile(); }}//출력값속성확인: {이름=민지, pw=1234, addr=192.168.0.2, id=joji_K}이름 : 민지pw : 1234addr : 192.168.0.2id : joji_K 동일한 프로젝트안에 config.properties파일명으로 properties파일이 생성된 것을 확인할 수 있다.","link":"/2020/08/12/200813javai/"},{"title":"EL과 Servlet : RequestDispatcher.forward 로 페이지 이동 후 데이터별 출력방법","text":"Servlet .java파일을 서블릿을 통해서 html처럼 나타낼 수 있다. 설정방법 web.xml 파일에 코드 추가 TestServlet.java 생성 : java페이지를 실행하면 jsp페이지가 출력된다. AttributeTest.jsp생성 forward 페이지이동예시1 : web.xml + 기본속성출력web.xml 파일에 코드 추가1234567891011121314151617181920//기본형&lt;servlet&gt; &lt;servlet-name&gt;서블릿이름(적당한 이름으로 내가 지정)&lt;/servlet-name&gt; &lt;servlet-class&gt;서블릿 클래스 위치(java 패키지이름까지 함께 작성)&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;위와 동일한 서블릿이름&lt;/servlet-name&gt; &lt;url-pattern&gt;접근할 주소이름&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;//예시&lt;servlet&gt; &lt;servlet-name&gt;test&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itwill.ex.TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;test&lt;/servlet-name&gt; &lt;url-pattern&gt;/test.com&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt; TestServlet.java 생성 화면에 텍스트도 출력해보자. 1234567891011121314151617181920public class TestServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //페이지 요청시 GET방식일때 처리 되는 메서드 System.out.println(\"doGet() 호출\"); //화면에 텍스트를 출력해보기 PrintWriter pr = response.getWriter(); pr.write(\"&lt;html&gt;\"); pr.write(\"&lt;head&gt;\"); pr.write(\"&lt;/head&gt;\"); pr.write(\"&lt;body&gt;\"); pr.write(\"&lt;h1&gt; Hi This is Servlet Test.&lt;/h1&gt;\"); pr.write(\"&lt;/body&gt;\"); pr.write(\"&lt;/html&gt;\"); pr.close();} AttributeTest.jsp 생성 EL태그 사용 주소는 내가 설정한 test.com인데 화면은 jsp가 출력된다. 12345678910111213141516171819202122232425262728293031&lt;%//int cnt = (int)request.getAttribute(\"cnt\");//Integer cnt = (Integer)request.getAttribute(\"cnt\");int cnt = 1000;%&gt;&lt;h2&gt;1. 스크립트 엘리먼트 (변수라고 부름) &lt;/h2&gt;전달값 : &lt;%=cnt +100%&gt;&lt;br&gt;&lt;h2&gt;2. EL 표현식 사용 cnt값 출력 (속성-attribute라고 부름) &lt;/h2&gt;${ requestScope.cnt+100 }&lt;br&gt; &lt;!-- requestScope생략가능 --&gt;${ cnt+100 } &lt;br&gt;&lt;h2&gt;4. requestScope(영역의 표시)없을경우 어떤 순서로 처리되는가? &lt;/h2&gt;&lt;!-- 왜 생략이 가능할까? 생략되면 어떤 방식으로 구동할까? 영역의 표시가 생략되거나 지정하지 않은 경우 모든 영역을 순차적으로 돌아다니면서 검색한다.영역의 크기가 작은순부터 : pageScope &gt; requestScope &gt; sessionScope &gt; applicationScope즉 pageScope에서 검색하여 있으면 찾아와서쓰고 없으면 requestScope 검색하여 영역모두에서 찾기를 반복한다중요 : 이전 영역에서 해당 값을 발견한 경우 다음 영역의 값을 사용할 수 없음.--&gt;session: ${sessionScope.cnt+100 }&lt;br&gt;//출력값1. 스크립트 엘리먼트 (변수라고 부름)전달값 : 11002. EL 표현식 사용 cnt값 출력 (속성-attribute라고 부름)10011004. requestScope(영역의 표시)없을경우 어떤 순서로 처리되는가?session: 1100 forward 페이지이동예시2 : web.xml + 객체출력web.xml에 mapping추가12345678 &lt;servlet&gt; &lt;servlet-name&gt;test2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itwill.ex.TestServlet2&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;test2&lt;/servlet-name&gt; &lt;url-pattern&gt;/test2.com&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; TestServlet2.java 생성123456789101112131415161718192021222324252627public class TestServlet2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"TestServlet2 doGet()호출\"); //3.ItwillBean 객체 생성 후 정보 저장 -&gt; request영역에 저장 (객체전달하는 경우) //3-1.객체생성 ItwillBean ib = new ItwillBean(); ib.setId(\"admin\"); ib.setPw(\"1234\"); ib.setName(\"관리자\"); ib.setAge(20); ib.setTel(\"010-1234-5678\"); //3-2. request영역에 저장 request.setAttribute(\"itBean\", ib); //4. ItwillUser 사용자 객체생성 (객체안의 객체까지 전달하는 경우) ItwillUser kim = new ItwillUser(\"김학생\", 22, new Phone(\"노트20\", \"010-4567-4567\")); request.setAttribute(\"kim\", kim); //2. BeanTest.jsp페이지생성 : forward사옹해서 이동 RequestDispatcher dis = request.getRequestDispatcher(\"./EL/BeanTest.jsp\"); dis.forward(request, response); }} BeanTest.jsp 생성12345678910111213141516171819202122232425&lt;h3&gt;TestServlet2에서 전달받은 객체 정보 출력&lt;/h3&gt;아이디 : ${requestScope.itBean.id} &lt;br&gt;이름 : ${requestScope.itBean.name} &lt;br&gt;비밀번호 : ${itBean.pw} &lt;br&gt;나이 : ${itBean.age} &lt;br&gt;전화번호 : ${itBean.tel} &lt;br&gt;&lt;h3&gt;TestServlet2에서 전달받은 객체의 객체 정보 출력&lt;/h3&gt;이름 : ${ requestScope.kim.name }&lt;br&gt;나이 : ${ requestScope.kim.age }&lt;br&gt;전화번호 : ${ requestScope.kim.note20.tel }&lt;br&gt;모델 : ${kim.note20.model }&lt;br&gt;//출력값TestServlet2에서 전달받은 객체 정보 출력아이디 : admin이름 : 관리자비밀번호 : 1234나이 : 20전화번호 : 010-1234-5678TestServlet2에서 전달받은 객체의 객체 정보 출력이름 : 김학생나이 : 22전화번호 : 010-4567-4567모델 : 노트20 forward 페이지이동예시3 : @WebServlet(&quot;/경로&quot;) + 배열, 컬랙션출력TestServlet3.java파일 생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.itwill.ex;import java.io.IOException;import java.util.ArrayList;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//1. @WebServlet(주소)어노테이션 - 특수한 기능 가짐 : 해당 클래스가 서블릿처럼 사용되도록 지정.//web.xml파일에 매핑해썬 정보 없이 바로 지정한 주소로 접근 가능//web.xml에서 아래코드를 지정해줄 필요가 없다/*&lt;servlet&gt;&lt;servlet-name&gt;test3&lt;/servlet-name&gt;&lt;servlet-class&gt;com.itwill.ex.TestServlet3&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;test3&lt;/servlet-name&gt;&lt;url-pattern&gt;/test3.com&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;*/@WebServlet(\"/test3\")public class TestServlet3 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"/test3 주소호출\"); //3.배열 데이터 array_collection페이지로 넘기기 String[] Food = {\"순대\", \"떡볶이\", \"대패삼겹살\", \"오리고기\"}; //3-1.request영역에 배열 Food를 저장 // req.setAttribute(키값, 데이터값); req.setAttribute(\"food\", Food); //4.컬렉션 데이터 array_collection페이지로 넘기기 ArrayList&lt;String&gt; movie = new ArrayList&lt;String&gt;(); movie.add(\"작은아씨들\"); movie.add(\"겨울왕국\"); movie.add(\"우리집\"); movie.add(\"벌새\"); req.setAttribute(\"movie\", movie); //2. 화면 페이지 array_collection.jsp로 forward 사용하여 페이지 이동 RequestDispatcher dis = req.getRequestDispatcher(\"/EL/array_collection.jsp\"); dis.forward(req, resp); }} array_collection.jsp 생성해서 배열출력array_collection.jsp는 TestServlet3.java에서 부터 페이지 이동해서 TestServlet3.java의 데이터를 출력할 페이지. 12345678910111213141516171819202122232425262728293031323334353637383940//배열 출력방법4-1. core 라이브러리추가&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;body&gt;&lt;h2&gt;TestServlet3.java에서 전달받은 음식정보ArrayList출력&lt;/h2&gt;&lt;!-- 배열 출력방법1. 자바코드 --&gt;&lt;%String[] food = (String[]) request.getAttribute(\"food\"); //다운캐스팅//1-1.Arrays.toString()out.print(Arrays.toString(food));//1-2 for each구문for(String s : food){ out.print(\" \"+s);}%&gt;&lt;hr&gt;&lt;!-- 배열 출력방법2. jsp표현식 --&gt;&lt;%=food[0] %&gt;&lt;%=food[1] %&gt;&lt;hr&gt;&lt;!-- 배열 출력방법3. EL표현식 --&gt;${requestScope.food[2] }${ food[3] }&lt;hr&gt;&lt;!-- 배열 출력방법4. jstl반복문사용 -:taglib core라이브러리추가 --&gt;&lt;c:forEach var=\"f\" items=\"${food }\"&gt; ${f }&lt;br&gt;&lt;/c:forEach&gt;//출력값[순대, 떡볶이, 대패삼겹살, 오리고기] 순대 떡볶이 대패삼겹살 오리고기순대 떡볶이대패삼겹살 오리고기순대떡볶이대패삼겹살오리고기 array_collection.jsp 생성해서 컬렉션출력123456789101112131415161718192021222324252627282930313233343536&lt;!-- 컬렉션 출력방법1. 자바코드 --&gt;&lt;%ArrayList&lt;String&gt; movie = (ArrayList&lt;String&gt;) request.getAttribute(\"movie\");for(String m : movie){ out.print(\"movie : \"+m+\"&lt;br&gt;\");}%&gt;&lt;hr&gt;&lt;!-- 컬렉션 출력방법2. jsp표현식 --&gt;&lt;%-- &lt;%=movie[0] %&gt; 이건 배열이고 ArrayList는 get을 쓴다--%&gt;&lt;%=movie.get(0) %&gt;&lt;%=movie.get(1) %&gt;&lt;hr&gt;&lt;!-- 컬렉션 출력방법3. EL표현식 --&gt;${requestScope.movie[2] }${requestScope.movie[3] }&lt;hr&gt;&lt;!-- 컬렉션 출력방법4. jstl반복문사용 -:taglib core라이브러리추가 --&gt;&lt;c:forEach var=\"m\" items=\"${movie }\"&gt; ${m }&lt;br&gt;&lt;/c:forEach&gt;//출력값movie : 작은아씨들movie : 겨울왕국movie : 우리집movie : 벌새작은아씨들 겨울왕국우리집 벌새작은아씨들겨울왕국우리집벌새","link":"/2020/08/13/200814jspi2/"},{"title":"Servlet쇼핑몰3: 로그인","text":"loginForm.jsp 생성 모든 페이지이동은 가상주소를 이용하여 이동 =&gt; 이것이 모델2방식 123456789101112&lt;!-- .me가 가상경로이기때문에 ../style.css가 아닌 ./style.css(./의 의미는 루트)가 되어야한다 --&gt;&lt;link href=\"./style.css\" rel=\"stylesheet\" /&gt;&lt;fieldset&gt;&lt;legend&gt;로그인&lt;/legend&gt; &lt;form action=\"./MemberLoginAction.me\" method=\"post\" name=\"fr\"&gt; 아이디 &lt;input type=\"text\" name=\"id\" required &gt;&lt;br&gt; 비밀번호 &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"로그인하기\"&gt; &lt;input type=\"button\" value=\"회원가입하기\" onclick=\"location.href='./MemberJoin.me'\"&gt; &lt;/form&gt;&lt;/fieldset&gt; MemberFrontController.java의 doProcess()메서드 추가 코드작성1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doProcess메서드 호출\"); //4. 가상주소 가져오기 : 가지고 다닐 주소는 /*.me 앞부분의 주소는 필요가 없다. String requestURI = req.getRequestURI(); StringBuffer requestURL = req.getRequestURL(); //uri와 url차이 -&gt; uri에서 내 프로젝트명을 뺀 /*.me만 들고다니면됨 System.out.println(\"리퀘스트uri: \"+requestURI); ///Model2JSP7/*.me System.out.println(\"리퀘스트url: \"+requestURL); //http://localhost:8088/Model2JSP7/*.me //contextPath는 프로젝트명을 호출함 String contextPath = req.getContextPath(); System.out.println(\"contextPath: \"+contextPath); ///Model2JSP7 //가상주소 command : 필요한 주소인 /*.me만 가져다니기 위해 substring()사용 String command = requestURI.substring(contextPath.length()); System.out.println(\"잘 짤렸는지 가상주소 command: \"+command); //9-1. 일회성이 아닌 다회용 여러번 쓸수있게 처리 Action action = null; //6-3.ActionForward 객체사용 ActionForward forward = null; //5. 특정 주소에 대한 처리 if(command.equals(\"/MemberJoin.me\")){ System.out.println(\"/MemberJoin.me 호출\"); //6. 회원가입처리 -&gt; 회원정보 입력창(view의 개념이 필요) //모델2에서 페이지 이동은 무조건 ActionForward사용 /*//6-1.페이지이동방법은 2가지 중 첫번째 : response resp.sendRedirect(\"./member/insertForm.jsp\"); //6-2.페이지이동방법은 2가지 중 두번째 : forward RequestDispatcher dis = req.getRequestDispatcher(\"./member/insertForm.jsp\"); dis.forward(req, resp);*/ //6-4. 특정주소에 대한 처리 후 페이지이동 =&gt;먼저 특정주소에 대한 처리는 ActionForward 객체 사용 //ActionForward 객체 생성되기 전에는 null (값이 없다)이다가 객체생성후 이동정보가 생긴다 forward = new ActionForward(); // 이동할 주소 forward.setPath(\"./member/insertForm.jsp\"); // 이동할 방법 forward.setRedirect(false); //8.MemberJoinAction일때도 주소 출력 //8-1.Action페이지는 모델1의 pro페이지 역할을 한다. }else if(command.equals(\"/MemberJoinAction.me\")){ //주소에 `.`붙이면 안됨 System.out.println(\"/MemberJoinAction.me 주소 호출\"); //8-2.전달되는 정보를 Action.java 인터페이스에 저장 --Acttion.java인터페이스와 MemberJoinAction.java생성--&gt; DB로 전달 //Action페이지를 통해서 처리 =&gt; MemberJoinAction 객체를 생성 후 execute메서드 호출 //MemberJoinAction action = new MemberJoinAction(); //데이터 업캐스팅(Action &lt;- MemberJoinAction)해서 저장 //9-2.`MemberJoinAction action = new MemberJoinAction()`을 `action = new MemberJoinAction();`으로 변경 action = new MemberJoinAction(); try { System.out.println(\"@@@@ Controller : MemberJoinAction 객체생성완료 후 excute()호출완료\"); forward = action.execute(req, resp); System.out.println(\"@@@@ Controller : 회원가입 처리완료 후 페이지 이동\"+forward); } catch (Exception e) { e.printStackTrace(); } //10. 로그인페이지연결 }else if(command.equals(\"/MemberLogin.me\")){ System.out.println(\"가상주소: /MemberLogin.me 주소 호출, 실제주소: ./member/loginForm.jsp\"); forward = new ActionForward(); forward.setPath(\"./member/loginForm.jsp\"); forward.setRedirect(false); //10-1. 로그인처리 }else if(command.equals(\"/MemberLoginAction.me\")){ //10-2. MemberLoginAction.java 생성 action = new MemberLoginAction(); try { System.out.println(\"@@@@ Controller : MembeLoginAction 객체생성완료 후 excute()호출완료\"); forward = action.execute(req, resp); System.out.println(\"@@@@ Controller : 로그인 처리완료 후 페이지 이동\"+forward); } catch (Exception e) { e.printStackTrace(); } } //7.페이지이동 : 두가지방식 //이동정보가 있을때 (ActionForward객체가 생성되었을때) 페이지이동이 실행되어야한다 //7-1.response =&gt; true일때 이동 //7-2.forward =&gt; false일때 이동 if(forward != null){ System.out.println(\"@@@페이지이동@@@\"); if(forward.isRedirect()){//1 - response.sendRedirect(주소)사용 //정보는 ActionForward객체 안에 있다 System.out.println(\"sendRedirect방식의 이동\"+forward.getPath()); resp.sendRedirect(forward.getPath()); }else{ //0 - forward사용 System.out.println(\"RequestDispatcher방식의 이동\"+forward.getPath()); RequestDispatcher dis = req.getRequestDispatcher(forward.getPath()); dis.forward(req, resp); } }}//end of doProcess MemberLoginAction.java 객체 생성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MemberLoginAction implements Action{ @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"@@@@ Action: MembeLoginAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2.전달되는 파라미터 정보저장 -&gt;MemberLoginAction객체생성 String id = req.getParameter(\"id\"); String pw = req.getParameter(\"pw\"); //3. DB객체처리 MemberDAO mdao = new MemberDAO(); int check = mdao.idCheack(id, pw); //4. 페이지이동 : 결과에 따른 페이지이동처리, 무조건 Controller로 이동 System.out.println(\"@@@@ Action : 페이지이동 \"+check); //4-2.로그인 비번오류 if(check == 0){ //로그인 비번오류 //자바스크립트사용하여 alert()창띄우기 resp.setContentType(\"text/html; charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.print(\"&lt;script&gt;\"); out.print(\"alert('비밀번호오류');\"); out.print(\"history.back();\"); out.print(\"&lt;/script&gt;\"); //자원해제 out.close(); return null; //null이란 Controller에서 페이지 이동하지않겠다는 의미 }else if(check == -1){ //자바스크립트사용하여 alert()창띄우기 resp.setContentType(\"text/html; charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.print(\"&lt;script&gt;\"); out.print(\"alert('존재하지 않는 아이디입니다');\"); out.print(\"history.back();\"); out.print(\"&lt;/script&gt;\"); //자원해제 out.close(); return null; //null이란 Controller에서 페이지 이동하지않겠다는 의미 } //4-1. 정상 로그인처리 if (check == 1){ //정상 로그인처리 //아이디값 세션객체에 저장 //jsp페이지가 아닌 java페이지기때문에 java에는 session내장객체가 없다. //session.setAttribute(\"id\", id); 한줄로는 실행이 안되니까 HttpSession session = req.getSession(); 추가해준다 HttpSession session = req.getSession(); session.setAttribute(\"id\", id); } //페이지이동객체생성 ActionForward forward = new ActionForward(); forward.setPath(\"./Main.me\"); forward.setRedirect(true); return forward; } } MemberDAO.java의 idCheck()메서드 추가 코드 작성12345678910111213141516171819202122232425262728293031323334353637//4. 로그인메서드// DB에서 해당 값이 있는지 체크하고 결과를 리턴// 정수형 데이터값 사용(1-정상처리, 0-비번오류, (-1)-아이디가없음)public int idCheack(String id, String pw){ int result = -1; try { //4-1. 드라이브로드 디비연결 con = getCon(); //4-2. SQL &amp; pstmt 생성 sql = \"select pw from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); //4-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //4-4. 데이터 처리 //왜 while이 아닌 if인가? where절에서 id는 pk조건을 가지고 있으므로 중복이 없기때문 if(rs.next()){ if(pw.equals(rs.getString(\"pw\"))){ result = 1; //4-5. 세션정보를 만들 수 있을까? 만들 수 없다. //session.setAttribute(); //why? session은 jsp내장객체이다. // 따라서 java에서 사용할 수 없지만 추후 서블릿을 통해 사용할 수 있다. }else{ result = 0; } }else{ result = -1; } System.out.println(\"@@@@ DAO : 로그인처리완료 \"+result); } catch (Exception e) { e.printStackTrace(); } finally { //4-6. 자원해제 closeDB(); } return result;}//idCheck닫힘 index.jsp코드 수정프로젝트 시작페이지를 login페이지로 변경 1234&lt;%//프로젝트의 시작페이지response.sendRedirect(\"./MemberLogin.me\");%&gt;","link":"/2020/08/18/200819jspi2/"},{"title":"Servlet쇼핑몰2: 회원가입","text":"MemberFrontController.java의 doProcess()메서드 추가 코드작성 6번부터 회원가입처리 -&gt; 회원정보 입력창(view의 개념이 필요) 모델2에서 페이지 이동은 무조건 ActionForward사용 페이지이동방법은 2가지 response : response.sendRedirect(&quot;./member/insertForm.jsp&quot;) =&gt; 웹주소가 .jsp끝나기때문에 우리가 원하는 모델2방식이 아니다. forward : RequestDispatcher사용 =&gt; 웹주소가 .me로 끝나기때문에 우리가 원하는 방식이지만 코드길이가 너무 길어진다. =&gt; ActionForward객체를 사용하면 편하다12RequestDispatcher dis = request.getRequestDispatcher(&quot;./member/insertForm.jsp&quot;);dis.forward(request, response); ActionForward객체로 특정주소에 대한 처리 후 response나 forward방식으로 페이지이동. 모델2에서 페이지 이동은 무조건 ActionForward사용. MemberJoinAction.java일때도 .me주소 출력 MemberJoinAction action = new MemberJoinAction()을 action = new MemberJoinAction();으로 변경하여 일회성이 아닌 여러번 사용가능하도록 만들기. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//3. doProcess()생성protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doProcess메서드 호출\"); //4. 가상주소 가져오기 : 가지고 다닐 주소는 /*.me 앞부분의 주소는 필요가 없다. String requestURI = req.getRequestURI(); StringBuffer requestURL = req.getRequestURL(); //uri와 url차이 -&gt; uri에서 내 프로젝트명을 뺀 /*.me만 들고다니면됨 System.out.println(\"리퀘스트uri: \"+requestURI); ///Model2JSP7/*.me System.out.println(\"리퀘스트url: \"+requestURL); //http://localhost:8088/Model2JSP7/*.me //contextPath는 프로젝트명을 호출함 String contextPath = req.getContextPath(); System.out.println(\"contextPath: \"+contextPath); ///Model2JSP7 //가상주소 command : 필요한 주소인 /*.me만 가져다니기 위해 substring()사용 String command = requestURI.substring(contextPath.length()); System.out.println(\"잘 짤렸는지 가상주소 command: \"+command); //9-1. 일회성이 아닌 다회용 여러번 쓸수있게 처리 Action action = null; //6-3.ActionForward 객체사용 ActionForward forward = null; //5. 특정 주소에 대한 처리 if(command.equals(\"/MemberJoin.me\")){ System.out.println(\"/MemberJoin.me 호출\"); //6. 회원가입처리 -&gt; 회원정보 입력창(view의 개념이 필요) //모델2에서 페이지 이동은 무조건 ActionForward사용 /*//6-1.페이지이동방법은 2가지 중 첫번째 : response resp.sendRedirect(\"./member/insertForm.jsp\"); //6-2.페이지이동방법은 2가지 중 두번째 : forward RequestDispatcher dis = req.getRequestDispatcher(\"./member/insertForm.jsp\"); dis.forward(req, resp);*/ //6-4. 특정주소에 대한 처리 후 페이지이동 =&gt;먼저 특정주소에 대한 처리는 ActionForward 객체 사용 //ActionForward 객체 생성되기 전에는 null (값이 없다)이다가 객체생성후 이동정보가 생긴다 forward = new ActionForward(); // 이동할 주소 forward.setPath(\"./member/insertForm.jsp\"); // 이동할 방법 forward.setRedirect(false); //8.MemberJoinAction일때도 주소 출력 //8-1.Action페이지는 모델1의 pro페이지 역할을 한다. }else if(command.equals(\"/MemberJoinAction.me\")){ //주소에 `.`붙이면 안됨 System.out.println(\"/MemberJoinAction.me 주소 호출\"); //8-2.전달되는 정보를 Action.java 인터페이스에 저장 --Acttion.java인터페이스와 MemberJoinAction.java생성--&gt; DB로 전달 //Action페이지를 통해서 처리 =&gt; MemberJoinAction 객체를 생성 후 execute메서드 호출 //MemberJoinAction action = new MemberJoinAction(); //데이터 업캐스팅(Action &lt;- MemberJoinAction)해서 저장 //9-2.`MemberJoinAction action = new MemberJoinAction()`을 `action = new MemberJoinAction();`으로 변경 action = new MemberJoinAction(); try { System.out.println(\"@@@@ Controller : MemberJoinAction 객체생성완료 후 excute()호출완료\"); forward = action.execute(req, resp); System.out.println(\"@@@@ Controller : 처리완료 후 페이지 이동\"+forward); } catch (Exception e) { e.printStackTrace(); } } //7.페이지이동 : 두가지방식 //이동정보가 있을때 (ActionForward객체가 생성되었을때) 페이지이동이 실행되어야한다 //7-1.response =&gt; true일때 이동 //7-2.forward =&gt; false일때 이동 if(forward != null){ System.out.println(\"@@@페이지이동@@@\"); if(forward.isRedirect()){//1 - response.sendRedirect(주소)사용 //정보는 ActionForward객체 안에 있다 System.out.println(\"sendRedirect방식의 이동\"+forward.getPath()); resp.sendRedirect(forward.getPath()); }else{ //0 - forward사용 System.out.println(\"RequestDispatcher방식의 이동\"+forward.getPath()); RequestDispatcher dis = req.getRequestDispatcher(forward.getPath()); dis.forward(req, resp); } }}//end of doProcess DB 테이블 생성 회원정보시 필요한 데이터를 입력받은 DB 테이블을 생성한다 insertForm.jsp 생성 DB테이블을 기준으로 입력받은 폼을 작성한다. 123456789101112131415161718192021&lt;!-- .me가 가상경로이기때문에 ../style.css가 아닌 ./style.css(./의 의미는 루트)가 되어야한다 --&gt;&lt;link href=\"./style.css\" rel=\"stylesheet\" /&gt;&lt;%//1. DB생성 - member테이블 사용//2. 데이터 입력받을 화면 작성%&gt;&lt;fieldset&gt;&lt;legend&gt;회원가입&lt;/legend&gt; &lt;form action=\"./MemberJoinAction.me\" method=\"post\" name=\"fr\"&gt; 아이디 &lt;input type=\"text\" name=\"id\" required&gt;&lt;br&gt; 비밀번호 &lt;input type=\"password\" name=\"pw\"&gt;&lt;br&gt; 이름 &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt; 나이 &lt;input type=\"text\" name=\"age\"&gt;&lt;br&gt; 성별 &lt;input type=\"radio\" name=\"gender\" value=\"여\"&gt; 여성 &lt;input type=\"radio\" name=\"gender\" value=\"남\"&gt; 남성&lt;br&gt; 이메일 &lt;input type=\"text\" name=\"email\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"회원가입하기\"&gt; &lt;/form&gt;&lt;/fieldset&gt; 인터페이스 Action.java 생성 왜 Interface를 사용해야할까? SOLID 객체지향 설계 추상메서드는 서브클래스들한테 강제성을 부여 =&gt; 틀이 정해짐 =&gt; 개발 형식의 통일. 강제성 : implement를 하려면 내가 가지고 있는 추상메서드를 오버라이딩해야만 해! 객체간의 관계가 약화됨 =&gt; 각각의 객체가 해당 동작만 처리/제어 장점 : 오류처리에 용이. 오류나면 전체가 아닌 특정 객체 부분만 바꾸면 됨. Action 페이지의 동작을 미리 선언해서 사용함. 1234567891011package com.itwillbs.member.action;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public interface Action { //상수, 추상메서드 사용가능 //1. 추상 메서드 작성 public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception; }//end of interface MemberJoinAction.java생성 Action으로 끝나면 모델1의 pro페이지의 역할을 한다. 접두사 Action 객체는 항상 Action 인터페이스를 구현해서 사용 insertForm.jsp에서 회원가입을 클릭했을 때 MemberJoinAction.java로 이동되는 것을 구현. 123456789101112131415161718192021222324252627282930313233public class MemberJoinAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"MemberJoinAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2.전달되는 파라미터 정보저장 -&gt;MemberBean 생성 MemberBean mb = new MemberBean(); mb.setAge(Integer.parseInt(req.getParameter(\"age\"))); mb.setEmail(req.getParameter(\"email\")); mb.setGender(req.getParameter(\"gender\")); mb.setId(req.getParameter(\"id\")); mb.setName(req.getParameter(\"name\")); mb.setPw(req.getParameter(\"pw\")); //시간은 파라미커가 아닌 현재시간으로 객체생성하여 저장 mb.setReg_date(new Timestamp(System.currentTimeMillis())); System.out.println(\"@@@@ Action : 전달받은 정보 MemberBean 객체 확인\"+mb); //3. DB객체처리 MemberDAO mdao = new MemberDAO(); mdao.insertMember(mb); System.out.println(\"@@@@ Action : 디비작업처리완료\"); //4. 페이지이동 : 무조건 Controller로 이동 System.out.println(\"@@@@ Action : 페이지이동\"); ActionForward forward = new ActionForward(); forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; }} MemberBean.java 생성12345678910111213141516171819202122232425262728293031public class MemberBean { //자바빈 -&gt; 회원정보를 저장해서 이동시키기 위한 객체 //DTO(데이터 전송 객체)로도 불린다. //1. DB의 테이블의 컬럼을 자바빈의 멤버 변수로 생성 private String id; private String pw; private String name; private int age; private String gender; private String email; private Timestamp reg_date; //import필수 //2. getter 와 setter생성 public String getId() { return id; } public void setId(String id) { this.id = id; } public String getPw() { return pw; (중략) //3. toString생성 @Override public String toString() { return \"멤버 [id=\" + id + \", pw=\" + pw + \", name=\" + name + \", age=\" + age + \", gender=\" + gender + \", email=\" + email + \", reg_date=\" + reg_date + \"]\"; }} 라이브러리 8개 추가 WEB-INF폴더안에 lib폴더안에 8개 라이브러리 추가 commons-collections4-4.4.jar commons-dbcp2-2.7.0.jar commons-pool2-2.8.0.jar cos.jar mysql-connector-java-5.1.49-bin.jar taglibs-standard-impl-1.2.5.jar taglibs-standard-jstlel-1.2.5.jar taglibs-standard-spec-1.2.5.jar META-INF폴더안의 Context.xml 추가 새로운 프로젝트나 추가 프로젝트를 진행하면 name, url, username, password 변경해줘야함 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- 디비연결에 필요한 정보 저장 --&gt; &lt;!-- 속성 name : 외부에서 해당 정보에 접근할수있도록하는 이름값(변경가능) auth : 자원관리자를 지정(Container/Application) type : 웹에서 사용될때(name으로 호출) 표시되는 객체 타입 driverClassName : JDBC 드라이버 주소(mysql) (변경가능) ORACLE : oracle.jdbc.driver.OracleDriver url : 디비가 존제하는 위치 (디비서버의 주소) (변경가능) ORACLE : jdbc:oracle:thin:@localhost:1521:orcl username/password : 디비 접속 계정 maxWait : 커넥션풀에 사용가능한 커넥션이 없을경우 커넥션의 회수를 기다리는 시간지정 ( 1 / 1000 초 사용) --&gt; &lt;Context&gt; &lt;Resource name=\"jdbc/model2DB\" auth=\"Container\" type=\"javax.sql.DataSource\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/jspdb\" username=\"root\" password=\"1234\" /&gt; &lt;/Context&gt; MemberDAO.java 생성 DB연결 메서드 구현 자원해제 메서드 구현 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MemberDAO { Connection con =null; PreparedStatement pstmt = null; ResultSet rs = null; String sql = \"\"; //1. DB연결메서드 public Connection getCon() throws Exception{ Context init= new InitialContext(); DataSource ds = (DataSource) init.lookup(\"java:comp/env/jdbc/model2DB\"); //Context.xml의 주소와 동일해야함 con = ds.getConnection(); return con; }//end of getCon() //2. 자원해제 메서드 구현 public void closeDB(){ try{ if(rs != null) rs.close(); if(pstmt != null) pstmt.close(); if(con != null) con.close(); } catch (SQLException e) { e.printStackTrace(); } }//closeDB() //3. 회원가입처리 (외부에서 접근가능해야하니까 public) public void insertMember(MemberBean mb){ //파라미터로 정보를 받아서 DB에 저장 try { //3-1. DB연결메서드 불러오기 con = getCon(); //3-2. SQL &amp; pstmt 생성 &amp; 실행 sql = \"insert into itwill_member value(?,?,?,?,?,?,?)\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, mb.getId()); pstmt.setString(2, mb.getPw()); pstmt.setString(3, mb.getName()); pstmt.setInt(4, mb.getAge()); pstmt.setString(5, mb.getGender()); pstmt.setString(6, mb.getEmail()); pstmt.setTimestamp(7, mb.getReg_date()); //insertForm에는 reg_date를 입력하는 란이 없기에 mb에 따로 넣어줘야한다. //즉, 파라미터로 전달되지 않는 정보는 insertForm에서 직접생성 pstmt.executeUpdate(); System.out.println(\"회원가입성공\"); } catch (SQLException e) { System.out.println(\"sql구문땜시 회원가입실패\"); e.printStackTrace(); } catch (Exception e) { System.out.println(\"회원가입실패\"); e.printStackTrace(); } finally { //자원해제로 DB 효율성을 높일수있다. closeDB(); } }//insertMember닫힘 }//end of class 순서 정리 web.xml &gt; index.jsp &gt; 가상주소 MemberJoin.me(실제주소: insertForm.jsp) &gt; 가상주소 MemberLogin.me(실제주소 : ) 가상주소 사용을 해주는 동작 : MemberFrontController","link":"/2020/08/18/200819jspi/"},{"title":"멀티스레드프로그래밍1 : 개념, 용어정리, 스래드 상태와 제어","text":"개념, 용어정리 용어 개념 애플리케이션 이클립스나 파워포인트, 브라우저와 같은 코드 덩어리 프로세스 설치된 애플리케이션을 실행하게되면 운영체제(OS)로부더 메모리의 일정영역을 할당받고 CPU와 HDD를 이용해서 동작하는 것 멀티프로세스 동시에 여러 프로세스를 실행 스레드 프로세스 동작의 최소 단위. 모든 프로세스는 하나 이상의 스레드로 구성 메인스레드 메인스레드가 main()메서드를 실행하면서 애플리케이션이 구동됨 멀티스레드 둘 이상의 스레드로 구성된 프로세스 멀티스레드 프로그램 작업을 스레드 단위로 분리해서 병렬 수행가능 스레드는 모든 게임에 자주 사용된다 총게임에서 총알을 발생하기 등등 멀티스레드 장단점장점 CUP사용률 향상 작업의 분리로 응답성 향상 자원의 공유를 통한 효율성 증대 단점 컨텍스트 스위칭 과정에 별도의 비용발생 제어가 어려움 : 어떤 스레드를 먼저 실행할지 제어하기 힘들다 동기화(synchronization), 교착상태(deadlock)와 같은 문제 발생 스레드 생성2가지 생성방법 Runnable 인터페이스를 구현하는 방법 : 오버라이딩 -&gt; 생성자에 파라미터를 넘겨주면서 객체생성 Thread클래스를 상속받는 방법 : implements 끝 다음 예시코드를 보자. 아래는 -를 5번반복하고 @는 10번 반복후 출력하는 코드이다. 12345678910111213141516171819202122232425public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { for(int i =0 ; i&lt;5; i++){ System.out.print(\"-\"); } } }); Thread t2 = new Thread(() -&gt; { for(int i = 0; i&lt;10; i++){ System.out.print(\"@\"); } }); //JVM스케줄러가 달라져서 출력값이 매번 다름 t1.start(); t2.start(); System.out.println(\"메인끝\");}//출력값메인끝@@--@@@@@---@@@ 예시코드의 의문점 3가지위의 코드에 3가지 의문점이 있다. run()이 없는데 실행되었다 : start()가 호출되면 JVM이 운영체제의 스레드 스케줄러에 의해 가능할때 run()을 호출한다. 출력값이 매번다르다 : JVM스케쥴러가 달라져서. 메인끝은 맨 마지막에 작성했는데 제일 처음 출력되었다 : main()스레드가 t1의 start()스레드를 생성 하게되면 별도의 스택공간을 구성한다. 이 공간은 메인스레드공간과 전혀 무관한 t1스레드의 공간으로 별도의 흐름이 생겨난다. 이후 두 스레드는 병렬스레드로 번갈아가면서 작업이 되는데 start()스레드 전에 main()스레드가 종료되었기때문에 제일 먼저 출력되었다. 만약 위의 코드에서 start()가 아닌 run()을 하면 어떻게 될까?123456t1.run();t2.run();System.out.println(\"메인끝\");//출력값-----@@@@@@@@@@메인끝 이때는 메인스레드에서 실행되는 것이고 t1과t2가 별도의 스택을 구성하지않기때문에 싱글스레드이므로 코드 순서대로 실행된다. 어떤 스레드가 먼저 실행될까?스레드들은 별도이 스택에서 따로따로 동작하기 때문에 제어가 어렵다. 1 우선순위를 통한 제어 스레드가 runnable상태에서 선택될 때는 우선순위가 적용됨. MIN_PRIORITY = 1, MAX_PRIORITY = 10이다. 노말은 5. 아래예시는 F에 우선순위 10을 주고 T에는 제일 낮은 우선순위를 준 뒤 출력하는 값이다 123456789101112131415161718192021static class MessengerThread extends Thread{ public MessengerThread(String name){ super(name); } public void run(){ for(int i=0; i&lt;10; i++){ System.out.print(this.getName()); } }}public static void main(String[] args) { Thread ft = new MessengerThread(\"F\"); Thread tt = new MessengerThread(\"T\"); ft.setPriority(Thread.MIN_PRIORITY); //MIN_PRIORITY은 1이다. tt.setPriority(Thread.MAX_PRIORITY); //MAX_PRIORITY는 10이다 ft.start(); tt.start();}//출력값FFFFFFFTTTTTTTTTTFFF 우선순위때문에 F가 모두 출력된뒤 T가 출력되어야하지만 출력값은 그게 아니다. 왜그럴까?스레드의 우선순위 역할은 실행할 확률이 높아지는 것뿐 우선순위만으로는 100%제어할 수 없다. 2 sleep()을 통한 상태제어 sleep()메서드는 동작하는 스레드를 주어진 시간동안 일시정지키셔 대기 풀에서 sleep하게 한다. 대기시간이 끝나거나 interrupt()메서드가 호출되면 대기 풀에서 벗어나 다시 runnable상태로 이동한다. 3 interrupt()를 통한 상태제어 interrupt()를 사용하여 대기 중인 스레드에게 InterruptedException을 발생시켜 즉시 runnable상태로 이동한다. sleep()이나 join()으로 인해 대기 풀에 대기 중인 스레드들은 지정된 시간이 지나거나 끼웠던 스레드가 종료되면 자동으로 runnable 상태로 이동한다. BUT 대기 중인 스레드가 임의로 runnable상태로 바꿔야할 때가 있다 예를 들어 음악 재생에서 일시정지했다가 다시 실행하는 경우가 해당. 예시 : 카운트10초동안 구구단 문제를 풀고 답을 입력하면 카운드가 종료되면서 사용자가 기입한 답과 정답을 리턴하는 코드이다 123456789101112131415161718192021public static void main(String[] args) { Thread cnt = new Thread(()-&gt;{ for(int i=10; i&gt;0; i--){ try{ Thread.sleep(1000); }catch(InterruptedException e){ break; } System.out.println(\"카운트다운: \"+i); } }); cnt.start(); Random rd = new Random(); int first = rd.nextInt(9)+1; int second = rd.nextInt(9)+1; String result = JOptionPane.showInputDialog(first+\" * \"+second+\" ? \"); cnt.interrupt(); System.out.println(\"사용자가 기입한 답: \"+result+\", 정답: \"+(first*second));}//end of main() 4 join()를 통한 상태제어 sleep()과 비슷하게 스레드를 대기 풀로 이동시키는 메서드 다른 스레드의 작업이 종료될때까지 join()을 호출하는 스레드는 대기풀에서 대기 다른 작업을 나의 작업에 참여(join)시킨다. 예시 : 구구단만들기메인스레드와 9개의 구구단 스레드, 숫자를 곱할 때마다 1초씩 sleep()을 호출메인스레드는 구구단 스레드들이 각 단을 완성하면 최종 결과를 출력 123456789101112131415161718192021222324252627282930313233343536373839404142static class GuguThread extends Thread{ private int dan; String[] result = new String[9]; public GuguThread(int dan){ this.dan = dan; } public void run(){ for(int i=1; i&lt;10; i++){ result[i-1] = dan + \"*\"+i+\"=\"+(dan*i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"단완료\"); }}public static void main(String[] args) { List&lt;GuguThread&gt; gs = new ArrayList&lt;&gt;(); for(int i=2; i &lt;10; i++){ GuguThread g = new GuguThread(i); //생성 gs.add(g); g.start(); //스레드생성ㄴ } for(GuguThread g : gs){ try { g.join(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"\\n 구구단출력\"); for(GuguThread g : gs){ System.out.println(Arrays.toString(g.result)); }} 5 yield()를 통한 상태제어 sleep()이나 join()은 스레드 상태를 대기상태로 변경하는 반면 yield()는 대기상태로 변하지 않고 동일한 우선순위를 가진 다른 스레드에게 실행을 양보하고 즉시 runnable상태가 변경된다. 12345678910111213141516171819202122232425static class YieldThread extends Thread{ String s; public YieldThread(String s){ //생성자 this.s = s; } public void run(){ for(int i=0; i&lt;60; i++){ if(i%2==0){ //짝수이면 System.out.print(s); }else{ Thread.yield(); } } }}public static void main(String[] args) { new YieldThread(\"@\").start(); new YieldThread(\"*\").start();}//출력값교대로 마음대로 출력된다 스레드의 종료 run()스레드가 끝나면 자동으로 종료 외부조건에 의해 스레드 종료 가능 : stop()메서드가 있지만 안정성을 위해 flag값을 이용해서 내부값을 자연스럽게 종료시켜야한다. 종료된 메서드는 생존주기가 소멸된다 -&gt; 한 번 소멸된 스레드는 다시 start()를 통해서 runnable로 이동할 수 없다. 예시 : stop()과 flag사용법 차이 123456789101112131415161718192021222324252627static class Rut extends Thread{ boolean flag = true; public void run(){ System.out.println(\"자원획득\"); while(flag){ try{ Thread.sleep(1000); }catch(InterruptedException e){ e.printStackTrace(); }System.out.println(\"자원사용\"); }System.out.println(\"자원반납\"); }}public static void main(String[] args) { Rut t = new Rut(); t.start(); Scanner s = new Scanner(System.in); if(s.nextLine().equals(\"s\")){ t.stop(); }else{ t.flag = false; } //자원해제 s.close(); System.out.println(\"메인끝\");} flag는 자원반납까지가능 stop은 자원반납못하고 즉시 종료됨","link":"/2020/08/19/200820javai/"},{"title":"Servlet쇼핑몰5: 회원정보수정","text":"main.jsp 생성 &lt;input type=&quot;button&quot; value=&quot;회원정보수정&quot; class=&quot;btn&quot; onclick=&quot;location.href='./MemberUpdate.me'&quot;&gt; href속성 .me로 작성작성 123456789101112131415161718192021222324252627&lt;%//1.한글처리, 파라미터 request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object를 string으로 다운캐스팅String name = request.getParameter(\"name\");//1-1. id없이는 진입불가, id없는 경우 로그인페이지로 이동. 가상주소로 이동if(id == null){ response.sendRedirect(\"./MemberLogin.me\");}%&gt;&lt;h3&gt;아이디: &lt;%=id %&gt;&lt;/h3&gt;&lt;h3&gt;아이디(session-EL표현식) : ${ sessionScope.id } &lt;/h3&gt;&lt;input type=\"button\" value=\"ITWILL게시판가기\" class=\"btn\" onclick=\"location.href='../board/boardList.jsp'\"&gt;&lt;input type=\"button\" value=\"회원정보조회\" class=\"btn\" onclick=\"location.href='./MemberInfo.me'\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" class=\"btn\" onclick=\"location.href='./MemberUpdate.me'\"&gt;&lt;input type=\"button\" value=\"로그아웃\" class=\"btn\" onclick=\"location.href='./MemberLogout.me'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" class=\"btn\" onclick=\"location.href='deleteForm.jsp'\"&gt;&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id != null){ if(id.equals(\"admin\")){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" class=\"btn\" onclick=\"location.href='memberList.jsp'\"&gt;&lt;% }}%&gt; MemberFrontController.java의 doProcess()메서드 추가 코드작성 회원정보수정페이지에 DB데이터 가져오기 회원정보수정페이지에서 비밀번호 일치하면 DB업데이트하기 위의 두가지를 해야한다 1234567891011121314151617181920212223242526272829303132 //13. 회원정보조회}else if(command.equals(\"/MemberInfo.me\")){ System.out.println(\"@@@@ Controller : 가상주소 /MemberInfo.me 실제주소: ./member/memberinfo.jsp\"); action = new MemberInfoAction(); try { forward = action.execute(req, resp); } catch (Exception e) { e.printStackTrace(); } //14. 회원정보 수정 //회원정보 수정의 경우 DB에서 정보를 불러오면서 또 DB에 다시 정보를 수정해야한다. //14-1.DB에서 정보를 가지고와야함}else if(command.equals(\"/MemberUpdate.me\")){ System.out.println(\"@@@@ Controller : 가상주소 MemberUpdate/.me 실제주소: ./member/updateForm.jsp\"); action = new MemberUpdateAction(); try { forward = action.execute(req, resp); } catch (Exception e) { e.printStackTrace(); } //14-2.비밀번호가 일치하면 회원정보를 수정}else if(command.equals(\"/MemberUpdatePro.me\")){ System.out.println(\"@@@@ Controller : 가상주소 MemberUpdatePro/.me 실제주소: ./member/updateForm.jsp\"); //MemberUpdateProAction()객체생성 action = new MemberUpdateProAction(); try { forward = action.execute(req, resp); } catch (Exception e) { e.printStackTrace(); }} MemberUpdateAction.java 생성 회원정보가져오는 메서드 getMember()이미있으므로 생성 아닌 호출 123456789101112131415161718192021222324252627282930313233343536public class MemberUpdateAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"@@@@ Action: MemberUpdateAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2. 세션값 제어(id) : 로그인유무 확인 HttpSession session = req.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null){ //model2방식이므로 req.sendRedirect()가 아닌 ActionForward방식으로 이동 forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } //3.MemberDAO객체생성 MemberDAO mdao = new MemberDAO(); //4.회원정보가져오는 메서드 getMember()이미있으므로 생성 아닌 호출 MemberBean mb = mdao.getMember(id); //5.회원정보를 req영역에 저장 (req안되면 session이나 application에 담아야함) req.setAttribute(\"mb\", mb); //되도록이면 key명과 value명 같이하면 안 헷갈림 //6.페이지이동(./member/updateForm.jsp) //.은 webcontent라고 생각할것 forward.setPath(\"./member/updateForm.jsp\"); forward.setRedirect(false);//주소는 그대로인데 화면은 jsp이여야함 forward방ㅣㄱ System.out.println(\"@@@@ 모델 : DB에서 회원정보 가져와서 저장 후 updateForm.jsp페이지이동\"); return forward; }//end of execute } updateForm.jsp 생성12345678910111213141516171819202122232425262728293031323334353637&lt;%//1.로그인여부체크 (로그인x-&gt;로그인페이지로이동)request.setCharacterEncoding(\"UTF-8\");String id = (String) session.getAttribute(\"id\");//object이기에 형변환필수if(id == null){ response.sendRedirect(\"./MemberLogin.me\");} //2. 드라이브로드 &amp; 디비연결 : 로그인한 사용자의 정보를 가져오기 =&gt; MemberUpdateAction.java에서 처리MemberBean mb = (MemberBean) request.getAttribute(\"mb\");System.out.println(\"@@@@ 뷰 : 액션페이지에서 정보 전달받음\"+mb);//3. 데이터처리 : 테이블형식으로 출력//4. 비밀번호를 입력받은 뒤 수정하기 -&gt;updatePro.jsp에서 진행%&gt;&lt;fieldset&gt;&lt;legend&gt;회원정보수정&lt;/legend&gt; &lt;form action=\"./MemberUpdatePro.me\" method=\"post\" name=\"fr\"&gt; 아이디 &lt;input type=\"text\" name=\"id\" value=\"&lt;%=mb.getId() %&gt;\" readonly&gt;&lt;br&gt; 비밀번호 &lt;input type=\"password\" name=\"pw\" placeholder=\"비밀번호를 입력하세요\" required&gt;&lt;br&gt; 이름 &lt;input type=\"text\" name=\"name\" value=\"&lt;%=mb.getName() %&gt;\"&gt;&lt;br&gt; 나이 &lt;input type=\"text\" name=\"age\" value=\"&lt;%=mb.getAge() %&gt;\"&gt;&lt;br&gt; 성별 &lt;input type=\"radio\" name=\"gender\" value=\"여\" &lt;% if(mb.getGender().equals(\"여\")){ %&gt; checked &lt;%}%&gt; &gt; 여성 &lt;input type=\"radio\" name=\"gender\" value=\"남\" &lt;% if(mb.getGender().equals(\"남\")){ %&gt; checked &lt;%}%&gt; &gt; 남성&lt;br&gt; 이메일 &lt;input type=\"text\" name=\"email\" value=\"&lt;%=mb.getEmail() %&gt;\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"btn\" value=\"회원정보수정하기\"&gt; &lt;/form&gt;&lt;/fieldset&gt;&lt;button class=\"btn\" onclick=\"location.href='./Main.me'\"&gt;뒤로가기&lt;/button&gt; MemberUpdateProAction.java 생성1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MemberUpdateProAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"@@@@ 모델: MemberUpdateProAction안의 execute() 실행됨\"); //1. 한글처리 req.setCharacterEncoding(\"UTF-8\"); //2. 세션값 제어(id) : 로그인유무 확인 HttpSession session = req.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null){ //model2방식이므로 req.sendRedirect()가 아닌 ActionForward방식으로 이동 forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } //3.전달되는 정보 모두 저장 MemberBean mb = new MemberBean(); mb.setAge(Integer.parseInt(req.getParameter(\"age\"))); mb.setEmail(req.getParameter(\"email\")); mb.setGender(req.getParameter(\"gender\")); mb.setId(req.getParameter(\"id\")); mb.setName(req.getParameter(\"name\")); mb.setPw(req.getParameter(\"pw\")); System.out.println(\"@@@@ Action : 전달받은 정보인 MemberBean객체 확인\"+mb); //4.MemberDAO객체생성 &gt; updateMember()생성 MemberDAO mdao = new MemberDAO(); int result = mdao.updateMember(mb); //5.페이지이동(js사용) if(result == 0){ //로그인 비번오류 //자바스크립트사용하여 alert()창띄우기 resp.setContentType(\"text/html; charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.print(\"&lt;script&gt;\"); out.print(\"alert('비밀번호오류');\"); out.print(\"history.back();\"); out.print(\"&lt;/script&gt;\"); System.out.println(\"@@@@ 모델 : 자바스크립트 페이지이동\"); //자원해제 out.close(); return null; //null이란 Controller에서 페이지 이동하지않겠다는 의미 }else if(result == -1){ //자바스크립트사용하여 alert()창띄우기 resp.setContentType(\"text/html; charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.print(\"&lt;script&gt;\"); out.print(\"alert('존재하지 않는 아이디입니다');\"); out.print(\"history.back();\"); out.print(\"&lt;/script&gt;\"); System.out.println(\"@@@@ 모델 : 자바스크립트 페이지이동\"); //자원해제 out.close(); return null; //null이란 Controller에서 페이지 이동하지않겠다는 의미 } //4-1. 정상 로그인처리 //result == 1 //정상 로그인처리 //자바스크립트사용하여 alert()창띄우기 resp.setContentType(\"text/html; charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.print(\"&lt;script&gt;\"); out.print(\"alert('회원정보 수정이 정상 처리되었습니다');\"); out.print(\"location.href='./Main.me'\"); out.print(\"&lt;/script&gt;\"); System.out.println(\"@@@@ 모델 : 자바스크립트 페이지이동\"); //자원해제 out.close(); return null; }} MemberDAO.java의 updateMember()메서드 추가 코드 작성123456789101112131415161718192021222324252627282930313233343536373839404142434445//6. 회원정보 수정 메서드public int updateMember(MemberBean mb){ int result = -1; try { //6-1. 드라이브로드 디비연결 con = getCon(); //6-2. SQL 구문작성 &amp; pstmt 생성 sql = \"select pw from itwill_member where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, mb.getId()); //6-3. 실행 -&gt; rs저장 rs = pstmt.executeQuery(); //6-4. 데이터처리 : DB에 있는 회원인 경우 수정 아닌 경우 에러 if(rs.next()){//DB에 있는 회원 if(mb.getPw().equals(rs.getString(\"pw\"))){//비번일치 //6-5. 비번일치하면 정보수정 작업 //6-5-1. SQL 구문작성 &amp; pstmt 생성 sql = \"update itwill_member set name=?,age=?,gender=?,email=? \" + \"where id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, mb.getName()); pstmt.setInt(2, mb.getAge()); pstmt.setString(3, mb.getGender()); pstmt.setString(4, mb.getEmail()); pstmt.setString(5, mb.getId()); //6-5-2. 실행 pstmt.executeUpdate(); System.out.println(\"회원정보수정성공\"); result = 1; }else{ result = 0; System.out.println(\"아디일치,비번불일치 - 회원정보수정실패\"); } }else{ //DB에 없는 회원 result = -1; System.out.println(\"존재하지않는아이디 - 회원정보수정실패\"); } } catch (Exception e) { e.printStackTrace(); } finally{ closeDB(); } return result;}//updateMember닫힘","link":"/2020/08/26/200827jspi/"},{"title":"Oracle DB구조2 : Instance의 SGA 메모리구조","text":"오라클 데이터베이스 구조 오라클DB는 크게 인스턴스(SGA 메모리구조와 백그라운드 프로세스와 데이터베이스로 나뉜다. InstanceSGA(System Grobal Area)메모리구조Shared poolLibrary cache :- 최근에 실행된 sql구문과 실행계획이 저장되는 공간- LRU(Least Recently Used Algorithm) 알고리즘으로 관리됨.- 대소문자, 공백까지 일치가 되어야 hit됨.Data dictionary cache : - 최근에 사용된 DB 정의정보가 저장된 공간- 정의정보란 file, object, 권한, 제약조건 등- LRU(Least Recently Used Algorithm) 알고리즘으로 관리됨.DB buffer cache실제 실행 작업을 하는 메모리 구조-최근에 사용된 Data block이 저장된 곳-LRU 알고리즘으로 관리됨Redo log buffer-DB에서 발생된 변경작업의 로그정보(Redo data)가 기록되는 곳-순환형으로 관리됨Background ProcessPMON- User proc fail시 진행하던 트랜잭션 롤백 및 선점하고 있던 자원과 lock을 해제함SMON- Instance fail(= DB 비정삭적인 종료) 후 DB 재시작될 때 DB동기화를 시켜줌DBWR- DB buffer cache의 Dirty block을 datafile로 기록함- 체크포인트 발생시 기록함LGWR- commit이 발생될 때 redo log buffer의 로그정보(= redo data)를 redo log file로 기록함CKPT- 체크포인트 발생시 DBWR에게 알려줌.- DBWR기록 후 datafiles 헤더와 controlfile에 마지막 체크포인트 번호를 갱신함DatabaseDatabase 3대파일Data files실제 data가 저장되는 공간data dictionary가 저장되는 공간datafile 정보 조회 : v$datafile(영구data), v$tempfile(임시data)Control fileDB의 무결성 유지/관리할 수 있는 모든 동기화정보가 기록된 공간DB의 논리적/물리적 구조 정보, 마지막 작업번호 등이 저장DB당 하나이상 존재 -&gt; 최대8개까지 다중화기능제공오라클 권장 3개Control file 정보조회: v$controlfileRedolog filesDB에서발생된 변경 작업의 로그정보(Redo data)가 기록된 공간주목적 : Datafile recovery(복구)DB당 최소 2개이상 존재순환형 관리Redo log Group(논리적 구조) : DB당 2개이상Redo log Member(물리적 구조,file) : Redo log Group당 1개이상오라클 권장사항 : Group 3개, Member 2개씩Redolog files 정보조회 : v$log, v$logfileParameter fileInstance의 정의정보가 기록된 공간SGA할당정보, B/G proc정보 등DB의 여러 설정 정보가 기록된 공간위치 : $ORACLE_HOME/dbs이름 : spfileSID.ora 또는 initSID.oraPassword fileDB를 시작/종료할 수 있도록 인증해주는 공간.위치 : $ORACLE_HOME/dbs이름 : orapwSIDOptionalArchived log files- Redo log file의 오프라인 복사본- 주목적 : Datafile Recovery- log mode : Narchive log mode VS Archive log mode 중 선택- log mode 정보 조회 : v$database SGA (System Grobal Area) 메모리구조 필수 메모리 구조는 3개가 있다. Shared pool, DB buffer cache, Redo log buffer 공유가 가능한 메모리 구조. 실행순서 : Library cache &gt; Data dictionary cache &gt; DB buffer cache Shared pool사전 준비작업을 하는 메모리 구조 프로세스 예시 유저가 접속한다. &gt; select 구문을 날린다. user proc가 구문을 받는다 : 유저의 요청을 이진정보로 변경 &gt; 해시함수를 통해 반환된 해시value값을 server proc로 전달한다. 대소문자와 공백등 완전히 똑같은 구문이라면 해시value가 동일하다. server proc가 진행 : 고유한 해시값을 가지고 Library cache로 간다 해시값을 대조해서 동일한 값이 있으면 hit하고 실행계획을 재사용(응답속도 향상) 동일한 해시값이 없으면 miss가 되고 Library cache에 새로 생성. 그 다음 Data dictionary cache로 간다. Library cache 최근에 실행된 sql구문과 실행계획이 저장되는 공간 LRU(Least Recently Used Algorithm) 알고리즘으로 관리됨. 주로 사용되는 FIFO 정책이 아닌 LRU 알고리즘 방식으로 최근에 사용된 적이 없는 것부터 덮어쓴다. 알고리즘과 자료구조는 복잡하지만 개별적으로 공부하면 좋다. 대소문자, 공백까지 일치가 되어야 hit됨. hit가 많을 수록 응답속도가 향상되어 DB성능이 좋아진다. 개발자입장에서 어떻게 hit를 높일 수 있을까? 대소문자를 어떻게 쓸지 정확히 정하고 따른다. 같은 DB를 사용하는 사람들끼리 대소문자, 공백등 규칙을 정하고 따른다. DBA입장에서 어떻게 hit를 높일까? Library cache 메모리 사이즈를 최대한 크게 잡을 수록 HIT율은 올라간다. Data dictionary cache 최근에 사용된 DB 정의정보가 저장된 공간 정의정보란 file, object, 권한, 제약조건 등 위치 : Datafiles의 1번 데이터파일 LRU(Least Recently Used Algorithm) 알고리즘으로 관리됨 Data dictionary cache의 hit율을 높일 수 있는 방법 개발자입장 : 불필요한 쿼리구문 실행하지말 것. DBA입장 : cache 메모리 사이즈를 최대한 크게 잡기. DB buffer cache 실제 실행 작업을 하는 메모리 구조 최근에 사용된 Data block이 저장된 공간 LRU 알고리즘으로 관리됨 데이터 블록 크기의 권장사항은 8k(권장사항) 소규모의 데이터를 자주 캐치하는 회사라면 데이터 크기가 작은 것이 처리가 빠르다 : 2k, 4k 대규모의 데이터를 자주 캐치하는 회사라면 데이터 크기가 큰 것이 처리가 빠르다 : 16k, 32k Redo log buffer DB에서 발생된 변경작업의 로그정보(Redo data)가 기록된 공간 순환형으로 관리됨","link":"/2020/08/27/200828dbi/"},{"title":"Servlet게시판3: 게시판 리스트·게시글전체목록·페이징처리","text":"BoardFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 123456789101112 //게시글전체조회}else if(command.equals(\"/BoardList.bo\")){ System.out.println(\"컨트롤러: /BoardList.bo주소요청\"); //게시글 전체를 확인 하려면 : .jsp(뷰) &lt;- servlet(컨트롤러) &lt;- .java(모델) &lt;- DB로 이동 해야한다. action = new BoardListAction(); System.out.println(\"컨트롤러 : BoardListAction객체 생성 execute() 호출\"); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} boardList.jsp 생성 페이징처리는 BoardListAction.java에서 처리 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;% //request 영역에 boardList 저장ArrayList&lt;BoardDTO&gt; boardList = (ArrayList&lt;BoardDTO&gt;) request.getAttribute(\"boardList\"); //캐스팅int cnt = (int)request.getAttribute(\"cnt\");//페이징 정보 저장 String pageNum = (String)request.getAttribute(\"pageNum\"); int pageCount = (Integer)request.getAttribute(\"pageCount\"); int pageBlock = (Integer)request.getAttribute(\"pageBlock\"); int startPage = (Integer)request.getAttribute(\"startPage\"); int endPage = (Integer)request.getAttribute(\"endPage\"); //6. 게시판 모든 내용을 화면에 출력String id = (String) session.getAttribute(\"id\");%&gt;&lt;fieldset&gt;&lt;legend&gt;땡땡게시판&lt;/legend&gt; &lt;div id=\"contents\"&gt; 게시판 총 글의 수 : &lt;%=cnt%&gt; 개 &lt;% if(id == null){ %&gt; &lt;input class=\"btn\" type=\"button\" value=\"로그인\" onclick=\"location.href='./MemberLogin.me'\"&gt; &lt;% }else if( id != null){ %&gt; &lt;input class=\"btn\" type=\"button\" value=\"로그아웃\" onclick=\"location.href='./MemberLogout.me'\"&gt; &lt;input class=\"btn\" type=\"button\" value=\"글쓰기\" onclick=\"location.href='./BoardWrite.bo'\"&gt; &lt;input class=\"btn\" type=\"button\" value=\"파일 올리기\" onclick=\"location.href='./FileBoardWrite.bo'\"&gt; &lt;% } %&gt; &lt;br&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;글번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성자&lt;/th&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;th&gt;작성일&lt;/th&gt; &lt;th&gt;IP&lt;/th&gt; &lt;/tr&gt; &lt;%//반복문 //ArrayList는 가변배열이므로 length가 없고 size가 존재한다. //size()메서드는 배열의 요소의 갯수를 리턴 for(int i=0;i&lt;boardList.size(); i++){ //ArrayList 한칸의 정보 -&gt;BoardBean 객체 하나로 이동 BoardDTO bb = (BoardDTO)boardList.get(i); %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=bb.getBno()%&gt;&lt;/td&gt; &lt;td&gt; &lt;% //답글일때만 이미지넣기 //변수 wid를 이용하여 들여쓰기 처리 int wid = 0; if(bb.getRe_lev() &gt; 0){ wid= 10 * bb.getRe_lev(); //레벨값의 10을 곱한 값만큼 이미지 가로길이를 길게해줌 %&gt; &lt;img src=\"./board/level.gif\" width=\"&lt;%=wid%&gt;\" height=\"15\"&gt; &lt;img src=\"./board/re.gif\"&gt; &lt;% } %&gt; &lt;a href=\"./BoardContent.bo?bno=&lt;%=bb.getBno()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;\"&gt;&lt;%=bb.getSubject()%&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getName()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getReadcount()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getDate()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bb.getIp()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;/table&gt; &lt;/div&gt;&lt;/fieldset&gt;&lt;% // 다른 페이지 이동 버튼 if(cnt != 0){ %&gt; &lt;div id=\"pageBlock\"&gt; &lt;% // 이전 if(startPage &gt; pageBlock){ %&gt; &lt;a href=\"./BoardList.bo?pageNum=&lt;%=startPage-pageBlock%&gt;\"&gt;[이전]&lt;/a&gt; &lt;% } // 숫자 (1...10/11...20/.....) for(int i=startPage;i&lt;=endPage;i++){ %&gt; &lt;a href=\"./BoardList.bo?pageNum=&lt;%=i%&gt;\"&gt;[&lt;%=i %&gt;]&lt;/a&gt; &lt;% } // 다음 if(endPage &lt; pageCount){ %&gt; &lt;a href=\"./BoardList.bo?pageNum=&lt;%=startPage+pageBlock%&gt;\"&gt;[다음]&lt;/a&gt; &lt;% } %&gt; &lt;/div&gt; &lt;% } %&gt; BoardListAction.java 생성 페이징처리 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class BoardListAction implements Action { @Override public ActionForward execute(HttpServletRequest req, HttpServletResponse resp) throws Exception { System.out.println(\"모델: BoardListAction안의 execute() 실행됨\"); // 페이징 처리***************************** // 한 페이지에서 보여줄 글의 개수 설정 int pageSize = 10; // 현 페이지의 페이지값을 확인 String pageNum = request.getParameter(\"pageNum\"); if (pageNum == null) { // 페이지 정보가 없을경우 항상 1페이지 pageNum = \"1\"; } // 시작 행번호 계산 1...10 / 11...20 / 21...30 / 31...40 int currentPage = Integer.parseInt(pageNum); int startRow = (currentPage - 1) * pageSize + 1; // 끝 행번호 계산 int endRow = currentPage * pageSize; ////////////////페이징 처리 위쪽////////////////////////// // BoardDAO 객체 생성 BoardDAO bdao = new BoardDAO(); // 글 개수 체크하는 메서드, 정보 가져오는 메서드 // getBoardCount(), getBoardList() int boardCount = bdao.getBoardCount(); //////////////////페이징 처리 아래쪽///////////////////// // 전체 페이지수 - 글 50 / 화면 10씩 출력 =&gt; 5페이지 // - 글 56 / 화면 10씩 출력 =&gt; 6페이지 int pageCount = boardCount / pageSize + (boardCount % pageSize == 0 ? 0 : 1); // 한 화면에 보여줄 페이지 번호개수 int pageBlock = 2; // 페이지 블럭의 시작페이지 번호 1...10/11...20/21....30/31....40 int startPage = ((currentPage - 1) / pageBlock) * pageBlock + 1; // 페이지 블럭의 끝 페이지 번호 int endPage = startPage + pageBlock - 1; if (endPage &gt; pageCount) { endPage = pageCount; } // BoardDAO 객체 생성 BoardDAO bdao = new BoardDAO(); // 글 개수 체크하는 메서드, 정보 가져오는 메서드 // getBoardCount(), getBoardList() int boardCount = bdao.getBoardCount(); // 글 개수 체크하는 메서드, 정보 가져오는 메서드 // getBoardCount(), getBoardList() //글이 있는 경우에만 글 가져오기 ArrayList boardList = null; if(boardCount &gt; 0){ boardList = (ArrayList) bdao.getBoardList(); } System.out.println(\"모델: \"+boardList); // 정보(글목록)를 가지고 .jsp페이지로 이동 // request 영역에 boardList 저장 req.setAttribute(\"boardList\", boardList); req.setAttribute(\"cnt\", boardCount); // 페이징처리를 위한 정보 추가 저장 request.setAttribute(\"pageNum\", pageNum); request.setAttribute(\"pageCount\", pageCount); request.setAttribute(\"pageBlock\", pageBlock); request.setAttribute(\"startPage\", startPage); request.setAttribute(\"endPage\", endPage); // 페이지 이동 (./board/boardList.jsp) ActionForward forward = new ActionForward(); forward.setPath(\"./board/boardList.jsp\"); forward.setRedirect(false); return forward; }} BoardDAO.java에 getBoardCount()메서드 추가 코드12345678910111213141516171819//게시글카운트public int getBoardCount(){ int cnt = 0; try{ getCon(); sql=\"select count(*) from itwill_board\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); if(rs.next()){ cnt = rs.getInt(1); } System.out.println(\"DAO: DB에 저장된 글의 수 \"+cnt); } catch(Exception e) { e.printStackTrace(); } finally{ closeDB(); } return cnt;} BoardDAO.java에 getBoardList()메서드 추가 코드1234567891011121314151617181920212223242526272829303132333435363738//게시글불러오기//실무에서 arraylist말고 list를 쓰는 이유는 부모의 기능들을 바로 사용하기 위해서임//하위클래스로 캐스팅이 될때 사용할 수 있는 기능에 차이가 있다.public List&lt;BoardDTO&gt; getBoardList() { //List&lt;BoardDTO&gt; boardList = new List&lt;&gt;(); 안됨 따라서 class로 업캐스팅해줘야함 List&lt;BoardDTO&gt; boardList = new ArrayList&lt;BoardDTO&gt;(); //업캐스팅 try{ getCon(); sql=\"select * from itwill_board\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); while(rs.next()){ BoardDTO bdto = new BoardDTO(); bdto.setBno(rs.getInt(\"bno\")); bdto.setContent(rs.getString(\"content\")); bdto.setDate(rs.getDate(\"date\")); bdto.setFile(rs.getString(\"file\")); bdto.setIp(rs.getString(\"ip\")); bdto.setName(rs.getString(\"name\")); bdto.setPw(rs.getString(\"pw\")); bdto.setRe_lev(rs.getInt(\"re_lev\")); bdto.setRe_ref(rs.getInt(\"re_ref\")); bdto.setRe_seq(rs.getInt(\"re_seq\")); bdto.setReadcount(rs.getInt(\"readcount\")); bdto.setSubject(rs.getString(\"subject\")); boardList.add(bdto); } System.out.println(\"DAO: 게시글불러오기\"); }catch(Exception e){ e.printStackTrace(); }finally{ closeDB(); } return boardList;}//end of getBoardList","link":"/2020/08/31/200901jspi2/"},{"title":"Servlet상품2: 상품등록","text":"AdminGoodsFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 컨트롤러(.ag) -&gt; 뷰페이지(.jsp)로 이동 : forward 사용 .ag -&gt; 디비(Action_DAO_DB) -&gt; .jsp로 이동 : Action사용 123456789101112131415161718System.out.println(\"--------------@ 주소 비교후 처리 @-------------\");Action action = null;ActionForward forward = null;// 주소에 따른 처리 구분 (주소 매핑후 이동)if(command.equals(\"/GoodsAdd.ag\")){ System.out.println(\"C: /GoodsAdd.ag 호출\"); //.ag -&gt; .jsp로 이동 //컨트롤러 -&gt; 뷰페이지 이동 forward = new ActionForward(); forward.setPath(\"./admingoods/admin_goods_write.jsp\"); forward.setRedirect(false);}else if(command.equals(\"/GoodsAddAction.ag\")){ System.out.println(\"C: /GoodsAddAction.ag 호출\"); // .ag -&gt; Action_DAO_DB -&gt; .jsp action = new GoodsAddAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} GoodsAddAction.java 생성 파일 업로드 준비 : multipart객체생성 ./upload폴더생성 for 가상경로 파일이 저장되는 실제위치 : request.getRealPath는 deprecated이므로 context.getRealPath()사용 할 것 크기 : 10MB (크기가 클수록 서버에는 부담) multipart객체생성 상품정보를 저장(파라미터) GoodsDTO 객체 생성 AdminGoodsDAO 객체생성 -&gt; insertGoods()메서드 생성 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class GoodsAddAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : GoodsAddAction의 execute() 호출\"); //1. 파일 업로드 준비 : multipart객체생성과 //1-1. `./upload`폴더생성 for 가상경로 //1-2. 파일이 저장되는 실제위치 : request.getRealPath는 deprecated이므로 context.getRealPath()사용 할 것 ServletContext context = request.getServletContext(); String realpath = context.getRealPath(\"/upload\"); System.out.println(\"realpath: \"+realpath); //2. 크기 : 10MB (크기가 클수록 서버에는 부담) int maxSize = 10 * 1024 * 1024; //3. multipart객체생성 MultipartRequest multi = new MultipartRequest( request, realpath, maxSize, \"UTF-8\", new DefaultFileRenamePolicy() ); System.out.println(\"M : 파일업로드완료\"+multi); //4. 상품정보를 저장(파라미터) = GoodsDTO 객체 생성, DBMS에 테이블 생성 GoodsDTO gdto = new GoodsDTO(); gdto.setCategory(multi.getParameter(\"category\")); gdto.setName(multi.getParameter(\"name\")); gdto.setPrice(Integer.parseInt(multi.getParameter(\"price\"))); gdto.setColor(multi.getParameter(\"color\")); gdto.setAmount(Integer.parseInt(multi.getParameter(\"amount\"))); gdto.setSize(multi.getParameter(\"size\")); gdto.setContent(multi.getParameter(\"content\")); gdto.setBest(0); //0인경우:일반상품, 1인경우:인기상품 //4-1. 이미지정보처리 String img = multi.getFilesystemName(\"file1\")+\",\" + multi.getFilesystemName(\"file2\")+\",\" + multi.getFilesystemName(\"file3\")+\",\" + multi.getFilesystemName(\"file4\"); System.out.println(\"img 4개합: \"+img); gdto.setImage(img); //5. AdminGoodsDAO 객체생성 -&gt; insertGoods()메서드 생성 AdminGoodsDAO agdao = new AdminGoodsDAO(); agdao.insertGoods(gdto); //6. 페이지 이동 ActionForward forward = new ActionForward(); forward.setPath(\"./AdminGoodsList.ag\"); forward.setRedirect(true); return forward; }} admin_goods_write.jsp 생성 반드시 post방식을 써야하는 이유 : file업로드를 할 것이기때문에 필수이다. input태그 속성으로 file을 사용했다면 폼태그 속성으로 method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; 필수! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%//관리자만 페이지 볼 수 있게 추가String id = (String) session.getAttribute(\"id\");if(id == null || !id.equals(\"admin\")){ response.sendRedirect(\"./Main.me\");}%&gt;&lt;fieldset&gt;&lt;legend&gt;상품등록&lt;/legend&gt; &lt;form action=\"\" method=\"post\" name=\"fr\"&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;카테고리&lt;/td&gt; &lt;td&gt; &lt;select name=\"category\"&gt; &lt;option value=\"outwear\"&gt;아우터&lt;/option&gt; &lt;option value=\"fulldress\"&gt;정장&lt;/option&gt; &lt;option value=\"Tshirts\"&gt;티셔츠&lt;/option&gt; &lt;option value=\"shirts\"&gt;셔츠&lt;/option&gt; &lt;option value=\"pants\"&gt;바지&lt;/option&gt; &lt;option value=\"shoes\"&gt;신발&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;상품이름&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;판매가격&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"price\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;색상&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"color\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;수량&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"amount\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;사이즈&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"size\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;제품정보&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"content\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;메인이미지&lt;/td&gt; &lt;td&gt;&lt;input type=\"file\" name=\"file1\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;제품이미지1&lt;/td&gt; &lt;td&gt;&lt;input type=\"file\" name=\"file2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;제품이미지2&lt;/td&gt; &lt;td&gt;&lt;input type=\"file\" name=\"file3\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;제품이미지3&lt;/td&gt; &lt;td&gt;&lt;input type=\"file\" name=\"file4\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt; &lt;input type=\"submit\" value=\"상품등록\"&gt; &lt;input type=\"reset\" value=\"상품등록취소\"&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/fieldset&gt; GoodsDTO.java 생성 후 코드 추가 adminDTO가 아닌 GoodsDTO를 생성 하는 이유는? 관리자가 등록하는 상품과 구매자가 보는 상품이 같기때문에, 관리자상품과 사용자상품으로 나눠서 중복으로 DTO를 생성할 필요가 없다. DBMS에 테이블 생성 12345678910111213141516171819202122232425262728293031323334public class GoodsDTO { //1번규칙만족 : 클래스는 public //2번규칙만족 : 멤버변수선언 private private int gno; private String category; private String name; private int price; private String color; private int amount; private String size; private String content; private String image; private int best; private Date date; //4번규칙만족 : 기본생성자존재하지만 생략됨 //3번규칙만족 : 멤버변수마다 별도의 get/set메소드가 존재해야한다. public int getGno() { return gno; } public void setGno(int gno) { this.gno = gno; } 중략 @Override public String toString() { return \"GoodsDTO [gno=\" + gno + \", category=\" + category + \", name=\" + name + \", price=\" + price + \", color=\" + color + \", amount=\" + amount + \", size=\" + size + \", content=\" + content + \", image=\" + image + \", best=\" + best + \", date=\" + date + \"]\"; } AdminGoodsDAO.java 생성 후 insertGoods()메서드 코드 추가 DB연결 메서드인 getCon()구현 자원해제 메서드인 closeDB()구현 insertGoods()구현 1234567891011121314151617181920212223242526272829303132333435363738//상품등록public void insertGoods(GoodsDTO gdto) { int num = 0; try{ getCon(); //1. 상품등록번호계산 sql = \"select max(gno) from itwill_goods\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); if(rs.next()){ num = rs.getInt(1)+1; //인덱스 사용 호출 //rs.getInt(\"max(bno)\"); // 컬럼명 사용 호출 } System.out.println(\"DAO : 상품번호 \"+num); //2. 상품등록 sql = \"insert into itwill_goods values(?,?,?,?,?,\" + \"?,?,?,?,?,\" + \"now())\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, num); pstmt.setString(2, gdto.getCategory()); pstmt.setString(3, gdto.getName()); pstmt.setInt(4, gdto.getPrice()); pstmt.setString(5, gdto.getColor()); pstmt.setInt(6, gdto.getAmount()); pstmt.setString(7, gdto.getSize()); pstmt.setString(8, gdto.getContent()); pstmt.setString(9, gdto.getImage()); pstmt.setInt(10, gdto.getBest()); pstmt.executeUpdate(); System.out.println(\"상품등록완료\"); }catch(Exception e){ e.printStackTrace(); }finally{ closeDB(); }}//end of insertGoods()","link":"/2020/09/06/200907jspi5/"},{"title":"Servlet상품4: 상품수정·인기상품처리","text":"AdminGoodsFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 12345678910111213 //상품수정}else if(command.equals(\"/AdminGoodsModify.ag\")){ System.out.println(\"C: /AdminGoodsModify.ag 호출\"); //.ag -&gt; Action_DAO_DB -&gt;.jsp로 이동 action = new AdminGoodsModifyFormAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }}else if(command.equals(\"/AdminGoodsModifyAction.ag\")){ //.jsp -&gt; Action_DAO_DB -&gt;.ag로 이동 action = new AdminGoodsModifyProAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} AdminGoodsModifyFormAction.java 생성 request영역에 저장할때 아래 두코드를 모두 사용할 수 있다. 두 코드는 동일한 코드이다. 여러번 사용할 변수가 아니면 2번 코드를 사용하는 것이 더 적합하다. request.setAttribute(&quot;gdto&quot;, gdto); request.setAttribute(&quot;gdto&quot;, agdao.getGoods(gno)); 1234567891011121314151617181920212223242526272829303132333435363738public class AdminGoodsModifyFormAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : AdminGoodsModifyFormAction의 execute() 호출\"); //관리자계정확인(세션 ID) HttpSession session = request.getSession(); String id = (String)session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null || !id.equals(\"admin\")){ //response.sendRedirect(\"./Main.me\"); 컨트롤러통해서 이동시키기 forward.setPath(\"./Main.me\"); forward.setRedirect(true); return forward; } //전달된 파라미터값 저장 int gno = Integer.parseInt(request.getParameter(\"gno\")); //AdminGoodsDAO 객체생성 -&gt; getGoods(gno) //상품번호에 해당하는 상품정보 전체 가져오기 AdminGoodsDAO agdao = new AdminGoodsDAO(); GoodsDTO gdto = agdao.getGoods(gno); System.out.println(\"M : \"+gdto); //request영역에 저장(아래 두코드는 동일한 코드. 여러번 사용할 변수가 아니면 2번 코드가 더 적합) request.setAttribute(\"gdto\", gdto); //request.setAttribute(\"gdto\", agdao.getGoods(gno)); //view페이지로 이동 ('./admingoods/admin_goods_modify.jsp') forward.setPath(\"./admingoods/admin_goods_modify.jsp\"); forward.setRedirect(false); return forward; }} admin_goods_modify.jsp 생성 이미지를 제외한 input태그들만 수정가능하도록 만들기 EL태그를 사용하여 request객체로 전달받은 값들을 나타낼 수 있다. jsp페이지에 &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 코어라이브러리추가 request객체안의 정보를 담은 변수를 선언. =&gt; GoodsDTO gdto = (GoodsDTO) request.getAttribute(&quot;gdto&quot;); gdto.set()명으로 불러오면 된다. =&gt; ${gdto.name} 카테고리가 선택되어있지 않은 경우 아래 두 코드 중 원하는 코드를 사용하면 된다. 두 코드는 동일한 결과값을 가진다. if(gdto.getCategory().equals(&quot;&quot;)){ %&gt; selected &lt;% } %&gt; if(gdto.getCategory() == null){ %&gt; selected &lt;% } %&gt; 인기상품은 0인 경우 아니요 1인 경우예로 데이터처리 tmp는 DB의 몇개의 row가 영향을 받느냐를 나타내는데 여기서는 gno컬럼이 pk이므로 1 또는 0만 나옴 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;%//관리자만 페이지 볼 수 있게 추가String id = (String) session.getAttribute(\"id\");if(id == null || !id.equals(\"admin\")){ response.sendRedirect(\"./Main.me\");}//저장된 정보 가져오기GoodsDTO gdto = (GoodsDTO) request.getAttribute(\"gdto\");%&gt;&lt;fieldset&gt;&lt;legend&gt;상품수정&lt;/legend&gt; &lt;form action=\"./AdminGoodsModifyAction.ag?\" method=\"post\" name=\"fr\"&gt; &lt;input type=\"hidden\" name=\"gno\" value=\"&lt;%=gdto.getGno()%&gt;\"&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;카테고리&lt;/td&gt; &lt;td&gt; &lt;select name=\"category\"&gt; &lt;option value=\"\" &lt;% if(gdto.getCategory().equals(\"\")){ %&gt; selected &lt;% } %&gt; &lt;%--이것도가능 &lt;% if(gdto.getCategory() == null){ %&gt; selected &lt;% } %&gt; --%&gt; &gt;선택하세요&lt;/option&gt; &lt;option value=\"outwear\" &lt;% //selected 속성으로 제어가능 if(gdto.getCategory().equals(\"outwear\")){ %&gt; selected &lt;% } %&gt; &gt;아우터&lt;/option&gt; &lt;option value=\"fulldress\" &lt;% if(gdto.getCategory().equals(\"fulldress\")){ %&gt; selected &lt;% } %&gt; &gt;정장&lt;/option&gt; &lt;option value=\"Tshirts\" &lt;% if(gdto.getCategory().equals(\"Tshirts\")){ %&gt; selected &lt;% } %&gt; &gt;티셔츠&lt;/option&gt; &lt;option value=\"shirts\" &lt;% if(gdto.getCategory().equals(\"shirts\")){ %&gt; selected &lt;% } %&gt; &gt;셔츠&lt;/option&gt; &lt;option value=\"pants\" &lt;% if(gdto.getCategory().equals(\"pants\")){ %&gt; selected &lt;% } %&gt; &gt;바지&lt;/option&gt; &lt;option value=\"shoes\" &lt;% if(gdto.getCategory().equals(\"shoes\")){ %&gt; selected &lt;% } %&gt; &gt;신발&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;상품이름&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\" value=\"${gdto.name}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;판매가격&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"price\" value=\"${gdto.price}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;색상&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"color\" value=\"${gdto.color}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;수량&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"amount\" value=\"&lt;%=gdto.getAmount() %&gt;\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;사이즈&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"size\" value=\"&lt;%=gdto.getSize()%&gt;\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;제품정보&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"content\" value=\"&lt;%=gdto.getContent() %&gt;\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;인기상품등록&lt;/td&gt; &lt;!-- best 0-아니요 1-예로 데이터처리 --&gt; &lt;td&gt; &lt;input type=\"radio\" name=\"best\" value=\"1\" &lt;%if(gdto.getBest() == 1){ %&gt; checked &lt;%} %&gt; &gt;예 &lt;input type=\"radio\" name=\"best\" value=\"0\"s &lt;%if(gdto.getBest() == 0){ %&gt; checked &lt;%} %&gt; &gt;아니요 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt; &lt;input type=\"submit\" value=\"상품수정\"&gt; &lt;input type=\"reset\" value=\"초기화\"&gt; &lt;input type=\"button\" value=\"뒤로가기\" onclick=\"location.href='./AdminGoodsList.ag'\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/fieldset&gt; AdminGoodsDAO.java 생성 후 getGoods(int gno)메서드 코드 추가 추후 spring framework를 하면 DTO에 담는 작업(dto.set()작업)은 스프링이 자동으로 진행해준다. 1234567891011121314151617181920212223242526272829303132//상품정보 가져오기public GoodsDTO getGoods(int gno) { GoodsDTO gdto = null; try{ getCon(); sql =\"select * from itwill_goods where gno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, gno); rs = pstmt.executeQuery(); if(rs.next()){ //추후 spring framework를 하면 DTO에 담는 작업은 스프링이 자동으로 진행해준다 gdto = new GoodsDTO(); gdto.setAmount(rs.getInt(\"amount\")); gdto.setBest(rs.getInt(\"best\")); gdto.setCategory(rs.getString(\"category\")); gdto.setColor(rs.getString(\"color\")); gdto.setContent(rs.getString(\"content\")); gdto.setDate(rs.getDate(\"date\")); gdto.setGno(rs.getInt(\"gno\")); gdto.setName(rs.getString(\"name\")); gdto.setPrice(rs.getInt(\"price\")); gdto.setSize(rs.getString(\"size\")); gdto.setImage(rs.getString(\"image\")); } System.out.println(\"해당 상품정보 저장 완료\"); }catch(Exception e){ e.printStackTrace(); }finally { closeDB(); } return gdto;}//end of getGoods AdminGoodsModifyProAction.java 생성1234567891011121314151617181920212223242526272829303132333435363738394041424344public class AdminGoodsModifyProAction implements Action{ @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : AdminGoodsModifyProAction의 execute() 호출\"); //관리자계정확인(세션 ID) HttpSession session = request.getSession(); String id = (String)session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null || !id.equals(\"admin\")){ //response.sendRedirect(\"./Main.me\"); 컨트롤러통해서 이동시키기 forward.setPath(\"./Main.me\"); forward.setRedirect(true); return forward; } //한글처리 request.setCharacterEncoding(\"UTF-8\"); //전달되는 파라미터값 GoodsDTO로 받아서 사용 GoodsDTO gdto = new GoodsDTO(); gdto.setAmount(Integer.parseInt(request.getParameter(\"amount\"))); gdto.setBest(Integer.parseInt(request.getParameter(\"best\"))); gdto.setCategory(request.getParameter(\"category\")); gdto.setColor(request.getParameter(\"color\")); gdto.setContent(request.getParameter(\"content\")); gdto.setGno(Integer.parseInt(request.getParameter(\"gno\"))); gdto.setName(request.getParameter(\"name\")); gdto.setPrice(Integer.parseInt(request.getParameter(\"price\"))); gdto.setSize(request.getParameter(\"size\")); //DB수정을 위해 DAO생성 -&gt; modifyGoods(gdto) AdminGoodsDAO agdao = new AdminGoodsDAO(); agdao.modifyGoods(gdto); //리스트 페이지이동 forward.setPath(\"./AdminGoodsList.ag\"); forward.setRedirect(true); return forward; }} AdminGoodsDAO.java 생성 후 modifyGoods(GoodsDTO gdto)메서드 코드 추가123456789101112131415161718192021222324//상품수정public void modifyGoods(GoodsDTO gdto) { try{ getCon(); sql=\"update itwill_goods set category=?,name=?,price=?,color=?,amount=?,\" + \"size=?,content=?,best=? where gno=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, gdto.getCategory()); pstmt.setString(2, gdto.getName()); pstmt.setInt(3, gdto.getPrice()); pstmt.setString(4, gdto.getColor()); pstmt.setInt(5, gdto.getAmount()); pstmt.setString(6, gdto.getSize()); pstmt.setString(7, gdto.getContent()); pstmt.setInt(8, gdto.getBest()); pstmt.setInt(9, gdto.getGno()); int tmp = pstmt.executeUpdate(); System.out.println(\"DAO : 상품정보 수정완료\"+ tmp); }catch(Exception e){ e.printStackTrace(); }finally { closeDB(); }}//end of modifyGoods","link":"/2020/09/08/200909jspi/"},{"title":"Servlet일반상품2 : 카테고리별 상품목록조회","text":"GoodsFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 123456789101112System.out.println(\"--------------@ 주소 비교후 처리 @-------------\");Action action = null;ActionForward forward = null;// 주소에 따른 처리 구분 (주소 매핑후 이동)if(command.equals(\"/GoodsList.go\")){ // http://localhost:8088/Model2JSP7/GoodsList.go System.out.println(\"C: /GoodsList.go 호출\"); //.go -&gt; Action_DAO_DB -&gt;.jsp로 이동 action = new GoodsListAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} GoodsListAction.java 생성1234567891011121314151617181920212223242526272829303132333435public class GoodsListAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : GoodsListAction의 execute() 호출\"); //한글처리 request.setCharacterEncoding(\"UTF-8\"); //카테고리별로 데이터 출력을 위한 카테고리파라미터값저장 String item = request.getParameter(\"item\"); System.out.println(\"카테고리 : \"+item); if(item == null){ item = \"all\"; } //GoodsDAO객체 생성 후 getGoodsList()생성 GoodsDAO gdao = new GoodsDAO(); //List&lt;GoodsDTO&gt; goodsList = gdao.GoodsListAll(); //전체상품 가져오기 List&lt;GoodsDTO&gt; goodsList = gdao.GoodsList(item); //카테고리별 전체상품가져오기 //등록된 상품 목록 전부 가져오기 System.out.println(\"M : \"+goodsList); //requset영역에 저장 request.setAttribute(\"goodsList\", goodsList); //goods_list.jsp 페이지이동(뷰페이지로이동) ActionForward forward = new ActionForward(); forward.setPath(\"./goods/goods_list.jsp\"); forward.setRedirect(false); return forward; }} GoodsDAO.java 생성 후 GoodsListAll()메서드 코드 추가 상품전제목록 조회 -&gt; 이거 대신 카테고리별 상품목록조회 GoodsList(String item)메서드 사용12345678910111213141516171819202122232425262728293031323334//상품 전체목록public List&lt;GoodsDTO&gt; GoodsListAll() { List&lt;GoodsDTO&gt; goodsList = new ArrayList&lt;GoodsDTO&gt;(); try { getCon(); sql = \"select * from itwill_goods\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); while(rs.next()){ GoodsDTO gdto = new GoodsDTO(); gdto.setGno(rs.getInt(\"gno\")); gdto.setCategory(rs.getString(\"category\")); gdto.setName(rs.getString(\"name\")); gdto.setPrice(rs.getInt(\"price\")); gdto.setColor(rs.getString(\"color\")); gdto.setAmount(rs.getInt(\"amount\")); gdto.setSize(rs.getString(\"size\")); gdto.setContent(rs.getString(\"content\")); gdto.setImage(rs.getString(\"image\")); gdto.setBest(rs.getInt(\"best\")); gdto.setDate(rs.getDate(\"date\")); goodsList.add(gdto); } System.out.println(\"DAO : 상품목록 모두 저장완료! \"+goodsList); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return goodsList; }//end of getGoodsList() GoodsDAO.java 생성 후 GoodsList(String item)메서드 코드 추가 item에 따라 쿼리구문이 달라진다. item이 각 카테고리명인 경우 sql = &quot;select * from itwill_goods where category=?&quot;; item == null인 경우 sql = &quot;select * from itwill_goods&quot;; item == best인 경우 sql = &quot;select * from itwill_goods where best=?&quot;; 따라서 String대신 StringBuffer를 써보자. 참고 : StringBuffer와 String의 차이점 아래 세가지 방법으로 StringBuffer를 String으로 나타낼수있다 pstmt = con.prepareStatement(SQL.toString()); pstmt = con.prepareStatement(SQL+””); +는 덧셈 또는 String타입으로 바꿔주는 두 가지 기능이 있다. 뒤에 + 공백이 붙으면 +가 두번째 기능을 해서 String으로 데이터 타입을 바꿔준다. 기억할 것! pstmt = con.prepareStatement(String.valueOf(SQL)); //object에 담아서 거기서 string으로 꺼낸다 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//카테고리별 상품목록 출력public List&lt;GoodsDTO&gt; GoodsList(String item) { List&lt;GoodsDTO&gt; goodsList = new ArrayList&lt;GoodsDTO&gt;(); //item에 따라 쿼리구문이 달라진다. 불변성때문에 String대신 따라서 StringBuffer를 사용 StringBuffer SQL = new StringBuffer(); try { getCon(); SQL.append(\"select * from itwill_goods\"); //item가 null인경우 if(item.equals(\"all\")){ }else if(item.equals(\"best\")){ SQL.append(\" where best=?\"); }else{ SQL.append(\" where category=?\"); } //아래 세가지 방법으로 StringBuffer를 string으로 나타낼수있다 pstmt = con.prepareStatement(SQL.toString()); //pstmt = con.prepareStatement(SQL+\"\"); //pstmt = con.prepareStatement(String.valueOf(SQL)); //object에 담아서 거기서 string으로 꺼낸다 if(item.equals(\"all\")){ }else if(item.equals(\"best\")){ pstmt.setInt(1, 1); //DB테이블안의 best값이 1인 요소만 출력 }else{ pstmt.setString(1, item); } rs = pstmt.executeQuery(); while(rs.next()){ GoodsDTO gdto = new GoodsDTO(); gdto.setGno(rs.getInt(\"gno\")); gdto.setCategory(rs.getString(\"category\")); gdto.setName(rs.getString(\"name\")); gdto.setPrice(rs.getInt(\"price\")); gdto.setColor(rs.getString(\"color\")); gdto.setAmount(rs.getInt(\"amount\")); gdto.setSize(rs.getString(\"size\")); gdto.setContent(rs.getString(\"content\")); gdto.setImage(rs.getString(\"image\")); gdto.setBest(rs.getInt(\"best\")); gdto.setDate(rs.getDate(\"date\")); goodsList.add(gdto); } System.out.println(\"DAO : 상품목록 모두 저장완료! \"+goodsList); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return goodsList; } goods_list.jsp 생성 제품의 총 개수를 카테고리수 만큼만 출력하고 그 이상인 경우 다음 row로 출력하려면 어떻게 하면 될까? 필요한 정보 : total개수, row개수, col개수 예를 들어 total 16개 col은 8개 =&gt; 필요한 row는 2개 예를 들어 total 17개 col은 8개 =&gt; 필요한 row는 3개 내코드12int result = goodsCnt%col;int row = result == 0 ? result:result+1; 강사님코드1int row = (goodsCnt/col) + (goodsCnt%col&gt;0? 1:0); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 &lt;%// request영역에서 정보를 꺼내서 테이블에 추가 List&lt;GoodsDTO&gt; goodsList = (List&lt;GoodsDTO&gt;)request.getAttribute(\"goodsList\"); //object-&gt;list타입 캐스팅 %&gt;&lt;fieldset&gt;&lt;legend&gt;상품목록&lt;/legend&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"button\" class=\"btnCate\" value=\"전체\" onclick=\"location.href='./GoodsList.go'\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" class=\"btnCate\" value=\"인기상품(Best)\" onclick=\"location.href='./GoodsList.go?item=best'\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" class=\"btnCate\" value=\"아우터\" onclick=\"location.href='./GoodsList.go?item=outwear'\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" class=\"btnCate\" value=\"정장\" onclick=\"location.href='./GoodsList.go?item=fulldress'\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" class=\"btnCate\" value=\"티셔츠\" onclick=\"location.href='./GoodsList.go?item=Tshirts'\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" class=\"btnCate\" value=\"셔츠\" onclick=\"location.href='./GoodsList.go?item=shirts'\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" class=\"btnCate\" value=\"바지\" onclick=\"location.href='./GoodsList.go?item=pants'\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" class=\"btnCate\" value=\"신발\" onclick=\"location.href='./GoodsList.go?item=shoes'\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% //필요한 정보 : total개수, row개수, col개수 //total 16개 col은 8개 =&gt; 필요한 row는 2개 //total 17개 col은 8개 =&gt; 필요한 row는 3개 int goodsCnt = goodsList.size(); int col = 8; //내코드/* int result = goodsCnt%col; int row = result == 0 ? result:result+1; */ //강사님코드 int row = (goodsCnt/col) + (goodsCnt%col&gt;0? 1:0); int checkNum = 0; //출력개수를 총개수보다 많지 않게 처리하는 값을 저장하는 변수 for(int i=0; i&lt;row; i++){ %&gt; &lt;tr&gt; &lt;% for(int j=0; j&lt;col; j++){ //List 한칸의 정보 -&gt; GoodsDTO 객체 하나로 이동 GoodsDTO gdto = goodsList.get(checkNum); %&gt; &lt;td&gt; &lt;img src=\"./upload/&lt;%=gdto.getImage().split(\",\")[0]%&gt;\" height=\"100\"&gt;&lt;br&gt; &lt;a href= \"./GoodsDetail.go?gno=&lt;%=gdto.getGno()%&gt;\"&gt;&lt;%=gdto.getName() %&gt;&lt;/a&gt;&lt;br&gt; 가격 : &lt;%=gdto.getPrice() %&gt;원&lt;br&gt; &lt;input type=\"button\" class=\"btn\" value=\"장바구니\" onclick=\"location.href='./AdminGoodsDeleteAction.ag?gno=&lt;%=gdto.getGno()%&gt;'\"&gt; &lt;/td&gt; &lt;% checkNum++; if(checkNum == goodsCnt) break; } %&gt; &lt;/tr&gt; &lt;% } //end of for-i반복문 %&gt; &lt;/table&gt; &lt;/fieldset&gt;","link":"/2020/09/09/200910jspi2/"},{"title":"Servlet일반상품3 : 상품 상세페이지, c:forTokens","text":"GoodsFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 12345678 //상품 상세페이지}else if(command.equals(\"/GoodsDetail.go\")){ System.out.println(\"C: /GoodsList.go 호출\"); //.go -&gt; Action -&gt; DB(DAO) -&gt;.jsp로 이동 action = new GoodsDetailAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} GoodsDetailAction.java 생성 GoodsDAO객체 생성 후 getGoodsDetail()생성시 아래 코드를 한줄로 나타낼 수 있다. 변수를 굳이 사용하지않는다면 한 줄코딩하는 것이 좋다. 123456//두줄GoodsDTO gdto = gdao.getGoodsDetail(gno);request.setAttribute(\"gdto\", gdto);//한줄 처리request.setAttribute(\"gdto\", gdao.getGoodsDetail(gno)); 전체코드 12345678910111213141516171819202122232425262728public class GoodsDetailAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : GoodsDetailAction의 execute() 호출\"); //한글처리 request.setCharacterEncoding(\"UTF-8\"); //전달받은 파라미터 저장 int gno = Integer.parseInt(request.getParameter(\"gno\")); //GoodsDAO객체 생성 후 getGoodsDetail()생성 GoodsDAO gdao = new GoodsDAO(); GoodsDTO gdto = gdao.getGoodsDetail(gno); //requset영역에 저장 request.setAttribute(\"gdto\", gdto); //위와 동일한 코드 //request.setAttribute(\"gdto\", gdao.getGoodsDetail(gno)); //goods_list.jsp 페이지이동(뷰페이지로이동) ActionForward forward = new ActionForward(); forward.setPath(\"./goods/goods_detail.jsp\"); forward.setRedirect(false); return forward; }} AdminGoodsDAO.java 생성 후 getGoodsDetail()메서드 코드 추가123456789101112131415161718192021222324252627282930313233//상품 상세정보 가져오기public GoodsDTO getGoodsDetail(int gno) { GoodsDTO gdto = null; try { getCon(); sql = \"select * from itwill_goods where gno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, gno); rs = pstmt.executeQuery(); if(rs.next()){ gdto = new GoodsDTO(); gdto.setGno(rs.getInt(\"gno\")); gdto.setCategory(rs.getString(\"category\")); gdto.setName(rs.getString(\"name\")); gdto.setPrice(rs.getInt(\"price\")); gdto.setColor(rs.getString(\"color\")); gdto.setAmount(rs.getInt(\"amount\")); gdto.setSize(rs.getString(\"size\")); gdto.setContent(rs.getString(\"content\")); gdto.setImage(rs.getString(\"image\")); gdto.setBest(rs.getInt(\"best\")); gdto.setDate(rs.getDate(\"date\")); } System.out.println(\"상품 상세정보 저장 완료\"); } catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } return gdto;}//end of 상품상세정보가져오기 goods_detail.jsp 생성 DB의 정보를 request에 저장했고 그걸 불러와서 select항목에 넣을 수 있다. 이때 두가지 방법이 있다. &lt;c:forEach&gt;와 &lt;c:forTokens&gt;의 차이점은 &lt;c:forTokens&gt;의 경우 문자열을 분리자를 사용해서 분리해서 출력가능 12345678&lt;c:forTokens var=\"name\" items=\"고양이,강아지,소\" delims=\",\"&gt; &lt;p&gt;&lt;c:out value=\"${name}\"/&gt;&lt;/p&gt;&lt;/c:forTokens&gt;//출력결과고양이강아지소 첫번째 방법 : forTokens +스크립틀릿사용123456789101112&lt;select&gt; &lt;option value=\"\"&gt;선택하세요&lt;/option&gt; &lt;c:forTokens var=\"size\" items=\"\"&lt;%=gdto.getSize() %&gt;\" delims = \",\"&gt; &lt;option value=\"${gdto.size}\"&gt;${size}&lt;/option&gt; &lt;/c:forTokens&gt;&lt;/select&gt;//출력값S M L XL 두번째 방법 : forTokens + EL태그사용123456789101112&lt;select&gt; &lt;option value=\"\"&gt;선택하세요&lt;/option&gt; &lt;c:forTokens var=\"color\" items=\"${gdto.color}\" delims = \",\"&gt; &lt;option value=\"${gdto.color}\"&gt;${color}&lt;/option&gt; &lt;/c:forTokens&gt;&lt;/select&gt;&lt;br&gt;//출력값whiteblackyellow javascript 코드 한줄로 불러오기 a태그를 이용하면 href로 항상 페이지이동이 된다. 이를 막기 위해서는 2가지 방법이 있다. e.preventDefault(); javascript:isBasket(); 12345//원치않는 href=\"#\"가 진행되어 페이지이동이 일어난다(여기선 새로고침)&lt;a href=\"\" onclick=\"isBasket();\"&gt; [장바구니 담기] &lt;/a&gt;//이렇게부르면 페이지이동없이 자바스크립트를 실행할 수 있다&lt;a href=\"javascript:isBasket();\"&gt; [장바구니 담기] &lt;/a&gt; 구매수량이 재고보다 많은 경우 제어 자바표현식 : DB정보를 꺼내오기 불가능. 페이지 구성상 제일 마지막에 호출되므로 자바표현식으로 사용불가능 EL표현식 : DB정보를 꺼내오기 가능. 자바스크립트태그안에서는 EL표현식을 문자형태(‘’)로 사용하는 것이 일반적. 문자형태로 쓰지않아도 객체로 처리되기때문에 동일하게 처리되나 문법상 문자형태로 (‘’)써줘야 함. 12345678910111213// 구매 수량var buyCnt = document.goodsform.amount.value;// 남은 수량 (DTO정보)var DBCnt = &lt;%=gdto.getAmount()%&gt; //에러var DBCnt = ${gdto.amount}; //사용가능var DBCnt = '${gdto.amount}'; //문자형태도 사용가능if(buyCnt &gt; DBCnt){ alert(\"구매 수량을 조절하시오\"); document.goodsform.amount.focus(); return;} 전체코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;%// GoodsDetailAction 에서 저장한 상품 정보를 받아오기GoodsDTO gdto = (GoodsDTO) request.getAttribute(\"gdto\");%&gt;&lt;form action=\"\" method=\"post\" name=\"goodsform\"&gt;&lt;input type=\"hidden\" name=\"name\" value=\"&lt;%=gdto.getName()%&gt;\"&gt;&lt;input type=\"hidden\" name=\"price\" value=\"${gdto.price }\"&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"./upload/&lt;%=gdto.getImage().split(\",\")[0]%&gt;\" width=\"300\" height=\"300\"&gt; &lt;/td&gt; &lt;td&gt; 상품명 : ${gdto.name} &lt;br&gt; 판매가격 : &lt;%=gdto.getPrice() %&gt;원&lt;br&gt; 구매수량 : &lt;input type=\"text\" name=\"amount\"&gt;개&lt;br&gt; 남은수량 : ${gdto.amount}개&lt;br&gt; 크기 : &lt;select name=\"size\"&gt; &lt;option value=\"\"&gt;선택하세요&lt;/option&gt; &lt;c:forTokens var=\"size\" items=\"&lt;%=gdto.getSize() %&gt;\" delims = \",\"&gt; &lt;option&gt;${size}&lt;/option&gt; &lt;/c:forTokens&gt; &lt;/select&gt; &lt;br&gt; 색상 : &lt;select name=\"color\"&gt; &lt;option value=\"\"&gt;선택하세요&lt;/option&gt; &lt;c:forTokens var=\"color\" items=\"${gdto.color}\" delims = \",\"&gt; &lt;option&gt;${color}&lt;/option&gt; &lt;/c:forTokens&gt; &lt;/select&gt; &lt;br&gt; &lt;!-- &lt;input type=\"button\" class=\"btn\" value=\"[장바구니 담기]\" onclick=\"isBasket();\" &gt; --&gt; &lt;input type=\"button\" class=\"btn\" value=\"[장바구니 담기]\" onclick=\"javascript:isBasket();\" &gt; &lt;input type=\"button\" class=\"btn\" value=\"[바로 구매하기]\" onclick=\"javascript:isBasket();\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt; &lt;h2&gt;상세페이지&lt;/h2&gt; &lt;img src=\"./upload/&lt;%=gdto.getImage().split(\",\")[0]%&gt;\" width=\"400\" height=\"600\"&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;script type=\"text/javascript\"&gt;/* 장바구니 기능 구현 *///각각의 링크 클릭시 해당 페이지로 정보를 가지고 이동function isBasket() { //유효성체크 //사이즈선택유무 if(document.goodsform.size.value == \"\"){ alert(\"사이즈를 선택하세요\"); document.goodsform.size.focus(); return false; } //색상선택유무 if(document.goodsform.color.value == \"\"){ alert(\"색상을 선택하세요\"); document.goodsform.color.focus(); return; } //수량기입유무 if(document.goodsform.amount.value == \"\"){ alert(\"수량을 입력하세요\"); document.goodsform.amount.focus(); return; //수량이 재고보다 많은 경우 }else if(document.goodsform.amount.value &gt; ${gdto.amount}){ alert(\"수량을 남은 수량 ${gdto.amount}개 이하로 입력하세요\"); document.goodsform.amount.focus(); return; } //이동 let result = confirm(\"장바구니로 이동하시겠습니까?\"); if(result){ //form action속성에 주소입력 document.goodsform.action = \"./BasketAdd.ba?gno=${gdto.gno}\"; //form태그 정보를 가지고 페이지 이동 document.goodsform.submit(); }else{ return; }}&lt;/script&gt;","link":"/2020/09/14/200915jspi/"},{"title":"datafile 관리하기","text":"datafile 저장영역 구조 모든 Datafile은 Tablespace로 감싸져있어야한다 Tablespace : 논리적 저장 영역 구조 논리적이기때문에 SIZE가 없다. Tablespace 개수 ≤ Datafile 개수 Tablespace개수가 Datafile개수보다 더 많을 수 없다. DB생성시 system데이터파일/system테이블스페이스와 undo데이터파일/undo테이블스페이스는 필수이다. 두 용어의 차이. 헷갈리지말 것 extent : segment(객체)의 확장단위·할당단위 extend : datafile의 확장단위 datafile 내용 보기 데이터파일안의 구성은 v$datafile와 v$tempfile를 통해서 알 수 있다. 1234567891011121314SQL&gt; select name from v$datafile;NAME--------------------------------------------------------------------------------/u01/app/oracle/oradata/ORCL/datafile/o1_mf_system_fwvn49fw_.dbf/u01/app/oracle/oradata/ORCL/datafile/o1_mf_sysaux_fwvn5f1l_.dbf/u01/app/oracle/oradata/ORCL/datafile/o1_mf_undotbs1_fwvn66mp_.dbf/u01/app/oracle/oradata/ORCL/datafile/o1_mf_users_fwvn681o_.dbfSQL&gt; select name from v$tempfile;NAME--------------------------------------------------------------------------------/u01/app/oracle/oradata/ORCL/datafile/o1_mf_temp_fwvnbgvk_.tmp system.dbf : Data dictionary sysaux.dbf : 통계 데이터을 모아놓은 파일, undo.dbf : undo데이터, DML작업은 COMMIT도 되지만 ROLLBACK도 되기때문에 오라클은 변경작업하기전에 이전 데이터의 복사본을 UNDO데이터 파일에 올려놓는다. users.dbf : 일반 user 소유의 object를 보관하기 위한 파일 temp.tmp : 임시데이터. sub쿼리의 결과값을 저장하는 파일(메인쿼리실행할때 참조함), order by절이나 group by절을 실행하면 정렬을 해야하므로 임시데이터를 생성함. dist 중복된 값 제거를 위해서 정렬을 해야하기때문에 임시데이터를 생성함. 일반적인 회사는 system.dbf, sysaux.dbf, undo.dbf,temp.tmp는 기본으로 있고 회사의 규모에 따라 users.dbf파일의 개수가 차이난다. Tablespace이름과 datafile이름을 함께 보는 쿼리 tablespace의 개수와 tablespace이름, 데이터파일이름을 알아보는 쿼리이다. 12345678910111213141516171819 1 select d.ts#, t.name as \"T/S name\", d.name \"Datafile name\" 2 from v$datafile d 3 join v$tablespace t 4* on d.ts# = t.ts#SQL&gt; / TS# T/S name Datafile name---------- -------------------- ---------------------------------------- 0 SYSTEM /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_system_fwvn49fw_.dbf 1 SYSAUX /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_sysaux_fwvn5f1l_.dbf 2 UNDOTBS1 /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_undotbs1_fwvn66mp_.dbf 4 USERS /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_users_fwvn681o_.dbf DB공간관리, DB공간 늘리는 3가지 방법 새로운 Tablespace를 추가해서 DB공간을 늘릴 수 있다. why? Tablespace를 추가하려면 반드시 하나이상의 데이터파일이 속해있어야한다. 따라서 데이터파일의 물리적 크기만큼 DB공간을 늘릴 수 있다. 기존 Tablespace에 데이터파일을 추가하여 DB공간을 늘릴 수 있다. 기존 데이터파일의 크기를 늘려서 DB공간을 늘릴 수 있다. EM을 이용하여 새로운 Tablespace를 추가해서 DB공간을 늘리기 EM접속 -&gt; storage탭 -&gt; Tablespace 클릭 -&gt; create버튼 클릭 -&gt; 속성 설정하고 OK EM을 이용하여 기존 Tablespace에 데이터파일을 추가하여 DB공간 늘리기 EM접속 -&gt; storage탭 -&gt; Tablespace 클릭 -&gt; 기존테이블스페이스 클릭 -&gt; add datafile 버튼 클릭 -&gt; 속성 설정하고 OK EM을 이용하여 기존 데이터파일의 크기를 늘려서 DB공간을 늘리기 EM접속 -&gt; storage탭 -&gt; Tablespace 클릭 -&gt; 기존 데이터파일의 클릭 -&gt; action 버튼 클릭 -&gt; resize 클릭 -&gt; 속성 설정하고 OK 명령어로 새로운 Tablespace를 추가해서 DB공간을 늘리기 autoextend on : 자동확장기능 옵션, 기존사이즈 100M가 다 차면 10M씩 최대 500M까지 늘어난다 maxsize지정안하면 사이즈가 무한대다. 1234567891011121314151617181920212223242526272829303132333435363738SQL&gt; create tablespace appuser 2 datafile '/u01/app/oracle/oradata/ORCL/datafile/appuser01.dbf' size 100M 3 autoextend on next 10M maxsize 500M;Tablespace created.//생성한 테이블스페이스 확인하기SQL&gt; select d.ts#, t.name as \"T/S name\", d.name \"Datafile name\" 2 from v$datafile d 3 join v$tablespace t 4 on d.ts# = t.ts#; TS# T/S name Datafile name---------- -------------------- ---------------------------------------- 0 SYSTEM /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_system_fwvn49fw_.dbf 4 USERS /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_users_hp871s7n_.dbf 1 SYSAUX /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_sysaux_fwvn5f1l_.dbf 2 UNDOTBS1 /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_undotbs1_fwvn66mp_.dbf TS# T/S name Datafile name---------- -------------------- ---------------------------------------- 6 EXAMPLE /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_example_hp86s7s0_.dbf 4 USERS /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_users_fwvn681o_.dbf 7 APPUSER /u01/app/oracle/oradata/ORCL/datafile/ap puser01.dbf7 rows selected. 명령어로 기존 Tablespace에 데이터파일을 추가하여 DB공간 늘리기1234567891011121314151617181920212223242526272829303132333435SQL&gt; alter tablespace appuser 2 add datafile '/u01/app/oracle/oradata/ORCL/datafile/appuser02.dbf' size 50M;Tablespace altered.//기존 테이블스페이스에 새로 셍성한 데이터파일 확인하기SQL&gt; @/home/oracle/checkTablespaceNname.sql TS# T/S name Datafile name---------- -------------------- ---------------------------------------- 0 SYSTEM /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_system_fwvn49fw_.dbf 4 USERS /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_users_hp871s7n_.dbf 1 SYSAUX /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_sysaux_fwvn5f1l_.dbf 2 UNDOTBS1 /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_undotbs1_fwvn66mp_.dbf 6 EXAMPLE /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_example_hp86s7s0_.dbf 4 USERS /u01/app/oracle/oradata/ORCL/datafile/o1 _mf_users_fwvn681o_.dbf 7 APPUSER /u01/app/oracle/oradata/ORCL/datafile/ap puser01.dbf 7 APPUSER /u01/app/oracle/oradata/ORCL/datafile/ap puser02.dbf8 rows selected. 명령어로 기존 데이터파일의 크기를 늘려서 DB공간을 늘리기12345678910111213141516171819202122232425262728293031323334353637383940SQL&gt; alter database datafile '/u01/app/oracle/oradata/ORCL/datafile/appuser01.dbf'SQL&gt; resize 200M;Database altered.//변경사항 확인하기SQL&gt; 1 select d.ts#, t.name as \"T/S name\", d.name \"Datafile name\", d.bytes \"Size\" 2 from v$datafile d 3 join v$tablespace t 4* on d.ts# = t.ts#SQL&gt; / TS# T/S name Datafile name Size---------- --------------- ---------------------------------------- ---------- 0 SYSTEM /u01/app/oracle/oradata/ORCL/datafile/o1 838860800 _mf_system_fwvn49fw_.dbf 4 USERS /u01/app/oracle/oradata/ORCL/datafile/o1 31457280 _mf_users_hp871s7n_.dbf 1 SYSAUX /u01/app/oracle/oradata/ORCL/datafile/o1 555745280 _mf_sysaux_fwvn5f1l_.dbf 2 UNDOTBS1 /u01/app/oracle/oradata/ORCL/datafile/o1 73400320 _mf_undotbs1_fwvn66mp_.dbf TS# T/S name Datafile name Size---------- --------------- ---------------------------------------- ---------- 6 EXAMPLE /u01/app/oracle/oradata/ORCL/datafile/o1 52428800 _mf_example_hp86s7s0_.dbf 4 USERS /u01/app/oracle/oradata/ORCL/datafile/o1 5242880 _mf_users_fwvn681o_.dbf 7 APPUSER /u01/app/oracle/oradata/ORCL/datafile/ap 209715200 puser01.dbf 7 APPUSER /u01/app/oracle/oradata/ORCL/datafile/ap 52428800 puser02.dbf Tablespace 삭제 EM사용할 경우 drop버튼 클릭하면 끝! 명령어인 경우 and datafiles 옵션: 데이터파일은 rm명령어로 따로 지워여하는데 옵션을 사용하면 함께 삭제가능 cascade constraints 옵션: PK컬럼에 FK가 걸려있으면 삭제시 에러가 발생한다. PK컬럼에 FK가 걸려있는데도 삭제하고싶을 때 해당 옵션을 사용하여 FK제약조건을 삭제하여 PK컬럼도 삭제가능 FK걸려있는 제약조건만 삭제되지 FK걸려있던 해당 컬럼은 그대로 유지된다. 123drop tablespace appuser including contents[and datafiles][cascade constraints];","link":"/2020/09/17/200918dbi/"},{"title":"프론트엔드 직무멘토링","text":"직무멘토링 후기오늘은 보라님께서 프론트엔드로 근무하시는 현직자분과의 직무멘토링 자리를 마련해주셨다.정말 보라님은 천사인듯. 멘토링의 주제는 취준생일때 하면 좋은 것들과 신입일때 하면 좋은 것들에 대해서였고 생각보다 시간이 빨리 흘렀다.막막하기만 했던 취준에 한줄기 빛이랄까…?어두컴컴했던 길을 밝혀주는 빛…!한시간 반이라는 시간동안 엄청나게 꿀팁과 살아있는 지식들을 많이 배웠다. 어차피 떨어질 코딩테스트라고 생각하고 항상 막막해하고 지원조차를 포기한 적도 많은데..뜨끔멘토링을 듣고 생각이 바뀌었다. 나처럼 코테 피해가려는 취준생이 많다는 것. 나는 이제 피하지않을 것이다.🔥어떻게든 부딪혀보자.🔥 취준하시는 동안 살짝 자만하셨다고 하는데 그 말이 왜 이렇게 부럽던지…나도 자만할 수 있는 사람이었으면 좋겠다.자만할 수 있다는 것은 그만큼 자신의 실력에 자신이 있다는 거니까. 취준이야기 프로젝트는 다다익 완성을 목표로 하되, 가능하면 출시를 할 것. 자신이 짠 코드는 100%, 최소한 90%는 이해할 것 =&gt; 면접때 백퍼나옴 최소한 두명이상의 같은 직군 개발자와 개발해 볼 것. PR 리뷰를 통한 성장 리베이스/머지 과정에서 충돌 해결 경험 다른 직군 개발자와 개발해볼 것 프론트라면 백엔드와 협업 : API명세, 우선순위 등 디자이너가 있는 곳에거 같이 개발해 볼 것. 기획자도 있으면 더 좋음 디자인대로 개발하는 것이 중요하면서도 참 어렵다. 라이브러리를 너무 많이 의존하지말것 postcss-loader같은 경우 에러가 발생할 수 있음 -&gt; 서버가 터질 수도 있다. 라이브러리 최소화하려고 노력할 것 취업방향 어떻게 잡아야할까? 모바일, 웹프론트, 백엔드, 데브옵스, 게임 데이터엔지니어링, 딥러닝 등등 가능한 많은 것을 접해보고 취업방향을 결정하는 것이 좋다. -&gt; 분야를 결정했다면 한가지를 깊게 공부할 것. 도메인으로 결정해도 좋다 예를 들어 스트리밍 음악 서비스같은 것을 구현하고싶다면, 벡앤드: 스트리밍 기능, 스트리밍API 프론트: 음악플레이어 플랫폼: 웹 앱등 취업전 다른 개발자들과 개발경험은 어디서 쌓을까? 동아리 : nexters. yapp, ddd등 한 커뮤니티를 뚫으면 인맥도 늘어나고 기술도 늘어난다. 아래 교육은 회사에서도 알아주는 좋은 프로그램이다. SSAFY Software maestro 42 seoul BOB 정보보안 면접준비 면접질문 리스트 CS : 운영체제, 자바 어떻게 돌아가는지 등등 호이스팅이 뭔지? 왜 호이스팅을 쓰는지? 게임회사 : 게임에 사용되는 프로토콜을 뭘 쓸꺼냐 TCP? UDP?? CS(Computer Science) 위주로 공부 무조건 많이 알수록 유리하다 진행한 프로젝트에 대해서 기술위주로 100%이해할 것 한 가지 언어라도 깊게 공부할 것 =&gt; T자형 인재 회사선택의 기준 최소기준 선정 : 매출액 100억이상, 50명이상, 사수가 있는 회사, 자체 서비스를 보유하고 있는 회사 자신만의 기준을 만드는 것이 중요 포인트는 내가 성장할 수 있는 기준 도메인 선정 : 핀테크, e-commerce 지원 : 공채는 무조건 넣어볼 것 (떨어져도 영향이 없음) -&gt; 블라인드 코딩테스트 전부 지원 혼자서 알고리즘 공부하기 힘들어서 블라인드 코딩테스트를 다 신청해서 준비하면서 공부하게 됨 수시지원도 좋은 경험 학생의 장점 : 네이버 핵데이, 라인 체험형 인턴등 취업에 비해 경쟁률이 높지 않을 뿐더러 대기업에 입사할 수 있는 가장 좋은 기회 Q. 출시가 중요하다고 하셨는데 JAVA는 어떻게 출시하면 될까요? 백엔드는 API를 만들 수 있다. 예를 들어 음악을 좋아한다면 스트리밍 API등, 또한 JSP로 웹페이지 만들 수도 있다. 계속 한 가지 기능을 파고드는 것도 좋다. Q. 세미나 스태프나 직접 세미나 운영이랑 홍보해본것도 취업할때 조금은 도움이 될까요? 실력이 최우선이다. 취업에 그렇게 큰 도움이 되지않는다. 하지만 다른 활동을 하면 나란 사람을 파악하는 데에 좋다 Q. 현재 회사의 취업과정이 궁금합니다. 코딩테스트 합격자 위주로 해커톤을 했고 사이렌오더를 만들어서 성공(클라이언트: 안드로이드) 후 특채로 취업 신입이야기신입자세 가능하면 기록할 것 회사는 배우는 곳이 아님 스스로 찾아내고 학습하고 성장함 모든 작업내용은(자신이 무엇을 했는지) 팀원들에게 공유할 것 -&gt; 얘는 뭘 하고있구나를 사수들이 알 수 있음. 오히려 이 시기에 질문을 많이 하는 것이 좋음 신입때는 보통 간단한 토이 프로젝트를 진행하게 됨. 시간이 남으면 회사 프로젝트의 구조 파악할 것 webpack 설정, directory구조, architecture패턴등 공부할 것이 많음 =&gt; 레포파서 똑같이 만들어 볼 것 사수가 바라는 신입 탄탄하게 성장해주고 커피를 사달라고해도 좋아한다. 한번씩 사주고 (기브앤테이크) 해볼것을 다 다해보고 해본 내용을 정리한 뒤 이런거 해보고 저런거해봤는데 이런결과만 나왔습니다 조언이 필요합니다 라는 식으로 질문을 할 것. 신입 사수에게 질문하기 좋은 타이밍 DM으로 질문해도 괜찮은지 물어보는 것이 예의 질문을 올려놓고 편할때 답을 달라고 해도 됨 채팅을 통한 질문은 비동기임(시간이 되면 답을 주는 것) 대면질문이 가장 좋다. Q. 40~50대 개발자분들도 많이 있나요? 개발자 수명은 자신의 노력에 따라 다르다. 40~50대도 현업에 계시는 분이 있다. 개발자의 수명은 자신의 손에 달려있다. Q. 회사에서 가장 많이 하시는 일이 뭔지 자세히 알려주실 수 있으신가요? 마크업작업(컴포넌트를 많이 사용, 디자인시스템인 스토리북을 사용하여 정형화된 디자인을 사용) -&gt; API붙이는거(명세서는 백엔드에서 작성한 걸 보고 함 -&gt; 올드한 방식 지라문서 -&gt; 스웨거를 최근 자주 사용) 스토리북 페이지 단위의 개발이 이루어지던 과거와 달리 요즘의 프론트엔드 개발은 주로 컴포넌트 단위로 이루어진다. 이 컴포넌트라는 개념은 사용하는 라이브러리나 프레임워크에 따라 구현 방식이 다르지만, 철학은 거의 동일하다. 원래 컴포넌트는 외부 상태의 영향을 받지않는 독립된 개체로서, 고립된 환경에서도 자신만의 스타일과 상태를 가질 수 있어야 한다.컴포넌트 단위의 개발 환경을 지원하는 도구다. 개발자가 뷰를 개발할 때 고립된 환경을 제공해서 관심사를 의존성과 환경으로부터 분리시켜 준다.출처 : https://hyunseob.github.io/2018/01/08/storybook-beginners-guide/ Storybook 도입 - 마이구미 깃허브 저장소 : https://github.com/storybookjs/storybook/tree/master/addons/docs 스토리북 예시 지라 모든 유형의 팀이 작업을 관리할 수 있도록 설계됨. 원래 Jira는 버그 및 이슈 트랙커로 고안되었지만, 오늘날에는 요구 사항 및 테스트 사례 관리에서 애자일 소프트웨어 개발에 이르기까지 모든 유형의 사례에 적용할 수 있는 작업 관리 도구 소프트웨어 프로세스 관리 도구 JIRA 와 사용법 정리 - melonicedlatte 스웨거 API 관리 도구 전체 API에 대한 개요를 작성할 수 있으며, 추가적으로 태그(Tag)를 넣어서 각 API를 분류가능 Swagger Hub를 이용한 REST API 관리 - 안경잡이 개발자 가장 기억에 남는 면접질문과 가장 잘 대답했다고 생각하는 면접질문이 있을까요? 가장기억에 남는 질문 - url에 www.a.com 을 검색했을 때 일어나는 행동을 아는데로 말해보라는 질문이 기억에 남습니다. 면접 보기 전에 위 내용과 관련해서 공부했었는데 마침 딱 나와서 약 5분가량 대답을 했고, 잘 대답했다고 생각했는데 그 면접에서 떨어져서 기억이 나네요 ㅎㅎ가장 잘 답했다고 생각하는 질문 - GC에 대한 대답이었습니다. 처음 질문은 JVM 메모리 구조에 대한 질문이었는데, GC와 관련해서 공부를 열심히 했었기에 JVM 메모리 구조를 설명하면서 GC의 질문을 하도록 유도했고, 그게 먹혀들어서 바로 GC관련 질문을 해주셨었기에 잘 대답을 할 수 있었습니다.면접에서 위처럼 자신이 아는 질문으로 유도하는 것도 하나의 기술이기도 해요","link":"/2020/09/21/200921opemsource/"},{"title":"Servlet관리자용주문목록3 : 고객주문목록에서 주문 상태 및 운송장정보 변경","text":"주문상태,운송장번호 수정 시나리오 페이지 요청 : /AdminOrderDetail.ao?trade_num=20200917-1 주문상태, 운송장 번호 입력 주문번호 저장해서 이동 (hidden) ‘수정하기’ 버튼 클릭 -&gt; submit 수정할 페이지 이동 (+ 가상주소) 주문상태, 운송장번호, 주문번호 컨트롤러 -&gt; Action -&gt; DAO DAO 이동시 (주문상태, 운송장번호, 주문번호 )포함 이동 update 구문사용 (주문상태,운송장번호 수정) 주문번호 - 조건절 페이지 이동 (관리자 주문 리스트) AdminOrderFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가12345678910111213 //주문상태와 운송장번호 변경}else if(command.equals(\"/AdminOrderModify.ao\")){ System.out.println(\"C : AdminOrderModify.ao 호출\"); action = new AdminOrderModifyAction(); try{ forward = action.execute(request, response); }catch(Exception e) {e.printStackTrace();} //주문상태와 운송장번호 변경을 볼 수 있는 상세페이지}else if(command.equals(\"/AdminOrderDetail.ao\")){ System.out.println(\"C : AdminOrderDetails.ao 호출\"); action = new AdminOrderDetailAction(); try{ forward = action.execute(request, response); }catch(Exception e) {e.printStackTrace();} } AdminOrderModifyAction.java 생성123456789101112131415161718192021222324252627282930313233343536373839404142public class AdminOrderModifyAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : AdminOrderModifyAction의 execute() 호출\"); //한글처리 request.setCharacterEncoding(\"UTF-8\"); // 로그인 정보 (로그인 처리필요) HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null || !id.equals(\"admin\")){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } //전달정보 파라미터값 저장 String trade_num = request.getParameter(\"trade_num\"); int status = Integer.parseInt(request.getParameter(\"status\")); String trans_num = request.getParameter(\"trans_num\"); //AdminOrderDAO 객체 생성 -&gt; 배송지 수정등을 가능하게 하면 받아야할 파라미터가 많아져서 비효율적이다. //=&gt; DTO를 사용하면 한번에 들고 다닐 수 있다. OrderDTO odto = new OrderDTO(); odto.setO_trade_num(request.getParameter(\"trade_num\")); odto.setO_status(Integer.parseInt(request.getParameter(\"status\"))); odto.setO_trans_num(request.getParameter(\"trans_num\")); AdminOrderDAO aodao = new AdminOrderDAOImpl(); //aodao.updateOrder(trade_num); //주문상태만 단순변경하는 메서드 aodao.updateOrder(odto); //주문상태와 운송번호 같이 변경하는 메서드 +a 가능 //페이지이동 forward.setPath(\"./AdminOrderList.ao\"); forward.setRedirect(true); return forward; }} AdminOrderDAO.java에 updateOrder()메서드 코드 추가12345678910111213141516public interface AdminOrderDAO { // 인터페이스안의 추상메서드이기때문에 // 관리자가 주문목록을 확인하는 기능 getAdminOrderList() public List getAdminOrderList(); // 주문번호를 이용하여 주문상태만 변경 public void updateOrder(String trade_num); // 주문번호를 사용해서 주문상태,운송장번호 변경 가능 public void updateOrder(OrderDTO odto); // 주문번호에 해당하는 주문정보(리스트 전체)를 가져오는 동작을 처리 public abstract List getAdminOrderDetail(String trade_num); } AdminOrderDAOImpl.java에 updateOrder()메서드 오버라이딩하여 코드 추가 updateOrder(String trade_num)메서드는 pstmt.setInt(1, 1)` 이렇게 작성하면 다른 옵션들은 처리를 고민해야한다. 1~5번까지(1-“발송준비” 2 - “발송완료” 3 - “배송중” 4 - “배송완료” 5 - “주문취소”) 모든 버튼을 다 만들어야할까? 따라서 이 코드는 매우 비효율적이다. 따라서 updateOrder(OrderDTO odto)메서드를 작성해야한다. 12345678910111213141516171819202122232425262728293031323334353637//주문목록에서 주문상태만 단순 변경@Overridepublic void updateOrder(String trade_num) { try{ getCon(); sql=\"update itwill_order set o_status=? where o_trade_num=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, 1); //1-발송준비 2 - \"발송완료\" 3 - \"배송중\" 4 - \"배송완료\" 5 - \"주문취소\" pstmt.setString(2, trade_num); pstmt.executeUpdate(); }catch(Exception e){ e.printStackTrace(); }finally{ closeDB(); }}//end of updateOrder()//주문번호를 사용해서 주문상태, 운송장번호 수정 가능//오버라이딩인 동시에 메서드 오버로딩@Overridepublic void updateOrder(OrderDTO odto) { try{ getCon(); sql=\"update itwill_order set o_status=?, o_trans_num=? where o_trade_num=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, odto.getO_status()); pstmt.setString(2, odto.getO_trans_num()); pstmt.setString(3, odto.getO_trade_num()); int num = pstmt.executeUpdate(); //몇줄의 row가 변경되었는지를 int로 리턴해줌 System.out.println(\"DAO: 주문상태랑 운송장번호 수정: \"+num); }catch(Exception e){ e.printStackTrace(); }finally{ closeDB(); }}//end of updateOrderDetail() admin_order_list.jsp 링크 수정 수정버튼의 기존 코드 './AdminOrderModify.ao?trade_num=&lt;%=odto.getO_trade_num()%&gt;'에서 './AdminOrderDetail.ao?trade_num=&lt;%=odto.getO_trade_num()%&gt;'로 변경 123456&lt;td&gt; &lt;input type=\"button\" class=\"btn\" value=\"수정\" onclick=\"location.href='./AdminOrderDetail.ao?trade_num=&lt;%=odto.getO_trade_num()%&gt;'\" &gt; / &lt;input type=\"button\" class=\"btn\" value=\"삭제\" onclick=\"location.href=\" &gt;&lt;/td&gt; AdminOrderDetailAction.java 생성123456789101112131415161718192021222324252627282930313233public class AdminOrderDetailAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { // 한글처리 request.setCharacterEncoding(\"UTF-8\"); // 관리자 ID해당하는 세션값 제어 HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null || !id.equals(\"admin\")){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } // trade_num 파라미터값 저장 String trade_num = request.getParameter(\"trade_num\"); // 주문번호에 해당하는 정보를 전부 가져오는 동작을 처리 AdminOrderDAO aodao = new AdminOrderDAOImpl(); // 주문정보를 저장 request.setAttribute(\"adminOrderdetailList\", aodao.getAdminOrderDetail(trade_num)); // 페이지 이동 (\"./adminorder/admin_order_modify.jsp\") forward.setPath(\"./adminorder/admin_order_modify.jsp\"); forward.setRedirect(false); return forward; }} AdminOrderDAO.java에 getAdminOrderDetail()메서드 코드 추가12345678910111213public interface AdminOrderDAO { // 인터페이스안의 추상메서드이기때문에 // 관리자가 주문목록을 확인하는 기능 getAdminOrderList() public List getAdminOrderList(); // 주문번호를 이용하여 주문상태 변경 public void updateOrder(String trade_num); // 주문번호에 해당하는 주문정보(리스트 전체)를 가져오는 동작을 처리 public abstract List getAdminOrderDetail(String trade_num); } AdminOrderDAOImpl.java에 getAdminOrderDetail()메서드 오버라이딩하여 코드 추가123456789101112131415161718192021222324252627282930313233343536373839404142//주문번호에 해당하는 주문정보(리스트 전체)를 가져오는 동작을 처리@Overridepublic List getAdminOrderDetail(String trade_num) { List&lt;OrderDTO&gt; adminOrderdetailList = new ArrayList&lt;OrderDTO&gt;(); try{ getCon(); sql=\"select * from itwill_order where o_trade_num=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, trade_num); rs = pstmt.executeQuery(); while(rs.next()){ OrderDTO odto = new OrderDTO(); odto.setO_date(rs.getDate(\"o_date\")); odto.setO_g_amount(rs.getInt(\"o_g_amount\")); odto.setO_g_color(rs.getString(\"o_g_color\")); odto.setO_g_name(rs.getString(\"o_g_name\")); odto.setO_g_num(rs.getInt(\"o_g_num\")); odto.setO_g_size(rs.getString(\"o_g_size\")); odto.setO_m_id(rs.getString(\"o_m_id\")); odto.setO_receive_memo(rs.getString(\"o_receive_memo\")); odto.setO_num(rs.getInt(1)); //컬럼명 대신 인덱스번호로도 가능 odto.setO_receive_addr1(rs.getString(\"o_receive_addr1\")); odto.setO_receive_addr2(rs.getString(\"o_receive_addr2\")); odto.setO_receive_name(rs.getString(\"o_receive_name\")); odto.setO_receive_phone(rs.getString(\"o_receive_phone\")); odto.setO_status(rs.getInt(\"o_status\")); odto.setO_sum_money(rs.getInt(\"o_sum_money\")); odto.setO_trade_date(rs.getDate(\"o_trade_date\")); odto.setO_trade_num(rs.getString(2)); //컬럼명 대신 인덱스번호로도 가능 odto.setO_trade_payer(rs.getString(\"o_trade_payer\")); odto.setO_trade_type(rs.getString(\"o_trade_type\")); odto.setO_trans_num(rs.getString(\"o_trans_num\")); adminOrderdetailList.add(odto); } }catch(Exception e){ e.printStackTrace(); }finally{ closeDB(); } return adminOrderdetailList;}//end of getAdminOrderDetail() admin_order_modify.jsp 생성 금액에 천의 단위를 입력하고 싶으면 DecimalFormat 클래스를 사용하면 된다. DecimalFormat dc = new DecimalFormat(&quot;###,###,###,###,###원&quot;); 테이블전체를 form태그로 감싸야한다. AdminOrderDAO 객체 생성 -&gt; 폼태그로 전달받은 파라미터값을 리퀘스트파라미터로 받는다. -&gt; 배송지 수정들을 가능하게 하면 받아야할 파라미터가 많아져서 비효율적이다. 인자가 많아질수록 성능이 비효율적이다 =&gt; DTO를 사용하면 한번에 들고 다닐 수 있다. 보통 인자는 4~5까지는 파라미터로 받고 그 이상인 경우는 DTO나 BEAN을 이용해야 성능이 좋다. 1234567891011//전달정보 파라미터값 저장String trade_num = request.getParameter(\"trade_num\");int status = Integer.parseInt(request.getParameter(\"status\"));String trans_num = request.getParameter(\"trans_num\");//AdminOrderDAO 객체 생성 -&gt; 배송지 수정들을 가능하게 하면 받아야할 파라미터가 많아져서 비효율적이다.//=&gt; DTO를 사용하면 한번에 들고 다닐 수 있다.OrderDTO odto = new OrderDTO();odto.setO_trade_num(request.getParameter(\"trade_num\"));odto.setO_status(Integer.parseInt(request.getParameter(\"status\")));odto.setO_trans_num(request.getParameter(\"trans_num\")); 전체태그 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;%//한글처리request.setCharacterEncoding(\"UTF-8\");//전달된 값 저장String trade_num = request.getParameter(\"trade_num\");List&lt;OrderDTO&gt; adminOrderdetailList = (List&lt;OrderDTO&gt;) request.getAttribute(\"adminOrderdetailList\");//공통항목을 처리하는 객체OrderDTO odto_total = adminOrderdetailList.get(0);//천의 단위 콤마DecimalFormat dc = new DecimalFormat(\"###,###,###,###,###원\");%&gt;&lt;form action=\"./AdminOrderModify.ao\" method=\"post\"&gt;&lt;input type=\"hidden\" name=\"trade_num\" value=\"&lt;%=trade_num%&gt;\"&gt; &lt;table border=\"1\"&gt;&lt;caption&gt;관리자 - 주문 상세보기 / 수정하기&lt;/caption&gt;&lt;!-- 주문정보 --&gt;&lt;tr&gt; &lt;th&gt;주문번호&lt;/th&gt; &lt;td colspan=\"4\"&gt;&lt;%=trade_num %&gt;&lt;/td&gt; &lt;/tr&gt;&lt;tr&gt; &lt;th colspan=\"5\"&gt;구매 상품 정보&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;th&gt;상품명&lt;/th&gt; &lt;th&gt;수량&lt;/th&gt; &lt;th&gt;크기&lt;/th&gt; &lt;th&gt;색상&lt;/th&gt; &lt;th&gt;가격&lt;/th&gt; &lt;/tr&gt;&lt;%int totalSum=0;for(OrderDTO odto : adminOrderdetailList){ totalSum += odto.getO_sum_money();%&gt;&lt;tr&gt; &lt;td&gt;&lt;%=odto.getO_g_name() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto.getO_g_amount() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto.getO_g_size() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto.getO_g_color() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=dc.format(odto.getO_sum_money()) %&gt;&lt;/td&gt; &lt;/tr&gt;&lt;%} %&gt;&lt;!-- 배송지 정보 --&gt; &lt;tr&gt; &lt;th colspan=\"5\"&gt;배송지 정보&lt;/th&gt; &lt;/tr&gt;&lt;tr&gt; &lt;th&gt;받는 사람&lt;/th&gt; &lt;th&gt;연락처&lt;/th&gt; &lt;th&gt;배송주소&lt;/th&gt; &lt;th&gt;세부 배송주소&lt;/th&gt; &lt;th&gt;요구사항&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;&lt;%=odto_total.getO_receive_name() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto_total.getO_receive_phone() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto_total.getO_receive_addr1() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto_total.getO_receive_addr2() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto_total.getO_receive_memo() %&gt;&lt;/td&gt; &lt;/tr&gt;&lt;!-- 결제정보 --&gt;&lt;tr&gt; &lt;th colspan=\"5\"&gt;결제 정보&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;th&gt;주문 합계 금액&lt;/th&gt; &lt;th&gt;결제 방법&lt;/th&gt; &lt;th&gt;입금자(구매자)&lt;/th&gt; &lt;th&gt;주문상태&lt;/th&gt; &lt;th&gt;운송장 번호&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;%=dc.format(totalSum) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto_total.getO_trade_type() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=odto_total.getO_trade_payer() %&gt;&lt;/td&gt; &lt;td&gt; &lt;div class=\"pure-css-select-style theme-square\"&gt; &lt;select name=\"status\"&gt; &lt;option value=\"0\" &lt;% if(odto_total.getO_status() == 0){%&gt; selected &lt;%} %&gt; &gt;대기중&lt;/option&gt; &lt;option value=\"1\" &lt;% if(odto_total.getO_status() == 1){%&gt; selected &lt;%} %&gt; &gt;발송준비&lt;/option&gt; &lt;option value=\"2\" &lt;% if(odto_total.getO_status() == 2){%&gt; selected &lt;%} %&gt; &gt;발송완료&lt;/option&gt; &lt;option value=\"3\" &lt;% if(odto_total.getO_status() == 3){%&gt; selected &lt;%} %&gt; &gt;배송중&lt;/option&gt; &lt;option value=\"4\" &lt;% if(odto_total.getO_status() == 4){%&gt; selected &lt;%} %&gt; &gt;배송완료&lt;/option&gt; &lt;option value=\"5\" &lt;% if(odto_total.getO_status() == 5){%&gt; selected &lt;%} %&gt; &gt;주문취소&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"trans_num\" value=\"&lt;%=odto_total.getO_trans_num() %&gt;\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td colspan=\"3\"&gt;&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;input type=\"submit\" class=\"btn\" value=\"수정\"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;input type=\"button\" class=\"btn\" value=\"뒤로가기(js코드)\" onclick=\"javascript:history.back()\"&gt;&lt;input type=\"button\" class=\"btn\" value=\"뒤로가기(history객체)\" onclick=\"history.back()\"&gt;","link":"/2020/09/22/200923jspi-3/"},{"title":"Controlfile다중화, Redologfile다중화, 데이터베이스로그모드","text":"Controlfile다중화 Controlfile은 DB당 하나만 존재하면 됨. 컨트롤파일이 날라갔다 = DB가 날라갔다, 컨트롤파일이 과거로 되돌아가는 것 = DB가 과거로 되돌아 가는 것 이렇듯 너무나 중요한 Control file은 백업으로는 역부족하여 데이터손실이 날 수 있으므로 Control file다중화를 통해서 동시 운영하는 것을 권장. Control file다중화 최대 8개까지 다중화 기능이 제공되고 오라클 3개 권장 다중화가 많을 수록 안정성\u0018, 성능↓ (3개든 5개든 다중화 갯수만큼 동시에 기록해야해서 성능떨어짐) 다중화가 적을 수록 안정성↓, 성능\u0018 다중화시킬때는 경로를 나눠서 운영해야함. 예를 들어 c드라이브와 d드라이브에 하나씩. 현재 controlfile 정보조회 controlfile은 다른 경로로 다중화해야지 안정성\u0018 123456789//현재 controlfile정보조회SQL&gt; select name SQL&gt; from v$controlfile;NAME--------------------------------------------------------------------------------/u01/app/oracle/oradata/ORCL/controlfile/o1_mf_fwvn95xm_.ctl/u01/app/oracle/fast_recovery_area/orcl/ORCL/controlfile/o1_mf_fwvn96cd_.ctl 다중화 순서 DB에 Controlfile 추가 지금 두개 등록되어있다고 하나만 등록하게되면 2개에서 1개로 바뀌어버린다. =&gt; 3개로 다중화하고싶다면 3개 다 작성해야한다. scope옵션 3가지 memory : 지금 당장 적용. 현재 DB의 parameter 만 수정하며, spfile 은 수정하지 않는다. 재시작 하면 원래 spfile 설정값으로 돌아간다. 3번째 컨트롤파일 추가하는 과정에서는 현재 3번째 컨트롤파일을 존재하지않기때문에 현 시점에서 사용 불가능. both : 현재 DB 의 parameter 와 spfile 모두 수정한다. default 값. 3번째 컨트롤파일 추가하는 과정에서는 현재 3번째 컨트롤파일을 존재하지않기때문에 현 시점에서 사용 불가능. spfile : Spfile만 수정한다. (정적인 파라미터 수정에서는 필수다) DB 종료 SQL&gt; ! -&gt; 작업후 -&gt; $&gt; exit: 지금 sys접속된 상태에서 잠시 나갔다가 다시 들어오는 명령어 SQL&gt; exit -&gt; 작업후 -&gt; $&gt;sqlplus &quot;sys/oracle as sysdba&quot; : 아예 DB나간 뒤 다시 접속 OS에 Controlfile 추가 DB 시작 정상적으로 처리되는 경우 아무런 출력 값이 나타나지않는다. 에러발생하는 경우 Error의 의미는 mount가 되지 않았다는 의미 파라미터(SQL&gt; show parameter control_files;)를 확인하여 오타난 부분을 찾은 뒤 1번부터 다시 진행한다. 다중화가 잘 되었는지 확인(DB가 open되어 있어야 확인가능) 12345678910111213141516171819202122232425262728293031323334353637383940414243//1.DB에 Controlfile 추가(다중화)SQL&gt; alter system set control_files= '/u01/app/oracle/oradata/ORCL/controlfile/o1_mf_fwvn95xm_.ctl', '/u01/app/oracle/fast_recovery_area/orcl/ORCL/controlfile/o1_mf_fwvn96cd_.ctl', '/home/oracle/control103.ctl' scope = spfile;System altered.//2.DB 종료SQL&gt; shut immediateDatabase closed.Database dismounted.ORACLE instance shut down.SQL&gt; ! (지금 sys접속된 상태에서 잠시 나갔다가 다시 들어오는 명령어)또는 SQL&gt; exit (아예 DB나간 뒤 다시 접속)//3.OS에 Controlfile 추가[oracle@localhost ~]$ cd /u01/app/oracle/oradata/ORCL/controlfile/[oracle@localhost controlfile]$ cp o1_mf_fwvn95xm_.ctl /home/oracle/control103.ctl$&gt; exit//4.DB 시작SQL&gt; startup//정상적으로 처리되는 경우 아무런 출력값이 나타나지않는다.//4-1. DB시작시 에러발생하는 경우SQL&gt; startup=&gt; Error//Error의 의미는 mount가 되지 않았다는 의미//이럴결우 파라미터를 확인하여서 오타난 부분을 찾은 뒤 1번부터 다시 진행한다.SQL&gt; show parameter control_files;//5.Controlfile다중화확인 (3개인지 확인!)SQL&gt; select name from v$controlfile;NAME--------------------------------------------------------------------------------/u01/app/oracle/oradata/ORCL/controlfile/o1_mf_fwvn95xm_.ctl/u01/app/oracle/fast_recovery_area/orcl/ORCL/controlfile/o1_mf_fwvn96cd_.ctl/home/oracle/control103.ctl 참고로 DB 켜져있는 지 확인 결과값이 open이면 인스턴스 생성완료 = DB가 켜짐 다른 결과값은 링크 확인할 것. 12345SQL&gt; select status from v$instance;STATUS------------------------OPEN Redologfile다중화 Redologfile은 DB에서발생된 변경 작업의 로그정보(Redo data)가 기록된 공간 다중화 개수 제한 없음 다중화가 많을 수록 안정성\u0018, 성능↓ 로그스위칭 : 순환형으로 관리되는 파일로 덮어써진다. 그룹번호는 항상 순차적이어야 로그스위칭이 정상적으로 일어난다. 새로 추가할 그룸 멤버들은 기존에 있는 멤버와 같은 size이어야한다. =&gt; 다중화시 굳이 명시할 필요가 없어서 해당 명령어가 없다. 그룹안의 멤버수는 서로 동일하거나 비슷하게 디자인한다. Redologfile 확인 : 쿼리구문 두가지로 확인해야한다.1234567891011121314151617181920212223242526272829303132333435363738394041SQL&gt; select group#, members 2 from v$log; GROUP# MEMBERS---------- ---------- 1 2 2 2 3 2 SQL&gt; select group#, member 1 from v$logfile 2 order by group# ; GROUP# MEMBER---------- ------------------------------ 1 /u01/app/oracle/oradata/ORCL/o nlinelog/o1_mf_1_fwvn9ddb_.log 1 /u01/app/oracle/fast_recovery_ area/orcl/ORCL/onlinelog/o1_mf _1_fwvn9o6v_.log 2 /u01/app/oracle/oradata/ORCL/o nlinelog/o1_mf_2_fwvn9ddv_.log 2 /u01/app/oracle/fast_recovery_ GROUP# MEMBER---------- ------------------------------ area/orcl/ORCL/onlinelog/o1_mf _2_fwvn9l85_.log 3 /u01/app/oracle/oradata/ORCL/o nlinelog/o1_mf_3_fwvn9t6z_.log 3 /u01/app/oracle/fast_recovery_ area/orcl/ORCL/onlinelog/o1_mf _3_fwvn9xf6_.log6 rows selected. 다중화 순서 redo log group 추가 redo log member 추가 멤버 만들고 싶은 그룹만 만들어도 된다. ex to group 1과 to group 3만 생성 가능 하지만 실무에선 그룹별 멤버수를 동일하게 관리하는 편이다. 1234567891011121314151617181920//1.redo log group 추가SQL&gt; ed 1 alter database add logfile group 4 2 ('/u01/app/oracle/oradata/ORCL/onlinelog/redo4a.log', 3 '/u01/app/oracle/fast_recovery_area/orcl/ORCL/onlinelog/redo4b.log') 4* size 50MSQL&gt; /Database altered.//2.redo log member 추가SQL&gt; ed 1 alter database add logfile member 2 '/u01/app/oracle/oradata/ORCL/datafile/redo1c.log' to group 1, 3 '/u01/app/oracle/oradata/ORCL/datafile/redo2c.log' to group 2, 4 '/u01/app/oracle/oradata/ORCL/datafile/redo3c.log' to group 3, 5* '/u01/app/oracle/oradata/ORCL/datafile/redo4c.log' to group 4SQL&gt; /alter database add logfile member Database log mode Database log mode는 2가지가 있다 Noarchive log mode : redologfile에 로그스위치 발생시 순환하면서 덮어씀 Archive log mode : redologfile에 로그스위치 발생시 offline 복사본 생성함. 즉 archive log file 운영함 DB log mode 조회123456789101112131415//첫번째 조회방법SQL&gt; select log_mode from v$database;LOG_MODE------------------------NOARCHIVELOG//두번째 조회방법SQL&gt; archive log listDatabase log mode No Archive ModeAutomatic archival DisabledArchive destination USE_DB_RECOVERY_FILE_DESTOldest online log sequence 36Current log sequence 38 순서 DB 종료 DB MOUNT DB LOG MODE 설정 SQL&gt; alter database archivelog; : Archive log mode모드로 변경 SQL&gt; alter database noarchivelog; : Noarchive log mode로 변경 DB OPEN 처리결과확인 123456789101112131415161718192021222324252627282930313233343536373839//1. DB 종료SQL&gt; shut immediate Database closed.Database dismounted.ORACLE instance shut down.//2. DB MOUNTSQL&gt; startup mountORACLE instance started.Total System Global Area 838860800 bytesFixed Size 8626240 bytesVariable Size 620761024 bytesDatabase Buffers 201326592 bytesRedo Buffers 8146944 bytesDatabase mounted.//3. DB LOG MODE 설정SQL&gt; alter database archivelog;또는SQL&gt; alter database noarchivelog;Database altered.//4. DB OPENSQL&gt; alter database open;Database altered.//5. 처리결과확인SQL&gt; archive log listDatabase log mode Archive ModeAutomatic archival EnabledArchive destination USE_DB_RECOVERY_FILE_DESTOldest online log sequence 36Next log sequence to archive 38Current log sequence 38","link":"/2020/09/27/200928dbi/"},{"title":"[스프링SPRING]제어의 역행(IoC)과 의존성 주입(DI)","text":"제어의 역행(IoC, Inversion of Control) 객체, 메서드 호출시 처리하지않고 외부(spring)에서 처리한다. 블럭 끼워넣기 개발이라고도 칭함 의존성 주입(DI, Dependency Injection) 제어의 역행이 발생할 때, 스프링 내부에 있는 객체가 해당 클래스를 사용할 때 필요한 관계를 관리하는 동작 또는 기법 여기서 의존성이란 객체가 혼자서는 처리할 수 없음을 뜻한다. 따라서 객체를 직접 생성해서 구현한다 ex) jsp model2에서의 DAO객체생성 관계를 약화시키면서 간접 구현 즉 호출해야한다. 따라서 의존성 주입이란 객체를 직접 생성/제어하는 것이 아니라, 제어의 역행을 사용해서 특정 객체를 필요한 객체의 외부에 가져다가 연결하는 것을 뜻한다. 객체가 필요한 어떤 객체를 생성자 혹은 setter를 통해 주입하는 것을 말한다. 예를 들어 사람이란 객체가 있다. 머리, 몸통, 팔, 다리부분으로 구성되어있는 객체이다. 여기서 머리만 바꿔끼우면(= 주입) 사람A에서 사람B가 될 수 있다. 의존성 주입 3가지 방법스프링 프레임워크는 @Autowired 애노테이션을 이용하여 다양한 의존성주입방법을 제공한다.@Autowired 애노테이션은 Spring에게 의존성을 주입하라는 지시자 역할로 쓰이는데 생성자, 필드, 세터에 붙일 수 있다. 생성자 주입 @Autowired 애노테이션 생략가능 -&gt; lombok을 활용해 @ReqyiredArgsConstructor와 상수 조합12345@RestController@ReqyiredArgsConstructorpublic class ApiController{ private final UserService service;} 필드 주입: 변수 선언부에 @Autowired 애노테이션을 붙인다. 가장 편리한 방법이면서 실무에서 자주 사용하는 주입 방법12345@RestControllerpublic class ApiController{ @Autowired private UserService service;} 수정자 주입(Setter): Setter 메소드에 @Autowired 애노테이션을 붙인다. 123456789@Componentpublic class ApiController { private UserService userService; @Autowired public void setUserService(UserService userService) { this.userService = userService; }} 위의 세가지 방법 중 spring에서 권장하는 방법은 생성자를 통한 주입 방법이다.생성자주입방법이 좋은 이유는 순환참조 방지, 테스트 코드 작성 용이하기 때문이다. 어노테이션을 쓰지않고 xml을 이용한 DI1 생성자를 이용한 예시 .xml파일에 spring beans DTD 연결 .xml파일의 &lt;bean&gt;태그로 객체생성하기 (new 키워드랑 동일한 결과) constructor-arg : “생성자 사용해서 값 주입” 원하는 파라미터 갯수만큼 &lt;constructor-arg&gt;태그생성 태그 생성시 순서 : 파라미터 순서그대로 대입됨 student.xml 코드 value담는 방식은 두가지 1. &lt;value&gt;태그사용 2.value=&quot;&quot;속성사용1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"&gt;&lt;beans&gt; &lt;bean id=\"studentBean\" class=\"com.itwill.spring.ItwillStudent\"&gt; &lt;property name=\"name\" value=\"홍길동\"&gt;&lt;/property&gt; &lt;property name=\"classNum\"&gt;&lt;value&gt;7&lt;/value&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 생성자이용하여 DI --&gt; &lt;bean id=\"conBean1\" class=\"com.itwill.spring.ItwillStudent\"&gt; &lt;constructor-arg&gt; &lt;value&gt;사용자3&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"conBean2\" class=\"com.itwill.spring.ItwillStudent\"&gt; &lt;constructor-arg value=\"사용자4\" /&gt; &lt;constructor-arg value=\"1\" /&gt; &lt;/bean&gt;&lt;/beans&gt; Student.java 인터페이스 생성 12345public interface Student { //인사 구현 public void showInfo(); } ItwillStudent.java 생성 12345678910111213141516171819202122232425262728293031public class ItwillStudent implements Student{ private String name; private int classNum; //생성자 만들기 public ItwillStudent(){} public ItwillStudent(String name){ this.name = name; } public ItwillStudent(String name,int classNum){ this.name = name; this.classNum = classNum; } //get메서드는 필요가 없다. set()은 필수 public void setName(String name) { this.name = name; } public void setClassNum(int classNum) { this.classNum = classNum; } @Override public void showInfo() { System.out.println(\"이름: \" + name + \", 강의장: \" + classNum); } @Override public String toString() { return \"toString [이름: \" + name + \", 강의장: \" + classNum + \"]\"; } } StudentTest.java 코드 12345678910111213141516171819202122232425public class StudentTest { public static void main(String[] args) { //기존 자바사용해서 객체 구현 및 사용 ItwillStudent kim = new ItwillStudent(); kim.setName(\"킴스\"); kim.setClassNum(8); kim.showInfo(); System.out.println(\"-----생성자 사용하여 객체생성\"); //생성자를 사용한 객체생성 ItwillStudent user1 = new ItwillStudent(\"사용자1\"); user1.showInfo(); Student user2 = new ItwillStudent(\"사용자2\", 7); user2.showInfo(); System.out.println(\"-----생성자 사용하여 DI\"); //생성자를 사용한 의존주입 ItwillStudent user3 = (ItwillStudent) fac.getBean(\"conBean1\"); user3.showInfo(); ItwillStudent user4 = (ItwillStudent) fac.getBean(\"conBean2\"); user4.showInfo(); }} 2 수정자 Setter메서드 이용한 예시 .xml파일에 spring beans DTD 연결 .xml파일의 &lt;bean&gt;태그로 객체생성하기 (new 키워드랑 동일한 결과) bean태그에서 사용할 수 있는 속성들 id : “빈 객체의 고유한 이름, 외부에서 접근하는 이름” name : “객체의 별칭” class : “생성할 클래스위치” property : “set() 사용해서 값을 주입” name속성 : bean태그의 class속성 위치에 있는 클래스의 멤버변수 중에 set 원하는 것을 지정 value담는 방식은 두가지 1. &lt;value&gt;태그사용 2.value=&quot;&quot;속성사용 constructor-arg : “생성자 사용해서 값 주입” person.xml 코드12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- DTD --&gt;&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"&gt;&lt;!-- bean == 객체(스프링이 제공하는 객체) --&gt;&lt;beans&gt; &lt;!-- 객체생성 (new 키워드랑 동일한 결과) --&gt; &lt;bean id=\"personBean\" class=\"com.itwill.spring.SubPerson\"&gt; &lt;!--속성 name은 class에 있는 멤버변수 명중에 선택하는 것임 value담는 방식은 두가지 1. 태그사용 2. 속성사용 --&gt; &lt;property name=\"name\"&gt;&lt;value&gt;아이린&lt;/value&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"25\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; IPerson.java 인터페이스생성 123456public interface IPerson { //사람객체를 생성하기위한 틀 //인사 구현 public void sayHello();} SubPerson.java 파일 생성 1234567891011121314151617181920212223242526272829public class SubPerson implements IPerson { //사람의 정보를 저장하면서 기능 구현 가능 private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public void sayHello() { System.out.println(name+\"님(\"+age+\"세), 안녕하세요!\"); } @Override public String toString() { return \"SubPerson정보 [이름=\" + name + \", 나이=\" + age + \"]\"; }} PersonTest.java파일에서 객체 사용하기 BeanFactory는 외부의 파일을 읽어와서 처리함 1234567891011121314151617181920212223242526272829303132333435public class PersonTest { public static void main(String[] arg){ //1.자바에서 객체생성하여 사용하기 Person p1 = new Person(); p1.setName(\"홍길동\"); p1.setAge(20); System.out.println(p1); System.out.println(p1.toString()); //인터페이스로 만든 SubPerson사용하고싶다면? //의존의 관계가 강한결합 -&gt; 인터페이스를 만들었으니 xml에서 약한 결합으로 바꿔줄수있다. SubPerson sp = new SubPerson(); sp.setName(\"소미\"); sp.setAge(22); sp.sayHello(); //2.스프링을 사용해서 객체 생성하고 사용하기(xml) BeanFactory fac = new XmlBeanFactory(new FileSystemResource(\"person.xml\")); //xml파일명 기입 //의존주입 IPerson ip = (IPerson) fac.getBean(\"personBean\"); //xml파일의 bean의 id값을 기입 ip.sayHello(); }}//출력값사용자정보 [이름=홍길동, 나이=20]사용자정보 [이름=홍길동, 나이=20]소미님(22세), 안녕하세요!log4j:WARN No appenders could be found for logger (org.springframework.beans.factory.xml.XmlBeanDefinitionReader).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.아이린님(25세), 안녕하세요! 강한 결합 VS 약한 결합 객체의 의존 관계에서 강한 결합이란, 말그대로 어떠한 객체가 다른 객체에 강한 의존성을 가지고 있는 것이다. 강한 결합을 가지면 코드 변경이 어려워지기때문에 약한 결합을 만들어주어 코드 변경을 용이하게 해야한다. 인터페이스와 서브클래스 관계를 사용하여 약한 결합 생성할 수 있다. 참고링크 : 사람이 치킨을 먹는 모습을 클래스 예시를 통한 강한 결합과 약한 결합 차이 JPA에서 주로 사용하는 DI 방법은?빌더 패턴을 사용하기를 권장하고 있다.그 이유는 생성패턴의 종류와 빌더패턴을 사용해야하는 이유포스팅에서 확인할 수 있다.","link":"/2020/10/03/201003spring-1/"},{"title":"Amazon 개발자가 말해주는 해외취업 웨비나 후기","text":"Amazon개발자가 말해주는 해외취업 내용 : 아마존 현직 개발자가 알려주는 해외 취업, 그리고 아마존이 일하는 방식.강사 : 민창현 아마존에서 근무를 하고 있으신 창현님께서 아마존의 일하는 방식과 해외 취업에 대해 설명해주신다고 해서 행사를 하나 열었습니다. 게시: Hojun Lee&nbsp;2020년 9월 28일 월요일 서류 링크드인 내부 직원 리퍼럴 통해서 지원👍 회사 직접 지원 왜 서류 통과가 안되었을까? 외국인을 뽑기 싫어서(비자문제, 비용문제) 지원자가 너무 많아서 내부 직원 리퍼럴로 1차 스크리닝 🌟TIP 인맥을 찾거나 무작정 연락해서 리퍼럴 부탁하기 인맥 추천할때 진짜 지인인지 어디서 만난 지인인지 구분하는 카테고리가 있기때문에 리퍼럴하는 것이 부담스럽지않다. 따라서 어떤 행사에서 만난 사람이라도 리퍼럴 부탁해 볼 것! 면접 전화면접 보통 1시간내외 하루 일정 중 몇시간 코딩하는지 나머지 시간은 뭐하는지 🌟TIP 중간중간에 내가 제대로 질문을 이해하고 답하고 있는지 면접관과 함께 체크하기 Does it make sense to you? 실시간 코딩 비교적 간단한 알고리즘 문제 On-site interview 또는 online interview 4번~5번 정도 1:1로 면접 진행 (1시간내외) 알고리즘 2 ~ 3회면접, 시스템디자인 1 ~ 2회, 인성면접 1회등 아마존의 경우 LP면접이 매우 중요. On-site interview의 경우, 화이트보드세션 online interview의 경우, 온라인 화이트보드 툴으로 시스템다이어그램 그려서 work flow설명하거나 실시간 코딩협업 툴 등 사용해서 설명해야함 Hiring Event 아마존에서 주로 많이 시행하는 대규모 채용 이벤트 주로 경력 개발자를 채용하기 위한 이벤트 신입의 경우 보통 현지 대학 졸업자들을 대상으로 진행 비교적 빠른 채용 프로세스(보통 1~2달만에 채용됨) 프로세스 : 서류 -&gt; 온라인 코딩 테스트 -&gt; 전화 면접 -&gt; On-site interview 경쟁률은 1:8정도임 다들 개발 엄청 잘 하나요? 내가 못해서 떨어진 것이 아니라 내가 운이 없어서, 지금 뽑는 팀에 부합하지 않아서 떨어진 것일 뿐입니다. 절대 겁먹지마세요지원해서 면접 본 사람 중에 잘 맞는 사람을 뽑는 것입니다. 지원하지않으면 luck안에 발도 들이지 못한다. 경력을 쌓아야겠다 다들 영어 엄청 잘하나요? 영어실력에 대한 판단은 면접관이 하는 것이니 미리 걱정하지마세요. 사실 합격하면 그때가 문제입니다.출퇴근시간을 이용하여 스탠드업 미팅을 혼자 영어로 꾸준히 연습해보세요.개발자가 아닌 사람에게 본인의 업무를 영어로 이야기를 해보세요. 자신이 개발한 기능 예를 들어 Merge sort를 영어로 설명하는 것을 연습해보세요내 프로젝트를 정리해보세요. 면접에서는 자신의 프로젝트에서 개선할 점이라든지 다시 돌아가면 어떻게 하겠다는 등에 관한 내용을 물어보기도 한답니다. 코딩테스트 Leetcode 100개이상 풀기 Dynamic programming은 잘 안 물어본다. Tree, Stack, Limked List부터 구현해보기 🌟TIP LRU cache는 빈출문제이니 꼭 마스터하기 STL의 API를 못 외워도 좋지만 API를 정의할 수 있어야한다. 🌟TIP 존재하는 API인지 아닌지 상관없이 스스로 이런 INPUT을 가진 API입니다라고 가정을 세워서 코딩테스트를 진행하기 코딩테스트하는 동안 내가 지금 뭘 하는 지 먼저 말하고 의도적으로 코딩 중에 말하면서 푸세요. 면접관과 계속 대화를 해야 면접관이 도와줄 수 있습니다.모르겠으면 빠르게 힌트를 요구하세요. 면접관과 대화를 통해서 코딩테스트 문제를 풀어내가는 과정이 중요합니다.답을 알더라도 내가 생각하는 것이 맞는 지 물어봐서 확신을 얻어내세요.마음대로 가정하지 말고 입력과 출력을 확실히 확인하세요. 예를 들어 데이터타입이 String, float등 다양하게 들어올 수 있는데 무조건 INT이다라고 생각하는 등. 면접관에게 처리할 데이터의 양을 무조건 물어보고 검증하세요.머리나 말로 코드를 설명하지말고 주석으로 디버깅 과정을 보여주세요면접툴을 미리 사용해볼 수 있으면 꼭 사용해보세요. 화이트보드에 직접 코드를 적는 경험을 꼭 연습해보세요. 시스템디자인 면접인 경우 자신이 지금 기획자와 회의에 들어와서 기획안을 한문장 듣고 시스템을 상상해서 설명한다고 생각하세요.면접관에게 반복적으로 질문하면서 입력과 출력을 적어보고 문제를 제대로 이해했는지 질문하세요. 그리고 답변을 마칠때 꼭 “이정도면 말씀하신 내용을 다 만족할까요? 혹시 추가적으로 고려해야 할 사항이 있을가요?”라고 물어보면서 마무리하세요. 이런 피드백 로그를 만드는 것이 굉장히 중요합니다.동그라미하나라도 그리세요. 그리고 이것이 서비스입니다라고 시작해도 될 정도로 무조건 답변할 수 있는 질문이니 포기하지마세요 많이 쓰는 미국 비자 H1B : 일반 취업 비자, 1년에 1번 석박사의 경우 2번 가능 석박사 아니면 받기 엄청 어려움. 취업확정이 난 상태에서 지원할 수 있음. 이직 가능 L1B : 해외 주재원 비자 동일 회사 해외 지사에서 1년 이상 근무시 지원가능. 따라서 이직 불가. 미국비자를 받을 수 있는 가장 최선의 방법 🌟TIP 가장 추천하는 방법 OPT : 미국내 대학(원) 졸업시 발급하는 임시 취업 비자 Green card : 영주권 만약 미국 비자가 없다면 캐나다, 유럽, 싱가폴, 일본으로 가세요… 1년~2년있다가 internal transfer로 옮기면 더 쉽다.테그직종에서 캐나다 영주권은 미국 영주권보다 쉽게 나오기도 하니 미국 영주권이 목표가 아니라면 다른 나라도 알아봐도 좋습니다.회사 짤리면 비자가 취소되는 경우가 대부분입니다. 급여수준과 보상 TC의 구성요소 기본급 사이닝 보너스 RSU : 주식 캐시 보너스 보통 5~10년차 한국 개발자가 미국에 왔을 때 대기업 기준 TC 18~20만불 정도로 시작(아마존 기준) 부자가 될 줄 알았지만… 주거비와 생활비용이 은근 비싸서 그냥 중산층정도입니다.3년동안 야근은 한 달정도하고 주말에 일한 건 5번 이하인 것 같아요.최초 계약시점이후로 TC가 잘 안 올라가기때문에 승진이나 이직을 고려해야합니다. 입사시 무조건 카운터 오퍼가 있어야 연봉협상이 가능합니다. 카운트 오퍼 : 다른 회사에서 이정도 연봉으로 받았다는 걸 알리고 자신의 연봉을 올리는 것 한국에서 어느정도 경력을 쌓아야할까요? 한국에서 3년차 이상정도면 그 이후부터는 주니어를 벗어나려고 노력하면서 해외취업 도전하시는 것이 좋을 것같습니다.프로젝트를 처음부터 끝까지 디자인할 수 있을 것 같을때 도전해보실만 합니다.아마존 하이어링이벤트가 최고의 기회라고 생각합니다. 면접비용, 이사비용 다 서포팅해줍니다.","link":"/2020/10/03/201004amazon/"},{"title":"[스프링SPRING]관점 지향(AOP, Aspect-Oriented Programming) 총정리","text":"관점 지향 (AOP, Aspect-Oriented Programming) 메서드나 객체 안에 주기능과 보조기능으로 분리한 후 선택적으로 적용해서 사용하는 방법 전체 코드에 흩어져있는 보조 기능들을 한 곳에 모아서 처리가능하다 필요시(=주기능이 사용될때마다) 선택적으로 보조기능을 사용할 수 있다. 예시 : 쇼핑몰개발자는 쇼핑몰 정보를 처리만 하고 보안처리는 spring 프레임워크가 하는 것 장점 : 코드가 단순해지면서 가독성 향상, 중복된 코드 제거. 사용처: 로깅, 보안, 트랜젝션처리시 사용 AOP용어 AOP용어 설명 특징 Target Advice가 적용되는 클래스/메서드 - Advice Aspect의 실체, 구현해놓은 클래스 메서드호출기준으로 여러 지점에서 호출 가능 Pointcut Jointpoint의 부분으로 실제로 Advice가 적용된 대상, JointPoint의 상세한 스펙을 정의한 것 패키지이름/클래스이름/메서드이름을 정규식으로 지정 후 처리함 Jointpoint Advice가 적용될 위치, 끼어들 수 있는 지점 스프링에서는 method 결합점만 제공 Aspect 공통기능, 구현하고자 하는 보조 기능 - Weaving(위빙) Advice를 핵심기능에 적용하는 행위 - 스프링API를 활용한 AOP구현방법 Target 클래스 지정 Advice 클래스 지정 설정파일(스프링프레임워크)에서 Pointcut을 지정 설정파일(스프링프레임워크)에서 Advice와 Pointcut을 결합하는 Advicer 생성 설정파일(스프링프레임워크)에서 ProxyFactoryBean(스프링에서 제공)클래스를 사용해서 Target에 Advice를 적용 getBean()메서드로 해당 bean(객체)접근해서 사용 스프링API에서 제공하는 Advice인터페이스 인터페이스 이름 추상메서드 이름 특징 MethodBeforeAdvice before() 주 메서드 실행하기 전에 실행. 예를 들면 내 주기능이 로그인이다. 로그인전에 보안처리나 로깅처리를 실행하고자할때 내 주기능 실행전에 실행하는 것 AfterReturningAdvice afterReturning() 주 메서드 실행 후 실행 ThrowsAdvice afterThrowing() 주 메서드에서 예외가 발생시 실행 MethodInterceptor invoke() 주 메서드의 실행 전/후에 실행(예외발생시 실행도 포함) 예시 : 계산기 만들기간단한 계산기 예제를 통해서 AOP를 알아보자 Calculator.java 생성 1234567891011121314151617181920212223public class Calculator { //계산기객체 target public void add(int x, int y){ int result = x + y; System.out.println(\"add 결과: \"+result); } public void sub(int x, int y){ int result = x - y; System.out.println(\"sub 결과: \"+result); } public void mul(int x, int y){ int result = x * y; System.out.println(\"mul 결과: \"+result); } public void div(int x, int y){ int result = x / y; System.out.println(\"div 결과: \"+result); }} target 객체생성advice 객체생성위에서 학습한 순서에 따라 객체 생성해보자.1번과 2번을 함께 xml파일에 생성 AOPTest.xml생성 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- DTD --&gt;&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"&gt;&lt;!-- BEAN --&gt;&lt;beans&gt; &lt;!--1.타겟 클래스 객체생성 --&gt; &lt;bean id=\"calcTarget\" class=\"com.itwill.aop.Calculator\" /&gt; &lt;!--2.로그기능을 처리하는 advice 객체생성 --&gt; &lt;bean id=\"logAdvice\" class=\"com.itwill.aop.LoggingAdvice\" /&gt;&lt;/beans&gt; 설정파일(스프링프레임워크)에서 Pointcut을 지정설정파일(스프링프레임워크)에서 Advice와 Pointcut을 결합하는 Advicer 생성3번 4번을 함께 java파일에 작성하자스프링API에서 제공하는 Advice인터페이스 중 MethodInterceptor를 구현해보았다. LoggingAdvice.java 생성 123456789101112131415161718192021import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;//로그를 기록하는 로강클래스public class LoggingAdvice implements MethodInterceptor { //주 메서드의 실행 전/후에 실행(예외발생시 실행도 포함)하는 메서드 오버라이딩 @Override public Object invoke(MethodInvocation inv) throws Throwable { //메서드 호출 전에 수행하는 구문 System.out.println(inv.getMethod()+\" 메서드 호출 전\"); //메서드 호출 Object obj = inv.proceed(); //메서드 호출 후에 수행하는 구문 System.out.println(inv.getMethod()+\" 메서드 호출 후\"); return obj; }} 설정파일(스프링프레임워크)에서 ProxyFactoryBean(스프링에서 제공)클래스를 사용해서 Target에 Advice를 적용 AOPTest.xml 추가 작성 (주석 5번내용) property의 name이 궁금해져서 ProxyFactoryBean공식문서를 찾아봤다 interceptorNames는 setInterceptorNames()를 통해서 의존 주입(Setter)을 하였다. 하지만 target의 경우 동일한 파라미터이름을 찾을 수 없었다. 하지만 그 비슷한 것을 찾았는데 setTargetName(String targetName)이다. name=&quot;targetName&quot;으로 하면 error가 발생한다. 데이터타입이 object인데 targetName의 데이터타입은 String이기때문이다. 그럼 어떤 메서드에 의해서 의존주입이 되는 것일까? 부모클래스인 Class AdvisedSupport의 setTarget(Object target) 따라서 property 속성을 꼭 name=&quot;target&quot;으로 지정해야 스프링이 해당 클래스가 target클래스인 걸 알 수 있다. 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- DTD --&gt;&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"&gt;&lt;!-- BEAN --&gt;&lt;beans&gt; &lt;!--1.타겟 클래스 객체생성 --&gt; &lt;bean id=\"calcTarget\" class=\"com.itwill.aop.Calculator\" /&gt; &lt;!--2.로그기능을 처리하는 advice 객체생성 --&gt; &lt;bean id=\"logAdvice\" class=\"com.itwill.aop.LoggingAdvice\" /&gt; &lt;!--5.ProxyFactoryBean(스프링에서 제공)클래스를 사용해서 Target에 Advice를 적용 --&gt; &lt;bean id=\"proxyCalc\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt; &lt;!--5-1.타켓클래스 지정(setTargetName메서드를 이용한 setter 의존주입) --&gt; &lt;property name=\"target\" ref=\"calcTarget\" /&gt; &lt;!--5-2.타겟클래스에서 메서드 호출시 logAdive객체 실행(setter 의존주입) --&gt; &lt;property name=\"interceptorNames\"&gt; &lt;list&gt; &lt;value&gt;logAdvice&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; getBean()메서드로 해당 bean(객체)접근해서 사용 CalcAOPTest.java생성 후 getBean()사용 1234567891011121314151617181920import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class CalcAOPTest { public static void main(String[] args) { System.out.println(\" 계산기 실행 ! \"); ApplicationContext appCtx = new ClassPathXmlApplicationContext(\"AOPTest.xml\"); System.out.println(\"-----------target 객체생성\"); Calculator cal2 = (Calculator)appCtx.getBean(\"calcTarget\"); cal2.add(200, 200); System.out.println(\"-----------Proxy로 객체생성\"); Calculator cal = (Calculator)appCtx.getBean(\"proxyCalc\"); cal.sub(100, 200); cal.mul(5, 2); }} 로그를 통해 정상적으로 객체를 생성하고 호출하는 것을 확인할 수 있다.","link":"/2020/10/06/201007spring/"},{"title":"[스프링SPRING]redirect나forward로 페이지이동하기, JSON데이터처리하기","text":"리턴타입 String일 때 리턴값을 redirect: 또는 forward:줘서 페이지이동 redirect: 또는 forward: 페이지이동 메서드에서 String 리턴시 주소 앞에 사용 리턴타입이 일반 string일때랑 redirect: 또는 forward형식의 String일때 차이가 있다. return string은 jsp뷰페이지를 바로 가는 것 return redirect: 또는 forward:은 jsp 뷰페이지를 찾는 것이 아니라 메서드를 호출하는 것 그리고 또 redirect와 forward도 차이가 있다 return &quot;redirect:doF&quot;; : 주소변경O, 페이지변경O return &quot;forward:doF&quot;; : 주소변경X, 페이지변경O 다양한 값들을 객체에 넣어서 파라미터로 전달 매개변수 객체에 데이터를 넣을 때 키값을 정하지 않고 value만 넣는 경우 자동으로 value의 데이터타입으로 전달된다. 예를 들어 model.addAttribute(&quot;1234test&quot;)한 경우 string=1234test를 주소에 붙어서 전달 다른 예로 model.addAttribute(132)인 경우 integer=132를 주소에 붙어서 전달 자바코드 key와 value를 객체에 넣기 : model.addAttribute(&quot;msg&quot;, &quot;4567test&quot;); string을 객체에 넣기 : model.addAttribute(&quot;1234test&quot;); int를 객체에 넣기 : model.addAttribute(132); 객체생성해서 객체에 넣기 : model.addAttribute(&quot;msg&quot;, new ProductVO(&quot;moniter&quot;, 2000)); =&gt; 불가능 입력한 주소 : http://localhost:8088/test/doE 메서드에 따라 호출되는 페이지 : doF.jsp 12345678910111213141516171819202122232425@Controllerpublic class SampleController4 { //로그정보 처리객체생성 private static final Logger logger = LoggerFactory.getLogger(SampleController4.class); // 맵핑 // http://localhost:8088/test/doE @RequestMapping(\"/doE\") public String doE(Model model) { logger.info(\"doE()호출\"); //model.addAttribute(\"msg\", \"4567test\"); //model.addAttribute(\"1234test\");//매개변수명을 지정하지 않으면 데이터타입으로 전달됨 string //model.addAttribute(132);//매개변수명을 지정하지 않으면 데이터타입으로 전달됨 integer //model.addAttribute(\"msg\", new ProductVO(\"moniter\", 2000)); //redirect로 파라미터 전달안됨 return \"redirect:/doF\"; //아래의 주소 호출하기 위해 사용 } // http://localhost:8088/test/doF @RequestMapping(\"/doF\") public void doF(@ModelAttribute(\"msg\") String msg) { logger.info(\"doF()호출\"); } } doF.jsp 뷰페이지 코드 (공통코드) 다양한 방법으로 파라미터 값을 가져와서 출력하려고 노력해보았다 key와 value를 객체에 넣은 경우 출력하기 : ${키_이름 } string을 객체에 넣은 경우 출력하기 : ${param.integer } int를 객체에 넣은 경우 출력하기 : ${param.string }` 키값이 없는 경우에는 param.자동으로_지정된_파라미터명으로 가져와야한다. 왜냐하면 param데이터 영역안에 값이 들어있기때문이다. 키값이 없는 경우 ${requestScope.자동으로_지정된_파라미터명 }를 사용해서 출력하려했으나 출력되지 않았다. 왜일까…? 강사님께 물어봤는데 자신도 찾아봐야겠다고하셨다… 12345678910111213141516171819&lt;body&gt;&lt;%request.setCharacterEncoding(\"UTF-8\");%&gt;여기는 doF.jsp입니다.&lt;br&gt;&lt;h2&gt;키값이 있는 파라미터 값 가져오기(객체는 안됨)&lt;/h2&gt;메세지(키값 msg) : ${msg }&lt;br&gt;&lt;hr&gt;&lt;h2&gt;키값이 없는 int 파라미터 값 가져오기&lt;/h2&gt;메세지(integer) : ${integer } 키값이 아니라서 안됨&lt;br&gt;메세지(param.integer) : ${param.integer } 파람데이터영역에서 꺼내기때문에 가능&lt;br&gt;메세지(requestScope.integer) : ${requestScope.integer } 왜 안 될까? &lt;br&gt;&lt;hr&gt;&lt;h2&gt;키값이 없는 String 파라미터 값 가져오기&lt;/h2&gt;메세지(string) : ${string } 키값이 아니라서 안됨&lt;br&gt;메세지(param.string) : ${param.string } 파람데이터영역에서 꺼내기때문에 가능&lt;br&gt;메세지(requestScope.string) : ${requestScope.string } 왜 안 될까? &lt;br&gt;&lt;/body&gt; RedirectAttributes클래스 사용하여 파라미터 1회성으로 전달하기 rttr.addFlashAttribute(&quot;msg&quot;, &quot;flash!&quot;); : 주소줄에 안보임, El표현식가능, jsp표현식불가능, 새로고침하면 사라짐(즉 1회성 데이터) 예를 들어 카운트를 올릴때 새로고침시 계속 조회수가 올라가는 것이 아니라 한번 올라가게끔 만들때 addFlashAttribute 사용 rttr.addAttribute(&quot;msg&quot;, &quot;add!&quot;); : 주소줄에 보임, El표현식가능, jsp표현식가능, 새로고침해도 그대로 자바코드 123456789101112131415161718192021222324@Controllerpublic class SampleController4 { //로그정보 처리객체생성 private static final Logger logger = LoggerFactory.getLogger(SampleController4.class); // http://localhost:8088/test/doE @RequestMapping(\"/doE\") public String doE(Model model, RedirectAttributes rttr) { logger.info(\"doE()호출\"); rttr.addFlashAttribute(\"msg\", \"flash!\"); //주소줄에 안보임, El표현식가능, jsp표현식불가능, 새로고침하면 사라짐(즉 1회성 데이터) // rttr.addAttribute(\"msg\", \"add!\"); //주소줄에 보임, El표현식가능, jsp표현식가능, 새로고침해도 그대로addFlashAttribute 사용 return \"redirect:/doF\"; } // http://localhost:8088/test/doF @RequestMapping(\"/doF\") public void doF(@ModelAttribute(\"msg\") String msg) { logger.info(\"doF()호출\"); } } doF.jsp 뷰페이지코드 1234메세지(키값 msg) : ${msg }&lt;br&gt;//출력값메세지(키값 msg) : flash! 데이터를 JSON으로 변경한 뒤 파라미터 전달하기 JSON데이터로 만들기 순서 라이브러리 복붙 doJSON()메서드 생성 Jackson Databind 라이브러리 추가 Jackson Databind » 2.8.4 버전코드를 복사하여 프로젝트의 po,.xml에 붙여넣기 복붙시 꼭 dependencies 태그 안에 위치시켜야한다. 123456789(중략) &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; doJSON()메서드 생성 ProductVO.java 객체생성 자바코드에서 사용할 json을 담을 객체를 만들어보자 12345678910111213141516171819202122232425262728293031323334//자바빈(DTO == VO)설계규약//규칙1번 : public클래스public class ProductVO { //규칙2 : private로 멤버변수 생성 private String name; private double price; //규칙4 : 생성자(생략가능 - 생략하면 디폴트생성자) public ProductVO() {}; public ProductVO(String name, double price) { this.name = name; this.price = price; }; //규칙3 : getter setter메서드생성 public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } // 5. toString @Override public String toString() { return \"제품정보 [name=\" + name + \", price=\" + price + \"]\"; }} 자바코드 VO데이터를 JSON데이터로 변경시키기위해서 리턴타입앞에 @ResponseBody을 사용한다. 12345678910111213141516171819@Controllerpublic class SampleController5 { //로그정보 처리객 체생성 private static final Logger logger = LoggerFactory.getLogger(SampleController5.class); // 맵핑 // http://localhost:8088/test/doJSON // 프레임워크를 사용하는 가장 큰 이유는 json데이터처리를 위해서. //JSON데이터로 만들기 1.라이브러리 복붙 2.doJSON()메서드생성 @RequestMapping(\"/doJSON\") public @ResponseBody ProductVO doJSON() { logger.info(\"doJSON 실행\"); ProductVO vo = new ProductVO(\"radio\", 1000); return vo; }} 뷰페이지 출력값 뷰페이지(.jsp)를 따로 만들지않아도 서버를 통해 json데이터를 화면에서 볼 수 있다. 12// 출력값{\"name\":\"radio\",\"price\":1000.0}","link":"/2020/10/12/201013spring-1/"},{"title":"[스프링SPRING]주니어레벨의 스프링MVC 개발순서, MyBatis(iBatis) 사용 방법 3가지","text":"주니어레벨의 스프링MVC 개발순서 DB -&gt; MyBatis -&gt; DAO -&gt; Service -&gt; Controller -&gt; View MyBatis(iBatis) 사용 방법 3가지 XML 코드를 사용해서 SQL구문, DAO파일에서 XML코드를 호출해서 사용 장점: SQL구문이 xml 파일로 분리, 쿼리 수정 유지보수에 유리 단점: 개발할 코드의 분량이 많아짐, 복잡도 증가 추가로 MyBatis(iBatis)란 개념 및 설치 애노테이션과 인터페이스를 사용해서 SQL구문 처리 장점: 별도의 DAO없이 개발 가능 (생산성 증가) 단점: 쿼리 수정이 필요한경우, 매번 컴파일 해야함. 인터페이스(애노테이션)와 XML을 같이 사용해서 SQL구문 처리 장점: 간단한 SQL 인터페이스로, 복잡한 SQL은 XML 파일을 사용하여 유연한 대처 단점: 개발자 마다 개발 방식의 차이가 발생 가능성 증가 MyBatis(iBatis) 사용 순서포스팅에서는 위의 3가지 방식 중에 1번 방법을 사용해 볼 것이다. 필요한 라이브러리 준비 DB생성 및 테이블 생성 도메인객체설계(DTO, VO), 클래스 생성 DAO 인터페이스 생성 인터페이스에 사용할 기능들을 작성(명세) XML Mapper 생성, SQL구문 작성 XML파일로 만들어진 Mapper의 위치설정 XML파일안에 Mapper - DTD 지정 SQL 구문 작성후 사용 MyBatis에서 XML Mapper를 인식하도록 설정 DAO 객체 구현 스프링을 활용한 DAO테스트(Junit) DB 생성 및 테이블 생성아래와 같이 테이블을 생성해준다. 도메인객체인 MemberVO.java 생성Domain(도메인)이란? 물리적인 환경으로 분리가 가능한 단위 개발(프로젝트)에서 가장 중요한 용어(단어)이고 주로 명사이다. 예를 들어 회원, 상품, 글, 주문, 배송, 댓글 … (1차 도메인) 회원-가입, 탈퇴, 수정 … (2차 도메인) 즉 DB테이블로 구분할 수 있는 단위 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itwillbs.domain;import java.sql.Timestamp;public class MemberVO { private String userid; private String userpw; private String username; private String useremail; private Timestamp regdate; private Timestamp updatedate; //생성자 2개 : 기본생성자, 멤버변수를 인자로 전부를 가진 생성자 public MemberVO() {} public MemberVO(String userid, String userpw, String username, String useremail, Timestamp regdate, Timestamp updatedate) { super(); this.userid = userid; this.userpw = userpw; this.username = username; this.useremail = useremail; this.regdate = regdate; this.updatedate = updatedate; } //get() set()메서드 생성 public String getUserid() { return userid; } public void setUserid(String userid) { this.userid = userid; } (중략) @Override public String toString() { return \"MemberVO [userid=\" + userid + \", userpw=\" + userpw + \", username=\" + username + \", useremail=\" + useremail + \", regdate=\" + regdate + \", updatedate=\" + updatedate + \"]\"; }} MemberDAO.java 인터페이스 생성 해당 도메인에 관련된 기능 선언 기능을 구현하는 것이 아니라 기능을 선언만 한다. 구현은 DAO 구현클래스에서 진행한다. 123456package com.itwillbs.persistence;public interface MemberDAO { //해당 도메인에 관련된 기능 선언 public String getTime();} XML Mapper 생성, SQL구문 작성 : memberMapper.xml 인터페이스 생성 src &gt; main &gt; resource &gt; mappers폴더생성 후 memberMapper.xml파일 생성 MyBatis 홈페이지 매핑된 SQL 구문 살펴보기에서 DOCTYPE 코드 복붙하기 XML파일로 만들어진 Mapper의 위치설정은 root-context.xml에 함 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- DTD지정 --&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- SQL 구문 작성후 사용 --&gt;&lt;mapper namespace=\"com.itwillbs.mappers.memberMapper\"&gt; &lt;select id=\"getTime\" resultType=\"string\"&gt; select now() &lt;/select&gt;&lt;/mapper&gt;&lt;!-- DAO패키지(com.itwillbs.persistence)와 연결 --&gt;&lt;context:component-scan base-package=\"com.itwillbs.persistence\" /&gt; MyBatis에서 XML Mapper를 인식하도록 설정 root-context.xml파일에 위에서 만든 mapper파일을 연결시켜준다. SqlSessionTemplate 객체 : DB연결, 사용후에는 자원해제 (close()) 처리해주는 객체 mybatis-spring 라이브러리에 포함되어있다. SqlSession 인터페이스를 구현한 객체이다. SqlSession인터페이스는 기본적인 트랜잭션, 쓰레드 처리의 안정성 보장, 디비 연결/해체처리 SqlSessionFactory 객체와 SqlSessionTemplate객체의 차이점 SqlSessionFactory객체는 Connection + MyBatis 객체연결 역할, DB해제는 못하고 Connection해제만 가능 SqlSessionTemplate객체는 DB연결/해제(pstmt, resultset포함 해제가능) 역할 크기가 작은 객체들을 먼저 생성하고 크기가 큰 객체들을 나중에 생성한다. 생성한 큰 객체들안에 작은 객체들을 주입한다. 처음부터 큰 객체를 만들면 되는데 왜 작은 객체부터 만드는걸까? 코드의 유지보수성때문에. 작은 기능을 사용할때는 작은 클래스를 사용할 수 있도록 모듈화하는 것이다. 12345678910111213141516&lt;!-- SqlSessionFactory 객체 (Connection + MyBatis 객체연결 역할, DB해제는 못하고 Connection해제만 가능)--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 위에서 생성된 객체를 주입하기 위해서는 value가 아니라 ref를 통해서 주입해야한다 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"configLocation\" value=\"classpath:/Mybatis-config.xml\" /&gt; &lt;!-- Mapper와 연결 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mappers/**/*Mapper.xml\" /&gt; &lt;/bean&gt;&lt;!-- SqlSessionFactory 객체 end--&gt;&lt;!-- SqlSesstionTemplate 객체 (DB연결/해제(pstmt, resultset포함 해제가능) 역할)--&gt;&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\" destroy-method=\"clearCache\"&gt; &lt;!-- 바로 위에 있는 sqlSessionFactory객체를 생상자 의존주입 --&gt; &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt;&lt;/bean&gt;&lt;!-- SqlSesstionTemplate 객체 end--&gt; DAO 객체 구현 : MemberDAOImpl.java 객체 생성 테스트를 위해서 @Repository 사용 DAO객체를 스프링으로 인식할 수 있도록 처리 1234567891011121314151617181920212223package com.itwillbs.persistence;import javax.inject.Inject;import org.apache.ibatis.session.SqlSession;import org.springframework.stereotype.Repository;@Repositorypublic class MemberDAOImpl implements MemberDAO { //DB연결 (xml에서 만들어진 객체를 가져다 사용하고자함 = 의존 주입) @Inject private SqlSession sqlSession; //mapper위치까지 접근 가능 but mapper가 여러개일수있음 =&gt; mapper구분필요 //mapper구분하는 값 namespace private static final String namespace = \"com.itwillbs.mappers.memberMapper\"; @Override public String getTime() { String result = sqlSession.selectOne(namespace+\".getTime\"); //괄호안에 쿼리구문 넣으면 됨 return result; } } 스프링을 활용한 DAO테스트(Junit) : MemberDAOTest.java 생성 @RunWith + @ContextConfiguration =&gt; 스프링으로 테스트하겠다는 의미 @RunWith + @ContextConfiguration + @WebAppConfiguration =&gt; 스프링MVC로 테스트하겠다는 의미 root-context.xml에 DAO객체를 연결해줘야 테스트 가능하다. 123456789101112131415161718192021222324252627282930package com.itwillbs.test;import javax.inject.Inject;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.itwillbs.persistence.MemberDAO;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= {\"file:src/main/webapp/WEB-INF/spring/root-context.xml\"})public class MemberDAOTest { //DB처리객체 생성 -&gt;MemberDAO 인터페이스라서 객체 생성할 수없다 -&gt; 의존 주입 @Inject 추가 @Inject private MemberDAO mdao; @Test public void testDAO(){ System.out.println(\"테스트 : DAO객체생성 \"+ mdao); } @Test public void testGetTime() throws Exception { //DAO getTime() 메서드 사용가능한지 테스트 System.out.println(mdao.getTime()); }}","link":"/2020/10/13/201014spring/"},{"title":"[스프링SPRING] 회원가입 및 로그인기능 구현","text":"MemberController.java 컨트롤러 생성 회원가입 기능과 로그인 기능 입력 http://localhost:8088/member/insert에서 뷰페이지를 볼 수 있다. 한글처리하는 방법 redirect의 의미 : 주소줄에 페이지 전환을 의미 파라미터를 가지고 다니는 방법 두가지 첫번째방법 : MemberVO vo 두번째 방법 : @ModelAttribute(&quot;userid&quot;) String id , 주 사용처 : 페이징처리시 페이지넘버 보통 하나의 파라미터가 있다면 아래 방법을 사용하고 두개이상의 파라미터를 가져가려면 VO객체를 가지고 이동한다. 만약 하나의 파라미터가 VO객체 안에 있는 파라미터라면 VO객체로 들고 다니면 된다. 제어 컨트롤러 : 페이지이동에 대한 제어 서비스 : 페이지이동외의 나머지 제어 메인페이지로 이동시 해당 정보 있는 경우 : =&gt; main페이지로 이동 if(returnVO.getUserid() != null) return &quot;redirect:/main&quot;; 에러발생 equest processing failed; nested exception is java.lang.NullPointerException: Cannot invoke “com.itwillbs.domain.MemberVO.getUserid()” because “returnVO” is null 따라서 if(returnVO.getUserid() != null) return &quot;redirect:/main&quot;; 대신 if(returnVO != null) return &quot;redirect:/main&quot;; 사용한다. HttpSession : 세션값생성 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.itwillbs.test;import javax.inject.Inject;import javax.servlet.http.HttpSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import com.itwillbs.domain.MemberVO;import com.itwillbs.service.MemberService;@Controller@RequestMapping(value = \"/member/*\")public class MemberController { //3-1. 서비스 처리 객체를 주입(DI) @Inject private MemberService service; private static final Logger l = LoggerFactory.getLogger(MemberController.class); /* 회원가입 처리하는 동작 */ //insert라는 하나의 주소로 get과 post방식 즉 입력과 출력 둘 다 처리 가능 // http://localhost:8088/test/insert // http://localhost:8088/test/member/insert // http://localhost:8088/member/insert @RequestMapping(value = \"/insert\", method = RequestMethod.GET) //value=\"/member/insert\"에서 member를 빼도 됨 public String insertGET() throws Exception { l.info(\"C: 회원가입 입력페이지 GET\"); return \"/member/insertMember\"; } @RequestMapping(value = \"/insert\", method = RequestMethod.POST) //value=\"/member/insertPro\"에서 member를 빼도 됨 public String insertPOST(MemberVO vo) throws Exception{ //1. 한글처리 : request객체가 없다 =&gt; web.xml에서 filter태그로 인코딩해야한다. //2. 전달된 파라미터 받기 //request.getParameter라는 내장객체가 없다. 따라서 메서드의 매개변수를 통해 가져올 수 있다. //l.info(\"C: \"+ request.getParameter()); 에러발생 l.info(\"C: \"+ vo); //3. 서비스객체 생성(직접생성안하고 의존주입) //3-2. 서비스객체호출 service.insertMember(vo); l.info(\"C: 회원가입 처리페이지 POST\"); //4. 로그인페이지로 이동(주소줄과 view페이지 동시에 insert-&gt;login 변경되어야함) return \"redirect:/member/login\"; } /* 로그인 기능 */ // http://localhost:8088/member/login @RequestMapping(value = \"/login\", method = RequestMethod.GET) public String loginGET() throws Exception{ l.info(\"C: 로그인 입력페이지 GET\"); return \"/member/loginForm\"; } @RequestMapping(value = \"/login\", method = RequestMethod.POST) //public String loginPOST(@ModelAttribute(\"userid\") String id, @ModelAttribute(\"userpw\") String pw) throws Exception{ public String loginPOST(MemberVO vo, HttpSession session, RedirectAttributes rttr) throws Exception{ l.info(\"C: 로그인 처리페이지 POST\"); //1.한글처리 =&gt; web.xml에서 완료 //2.전달받은 파라미터 저장 =&gt; loginPOST()메서드의 파라미터값으로 저장함. l.info(\"C: \"+ vo.getUserid() + vo.getUserpw()); //3.서비스객체생성 =&gt; 22번째 코드로 의존주입완료 //4.서비스 로그인 체크 동작(HttpSession) MemberVO returnVO = service.loginMember(vo); l.info(\"C: 리턴VO결과(서비스에서 예외처리를 진행했으므로 null이 출력되면 코드에 문제있다는 의미) \"+returnVO); //5.메인페이지로 이동(주소줄과 view페이지 동시에 main으로 변경되어야함) // 해당 정보 있는 경우 : =&gt; main페이지로 이동 //if(returnVO.getUserid() != null) { //에러가 발생하는 이유: if(returnVO != null) { //5.세션값생성 session.setAttribute(\"id\", returnVO.getUserid()); //RedirectAttributes의 addAttribute메서드 사용해보려고 했으나 실패. 에러 발생 //Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); //map.put(\"username\", returnVO.getUsername()); //map.put(\"useremail\", returnVO.getUseremail()); //rttr.addAttribute(\"mvo\", map); rttr.addFlashAttribute(\"mvo\", returnVO); //l.info(\"C: 모델에 뭐 들어있니?\"+model); return \"redirect:/member/main\"; } else { // 해당 정보 없는 경우 : =&gt; login페이지로 이동 return \"redirect:/member/login\"; } }//end of loginPOST()} insertMember.jsp 회원가입 입력받는 페이지 생성 회원가입 입력페이지 구현 123456789101112131415insertMember.jsp 입니다&lt;h1&gt;views의 폴더명은 컨트롤러의 모듈명과 동일&lt;/h1&gt;&lt;h1&gt; 회원가입 페이지 &lt;/h1&gt;&lt;fieldset&gt; &lt;legend&gt; ITWILL 회원가입 &lt;/legend&gt; &lt;form action=\"/member/insert\" method=\"post\"&gt; ID : &lt;input type=\"text\" name=\"userid\"&gt; &lt;br&gt; PW : &lt;input type=\"password\" name=\"userpw\"&gt; &lt;br&gt; NAME : &lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; EMAIL : &lt;input type=\"text\" name=\"useremail\"&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"회원가입\"&gt; &lt;/form&gt; &lt;/fieldset&gt; 주소줄에서 test빼기아래 방법으로 서버 주소줄에서 test를 뺄 수 있다. servers탭 &gt; server인 Tomcat 더블클릭 &gt; Modules클릭 &gt; Add Web Module클릭 &gt; Path: /test 를 /로 변경 &gt; ok클릭 &gt; 저장 후 서버 재시작 이제 http://localhost:8088/test/member/insert가 아닌 http://localhost:8088/member/insert로 접속가능하다 loginForm.jsp 로그인 입력받는 페이지 생성 로그인 입력 페이지 구현 action태그의 속성값(주소)이 없어도 동일하게 동작한다. 그 이유는 action태그에 주소가 없으면 자기 자신을 호출한다. GET방식으로 한번 호출 뒤 다시 자기자신을 호출하니까 POST방식이 호출되므로 주소가 있든 없든 동일한 결과를 볼 수 있다. 주소는 동일하지만 찾아갈 메서드가 GET에서 POST로 달라진다. 1234567891011121314loginFrom.jsp&lt;h1&gt;views의 폴더명은 컨트롤러의 모듈명과 동일&lt;/h1&gt;&lt;h1&gt; 로그인 &lt;/h1&gt;&lt;fieldset&gt; &lt;legend&gt; ITWILL 로그인 &lt;/legend&gt; &lt;!-- &lt;form action=\"/member/login\" method=\"post\"&gt; --&gt; &lt;form action=\"\" method=\"post\"&gt; ID : &lt;input type=\"text\" name=\"userid\"&gt; &lt;br&gt; PW : &lt;input type=\"password\" name=\"userpw\"&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"로그인\"&gt; &lt;input type=\"button\" onclick=\"location.href='/member/insert'\" value=\"회원가입\"&gt; &lt;/form&gt; &lt;/fieldset&gt; MemberService.java 인터페이스 생성 일반적으로는 DAO랑 같은 메소드명을 사용하여 일관성을 유지한다. 12345678910111213141516package com.itwillbs.service;import com.itwillbs.domain.MemberVO;public interface MemberService { // 회원 가입 (일반회원가입테이블에 sns계정 컬럼 추가하기) // 일반적으로는 DAO랑 같은 메소드명을 사용하여 일관성을 유지한다 public void insertMember(MemberVO vo); // 로그인기능 DAO랑 같은 이름으로 하지않은이유? 이름이 달라도 메서드생성가능하다는 걸 보여주기 위해서. // public MemberVO readMemberWithIDPW(String userid,String userpw) throws Exception; // 로그인기능 public MemberVO loginMember(MemberVO vo); } MemberServiceImpl.java 인터페이스 오버라이딩 메서드 구현 예외처리를 VO객체로 할 수 있다. catch구문안에 returnVO = null;을 넣어 실행하다 문제가 생겼을때 해당 데이터를 보내지않겠다는 의미로 예외처리를 할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940package com.itwillbs.service;import javax.inject.Inject;import org.springframework.stereotype.Service;import com.itwillbs.domain.MemberVO;import com.itwillbs.persistence.MemberDAO;@Servicepublic class MemberServiceImpl implements MemberService { //DB와 연결 (의존주입) @Inject private MemberDAO mdao; //회원가입 @Override public void insertMember(MemberVO vo) { //컨트롤러 -&gt; 서비스 호출 -&gt; DAO 호출 -&gt; Mapper -&gt; DB System.out.println(\"S : 회원가입동작\"); if(vo == null) { //처리 return; } mdao.insertMember(vo); } //로그인기능 @Override public MemberVO loginMember(MemberVO vo) { System.out.println(\"S : 컨트롤러에서 호출받으면 필요한 정보를 받아서 DAO로 전달\"); MemberVO returnVO = null; try { returnVO = mdao.readMemberWithIDPW(vo.getUserid(), vo.getUserpw()); } catch (Exception e) { e.printStackTrace(); returnVO = null; //실행하다 문제가 생겼을때 해당 데이터를 보내지않겠다는 의미 = 예외처리 } return returnVO; //null이 반환되면 앞의 코드가 문제가 있다는 것을 바로 알수있다. } } MemberDAO.java 인터페이스생성123456789101112131415import com.itwillbs.domain.MemberVO;public interface MemberDAO { //해당 도메인에 관련된 기능 선언 public String getTime(); //C: 회원가입 public void insertMember(MemberVO vo); //R: 회원 정보 조회 - 사용자 ID 해당하는 정보 가져오기 public MemberVO readMember(String userid) throws Exception; //R: 회원 정보 조회 - ID,PW정보에 해당하는 사용자 정보 public MemberVO readMemberWithIDPW(String userid,String userpw) throws Exception;} MemberDAOImpl.java 인터페이스 오버라이딩 메서드 구현1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.HashMap;import java.util.Map;import javax.inject.Inject;import org.apache.ibatis.session.SqlSession;import org.springframework.stereotype.Repository;import com.itwillbs.domain.MemberVO;@Repositorypublic class MemberDAOImpl implements MemberDAO { //DB연결 (xml에서 만들어진 객체를 가져다 사용하고자함 = 의존 주입) @Inject private SqlSession sqlSession; //mapper위치까지 접근 가능 but mapper가 여러개일수있음 =&gt; mapper구분필요 //mapper구분하는 값 namespace private static final String namespace = \"com.itwillbs.mappers.memberMapper\"; @Override public String getTime() { String result = sqlSession.selectOne(namespace+\".getTime\"); //괄호안에 쿼리구문입력하기 return result; } //회원가입구현 -&gt; memberMapper.xml 작성 후 아래 메서드 작성 -&gt; MemberDAOtest.java 이동 @Override public void insertMember(MemberVO vo) { System.out.println(\"#####\"); sqlSession.insert(namespace+\".insertMember\", vo); //괄호안은 (쿼리구문, 매개변수)순으로 입력하기 } //회원 정보 조회-사용자 ID 해당하는 정보 가져오기 @Override public MemberVO readMember(String userid) throws Exception { //테스트(컨트롤러) 호출 -&gt; 정보를 저장 -&gt; DB로이동 MemberVO vo = sqlSession.selectOne(namespace+\".readMember\", userid); //괄호안의 물음표를 콤마뒤에 쓰는거임 return vo; } //인터페이스 선언 -&gt; 서브클래스 구현 //회원 정보 조회 - ID,PW정보에 해당하는 사용자 정보 @Override public MemberVO readMemberWithIDPW(String userid, String userpw) throws Exception { //테스트(컨트롤러) 호출 -&gt; 정보를 저장 -&gt; DB로이동 //String인자를 2개를 가져갈 수 없기때문에 파라미터 두개를 객체인 Map에 넣어서 가지고 넘긴다 //return sqlSession.selectOne(namespace+\".readMemberWithIDPW\", userid, userpw); // DB로 정보를 전달하기 위해서는 sqlSeesion 객체 활용 // * 1개 이상의 정보를 전달할때는 객체 단위로 전달 // * 객체(VO) 안에 저장이 안되는 정보의 경우 Map을 사용 // Map은 key-value형태 : 이때 key값은 sql구문의 #{ㅇㅇㅇ} 이름과 같아야함 Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); paramMap.put(\"userid\", userid); paramMap.put(\"userpw\", userpw); return sqlSession.selectOne(namespace+\".readMemberWithIDPW\", paramMap); }} memberMapper.xml 구현1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- DTD지정 --&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.itwillbs.mappers.memberMapper\"&gt; &lt;select id=\"getTime\" resultType=\"string\"&gt; select now() &lt;/select&gt; &lt;!-- values(?,?,?,?) sql문법 대신에 Mybatis 문법#{}을 사용 get() 또는 set() 마이바티스가 결정해서 메서드실행--&gt; &lt;insert id=\"insertMember\"&gt; insert into tbl_member(userid,userpw,username,useremail) values (#{userid},#{userpw},#{username},#{useremail}) &lt;/insert&gt; &lt;select id=\"readMember\" resultType=\"com.itwillbs.domain.MemberVO\"&gt; select * from tbl_member where userid=#{userid} &lt;/select&gt; &lt;select id=\"readMemberWithIDPW\" resultType=\"com.itwillbs.domain.MemberVO\"&gt; select * from tbl_member where userid=#{userid} and userpw=#{userpw} &lt;/select&gt; &lt;/mapper&gt; MemberVO.java 생성123456789101112131415161718192021222324252627282930313233import java.sql.Timestamp;public class MemberVO { private String userid; private String userpw; private String username; private String useremail; private Timestamp regdate; private Timestamp updatedate; //생성자 2개 : 기본생성자, 멤버변수를 인자로 전부를 가진 생성자 public MemberVO() {} public MemberVO(String userid, String userpw, String username, String useremail, Timestamp regdate, Timestamp updatedate) { super(); this.userid = userid; this.userpw = userpw; this.username = username; this.useremail = useremail; this.regdate = regdate; this.updatedate = updatedate; } //get() set()메서드 생성 public String getUserid() { return userid; } public void setUserid(String userid) { this.userid = userid; } (중략)}","link":"/2020/10/18/201019spring-2/"},{"title":"DB 복구(Recovery)","text":"DB 복구(Recovery) controlfile 손실 시 복구 redologfile 손실 시 복구 datafile 손실 시 복구 controlfile 손실 시 복구 Controlfile다중화 목적 : 최신 시점으로 복구하기 다중화되어있는 컨트롤파일의 Member 중 하나라도 이상이 있으면 DB작동이 멈춘다. 반드시 DB를 종료한 상태에서 남아 있는 Member를 사용해서 복원해야한다. 절대 백업파일을 사용하지않는다. 백업파일을 사용해서 백업하는 경우는 오로지 다중화된 controlfile의 Member 모두가 손실된 경우. 상황 : Controlfile이 다중화되어 있는데 특정 member가 손실된 경우 1. DB켜는 중 오류를 발견 123s&gt; startup //출력 =&gt; nomount는 되지만 mount시 오류발생 DB종료 1s&gt; shut immediate 남아있는 member를 사용해서 손실된 member복구 어떤 member가 손상되었는지 log정보 확인하거나 파일위치를 호가인하여 어떤 member가 손실되었는지 확인한다. 파일이 있는데 손상되어있는 경우는 드물다. 보통은 손실되는 경우가 많다. 123456789101112131415161718192021222324// 손상되거나 손실된 컨트롤파일 찾기 =&gt; fast_recovery_area에 있는 컨트롤파일이 사라졌다.SQL&gt; show parameter control_filesSQL&gt; ![oracle@localhost ~]$ cd [oracle@localhost ~]$ cd /u01/app/oracle/oradata/ORCL/controlfile/[oracle@localhost controlfile]$ lso1_mf_fwvn95xm_.ctl[oracle@localhost controlfile]$ cd[oracle@localhost ~]$ cd /u01/app/oracle/fast_recovery_area/orcl/ORCL/controlfile/[oracle@localhost controlfile]$ ls[oracle@localhost controlfile]$ cd /home/oracle/[oracle@localhost ~]$ ls200820quizMySol.sql checkTablespaceNname.sql consNcol.sql hr1.sql ingMe.sql new_dept.sql 공개 바탕화면 서식afiedt.buf cons1.sql control103.ctl hr2.sql labs_12c ora12c 다운로드 비디오 음악backup cons2.sql hr.sql hr3.sql load_emp.sql search_cons.sql 문서 사진[oracle@localhost ~]$ ^C// 컨트롤파일 복구[oracle@localhost controlfile]$ cp o1_mf_fwvn95xm_.ctl /u01/app/oracle/fast_recovery_area/orcl/ORCL/controlfile/o1_mf_fwvn96cd_.ctl// 컨트롤파일 잘 복사되었는지 확인[oracle@localhost controlfile]$ cd /u01/app/oracle/fast_recovery_area/orcl/ORCL/controlfile/[oracle@localhost controlfile]$ lso1_mf_fwvn96cd_.ctl DB 재시작 아까는 mount되지않았던 DB가 정상적으로 start되는 것을 확인할 수 있다. 1s&gt; startup redologfile 손실 시 복구 redolog file은 group내 member가 하나라도 정상이면 DB는 정상적으로 작동한다. 남아있는 member를 사용해서 복구하지않는다 =&gt; redologfile은 reuse안됨 기존에 사용했던 redologfile명 재사용 할 수 없다. 손실된 member 삭제하고 새로 다중화해야한다. redologfile 다중화 목적 : DB가 멈추지않고 계속 운영할수있도록 위함 1. redolog file확인 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SQL&gt; select group#, members from v$log; GROUP# MEMBERS---------- ---------- 1 3 2 3 3 3 4 3 SQL&gt; select group#, member from v$logfile; GROUP# MEMBER---------- -------------------------------------------------- 3 /u01/app/oracle/oradata/ORCL/onlinelog/o1_mf_3_fwv n9t6z_.log 3 /u01/app/oracle/fast_recovery_area/orcl/ORCL/onlin elog/o1_mf_3_fwvn9xf6_.log 2 /u01/app/oracle/oradata/ORCL/onlinelog/o1_mf_2_fwv n9ddv_.log 2 /u01/app/oracle/fast_recovery_area/orcl/ORCL/onlin elog/o1_mf_2_fwvn9l85_.log GROUP# MEMBER---------- -------------------------------------------------- 1 /u01/app/oracle/oradata/ORCL/onlinelog/o1_mf_1_fwv n9ddb_.log 1 /u01/app/oracle/fast_recovery_area/orcl/ORCL/onlin elog/o1_mf_1_fwvn9o6v_.log 4 /u01/app/oracle/oradata/ORCL/onlinelog/redo4a.log 4 /u01/app/oracle/fast_recovery_area/orcl/ORCL/onlin elog/redo4b.log GROUP# MEMBER---------- -------------------------------------------------- 1 /u01/app/oracle/oradata/ORCL/datafile/redo1c.log 2 /u01/app/oracle/oradata/ORCL/datafile/redo2c.log 3 /u01/app/oracle/oradata/ORCL/datafile/redo3c.log 4 /u01/app/oracle/oradata/ORCL/datafile/redo4c.log12 rows selected. redolog file복구 명령어 1234567// redologfile 일부러 삭제alter database drop logfile member '/u01/app/oracle/oradata/ORCL/onlinelog/o1_mf_1_fwvn9ddb_.log'// rodologfile 복구alter database add logfile member '/u01/app/oracle/oradata/ORCL/onlinelog/o1_mf_1_fwvn9ddb_1.log' datafile 손실 시 복구 Recovery = Restore + Recover Restore(복원) : 백업 파일로부터 손실된 파일을 디살리는 작업 명령어 : $&gt; cp Recover(복구) : datafile만 해당되는 작업 명령어 : $&gt; cp 케이스 2가지 Non-critical datafile(일반 Datafile) 손실 시 critical datafile(필수 Datafile-system, undo) 손실 시 Non-critical datafile(일반 Datafile) 손실 시 - DB켜는 중에 손실상황) DB켜는 중에 데이터파일4의 손실 발생했을 때 DB mount됨(open안됨) 손실된 datafile을 offline시킴 1s&gt; alter database datafile 4 offline; DB오픈 시킴 1s&gt; alter database open; restore : 백업으로부터 손실된 datafile만 복원 1$&gt;cp /home/oracle/backup/user01.dbf /u01/.../datafile/user01.dbf recover : 복원된 datafile만 복구(부분 DB복구) 1s&gt; recover datafile4; 복구가 완료된 datafile online 시킴 14&gt; alter database datafile 4 online; Non-critical datafile(일반 Datafile) 손실 시 - DB켜져있는 중에 손실발생상황) DB켜져있는 중에 데이터파일4의 손실 발생했을 때 손실된 datafile만 offline시킴 1s&gt; alter database datafile 4 offline immediate; DB오픈 유지함 restore : 백업으로부터 손실된 datafile만 복원 1$&gt; cp /home/oracle/backup/user01.dbf /u01/.../datafile/user01.dbf recover : 복원된 datafile만 복구(부분 DB복구) 1s&gt; recover datafile4; 복구가 완료된 datafile online 시킴 1s&gt; alter database datafile 4 online; Non-critical datafile 손실 시 복구 예시123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// datafiles 조회SQL&gt; select file#, name from v$datafile; FILE# NAME---------- -------------------------------------------------- 1 /u01/app/oracle/oradata/ORCL/datafile/o1_mf_system _fwvn49fw_.dbf 2 /u01/app/oracle/oradata/ORCL/datafile/o1_mf_users_ hp871s7n_.dbf 3 /u01/app/oracle/oradata/ORCL/datafile/o1_mf_sysaux _fwvn5f1l_.dbf 4 /u01/app/oracle/oradata/ORCL/datafile/o1_mf_undotb s1_fwvn66mp_.dbf FILE# NAME---------- -------------------------------------------------- 5 /u01/app/oracle/oradata/ORCL/datafile/o1_mf_exampl e_hp86s7s0_.dbf 7 /u01/app/oracle/oradata/ORCL/datafile/o1_mf_users_ fwvn681o_.dbf 8 /u01/app/oracle/oradata/ORCL/datafile/appuser01.dbf 9 /u01/app/oracle/oradata/ORCL/datafile/appuser02.dbf---------- --------------------------------------------------8 rows selected.// DB종류 후 데이터파일 일부러 손실시키기 (rm 명령어 = 삭제) SQL&gt; shut immediateDatabase closed.Database dismounted.ORACLE instance shut down.SQL&gt; ![oracle@localhost ~]$ cd /u01/app/oracle//oradata/ORCL/datafile/[oracle@localhost datafile]$ lsappuser01.dbf o1_mf_sysaux_fwvn5f1l_.dbf o1_mf_undotbs1_fwvn66mp_.dbf redo1c.log redo4c.logappuser02.dbf o1_mf_system_fwvn49fw_.dbf o1_mf_users_fwvn681o_.dbf redo2c.logo1_mf_example_hp86s7s0_.dbf o1_mf_temp_fwvnbgvk_.tmp o1_mf_users_hp871s7n_.dbf redo3c.log[oracle@localhost datafile]$ rm o1_mf_users_hp871s7n_.dbf [oracle@localhost datafile]$ exitexit// DB켜기SQL&gt; startupORACLE instance started.Total System Global Area 838860800 bytesFixed Size 8626240 bytesVariable Size 620761024 bytesDatabase Buffers 201326592 bytesRedo Buffers 8146944 bytesDatabase mounted.ORA-01157: cannot identify/lock data file 2 - see DBWR trace fileORA-01110: data file 2:'/u01/app/oracle/oradata/ORCL/datafile/o1_mf_users_hp871s7n_.dbf'// 손실된 datafile만 offline시키기SQL&gt; alter database datafile 2 offline; Database altered.// DB 오픈시키기SQL&gt; alter database open;Database altered.// 백업폴더로부터 손실된 datafile만 restore시키기SQL&gt; ![oracle@localhost ~]$ cd /home/oracle/backup/[oracle@localhost backup]$ lsappuser01.dbf conbk.ctl o1_mf_sysaux_fwvn5f1l_.dbf o1_mf_undotbs1_fwvn66mp_.dbf o1_mf_users_hp871s7n_.dbfappuser02.dbf o1_mf_example_hp86s7s0_.dbf o1_mf_system_fwvn49fw_.dbf o1_mf_users_fwvn681o_.dbf[oracle@localhost backup]$ cp /home/oracle/backup/o1_mf_users_hp871s7n_.dbf /u01/app/oracle/oradata/ORCL/datafile/o1_mf_users_hp871s7n_.dbf[oracle@localhost backup]$ exitexit// 복원된 datafile만 recover하기(부분 복구)SQL&gt; recover datafile 2;Media recovery complete.// 복구가 완료된 datafile online 시키기SQL&gt; alter database datafile 2 online;Database altered.// 잘 복구되었는지 확인SQL&gt; shut immediateDatabase closed.Database dismounted.ORACLE instance shut down.SQL&gt; startupORACLE instance started.Total System Global Area 838860800 bytesFixed Size 8626240 bytesVariable Size 620761024 bytesDatabase Buffers 201326592 bytesRedo Buffers 8146944 bytesDatabase mounted.Database opened. datafile online까지 잘 진행되었다면 DB를 껐다가 재접속시 원할하게 접속 가능하다! critical datafile 손실 시 복구상황 : system01.dbf(file# : 1) 손실한 경우 DB 종료 1SQL&gt; shut abort DB mount시킨다 mount상태에서 restore와 recover를 진행해야한다. 1SQL&gt; startup mount restore : 백업 파일로부터 손실된 Datafile만 복원 1$&gt; cp /home/oracle/backup/system01.dbf /u01/.../datafile/system01.dbf recover : 모든 datafile복구(전체 DB 복구) 부분 복구가 아니라 전체 datafile을 복구해야한다. 1SQL&gt; recover database; DB open시킨다. 1SQL&gt; alter database open; critical datafile 손실 시 복구 예시 rm *system* 파일중에 system이 들어간 파일을 삭제하겠다는 쿼리. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//DB를 끄고 dafatile 중 system파일을 일부러 손실시킨다SQL&gt; shut immediateDatabase closed.Database dismounted.ORACLE instance shut down.SQL&gt; ![oracle@localhost ~]$ cd /u01/app/oracle/oradata/ORCL/datafile/[oracle@localhost datafile]$ lsappuser01.dbf o1_mf_sysaux_fwvn5f1l_.dbf o1_mf_undotbs1_fwvn66mp_.dbf redo1c.log redo4c.logappuser02.dbf o1_mf_system_fwvn49fw_.dbf o1_mf_users_fwvn681o_.dbf redo2c.logo1_mf_example_hp86s7s0_.dbf o1_mf_temp_fwvnbgvk_.tmp o1_mf_users_hp871s7n_.dbf redo3c.log[oracle@localhost datafile]$ rm *system*[oracle@localhost datafile]$ lsappuser01.dbf o1_mf_example_hp86s7s0_.dbf o1_mf_temp_fwvnbgvk_.tmp o1_mf_users_fwvn681o_.dbf redo1c.log redo3c.logappuser02.dbf o1_mf_sysaux_fwvn5f1l_.dbf o1_mf_undotbs1_fwvn66mp_.dbf o1_mf_users_hp871s7n_.dbf redo2c.log redo4c.log[oracle@localhost datafile]$ exitexitSQL&gt; show userUSER is \"SYS\"SQL&gt; startupORACLE instance started.Total System Global Area 838860800 bytesFixed Size 8626240 bytesVariable Size 620761024 bytesDatabase Buffers 201326592 bytesRedo Buffers 8146944 bytesDatabase mounted.ORA-01157: cannot identify/lock data file 1 - see DBWR trace fileORA-01110: data file 1:'/u01/app/oracle/oradata/ORCL/datafile/o1_mf_system_fwvn49fw_.dbf'// DB 종료 후 mount 시킨다.SQL&gt; shut abortORACLE instance shut down.SQL&gt; startup mountORACLE instance started.Total System Global Area 838860800 bytesFixed Size 8626240 bytesVariable Size 620761024 bytesDatabase Buffers 201326592 bytesRedo Buffers 8146944 bytesDatabase mounted.// restore한다SQL&gt; ![oracle@localhost ~]$ ls200820quizMySol.sql checkTablespaceNname.sql consNcol.sql hr1.sql ingMe.sql new_dept.sql 공개 바탕화면 서식afiedt.buf cons1.sql control103.ctl hr2.sql labs_12c ora12c 다운로드 비디오 음악backup cons2.sql hr.sql hr3.sql load_emp.sql search_cons.sql 문서 사진[oracle@localhost ~]$ cd backup/[oracle@localhost backup]$ lsappuser01.dbf conbk.ctl o1_mf_sysaux_fwvn5f1l_.dbf o1_mf_undotbs1_fwvn66mp_.dbf o1_mf_users_hp871s7n_.dbfappuser02.dbf o1_mf_example_hp86s7s0_.dbf o1_mf_system_fwvn49fw_.dbf o1_mf_users_fwvn681o_.dbf[oracle@localhost backup]$ cp o1_mf_system_fwvn49fw_.dbf /u01/app/oracle/oradata/ORCL/datafile/o1_mf_system_fwvn49fw_.dbf[oracle@localhost backup]$ exitexit// recover한다SQL&gt; recover database;Media recovery complete.// DB open시킴SQL&gt; alter database open;Database altered.// DB 어디까이 켜져있는지 확인SQL&gt; select status from v$instance;STATUS------------------------OPEN DB어디까지 켜져있는 지 확인하는 명령어","link":"/2020/10/19/201020dbi/"},{"title":"[스프링SPRING] 회원정보조회, 회원정보수정, 회원정보삭제","text":"MemberController.java 코드 추가 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 회원정보보기 */// http://localhost:8088/test/member/info@RequestMapping(value = \"/info\", method = RequestMethod.GET)public void infoGET(HttpSession session, Model model) throws Exception{ //세션 객체 안에 있는 ID정보 저장 String id = (String) session.getAttribute(\"id\"); l.info(\"C: 회원정보보기 GET의 아이디 \"+id); //서비스안의 회원정보보기 메서드 호출 MemberVO vo = service.readMember(id); //정보저장 후 페이지 이동 model.addAttribute(\"memVO\", vo); l.info(\"C: 회원정보보기 GET의 VO \"+ vo);}/* 회원정보 수정 */@RequestMapping(value=\"/update\", method = RequestMethod.GET)public String updateGET(HttpSession session, Model model) throws Exception{ //세션 객체 안에 있는 ID정보 저장 //String id = (String) session.getAttribute(\"id\"); //l.info(\"C: 회원정보수정 GET의 아이디 \"+id); //서비스안의 회원정보보기 메서드 호출 //MemberVO vo = service.readMember(id); //정보저장 후 페이지 이동 //model.addAttribute(\"memVO\", vo); //위의 3단계를 한 줄에 작성 가능 model.addAttribute(\"memVO\", service.readMember((String)session.getAttribute(\"id\"))); return \"/member/updateForm\";}@RequestMapping(value=\"/update\", method = RequestMethod.POST)public String updatePOST(MemberVO vo) throws Exception{ l.info(\"C: 회원정보수정 입력페이지 POST\"); service.updateMember(vo); return \"/member/main\";}/* 회원정보삭제 */// http://localhost:8088/test/member/delete@RequestMapping(value = \"/delete\", method = RequestMethod.GET)public String deleteGET(HttpSession session) throws Exception{ l.info(\"C: 회원정보 삭제 GET\"); // 세션제어 String id = (String) session.getAttribute(\"id\"); if(id == null) { return \"redirect:/member/main\"; } return \"/member/deleteForm\"; }@RequestMapping(value = \"/delete\", method = RequestMethod.POST)public String deletePOST(MemberVO vo, HttpSession session) throws Exception{ l.info(\"C: 회원정보 삭제 POST\"); //1. 파라미터값 저장 l.info(\"C: deleteForm전달정보 \"+vo); // 2. 전달받은 정보를 가지고 삭제 동작 처리이동 // 3. service 객체 - 동작 service.deleteMember(vo); // 4. 세션초기화 session.invalidate(); // 5. 페이지 이동 return \"redirect:/member/main\"; } main.jsp에 링크연결123456789101112131415161718192021222324252627282930&lt;link href=\"${pageContext.request.contextPath}/resources/style.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;member/main.jsp&lt;/h1&gt;&lt;%String id = (String) session.getAttribute(\"id\");if(id == null) response.sendRedirect(\"/test/member/login\");%&gt;jsp표현식 세션 : &lt;%= id %&gt; &lt;br&gt;el표현식 세션: ${id } &lt;br&gt;그냥 : ${username } , ${useremail } &lt;br&gt;mvo그냥 : ${mvo.username } , ${mvo.useremail } &lt;br&gt;&lt;hr&gt;&lt;input type=\"button\" value=\"회원정보조회\" class=\"btn\" onclick=\"location.href='/test/member/info'\"&gt;&lt;input type=\"button\" value=\"회원정보수정\" class=\"btn\" onclick=\"location.href='/test/member/update'\"&gt;&lt;input type=\"button\" value=\"로그아웃\" class=\"btn\" onclick=\"location.href='/test/member/logout'\"&gt;&lt;input type=\"button\" value=\"회원탈퇴\" class=\"btn\" onclick=\"location.href='/test/member/delete'\"&gt;&lt;!-- 관리자일때만 메뉴확인가능 --&gt;&lt;% if(id != null){ if(id.equals(\"admin\")){ %&gt; &lt;input type=\"button\" value=\"회원전체목록(관리자용)\" class=\"btn\" onclick=\"location.href='/test/member/memberList'\"&gt; &lt;input type=\"button\" value=\"상품전체목록(관리자용)\" class=\"btn\" onclick=\"location.href='/test/member/adminGoodsList'\"&gt; &lt;input type=\"button\" value=\"주문전체목록(관리자용)\" class=\"btn\" onclick=\"location.href='/test/member/adminOrderList'\"&gt; &lt;% }}%&gt; info.jsp뷰 페이지 생성123456789101112131415161718192021222324252627&lt;body&gt;/member/info.jsp&lt;h2&gt;마이페이지&lt;/h2&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;아이디&lt;/td&gt; &lt;td&gt;${memVO.userid }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;비밀번호&lt;/td&gt; &lt;td&gt;${memVO.userpw }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;이름&lt;/td&gt; &lt;td&gt;${memVO.username }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;이메일&lt;/td&gt; &lt;td&gt;${memVO.useremail }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;가입일자&lt;/td&gt; &lt;td&gt;${memVO.regdate }&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;input type=\"button\" value=\"메인으로\" class=\"btn\" onclick=\"location.href='/member/main'\"&gt;&lt;/body&gt;s updateForm.jsp 뷰페이지생성12345678910111213&lt;body&gt;&lt;fieldset&gt;&lt;legend&gt;회원정보수정&lt;/legend&gt; &lt;form action=\"/member/update\" method=\"post\" name=\"fr\"&gt; 아이디 &lt;input type=\"text\" name=\"id\" value=\"${memVO.userid }\" readonly&gt;&lt;br&gt; 비밀번호 &lt;input type=\"password\" name=\"pw\" placeholder=\"비밀번호를 입력하세요\" required&gt;&lt;br&gt; 이름 &lt;input type=\"text\" name=\"name\" value=\"${memVO.username } \"&gt;&lt;br&gt; 이메일 &lt;input type=\"text\" name=\"email\" value=\"${memVO.useremail }\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"btn\" value=\"회원정보수정하기\"&gt; &lt;input type=\"button\" class=\"btn\" value=\"메인으로\" onclick=\"location.href='/member/main'\"&gt; &lt;/form&gt;&lt;/fieldset&gt;&lt;/body&gt; deleteForm.jsp 뷰페이지생성1234567891011121314151617&lt;%// 로그인 처리 -&gt; 로그인 x (로그인페이지 이동)String id = (String) session.getAttribute(\"id\");if( id == null ){ response.sendRedirect(\"/test/member/main\");}%&gt; &lt;fieldset&gt; &lt;legend&gt;회원탈퇴&lt;/legend&gt; &lt;form action=\"/member/delete\" method=\"post\"&gt; &lt;!-- input타입중 hidden은 화면에 있는 해당 input태그를 숨겨서 정보 전달 --&gt; 아이디 : &lt;input type=\"text\" name=\"userid\" value=\"&lt;%=id %&gt;\" readonly&gt;&lt;br&gt; 비밀번호 : &lt;input type=\"password\" name=\"userpw\"&gt;&lt;br&gt; &lt;input type=\"submit\" class=\"btn\" value=\"탈퇴하기\"&gt; &lt;input type=\"button\" class=\"btn\" value=\"뒤로가기\" onclick=\"location.href='/member/main'\"&gt; &lt;/form&gt;&lt;/fieldset&gt; MemberService.java 인터페이스에 메서드 추가123456789101112131415161718192021222324package com.itwillbs.service;import com.itwillbs.domain.MemberVO;public interface MemberService { // 회원 가입 (일반회원가입테이블에 sns계정 컬럼 추가하기) // 일반적으로는 DAO랑 같은 메소드명을 사용하여 일관성을 유지한다 public void insertMember(MemberVO vo); // 로그인기능 DAO랑 같은 이름으로 하지않은이유? 이름이 달라도 메서드생성가능하다는 걸 보여주기 위해서. // public MemberVO readMemberWithIDPW(String userid, String userpw) throws Exception; // 로그인기능 public MemberVO loginMember(MemberVO vo); //회원정보 보기 public MemberVO readMember(String id); //회원정보 수정 public void updateMember(MemberVO vo); //회원정보 삭제 public void deleteMember(MemberVO vo);} MemberServiceImpl.java 메서드 오버라이딩 코드 추가1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.itwillbs.service;import javax.inject.Inject;import org.springframework.stereotype.Service;import com.itwillbs.domain.MemberVO;import com.itwillbs.persistence.MemberDAO;@Servicepublic class MemberServiceImpl implements MemberService { //DB와 연결 (의존주입) @Inject private MemberDAO mdao; //회원가입 @Override public void insertMember(MemberVO vo) { //컨트롤러 -&gt; 서비스 호출 -&gt; DAO 호출 -&gt; Mapper -&gt; DB System.out.println(\"S : 회원가입() 실행\"); if(vo == null) { //처리 return; } mdao.insertMember(vo); } //로그인기능 @Override public MemberVO loginMember(MemberVO vo) { System.out.println(\"S : 컨트롤러에서 호출받으면 필요한 정보를 받아서 DAO로 전달\"); MemberVO returnVO = null; try { returnVO = mdao.readMemberWithIDPW(vo.getUserid(), vo.getUserpw()); } catch (Exception e) { e.printStackTrace(); returnVO = null; //실행하다 문제가 생겼을때 해당 데이터를 보내지않겠다는 의미 = 예외처리 } return returnVO; //null이 반환되면 앞의 코드가 문제가 있다는 것을 바로 알수있다. } //회원정보보기 @Override public MemberVO readMember(String id) { System.out.println(\"S : readMember()실행\"); MemberVO vo = null; try { vo = mdao.readMember(id); } catch (Exception e) { e.printStackTrace(); } return vo; } //회원정보수정 @Override public void updateMember(MemberVO vo) { try { mdao.updateMember(vo); } catch (Exception e) { e.printStackTrace(); } } //회원정보삭제 @Override public void deleteMember(MemberVO vo) { try { mdao.deleteMember(vo); } catch (Exception e) { e.printStackTrace(); } }} MemberDAO.java 인터페이스에 메서드 추가1234567891011121314151617181920212223package com.itwillbs.persistence;import com.itwillbs.domain.MemberVO;public interface MemberDAO { //해당 도메인에 관련된 기능 선언 public String getTime(); //C: 회원가입 public void insertMember(MemberVO vo); //R: 회원 정보 조회 - 사용자 ID 해당하는 정보 가져오기 public MemberVO readMember(String userid) throws Exception; //R: 회원 정보 조회 - ID,PW정보에 해당하는 사용자 정보 public MemberVO readMemberWithIDPW(String userid,String userpw) throws Exception; //U: 회원정보수정 public void updateMember(MemberVO vo) throws Exception; //D: 회원탈퇴 public void deleteMember(MemberVO vo) throws Exception;} MemberDAOImpl.java 메서드 오버라이딩 코드 추가1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.itwillbs.persistence;import java.util.HashMap;import java.util.Map;import javax.inject.Inject;import org.apache.ibatis.session.SqlSession;import org.springframework.stereotype.Repository;import com.itwillbs.domain.MemberVO;@Repositorypublic class MemberDAOImpl implements MemberDAO { //DB연결 (xml에서 만들어진 객체를 가져다 사용하고자함 = 의존 주입) @Inject private SqlSession sqlSession; //mapper위치까지 접근 가능 but mapper가 여러개일수있음 =&gt; mapper구분필요 //mapper구분하는 값 namespace private static final String namespace = \"com.itwillbs.mappers.memberMapper\"; @Override public String getTime() { String result = sqlSession.selectOne(namespace+\".getTime\"); //괄호안에 쿼리구문입력하기 return result; } //회원가입구현 -&gt; memberMapper.xml 작성 후 아래 메서드 작성 -&gt; MemberDAOtest.java 이동 @Override public void insertMember(MemberVO vo) { System.out.println(\"#####\"); sqlSession.insert(namespace+\".insertMember\", vo); //괄호안은 (쿼리구문, 매개변수)순으로 입력하기 } //회원 정보 조회-사용자 ID 해당하는 정보 가져오기 @Override public MemberVO readMember(String userid) throws Exception { //테스트(컨트롤러) 호출 -&gt; 정보를 저장 -&gt; DB로이동 MemberVO vo = sqlSession.selectOne(namespace+\".readMember\", userid); //괄호안의 물음표를 콤마뒤에 쓰는거임 return vo; } //인터페이스 선언 -&gt; 서브클래스 구현 //회원 정보 조회 - ID,PW정보에 해당하는 사용자 정보 @Override public MemberVO readMemberWithIDPW(String userid, String userpw) throws Exception { //테스트(컨트롤러) 호출 -&gt; 정보를 저장 -&gt; DB로이동 //String인자를 2개를 가져갈 수 없기때문에 파라미터 두개를 객체인 Map에 넣어서 가지고 넘긴다 //return sqlSession.selectOne(namespace+\".readMemberWithIDPW\", userid, userpw); // DB로 정보를 전달하기 위해서는 sqlSeesion 객체 활용 // * 1개 이상의 정보를 전달할때는 객체 단위로 전달 // * 객체(VO) 안에 저장이 안되는 정보의 경우 Map을 사용 // Map은 key-value형태 : 이때 key값은 sql구문의 #{ㅇㅇㅇ} 이름과 같아야함 Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); paramMap.put(\"userid\", userid); paramMap.put(\"userpw\", userpw); return sqlSession.selectOne(namespace+\".readMemberWithIDPW\", paramMap); } //회원정보 수정(정보를 가지고 mapper로 이동) @Override public void updateMember(MemberVO vo) throws Exception { sqlSession.update(namespace+\".updateMember\", vo); } //회원탈퇴 @Override public void deleteMember(MemberVO vo) throws Exception { int check = sqlSession.delete(namespace+\".deleteMember\",vo); System.out.println(\"DAO : deleteMember() \"+check); }} memberMapper.xml SQL쿼리 추가12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- DTD지정 --&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.itwillbs.mappers.memberMapper\"&gt; &lt;select id=\"getTime\" resultType=\"string\"&gt; select now() &lt;/select&gt; &lt;!-- values(?,?,?,?) sql문법 대신에 Mybatis 문법#{}을 사용 get() 또는 set() 마이바티스가 결정해서 메서드실행--&gt; &lt;insert id=\"insertMember\"&gt; insert into tbl_member(userid,userpw,username,useremail) values (#{userid},#{userpw},#{username},#{useremail}) &lt;/insert&gt; &lt;select id=\"readMember\" resultType=\"com.itwillbs.domain.MemberVO\"&gt; select * from tbl_member where userid=#{userid} &lt;/select&gt; &lt;select id=\"readMemberWithIDPW\" resultType=\"com.itwillbs.domain.MemberVO\"&gt; select * from tbl_member where userid=#{userid} and userpw=#{userpw} &lt;/select&gt; &lt;update id=\"updateMember\"&gt; update tbl_member set username=#{username}, useremail=#{useremail},updatedate=now() where userid=#{userid} and userpw=#{userpw} &lt;/update&gt; &lt;delete id=\"deleteMember\"&gt; delete from tbl_member where userid=#{userid} and userpw=#{userpw} &lt;/delete&gt;&lt;/mapper&gt;","link":"/2020/10/21/201022spring/"},{"title":"[국비교육 자바JAVA 팀프로젝트]3. 깃허브와 구글드라이브로 팀프로젝트하기2, 팀장의 시행착오","text":"깃허브와 구글드라이브로 팀프로젝트하기깃허브를 적극 활용하여 팀프로젝트에 열심히 적목시키고 있다. 나는 참 인복이 좋아서 좋은 팀원들을 만났다.다들 적극적으로 협업도구를 이용하고 있다. 가장 많이 사용하는 건 카카오톡이 아니라 의외로 깃헙이다.산발적인 정보들과 아이디어들을 깃헙 위키에 모아놓으니까 팀원들도 알아서 위키를 가장 많이 찾는 것 같아 참 뿌듯하다. 카카오톡은 투표용도로 주로 사용한다. 회의일정이라든지 의견이 나뉘는 결정사항이 있을때 투표를 통해 다수결의 제안을 받아들이고 협력하고 있다.자신의 의견이 확고한 경우 찾아온 ref를 공유하고 팀원들을 설득하여 서로 성장하는 방향으로 회의를 진행하고 있다.팀원들이 좋은 회의 분위기를 만들어줘서 서로 자신의 의견도 자유롭게 얘기하는 모습이 참 좋다.팀프로젝트가 잘 진행될 것 같은 좋은 예감이 든다. 주로 사용하는 도구 깃헙 레포 위키 모든 공지사항 프로젝트 일정확인 회의록을 작성하여 회의 내용 기록 구글드라이브 공유폴더 DB테이블이나 스토리보드등을 공유하고 댓글과 글작성으로 바로바로 소통하며 업무 진행 카카오톡 오픈채팅방 익명투표 프로젝트 일정처음의 목표와 크게 달라지지않았지만 조금 일정이 바뀌고 뒤로 밀려졌다.포스팅을 작성하고 있는 지금 도메인별 기능 분배까지 완료한 상태이다. 킥오프 회의 =&gt; 10/14 수 팀플 주제 선정 =&gt; 10/15 목 강사님 컨펌 =&gt; 10/15 목 피드백반영 회의 =&gt; 10/15 목 최종 주제 선정 =&gt; 10/15 목 CSS 템플릿 투표로 결정 =&gt; 10/16 금 게시판레이아웃, 기능정리, 각자 DB테이블짜기 =&gt; 10/17 ~ 10/18 (주말동안) DB테이블생성 =&gt; 10/19 ~ 10/21 수 도메인별 기능 분배 =&gt; 10/21 수 각 팀별 기능구현(수시로 기능 통합) =&gt; 10/21 수 ~ 11/8 일 (3주) 최종 테스트 후 버그 수정 &amp; 발표PPT제작 =&gt; 11/9 월 ~ 11/15 일 발표 =&gt; 11/17 화 팀장의 시행착오팀원들과 윈윈하는 프로젝트를 만들기위해서 참 많은 생각과 노력을 하고 있다.나는 내가 만약 팀장급이 된다면 똑똑하게 회의를 할 것이라고 다짐해왔다.정말 비효율적인 회의를 싹 다 버리고 싶었다. 특히 종이들고 하는 회의들… 바로바로 기록하고 바로 찾아보는 회의가 좋다. 서로의 시간을 버리는 회의를 하고 싶지 않았다.혹자는 머리를 맞대고 얘기하다보면 좋은 결과물이 나올 수 있다고 얘기하지만 그건 이 spring프로젝트에서만큼은 절대 아니다.각자의 의견이 있는 상태에서 이야기를 나눠야 좋은 결과물이 나오는 거지 프로젝트가 어떻게 흘러가는지도 모르고 이번 회의의 목표도 모르는 상태에서 회의를 한다는 건 아무 생각없이 앉아있는 것과 다를 바가 없다.내가 생각하는 회의란 이미 자신의 생각이 있는 상태(스스로 정보찾기가 완료된 상태)에서 서로의 생각을 공유하며 시야를 확장하며 결정사항들을 완료하는 시간이다. 이를 위해 여러 시행착오가 있었다. 첫 시행착오 : CSS 템블릿 찾아오기 과정 : 팀원 전체에게 각자 CSS 템플릿을 찾아보자고했다. 아쉬운 점 : 8개 템플릿의 소스코드를 검토하는 데만 상당한 시간이 소요되었다. 배운 점 : 페어를 정해서 CSS템플릿 찾아오기를 했다면 페어끼리 서로 의견을 합치게되고 좋은 의견이 있는 4개의 템플릿후보만 검토하면 되었을 것이다. 앞으로는 페어끼리 서로의 의견을 먼저 합친 후에 팀 전체회의를 진행해야겠다. 그렇게되면 8개가 아닌 4가지 안건 중에 결정하는 회의가 되니 효율적인 회의를 할 수 있다. 두번째 시행착오 : 페어팀끼리 프로젝트에서 해보고싶은 기능과 필요한 기능을 정해오기 과정 : 지난 과오를 깨닫고 이번에는 페어팀끼리 프로젝트에서 해보고싶은 기능과 필요한 기능을 ref와 함께 찾아보자고 했다. 그리고 전체회의 전 다른 페어팀의 결과물을 읽어보고 회의에 참석해달라고 요청했다. 아쉬운 점 : 각자 PPT결과물을 가지고 발표하는 시간을 가졌는데 굉장히 많은 시간이 소요되었다. 모든 페어팀발표가 끝나기 전에 다른 방법의 회의를 진행했다. 해결과정 : 팀장인 내가 시간을 따로 들여서 서로 이견이 있는 기능 7가지를 추려서 해당 7가지 기능을 결정하는 데 나머지 시간을 사용했다. 추가로 해보고싶은 기능들은 다수결을 통해 정했다. 준비해온 페어팀들을 위해 각자 발표할 시간을 주었어야 했을까 의문이 남는다. 세번째 시행착오 : 기능배분이 먼저인지 DB생성이 먼저인지 과정 : 기능배분 후 각 기능을 담당한 페어끼리 DB생성과 뷰까지 함께 진행하면 된다고 생각했다. 하지만 그건 오산이었다… 해결방법 : 강사님들에게 조언을 구한 뒤 DB전체 테이블 작성이 우선순위인 걸 깨닫고 다같이 추가 회의를 진행했다. 배운 점 : 혼자할 때는 뭘 먼저 시작해도 항상 해결할 수 있었는데 8명이 같이 하는 프로젝트이다보니 서로 헷갈리지않게 뭘 하든 순서가 필요했다. 기능배분이 아니라 DB설계가 먼저이다. 어차피 기능구현에 시간이 많이 걸리므로 기능 배분먼저 하고 싶었던 나의 마음은 큰 욕심이었다. 또 하나 배웠다. 앞으로도 수많은 시행착오가 있을 것이지만 그 속에서 웃음을 잃지않고 많은 것을 배우고 싶다.어차피 할 거 재미있게 해야지! 주제 재선정그 사이에 토론을 통해 주제를 재선정했다.기존에는 중고쇼핑몰플랫폼을 하려고 했으나 더 많은 기능을 개발할 수 있는 중고경매플랫폼으로 변경했다.그러면서 서로 가지고 있는 경매에 대한 생각이 달라서 그 부분을 한방향으로 모으느라 애를 먹었다.지속적으로 의사소통하면서 이견이 생기지않게 조율해야겠다. 파트장 정하기강사님이 파트장이 있으면 원할한 팀프로젝트 진행이 가능하다고 하셨다.이에 내가 생각하는 파트장의 역할과 권한을 추가 기재하여 총 세 파트의 파트장을 정하였다. 1234// 위키에 공유한 파트장 역할과 권한파트장 역할 : 각자 구현된 기능들을 원활하게 통합하도록 전체 프로젝트의 흐름과 코드흐름을 조망하고 통제할 수 있습니다.파트장 권한 : 팀원들은 변수명이나 이전 소스코드를 변경시 파트장과 꼭 의논 후 진행해야합니다. 하고싶은 사람이나 추천하고싶은 사람 이야기가 오고갔으나 아무도 나서지않아서…. 결국 익명투표를 진행했다.다들 잘 모른다면서 하기싫은 눈치였다. 우리 모두 다른 분야에서 국비지원을 통해 자바개발자로 취업하려고 모였으니 모두에게 처음인건 당연한건데도 말이다.개인프로젝트발표가 끝난 뒤라 개인프로젝트결과물을 보고 나는 소신투표했다!ㅋㅋㅋㅋ나는 컨트롤러파트장을 맡게되었다.팀장으로서 혼자서 고민했던 부분을 이제 파트장들과 함께 고민하게 되어 든든하다. 컨트롤러파트장 : 나! 뷰파트장 : 비밀 DB파트장 : 비밀 기능분배가장 골머리를 썩이고 있는 것은 바로 기능 분배였다. 다들 자기가 개발하고싶은 기능을 분배받으면 가장 좋겠지만 그 실상은 꽤나 복잡하다. 서로 하고싶은 기능이 같은 경우와 서로 기피하는 기능은 도대체 누가 할 것이냐?! 이거 하나로 감정이 확 상할 수 있기때문에 신중해야하는 문제이다.나는 모두가 윈윈하는 프로젝트를 만들고 싶었으므로 정말 많이 고민했다가 일일이 모든 팀원들에게 다가가 고민을 털어놓아보았다. 그럼에도 불구하고 이거 하는 방법이 없어 강사님을 찾아가 조언을 부탁드렸다.강사님이 들어보시더니 도메인별로 하는 것이 좋겠다고 하셨다.일단 프로젝트 일정이 촉박한 편이니 우선순위 기능부터 구현하라고 하셨다.그걸 기준으로 팀원들과 회의를 통해 아래처럼 개별 개발가능한 도메인별 기능들을 나누어보았다. 12345678910&lt;개별 개발가능한 도메인별 기능분배&gt;(1순위)플젝설정+회원가입, 로그인 =&gt; 1페어내경매게시판 경매등록/수정게시판 =&gt; 1페어고객센터게시판 =&gt; 1페어결제게시판 =&gt; 1페어--- 그 다음 마이페이지(회원정보수정/탈퇴/관심상품) 기타 기능 등등 이렇게 의견을 모은 뒤 누가 어떤 기능을 담당할 것인지 의견을 말해보았다.다들 경매게시판을 하고 싶어했다. 물론 나포함 ㅋㅋㅋㅋㅋ 경매기능이 우리 프로젝트의 핵심기능이니까.파트장은 되기 싫지만 핵심기능은 만들고싶다는 사람들의 묘한 심리…. 꽤 긴 회의를 통해 결국 사다리타기를 하였고ㅋㅋㅋㅋ 누군가의 환호 또 누군가의 한숨이 뒤섞인 회의를 끝으로 각자 기능 개발을 시작할 수 있었다. 팀장의 고민 어떻게 하면 수업끝나고 남아서 회의하는 시간을 줄일 수 있을까…? 의문사항이 생겼을때 정리하여 카톡을 통해 공유하고 결정하면 남아서하는 회의 시간을 축소할 수 있지않을까?","link":"/2020/10/21/201021team/"},{"title":"[스프링SPRING]스프링게시판3: 글쓰기, 글 전체 목록 조회","text":"BoardController.java 코드 추가 method 속성은 배열로 지정 가능하다. 한 번에 여러가지 속성값(ex get, post 둘다)을 사용가능 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.itwiilbs.controller;import java.util.List;import javax.inject.Inject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.servlet.mvc.support.RedirectAttributes;import com.itwillbs.domain.BoardVO;import com.itwillbs.service.BoardService;@Controller@RequestMapping(\"/board/*\")public class BoardController { private static final Logger l = LoggerFactory.getLogger(BoardController.class); //서비스객체 @Inject private BoardService service; /* 글쓰기 */ // http://localhost:8088/board/register @RequestMapping(value = \"/register\", method = RequestMethod.GET) public void registerGET() throws Exception{ l.info(\"C: register 겟 메서드 \"); } //@RequestMapping(value = \"/register\" // ,method = {RequestMethod.POST,RequestMethod.GET}) // -&gt; method 속성은 배열로 지정 가능(한번에 여러가지 속성값을 사용가능) @RequestMapping(value = \"/register\", method = RequestMethod.POST) public String registerPOST(BoardVO vo/* , Model model */, RedirectAttributes rttr) throws Exception{ l.info(\"C: register 포스트 메서드 \"+vo); System.out.println(\"C: register 포스트 메서드 \"+vo); service.regist(vo); //정상처리일때 -&gt; 다음페이지로 정보전달 //model.addAttribute(\"result\", \"success\"); rttr.addFlashAttribute(\"result\", \"success\"); //글전체목록출력시 등록한 글에만 팝업창출력 rttr.addFlashAttribute(\"isRegist\", \"true\"); //페이지 이동 to success.jsp //return \"/board/success\"; =&gt; 새로고침하는 순간 중복글쓰기발생 return \"redirect:/board/listAll\"; } //글 전체 목록 // http://localhost:8088/board/listAll @RequestMapping(value = \"/listAll\", method = RequestMethod.GET) public void listAll(@ModelAttribute(\"result\") String result,Model model) throws Exception{ //model.addAttribute(\"msg\", result); =&gt; 여기서 제어할 필요가 없다 registerPOST()에서 처리하면 된다. // 서비스 &lt;-&gt; DAO &lt;-&gt; mapper &lt;-&gt; DB List&lt;BoardVO&gt; boardList = service.listAll(); l.info(\"C: listAll 겟 메서드\"+boardList); // 글 정보를 가지고 오기 model.addAttribute(\"boardList\", boardList); // 뷰페이지로 이동 }} register.jsp 뷰 연결123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ include file=\"../include/header.jsp\" %&gt;&lt;!-- Main content --&gt;&lt;section class=\"content\"&gt; &lt;div class=\"row\"&gt; &lt;!-- left column --&gt; &lt;div class=\"col-md-12\"&gt; &lt;!-- general form elements --&gt; &lt;div class=\"box box-primary\"&gt; &lt;div class=\"box-header\"&gt; &lt;h3 class=\"box-title\"&gt;ITWILL 게시판&lt;/h3&gt; &lt;/div&gt; &lt;!-- /.box-header --&gt; &lt;!-- 바디 --&gt; &lt;form action=\"\" role=\"form\" method=\"post\"&gt; &lt;div class=\"box-body\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;제목&lt;/label&gt; &lt;input type=\"text\" name=\"title\" class=\"form-control\" placeholder=\"제목을 입력하시오\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;내용&lt;/label&gt; &lt;textarea name=\"content\" rows=\"5\" class=\"form-control\" placeholder=\"내용을 입력하시오\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;글쓴이&lt;/label&gt; &lt;input type=\"text\" name=\"writer\" class=\"form-control\" placeholder=\"글쓴이를 입력하시오\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;글 등록&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 바디 끝 --&gt; &lt;/div&gt; &lt;!-- /.box --&gt; &lt;/div&gt; &lt;!--/.col (left) --&gt; &lt;/div&gt; &lt;!-- /.row --&gt;&lt;/section&gt;&lt;!-- /.content --&gt;&lt;/div&gt;&lt;!-- /.content-wrapper --&gt;&lt;%@ include file=\"../include/footer.jsp\" %&gt; success.jsp 뷰 연결 문제 : 새로고침하는 순간 동일한 글이 계속 DB에 생성된다.(중복 글쓰기발생) =&gt; 동일한 글이 게시판에 도배된다. 해결 : 페이지이동을 시킨다 to listAll.jsp 123456789101112131415161718192021222324252627282930313233343536373839&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ include file=\"../include/header.jsp\" %&gt;&lt;!-- Main content --&gt;&lt;section class=\"content\"&gt; &lt;div class=\"row\"&gt; &lt;!-- left column --&gt; &lt;div class=\"col-md-12\"&gt; &lt;!-- general form elements --&gt; &lt;div class=\"box box-primary\"&gt; &lt;div class=\"box-header\"&gt; &lt;h3 class=\"box-title\"&gt;게시판 글쓰기 성공&lt;/h3&gt; &lt;/div&gt; &lt;!-- /.box-header --&gt; &lt;!-- 바디 --&gt; &lt;div class=\"box-body\"&gt; &lt;h2&gt;글쓰기 성공&lt;/h2&gt; ${vo } &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &lt;h2&gt;글쓰기 성공 footer&lt;/h2&gt; &lt;/div&gt; &lt;!-- 바디 끝 --&gt; &lt;/div&gt; &lt;!-- /.box --&gt; &lt;/div&gt; &lt;!--/.col (left) --&gt; &lt;/div&gt; &lt;!-- /.row --&gt;&lt;/section&gt;&lt;!-- /.content --&gt;&lt;/div&gt;&lt;!-- /.content-wrapper --&gt;&lt;%@ include file=\"../include/footer.jsp\" %&gt; listAll.jsp 뷰 연결 jstl로 foreach사용하면 List 출력가능 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ include file=\"../include/header.jsp\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;!-- Main content --&gt;&lt;section class=\"content\"&gt; &lt;div class=\"row\"&gt; &lt;!-- left column --&gt; &lt;div class=\"col-md-12\"&gt; &lt;!-- general form elements --&gt; &lt;div class=\"box box-primary\"&gt; &lt;div class=\"box-header\"&gt; &lt;h3 class=\"box-title\"&gt;게시판 글 조희&lt;/h3&gt; &lt;/div&gt; &lt;!-- /.box-header --&gt; &lt;!-- 바디 --&gt; &lt;div class=\"box-body\"&gt; &lt;table class=\"table table-bodered\"&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;글쓴이&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;내용&lt;/th&gt; &lt;th&gt;작성일&lt;/th&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach var=\"i\" items=\"${boardList }\"&gt; &lt;tr&gt; &lt;td&gt;${i.bno }&lt;/td&gt; &lt;td&gt;${i.writer }&lt;/td&gt; &lt;td&gt;&lt;a href=\"/board/read?bno=${i.bno }\"&gt;${i.title }&lt;/a&gt;&lt;/td&gt; &lt;td&gt;${i.content }&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=\"${i.regdate }\" pattern=\"yyyy-MM-dd (E) HH:mm\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;span class=\"badge bg-red\"&gt;${i.viewcnt }&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &lt;h3&gt; &lt;/h3&gt; &lt;/div&gt; &lt;!-- 바디 끝 --&gt; &lt;/div&gt; &lt;!-- /.box --&gt; &lt;/div&gt; &lt;!--/.col (left) --&gt; &lt;/div&gt; &lt;!-- /.row --&gt;&lt;/section&gt;&lt;!-- /.content --&gt;&lt;/div&gt;&lt;!-- /.content-wrapper --&gt;&lt;script type=\"text/javascript\"&gt; let result=\"${result}\"; let isResist = \"${isRegist}\"; if(result == 'success' &amp;&amp; isResist == 'true'){ alert('성공적으로 글 작성되었습니다.'); }else if(result == 'success' &amp;&amp; isResist != 'true'){ alert('글쓰기가 실패하였습니다.'); }else{ //글쓰기없이 출력시 alert창 필요없음 }&lt;/script&gt;&lt;%@ include file=\"../include/footer.jsp\" %&gt; BoardService.java 인터페이스에 메서드 추가12345678910111213package com.itwillbs.service;import java.util.List;import com.itwillbs.domain.BoardVO;public interface BoardService { //글쓰기 public void regist(BoardVO vo) throws Exception; //글 전체 목록 public List&lt;BoardVO&gt; listAll() throws Exception;} BoardServiceImpl.java 메서드 오버라이딩 코드 추가1234567891011121314151617181920212223242526272829303132package com.itwillbs.service;import java.util.List;import javax.inject.Inject;import org.springframework.stereotype.Service;import com.itwillbs.domain.BoardVO;import com.itwillbs.persistence.BoardDAO;@Servicepublic class BoardServiceImpl implements BoardService { @Inject private BoardDAO bdao; //글쓰기 @Override public void regist(BoardVO vo) throws Exception { bdao.create(vo); System.out.println(\"S: regist메서드 \"+vo); } //글 전체 목록 @Override public List&lt;BoardVO&gt; listAll() throws Exception { List&lt;BoardVO&gt; boardList = bdao.listAll(); System.out.println(\"S: listAll메서드 \"); return boardList; } } BoardDAO.java 인터페이스에 메서드 추가12345678910111213package com.itwillbs.persistence;import java.util.List;import com.itwillbs.domain.BoardVO;public interface BoardDAO { //글쓰기 (create) public void create(BoardVO vo) throws Exception; //글 전체 목록 public List&lt;BoardVO&gt; listAll() throws Exception; } BoardDAOImpl.java 메서드 오버라이딩 코드 추가1234567891011121314151617181920212223242526272829303132333435package com.itwillbs.persistence;import java.util.List;import javax.inject.Inject;import org.apache.ibatis.session.SqlSession;import org.springframework.stereotype.Repository;import com.itwillbs.domain.BoardVO;@Repositorypublic class BoardDAOImpl implements BoardDAO { //DB접근을 위해 필요한 객체 @Inject private SqlSession session; //Mapper의 위치정보를 저장 private static final String namespace = \"com.itwillbs.mapper.BoardMapper\"; //글쓰기 @Override public void create(BoardVO vo) throws Exception { session.insert(namespace+\".create\", vo); System.out.println(\"DAO: 글쓰기메서드\"); } //글 전체 목록 @Override public List&lt;BoardVO&gt; listAll() throws Exception { System.out.println(\"DAO: 글전체목록 메서드\"); //sqlSession 객체 사용하여 Mapper 호출 return session.selectList(namespace+\".listAll\"); } } BoardMapper.xml SQL쿼리 추가 글 전체목록 조회시 DB에서 데이터를 꺼낼때 LIST형식으로 꺼낼 수 없고 컬럼단위로 저장되는 VO로 꺼내야한다. =&gt; resultType=&quot;com.itwillbs.domain.BoardVO&quot; resultType=&quot;com.itwillbs.domain.BoardVO&quot;을 자주 쓸텐데 매번 반복해야해서 번거롭다 =&gt; Mybatis-config.xml에 typeAliases태그를 추가한다. 실무에서 글 전체목록 쿼리 중 where bno&gt;0 가 문제가 될 수 있다. Mapper는 xml형식으로 부등호를 닫는 태그로 인식할 수 있기에 &lt;![CDATA[]]&gt;를 이용한다. CDATA위치는 상관없다. 쿼리전체를 묶기도하고 에러발생부분만(where bno&gt;0)을 묶기도 한다 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.itwillbs.mapper.BoardMapper\"&gt; &lt;insert id=\"create\"&gt; insert into tbl_board (title,content,writer) values (#{title},#{content},#{writer}) &lt;/insert&gt; &lt;!-- DB에서 데이터를 꺼낼때 LIST형식으로 꺼낼 수 없고 컬럼단위를 VO로 꺼낼 수 있다 --&gt; &lt;!-- 실무에선 where bno&gt;0 가 문제가 될 수 있다. Mapper는 xml형식으로 부등호를 닫는 태그로 인식할 수도 있다. &lt;![CDATA[]]&gt;를 이용한다 CDATA위치는 상관없다. 범용적으로 쿼리전체를 묶기도하고 에러발생부분만(where bno&gt;0)을 묶기도 한다--&gt; &lt;!-- resultType=\"com.itwillbs.domain.BoardVO\"을 자주쓸텐데 매번 반복해야한다 &gt; Mybatis-config.xml를 입력한다 &lt;select id=\"listAll\" resultType=\"com.itwillbs.domain.BoardVO\" &gt; --&gt; &lt;select id=\"listAll\" resultType=\"BoardVO\" &gt; &lt;![CDATA[ select * from tbl_board where bno &gt; 0 order by bno desc, regdate desc ]]&gt; &lt;/select&gt;&lt;/mapper&gt; Mybatis-config.xml 코드 추가 자주 쓰는 도메인을 지정 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!-- 자주쓰는 도메인을 지정 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.itwillbs.domain\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt;","link":"/2020/10/27/201028spring/"},{"title":"[스프링SPRING MVC]구글 로그인 API(google login API)","text":"기본배경지식팀프로젝트로 SNS API 로그인 기능을 구현했다.간단할 줄 알았는데 이틀이나 고생을 했다. 안되겠다싶어서 생활코딩으로 개념을 잡고 다시 차근차근하니 성공했다!역시 기본기가 중요하다. 그냥 코드붙여넣지말고 개념을 챙기자! 나는 일반 회원가입과 로그인도 만들고 구글 아이디로 회원가입과 동시에 로그인하는 코드를 구현했다.간단한 방식으로 만들었으므로 완벽한 코드가 아님을 미리 알린다. 구글 WEB 로그인 문서 구글 버튼 디자인 바꾸기 폴더구조 구글 APIs에서 사용자 인증정보생성 구글 API 사용자 인증 정보 프로젝트이름과 URI 그리고 리디렉션 URI 를 설정한다. URI : 로그인하는 URI 리디렉션 URI : 로그인 후에 이동할 URI MemberController 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import javax.inject.Inject;import javax.servlet.http.HttpSession;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.mvc.support.RedirectAttributes;import com.bestpricemarket.domain.MemberVO;import com.bestpricemarket.service.MemberService;@Controller@RequestMapping(value = \"/member/*\")public class MemberController { @Inject //@Autowired private MemberService service; private static final Logger l = LoggerFactory.getLogger(MemberController.class); /* 회원가입 */ // http://localhost:8088/member/join @RequestMapping(value = \"/join\", method = RequestMethod.GET) public String insertGET() throws Exception { return \"/member/loginandjoin\"; } @RequestMapping(value = \"/join\", method = RequestMethod.POST) public String insertPOST(MemberVO vo) throws Exception{ l.info(\"C: 회원가입포스트메서드\"+ vo); service.joinMember(vo); return \"redirect:/member/login\"; } //회원가입시 아이디중복확인 @RequestMapping(value = \"/idCheck\", method = RequestMethod.POST) public @ResponseBody int idCheck(@RequestParam(\"id\") String id) throws Exception { MemberVO ck = service.idCheck(id); if(ck != null) return 1; else return 0; } /* 로그인 기능 */ // http://localhost:8088/member/login @RequestMapping(value = \"/login\", method = RequestMethod.GET) public String loginGET() throws Exception{ return \"/member/loginandjoin\"; } @RequestMapping(value = \"/login\", method = RequestMethod.POST) public String loginPOST(MemberVO vo, HttpSession session, RedirectAttributes rttr) throws Exception{ MemberVO returnVO = service.loginMember(vo); System.out.println(\"C: 리턴VO결과(서비스에서 예외처리를 진행했으므로 null이 출력되면 코드에 문제있다는 의미) \"+returnVO); if(returnVO != null) { session.setAttribute(\"id\", returnVO.getId()); rttr.addFlashAttribute(\"mvo\", returnVO); return \"redirect:/member/main\"; } else { return \"redirect:/member/login\"; } } /* 로그아웃 */ @RequestMapping(value = \"/logout\", method = RequestMethod.GET) public void logoutGET(HttpSession session) throws Exception{ l.info(\"C: 로그아웃 GET\"); session.invalidate(); // return \"redirect:/member/main\"; 얼럿창출력안하고싶을때 사용 } /* 구글아이디로 로그인 */ @ResponseBody @RequestMapping(value = \"/loginGoogle\", method = RequestMethod.POST) public String loginGooglePOST(MemberVO vo, HttpSession session, RedirectAttributes rttr, MemberVO mvo) throws Exception{ MemberVO returnVO = service.loginMemberByGoogle(vo); String mvo_ajaxid = mvo.getId(); System.out.println(\"C: 구글아이디 포스트 db에서 가져온 vo \"+ vo); System.out.println(\"C: 구글아이디 포스트 ajax에서 가져온 id \"+ mvo_ajaxid); if(returnVO == null) { //아이디가 DB에 존재하지 않는 경우 //구글 회원가입 service.joinMemberByGoogle(vo); //구글 로그인 returnVO = service.loginMemberByGoogle(vo); session.setAttribute(\"id\", returnVO.getId()); rttr.addFlashAttribute(\"mvo\", returnVO); } if(mvo_ajaxid.equals(returnVO.getId())){ //아이디가 DB에 존재하는 경우 //구글 로그인 service.loginMemberByGoogle(vo); session.setAttribute(\"id\", returnVO.getId()); rttr.addFlashAttribute(\"mvo\", returnVO); }else {//아이디가 DB에 존재하지 않는 경우 //구글 회원가입 service.joinMemberByGoogle(vo); //구글 로그인 returnVO = service.loginMemberByGoogle(vo); session.setAttribute(\"id\", returnVO.getId()); rttr.addFlashAttribute(\"mvo\", returnVO); } return \"redirect:/member/main\"; } 일반 회원가입, 로그인, 로그아웃 기능 구현아래 포스팅을 참고해서 일반 회원가입과 로그인 로그아웃기능을 구현했다.구글 SNS API를 추가한 코드만 작성하고자한다. 회원가입 및 로그인기능 구현 로그아웃 MemberService.java 코드1234567891011121314151617181920212223242526272829import com.bestpricemarket.domain.MemberVO;// 일반적으로는 DAO랑 같은 메소드명을 사용하여 일관성을 유지한다public interface MemberService { // 회원 가입 (일반회원가입테이블에 sns계정 컬럼 추가하기) public void joinMember(MemberVO vo); // 로그인 public MemberVO loginMember(MemberVO vo); // 회원가입시 아이디중복확인 public MemberVO idCheck(String id); // 회원정보 보기 public MemberVO readMember(String id); // 회원정보 수정 public void updateMember(MemberVO vo); // 회원탈퇴 public void deleteMember(MemberVO vo); //구글회원가입 public void joinMemberByGoogle(MemberVO vo); //구글로그인 public MemberVO loginMemberByGoogle(MemberVO vo); } MemberServiceImpl.java 코드일반 회원가입/로그인과 구글을 이용한 회원가입/로그인을 나누어서 작성해보았다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import javax.inject.Inject;import org.springframework.stereotype.Service;import com.bestpricemarket.domain.MemberVO;import com.bestpricemarket.persistence.MemberDAO;@Servicepublic class MemberServiceImpl implements MemberService{ //DB와 연결 (의존주입) @Inject //@Autowired private MemberDAO mdao; // 회원가입 @Override public void joinMember(MemberVO vo) { mdao.joinMember(vo); } // 로그인 @Override public MemberVO loginMember(MemberVO vo) { MemberVO returnVO = null; try { returnVO = mdao.readMemberWithIDPW(vo.getId(), vo.getPw()); System.out.println(\"S: 로그인 아디: \"+vo.getId()+\" 비번: \"+vo.getPw()+\" 이름: \"+vo.getUsername()); } catch (Exception e) { e.printStackTrace(); returnVO = null; //실행하다 문제가 생겼을때 해당 데이터를 보내지않겠다는 의미 = 예외처리 } return returnVO; } // 회원가입시 아이디중복확인 @Override public MemberVO idCheck(String id) { return mdao.idCheck(id); } // 회원정보보기 @Override public MemberVO readMember(String id) { MemberVO vo = null; try { vo = mdao.readMember(id); System.out.println(\"S: 로그인 정보 리턴\"); } catch (Exception e) { e.printStackTrace(); } return vo; } // 회원정보 수정 @Override public void updateMember(MemberVO vo) { try { mdao.updateMember(vo); } catch (Exception e) { e.printStackTrace(); } } // 회원탈퇴 @Override public void deleteMember(MemberVO vo) { try { mdao.deleteMember(vo); System.out.println(\"S: vo 확인\"+vo); } catch (Exception e) { e.printStackTrace(); } } //구글 회원가입 @Override public void joinMemberByGoogle(MemberVO vo) { mdao.joinMember(vo); } //구글 로그인 @Override public MemberVO loginMemberByGoogle(MemberVO vo) { MemberVO returnVO = null; try { returnVO = mdao.readMemberWithIDPW(vo.getId(), vo.getPw()); System.out.println(\"S: 로그인 아디: \"+vo.getId()+\" 비번: \"+vo.getPw()+\" 이름: \"+vo.getUsername()); } catch (Exception e) { e.printStackTrace(); returnVO = null; //실행하다 문제가 생겼을때 해당 데이터를 보내지않겠다는 의미 = 예외처리 } return returnVO; }} loginandjoin.jsp 코드가장 중요한 건 뷰이다. Ajax를 이용하여 데이터를 넘겼다. 구글 로그인 버튼 1&lt;span id=\"google_login\" class=\"circle google\" onclick=\"init();\"&gt; &lt;i class=\"fa fa-google-plus fa-fw\"&gt;&lt;/i&gt; &lt;/span&gt; 스크립트 코드구글에 따르면 profile.getId()값을 id로 서버로 전송하지말고 id_token사용을 사용하라고 적혀있다.보안문제가 발생할 수 있기 때문이다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- google signin api --&gt;&lt;script src=\"https://apis.google.com/js/platform.js?onload=init\" async defer&gt;&lt;/script&gt;// google signin APIvar googleUser = {};function init() { gapi.load('auth2', function() { console.log(\"init()시작\"); auth2 = gapi.auth2.init({ client_id: '구글API의 클라이언트 ID 입력' cookiepolicy: 'single_host_origin', }); attachSignin(document.getElementById('google_login')); });}//google signin API2function attachSignin(element) { auth2.attachClickHandler(element, {}, function(googleUser) { var profile = googleUser.getBasicProfile(); var id_token = googleUser.getAuthResponse().id_token; console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead. console.log('ID토큰: ' + id_token); console.log('Name: ' + profile.getName()); console.log('Email: ' + profile.getEmail()); // This is null if the 'email' scope is not present. $(function() { $.ajax({ url: '/member/loginGoogle', type: 'post', data: { \"id\" : &lt;!-- 필요한 데이터 담기 --&gt;, \"pw\" : &lt;!-- 필요한 데이터 담기 --&gt;, \"username\": profile.getName(), \"email\": profile.getEmail() }, success: function (data) { alert(\"구글아이디로 로그인 되었습니다\"); location.href=\"/member/main\"; } }); }) }, function(error) { alert(JSON.stringify(error, undefined, 2)); }); console.log(\"구글API 끝\"); } 결과물 참고 생활코딩 WEB2 - OAuth 2.0개념 생활코딩 Google Login","link":"/2020/10/30/201030googleloginapi/"},{"title":"[스프링SPRING] 게시판 페이징처리","text":"게시판 페이징처리 목적 : 필요한 만큼의 데이터를 전송/처리하기 위해서 서버에서 처리 가능한 가장 빠른 속도로 페이지 처리를 해야한다. 방식 2가지 &lt;a&gt;태그 : href속성으로 이동할 uri 지정 장점 : 검색엔진 노출에 효과적이다. 한번에 정보를 파악하기가 쉽다. 한계 : 반복적인 링크정보가 필요 &lt;form&gt;태그 : action속성으로 추가적인 정보를 가지고 지정한 uri러 이동 장점 : 간결한 페이지 이동, 필요한 데이터 추가저장 가능 페이징처리의 원칙 페이징처리는 반드시 get방식이어야 한다. 사용자에게 url로 정보를 전달하기때문에 get방식으로 해야한다. 페이징처리 완료시 반드시 목록으로 가기동작이 있어야 한다. 만약 3페이지의 글을 읽고 다시 목록으로 돌아갈때, 다시 3페이지로 이동해야한다. 페이징 처리시 반드시 필요한 페이지 번호만 제공 페이징 처리의 크기에 따라서 [이전],[다음]동작을 구현 페이징처리 개발순서 페이지 데이터가 화면에 출력 화면 하단에 보이는 페이징처리 본문 -&gt; 리스트이동시 페이징처리 페이지 하단부 페이징처리와 사용객체 페이지 이동시 처리 Criteria 객체안의 page와 pageSize를 사용 page - 현재 페이지번호 pageSize - 한 페이지에 출력할 개수 직접 계산해서 처리 시작페이지번호(startPage) 예) 화면에 10개의 페이지번호 데이터를 출력. [이전]이 부분 페이지 이동 제어를 담당. 끝페이지번호(endPage) : 시작페이지 번호에서 몇개 보여줄건지 결정 예) 총65페이지를 10개씩 출력하려면 총 7개페이지가 있어야한다. DB에서 처리 전체 글의 수(totalCount) DB에서 row수로 가져오거나 ai제약조건있으면 가장 마지막 번호 가져오기 [이전]페이지이동(prev) : 시작페이지가 1이 아닌 경우 생성됨 [다음]페이지이동(next) : 끝페이지 페이지블럭 BoardController.java 코드추가123456789101112131415161718192021//페이징처리한 글목록@RequestMapping(value = \"/listCri\", method = RequestMethod.GET)public void listCriGET(Criteria cri, Model model) throws Exception{ l.info(\"C: listCri 겟 호출\" + cri); model.addAttribute(\"boardList\", service.listCri(cri));}//글목록보기(PageMaker객체 사용)// http://localhost:8088/board/listPage@RequestMapping(value = \"/listPage\", method = RequestMethod.GET)public void listPageGET(Criteria cri, Model model) throws Exception{ l.info(\"C: cri는 \"+cri); model.addAttribute(\"boardList\", service.listCri(cri)); PageMaker pm = new PageMaker(); pm.setCri(cri); pm.setTotalCount(service.pageCount()); //DB의 전체ROW수 입력 // 뷰페이지로 전달 model.addAttribute(\"pm\", pm);} BoardService.java 코드추가12345//페이징처리한 글목록public List&lt;BoardVO&gt; listCri(Criteria cri) throws Exception;//DB 테이블에 있는 모든 글 개수 계산 후 리턴public int pageCount() throws Exception; BoardServiceImpl.java 코드추가1234567891011//페이지처리한 글 목록@Overridepublic List&lt;BoardVO&gt; listCri(Criteria cri) throws Exception { return bdao.listPageCri(cri);}//DB 테이블에 있는 모든 글 개수 계산 후 리턴@Overridepublic int pageCount() throws Exception { return bdao.pageCount();} BoardDAO.java 코드추가12345678//특정 페이지에 있는 글정보를 확인 public List&lt;BoardVO&gt; listPage(int page) throws Exception; //페이징 처리하는 동작(Criteria 객체 사용)public List&lt;BoardVO&gt; listPageCri(Criteria cri) throws Exception;//DB 테이블에 있는 모든 글 개수 계산 후 리턴public int pageCount() throws Exception; BoardDAOImpl.java 코드추가1234567891011121314151617181920212223//페이징@Overridepublic List&lt;BoardVO&gt; listPage(int page) throws Exception { //페이지가 0인 경우 1로 바꿔서 처리 if(page &lt;= 0) { page = 1; } page = (page - 1)*10; return session.selectList(namespace+\".listPage\", page);}//페이징 처리하는 동작(Criteria 객체 사용)@Overridepublic List&lt;BoardVO&gt; listPageCri(Criteria cri) throws Exception { System.out.println(\"DAO: listPageCri 호출\"); return session.selectList(namespace+\".listPageCri\", cri);}//DB 테이블에 있는 모든 글 개수 계산 후 리턴@Overridepublic int pageCount() throws Exception{ return session.selectOne(namespace+\".pageCount\");} BoardMapper.xml 코드추가12345678910111213141516171819&lt;!-- 페이지정보를 10개씩 가져오기 --&gt;&lt;select id=\"listPage\" resultType=\"BoardVO\"&gt; select * from tbl_board order by bno desc, regdate desc limit #{page},10&lt;/select&gt;&lt;!-- 페이지정보를 지정한 크기만큼 가져오기 --&gt;&lt;select id=\"listPageCri\" resultType=\"BoardVO\"&gt; select * from tbl_board order by bno desc, regdate desc limit #{pageStart},#{pageSize}&lt;/select&gt;&lt;select id=\"pageCount\" resultType=\"int\"&gt; select count(*) from tbl_board&lt;/select&gt; BoardDAOTest.java 테스트 코드 추가하기 src/test/java 폴더에서 test파일을 생성한다. 테스트가 정상적으로 작동함을 콘솔에서 확인할 수 있다. 123456789101112131415161718192021@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {\"file:src/main/webapp/WEB-INF/spring/root-context.xml\"})public class BoardDAOTest { //DB객체 @Inject private BoardDAO bdao; // 특정 페이지의 글 정보 확인 @Test public void testListPage() throws Exception{ //페이지정보 1,3,5 int page = 5; //주입받은 DAO 객체 사용 접근 List&lt;BoardVO&gt; boardList = bdao.listPage(page); //리스트에 저장된 정보를 콘솔창에 출력 for(BoardVO vo :boardList) { System.out.println(vo.getBno()+\"------\"+vo.getTitle()); } }} Criteria.java 생성 src/main/java에 domain폴더 하위에 생성한다. setter메서드에 추가 제어 코드를 넣어준다. 멤버변수가 아니지만 gettet와 setter를 생성하면 Mapper에서 접근가능하다. 멤버변수는 없지만 DB에서 처리해야하는 값을 생성하기 위해 GET메서드를 생성한다. Mapper에 접근가능한 이유는 getXXXX() 형태를 Mapper가 가지고 있기 때문 Mapper에서 사용하는 방법은 #{get을_제외한_메서드명} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Criteria { //페이지 정보, 페이지 크기 정보를 저장하는 객체 private int page; private int pageSize; public Criteria() { this.page = 1; this.pageSize = 10; } public int getPage() { return page; } public void setPage(int page) { if(page &lt;=0) { this.page = 1; return; } this.page = page; } public int getPageSize() { return pageSize; } public void setPageSize(int pageSize) { if(pageSize &lt;=0 || pageSize &gt; 100) { this.pageSize = 10; return; } this.pageSize = pageSize; } //페이징처리 시작하는 값생성 //멤버변수가 아니지만 gettet와 setter를 생성하면 Mapper에서 접근가능하다. //Mapper에서 사용하는 법 #{pageStart} public int getPageStart() { return (this.page - 1)*this.pageSize; } //toString() @Override public String toString() { return \"Criteria [page=\" + page + \", pageSize=\" + pageSize + \"]\"; } } PageMaker.java 객체 생성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.itwillbs.domain;public class PageMaker { private int totalCount; private int startPage; private int endPage; private boolean prev; private boolean next; //Criteria안에 page, pageSize 있음 private Criteria cri; //화면에 보여지는 페이지블럭의 수 private int displayPageNum = 10; public PageMaker() {} public PageMaker(int totalCount, int startPage, int endPage, boolean prev, boolean next, Criteria cri, int displayPageNum) { super(); this.totalCount = totalCount; this.startPage = startPage; this.endPage = endPage; this.prev = prev; this.next = next; this.cri = cri; this.displayPageNum = displayPageNum; } public int getTotalCount() { return totalCount; } public void setTotalCount(int totalCount) { //변경 this.totalCount = totalCount; System.out.println(\"DB에서 총 글의 개수를 계산\"); //총 글의 개수를 가지고 왔을때 필요한 정보를 계산 calcDate(); } private void calcDate() { endPage = (int) (Math.ceil(cri.getPage()/(double)displayPageNum) * displayPageNum); startPage = (endPage - displayPageNum) +1; int tempEndPage = (int) (Math.ceil(totalCount/(double)cri.getPageSize())); if(endPage &gt; tempEndPage) endPage = tempEndPage; prev = (startPage == 1? false:true); next = (endPage * cri.getPageSize() &gt;= totalCount? false:true); System.out.println(\"페이징처리정보 계산\"); } public int getStartPage() { return startPage; } public void setStartPage(int startPage) { this.startPage = startPage; } public int getEndPage() { return endPage; } public void setEndPage(int endPage) { this.endPage = endPage; } public boolean isPrev() { return prev; } public void setPrev(boolean prev) { this.prev = prev; } public boolean isNext() { return next; } public void setNext(boolean next) { this.next = next; } public Criteria getCri() { return cri; } public void setCri(Criteria cri) { //변경 this.cri = cri; } public int getDisplayPageNum() { return displayPageNum; } public void setDisplayPageNum(int displayPageNum) { this.displayPageNum = displayPageNum; } @Override public String toString() { return \"PageMaker [totalCount=\" + totalCount + \", startPage=\" + startPage + \", endPage=\" + endPage + \", prev=\" + prev + \", next=\" + next + \", cri=\" + cri + \", displayPageNum=\" + displayPageNum + \"]\"; } } listPage.jsp 뷰 생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ include file=\"../include/header.jsp\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;!-- Main content --&gt;&lt;section class=\"content\"&gt; &lt;div class=\"row\"&gt; &lt;!-- left column --&gt; &lt;div class=\"col-md-12\"&gt; &lt;!-- general form elements --&gt; &lt;div class=\"box box-primary\"&gt; &lt;div class=\"box-header\"&gt; &lt;h3 class=\"box-title\"&gt;게시판 글 조회&lt;/h3&gt; &lt;/div&gt; &lt;!-- /.box-header --&gt; &lt;!-- 바디 --&gt; &lt;div class=\"box-body\"&gt; &lt;table class=\"table table-bodered\"&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;글쓴이&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;내용&lt;/th&gt; &lt;th&gt;작성일&lt;/th&gt; &lt;th&gt;조회수&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach var=\"i\" items=\"${boardList }\"&gt; &lt;tr&gt; &lt;td&gt;${i.bno }&lt;/td&gt; &lt;td&gt;${i.writer }&lt;/td&gt; &lt;td&gt;&lt;a href=\"/board/read?bno=${i.bno }\"&gt;${i.title }&lt;/a&gt;&lt;/td&gt; &lt;td&gt;${i.content }&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=\"${i.regdate }\" pattern=\"yyyy-MM-dd (E) HH:mm\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;span class=\"badge bg-red\"&gt;${i.viewcnt }&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class=\"box-footer\"&gt; &lt;div class=\"text-center\"&gt; &lt;ul class=\"pagination\"&gt; &lt;!-- 이전prev --&gt; &lt;c:if test=\"${pm.prev }\"&gt; &lt;li&gt;&lt;a href=\"listPage?page=${pm.startPage-1}\"&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;!-- 페이지블럭 --&gt; &lt;c:forEach var=\"idx\" begin=\"${pm.startPage }\" end=\"${pm.endPage }\"&gt; &lt;!-- 삼항연산자를 사용해서 class로 스타일적용 --&gt; &lt;li ${pm.cri.page == idx? 'class=active':''}&gt; &lt;a href=\"listPage?page=${idx }\"&gt;${idx}&lt;/a&gt; &lt;/li&gt; &lt;/c:forEach&gt; &lt;!-- 다음next --&gt; &lt;c:if test=\"${pm.next &amp;&amp; pm.endPage &gt; 0}\"&gt; &lt;li&gt;&lt;a href=\"listPage?page=${pm.endPage+1}\"&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 바디 끝 --&gt; &lt;/div&gt; &lt;!-- /.box --&gt; &lt;/div&gt; &lt;!--/.col (left) --&gt; &lt;/div&gt; &lt;!-- /.row --&gt;&lt;/section&gt;&lt;!-- /.content --&gt;&lt;/div&gt;&lt;!-- /.content-wrapper --&gt;&lt;script type=\"text/javascript\"&gt; let result=\"${result}\"; let isResist = \"${isRegist}\"; if(result == 'success' &amp;&amp; isResist == 'true'){ alert('성공적으로 글 작성되었습니다.'); }else if(result == 'success' &amp;&amp; isResist != 'true'){ alert('글쓰기가 실패하였습니다.'); }else if(result =='up-ok'){ alert('성공적으로 글이 수정되었습니다.'); }else if(result =='delete-ok'){ alert('성공적으로 글이 삭제되었습니다.'); }else{ //글쓰기없이 출력시 alert창 필요없음 }&lt;/script&gt;&lt;%@ include file=\"../include/footer.jsp\" %&gt; 결과","link":"/2020/11/01/201102spring-1/"},{"title":"[REST API]REST란? RESTful이란? REST API란?","text":"REST(Representational State Transfer) 개념 : 하나의 URI는 하나의 고유한 리소스를 가진다. REST가 필요한 이유 : 모바일 기기가 다양해지면서 REST를 통해 다양한 기기로 공통의 데이터를 처리할 수 있다. REST API : REST방식을 사용한 API으로 핵심데이터, 콘텐츠, 기능등을 외부 페이지에서 가져와 사용할 수 있게 만들어 놓은 인터페이스이다. 외부 페이지를 어떻게 가져올까? URI 주소를 통해서! RESTful 의미 : REST방식의 서비스 제공이 가능한 형태. 필수 지침 : 마이크로 소프트 웹 API 디자인 DOCUMENT 이해에 도움이 되는 유튜브영상! 이해하기 쉽게 설명해주신다. REST 개발을 위한 제약조건 Client - Server : 요청 또는 제공 진영으로 표준 인터페이스를 사용해서 구분하며 상호 독립적이어야한다. 리소스(html, json등)를 관리하는 서버가 존재하고 다수의 클라이언트가 리소스를 소비하려고 네트워크를 통해 서버에 접근하는 구조여야한다. stateless(상태없음) : 클라이언트의 컨텍스트가 서버에 저장되지 않고 클라이언트에 저장되어야한다. 컨텍스트는 간단히 내 프로젝트 데이터라고 할 수 있다. 그리고 이 컨텍스트를 서버에 저장하지않아야한다는 의미이다. 즉, 서버는 이전 정보를 모른다 -&gt; 그럼 로그인 상태유지는 how? 클라이언트가 정보를 가지고 요청해야 한다. 상태없음이란? 클라이언트가 서버에 요청을 보낼 때 서버는 이전 요청의 영향을 받지 않음을 의미. HTTP는 기본적으로 상태가 없는 프로토콜임. 따라서 HTTP를 사용하는 웹 애플리케이션은 기본적으로 상태가 없는 구조를 따른다. cashe : 서버의 응답은 캐싱될 수 있어야하고 이를 사용하여 확장성, 개발 성능을 개선할 수 있다. 서버에서 리소스를 리턴할 때 캐시가 가능한지 아닌지 명시할 수 있어야 한다. uniform interface : 표준 인터페이스가 존재. 각각 서버/클라이언트를 발전가능 =&gt;아키텍쳐 디커플링 리소스 접근할때 인터페이스가 일관적 + URI의 일관성있어야 한다. layered system : 클라이언트와 서버사이의 부하분산을 의미허며 캐싱과 같은 중개서버 사용 가능하다. 클라이언트는 서버 레이어 존재 유무를 알지 못해야한다. 계층을 만들어서 클라이언트와 1:1이 아닌, 중간 서버가 필요하다는 의미 code-on-demand : Java Applet/Script를 통해 클라이언트가 사용가능한 코드를 제공한다. 필수는 아니고 선택사항으로 클라이언트는 서버에 코드를 요청할 수 있고 서버가 리턴한 코드를 실행할 수 있어야한다. SOAPREST API와 상반된 개념xml데이터를 사용해서 header와 body를 생성 후 text/xml형태로 정보를 전달한다. uniform interfaceuniform interface는 정해진 룰이 존재한다. 리소스는 URI로 구분되어야한다. 리소스를 생성/추가/삭제할때는 HTTP메세지의 상태정보를 사용해서 전달해야한다. 메세지는 스스로 설명가능해야한다. 즉 메세지 자체에 바로 이해할 수 있는 의미가 있어야한다. 프로그램 상태는 하이퍼링크로 전달 가능해야한다. @ResponseBody와 @RestController @ResponseBody @RestController 사용가능버전 스프링3버전부터 스프링4버전부터 개념 객체를 json으로 만들어주는 어노테이션 jsp뷰를 찾아가는게 아니라 데이터를 생성하는 것(REST방식) 사용특징 메서드/리턴타입에 사용가능 클래스에만 사용 특징 MessageConverter에 의해서 처리되는 정보가 브라우저로 전달되는 처리방식 하위의 메서드는 @ResponseBody가 없어도 동일하게 처리된다(@ResponseBody생략됨) 예시 jackson-databind 라이브러리 추가 jQuery 3.x snippet 뷰페이지에 복붙 어노테이션특징 @PathVariable : 요청URL에 있는 매개변수를 json형태로 가져옴 주소의 {num}값을 저장하여 사용가능 @RequestBody : JSON형태로 전달된 데이터를 해당 파라미터 타입에 자동으로 저장하겠다는 의미 소스코드 TestController.java 소스코드 @RestController를 활용하여 String, int, List, Map, JSON객체까지 데이터처리를 할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.itwillbs.controller;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import com.itwillbs.domain.SampleVO;@RestController@RequestMapping(value = \"/test/*\")public class TestController { //@ResponseBody : 객체를 json으로 만들어주는 어노테이션 //@RestController : 스프링4부터, 하위의 메서드는 @ResponseBody가 없어도 동일하게 처리된다(@ResponseBody생략됨) //http://localhost:8088/test/hello @RequestMapping(value= \"hello\", method= RequestMethod.GET) public String hello() { //문자열리턴의 목적은 : jsp페이지로 가는 것이 아니라 문자열타입의 데이터를 리턴하거나 생성하는 목적으로 사용된다. return \"Hello ITWILL!\"; //text형태로 보여짐 } //http://localhost:8088/test/sendVO @RequestMapping(value= \"sendVO\") public @ResponseBody SampleVO sendVO() { SampleVO svo = new SampleVO(1, \"나혜석\", \"010-123-4567\" ); return svo; } //컬렉션객체활용 1.List(리스트) //http://localhost:8088/test/sendList @RequestMapping(value = \"sendList\") public List&lt;SampleVO&gt; sendList(){ List&lt;SampleVO&gt; voList = new ArrayList&lt;SampleVO&gt;(); for(int i=0;i&lt;10;i++) { SampleVO vo = new SampleVO(i, \"나혜석\", \"0\"+i+\"0-123-4567\" ); voList.add(vo); } return voList; } //컬렉션객체활용 2.Map //http://localhost:8088/test/sendMap @RequestMapping(value = \"sendMap\") public Map&lt;Integer, SampleVO&gt; sendMap(){ Map&lt;Integer, SampleVO&gt; voMap = new HashMap&lt;Integer, SampleVO&gt;(); for(int i=0;i&lt;10;i++) { SampleVO vo = new SampleVO(i, \"나혜석\", \"0\"+i+\"0-123-4567\" ); voMap.put(i, vo); } return voMap; } //파라미터들을 json데이터로 꺼내올 수 있음 //http://localhost:8088/test/board2/1234 //@RequestMapping(value = \"board/{num}\") public int board(@PathVariable(\"num\") int num) { return num; //숫자리턴은 json형태가 된다. } //String타입 매개변수도 사용가능하다 @RequestMapping(value = \"board/{num}\") public int board(@PathVariable(\"num\") String num) { System.out.println(num); return 0; //숫자리턴은 json형태가 된다. } //String타입 매개변수도 사용가능하다 @RequestMapping(value = \"board2/{num}\") public SampleVO board2(@PathVariable(\"num\") int num) { SampleVO vo = new SampleVO(num, \"나혜석\", \"0\"+num+\"0-123-4567\" ); return vo; //숫자리턴은 json형태가 된다. } //ajax로 데이터전달받기 @RequestMapping(value = \"info\", method = RequestMethod.POST) public void checkVO(@RequestBody SampleVO vo) { //@RequestBody : JSON형태로 전달된 데이터를 해당타입(여기서는 SampleVO)에 자동으로 저장함 System.out.println(\"REST컨트롤러 checkVO메서드 호출\"+vo); } } SampleVO.java 소스코드 12345678910111213141516171819202122package com.itwillbs.domain;public class SampleVO { private Integer num; private String name; private String tel; public SampleVO() {}; public SampleVO(Integer num, String name, String tel) { super(); this.num = num; this.name = name; this.tel = tel; } public Integer getNum() { return num; } public void setNum(Integer num) { this.num = num; } (이하생략)} JSONTest.jsp 소스코드 JSON.stringify(member) : member변수로 만든 객체를 문자열로 바꾼다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;!-- 제이쿼리 라이브러리추가 --&gt;&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$(function(){ //alert(\"제이쿼리 테스트\") //뷰에서 버튼 클릭시, 전달한 데이터를 JSON형태로 생성 후 전송 -&gt; ajax 비동기방식사용하여 RestController로 이동 -&gt; RestController안에서 정보를 전달받아서 표시 $('#checkJsonBtn').click(function(){ //1.JSON형태로 데이터 생성 let member = {num: \"777\", name: \"사용자1\", tel: \"010-777-7777\"}; //2.데이터를 ajax 비동기방식으로 전송 $.ajax({ type:\"post\", url:\"${contextPath}/test/info\", //contextPath는 컨크롤러의 시작지점(/)을 의미 contentType: \"application/json\", data: JSON.stringify(member), //member변수로 만든 객체를 문자열로 바꿔서 보낸다는 의미 success:function(){ alert(\"ajax 이동 성공\") }, error:function(){ alert(\"ajax 이동 실패\") }, complete:function(){ alert(\"ajax complete 항상 실행(이건 성공/실패 유무와 상관없이 항상 실행됨)\") } }); });});&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;JSONtest.jsp&lt;/h1&gt;일반컨트롤러(HomeController)로 접속 후 input태그 사용&lt;br&gt;&lt;input type=\"button\" id=\"checkJsonBtn\" value=\"회원정보전송\"&gt;&lt;/body&gt;&lt;/html&gt; REST API를 RESTful API로!이상학 - RESTful API 설계 가이드를 참고하니 좋은 내용이 정말 많았다. 꼭 읽어봐야하는 글이다! 정리 분류 설명 추가설명 URL Rules 1 마지막에 / 포함하지 않는다. URL Rules 2 _(underbar) 대신 -(dash)를 사용한다. URL Rules 3 소문자를 사용한다. URL Rules 4 행위(method)는 URL에 포함하지 않는다. URL Rules 5 컨트롤 자원을 의미하는 URL 예외적으로 동사를 허용한다. Set HTTP Headers 1 Content-Location Set HTTP Headers 2 Content-Type Set HTTP Headers 3 Retry-After 인증, 자원 요청 Set HTTP Headers 4 Link Use HTTP methods 1 POST, GET, PUT, DELETE 4가지 methods는 반드시 제공한다. Use HTTP methods 2 OPTIONS, HEAD, PATCH를 사용하여 완성도 높은 API를 만든다. OPTIONS, HEAD, PATCH Use HTTP status 1 의미에 맞는 HTTP status를 리턴한다. Use HTTP status 2 HTTP status만으로 상태 에러를 나타낸다. Use the correct HTTP status code 1 성공 응답은 2XX로 응답한다. Use the correct HTTP status code 2 실패 응답은 4XX로 응답한다. Use the correct HTTP status code 3 5XX 에러는 절대 사용자에게 나타내지 마라! Use HATEOAS 구성 요소 Paging Paging Key HTTP Header의 Link 속성을 이용하고 HATEOAS로 응답한다. Ordering Ordering Filtering Field-Selecting Versioning 예외적으로 서비스의 기본 도메인이 3차인 경우 path level에 모두 명시한다. Use HTTP statusRESTful API를 설계하기 위해선 HTTP status를 정확하게 사용해야한다.서버API를 개발하다보면 흔하게(?) 받는 요청사항이 모든 응답을 200으로 처리하고 body 내용으로 성공|실패를 판단하게끔 해달라는 것이었다. 이는 사실 잘못된 설계이다.그와 관련해서 이상학 - REST API 관점에서 바라보는 HTTP 상태 코드(HTTP status code)글이 정말 좋다. 강력추천!","link":"/2020/11/09/201110restapi/"},{"title":"[웨비나후기]3월 우아한테크세미나 : 우아한 ATDD","text":"웨비나 소개 및 후기테스트의 중요성은 익히 알고 있지만 코드를 짜기 급급한 나는 테스트 주도 개발을 해본 적이 없다.이번 웨비나를 통해 간접적으로나마 우아한형제들에서는 어떻게 ATDD를 하는지 알 수 있어서 유익했다.또 인수 테스트와 단위테스트에 대한 비교를 실제 사례로 들어볼 수 있어서 이해가 쏙쏙 되었다.너무 재밌다! 토이프로젝트에 꼭 넣어보고싶다! ATDD (인수테스트) 란?TDD(단위테스트) 수행시 어떻게 시작하고 언제 끝나는 지가 모호한 경우가 많고 각 단위들이 잘 통합하는 지 확인하기 어렵다.만약 인수테스트가 없다면 배포해서 기능 동작을 확인해야하며 페이지에서 테스트를 해야하고 수동으로 변경사항을 확인해야한다.하지만 인수테스트가 있으면 배포없이 테스트로 대부분 검증이 가능해지며 인수 테스트로 스펙표현까지 가능하다. 시나리오(사용자 스토리) 기반으로 기능 테스트 장점 배포없이 받는 빠른 피드백 새로운 팀의 도메인과 서비스 흐름 파악에 큰 도움이 됨 도메인 이해에 예상보다는 짧은 시간이 소요 ATDD 개발 프로세스 ATDD 개발 프로세스: 시나리오 기반 표현 방식(Given:사전조건/When:검증대상/Then:기대결과)을 통한 인수 조건 정의 -&gt; 인수 테스트 작성 -&gt; 기능구현 즉 예제로 명세하기 -&gt; 예제로 정제하기 -&gt; 실행가능한 명세만들기 인수조건인수조건 작성시 검증하고자하는 when 구문을 먼저 작성 후 기대 결과를 의미하는 then구문 작성하고 when과 then에서 필요한 정보를 given을 통해서 마련한다. 인수조건 예시1 12345678910기능 : 강의 수강 대기 신청인수조건:- given: 강사는 강의를 생성했다. 강사는 강의를 신청 가능 상태로 변경했다. 강의 모집인원만큼 신청을 받았다.- when: 회원이 수강 대기 신청을 요청한다.- then: 회원은 강의의 수강 대기자로 등록되었다.인수테스트: 실제 요청/응답하는 환경과 유사하게 테스트 환경을 구성기눙구현: 코드작성. TDD로 진행할 수 있음 인수조건 예시2 12345678910기능 : 강의 수강 대기 신청인수조건:- given: 수강생이 수강 신청을 하였다. 과정의 남은 기간이 절반 이상이다.- when: 강사는 특정 수강생의 수강 상태를 취소 요청을 한다.- then: 특정 수강생의 수강 상태가 취소된다. 특정 수강생의 결제 내역이 환불된다.인수테스트: 실제 요청/응답하는 환경과 유사하게 테스트 환경을 구성기눙구현: 코드작성. TDD로 진행할 수 있음 인수테스트 특징: Black Box 테스트(내부 구조나 작동과 연관이 없는 테스트) UI레벨 대신 API 레벨 인수테스트를 추천: 백엔드 개발자 입장에서 공수가 너무 많이 들기때문. 테스트도구 테스트 서버(환경): @SpringBootTest 실제 웹 환경과 유사한 RANDOM_PORT 설정 선택 테스트 클라이언트: MockMVC, WebTestClient, RestAssured 테스트 환경+테스트클라이언트 조합 @SpringBootTest / Mock + MockMVC @SpringBootTest / RANDOM_PORT + RestAssured (연사님 픽) TDD 강연 추천 성공적인 ATDD 도입하기 나혼자 ATDD 토이 프로젝트로 충분히 경험 쌓기 간단한 기능부터 적용해보기 경험해보면서 상황에 맞는 방법 찾기 실전 프로젝트 적용시 아주 쉽게 시작할 수 있는 부분, 기본적인 기능부터 도입 레거시 기반 인수 테스트 작성하기 먼저 인수 테스트를 작성하여 기존에 구현된 기능을 보호하기 인수 가이드 작성 지속적인 리뉴얼, 버전업 지속적인 피드백 기획 &amp; QA와 함께하는 ATDD 기획 &amp; QA 담당자에게 장점을 소개하며 설득하기 개발 친화적인 용어는 제외하고 설명하기 EX) 추가적인 커뮤니케이션비용이 절약될거다. EX) 테스트시간이 단축된다. 기존 방식과 비교하여 장점 이야기하기 다같이 만드는 요구사항 화면 기반으로 작성할 경우 이해도가 높음 모든 인수 조건을 다같이 만드는 건 비효율적 실제 적용사례 후기실제로 처음 조직에 적용했을때의 피드백 장점: Common Understanding 다른 포지션의 관점은 물론 업무 프로세스도 간접적으로 익힐 수 있음 단점: 인수 조건 정의가 어렵고 문서를 어떻게 관리해야할 지에 대한 고민이 필요 질의응답Q. RestAssured를 사용하신다고 하셨는데 TestRestTemplate를 사용해서 백엔드만의 테스트를 가능하다고 생각하는데 RestAssured를 따로 사용하신 이유가 있으실까요? TestRestTemplate 객체를 사용하지않는 이유는 공식문서에 다른 객체를 사용해라는 말이 있어서 곧 없어지겠구나생각을 했고 사용하는 면에 있어서도 RestAssured가 편했기에 사용했다. 각각 장단점이 있으니 직접 사용한 뒤 상황에 맞게 적용하면 될 것같다. Q. 세미나를 들으면서 문득 궁금점이 생겼는데 어떤 기능 하나를 개발하고자 할 때 인수 테스트부터 작성하려고 하면 유닛 테스트에 비해 해결해야 하는 문제가 커서 TDD가 주는 빠른 피드백과 설계에 도움을 주는 장점이 많이 희석될 것 같다는 생각이 드는데요. 인수테스트 작성 비용과 사이클을 도는 데까지 드는 시간도 오래걸린다. 인수테스트 하나를 만든다면 그 안에 TDD가 포함되어있다. 도메인단위테스트만 만들어도 되지만 인수테스트는 요청과 응답이 명확하다는 장점이 있다.인수테스트가 빠른 피드백을 주기는 힘들지만 해당 기능을 배포하지않고도 확인할 수 있다는 장점이 있다. Q. 한글/영어로 각 테스트 메소드 작성하실때 어떤 컨벤션을 지키시는 중이신가요? 핵심이 되는 도메인이름작성후 when과 같이 요청을 하는 부분은 요청이라는 컨벤션을 넣어서 진행중이다. 언더바를 사용해서 처리하고 있고 팀원들과 회의하면서 진행하고 있다. Q. ATDD를 작성 후 어떤 사이클로 실행하나요? 배포 전에? pr날릴 때?? 인수테스트를 만들고 내부 기능을 TDD로 만든다. 기능 구현이 어느정도 끝나면 인수테스트를 한번 돌리고 배포전에는 모든 인수테스트를 통과해야 배포가 되게끔 하고있다. PR날릴때는 실행하지않는다. Q. 테스트 커버리지를 수시로 확인하시나요? 불안감이 적은 수준으로 테스트코드를 작성하려고 노력하고 있고 코드리뷰라는 장치가 있기때문에 테스트 커버리지를 따로 확인하지 않고 있다. Q.TDD도 아직 잘 안되는 팀인데, ATDD를 하기는 버거울 것 같은데 TDD를 먼저 도입을 하고 그 후에 ATDD를 도입하는게 괜찮을까요? TDD보다 ATDD를 도입하는 것이 더 쉽게 접근할 수 있다고 생각한다. 적용하기 쉬운 부분부터 차근차근 적용하는 것을 추천한다. API 요청과 응답이 명확하기때문에 ATDD가 더 접근하기 쉽다. 우리 서비스의 핵심부분에 대해서만이라도 ATDD를 적용하여 경험을 쌓으면서 점차 확대하는 것이 좋을 것 같다. Q. 설득하는 방법 변화를 만들기위해서는 본인이 인수테스트에 대한 자신감이 있어야한다. 생각치도 못한 예외상황을 빠르게 해결해야한다. 이를 위해서 토이프로젝트를 통해 기술을 쌓아야한다. 변화를 원하는 사람이 가장 늦게까지 야근한다. 그 속에서 가장 많이 성장하는 사람은 바로 나 자신이다. 개발자는 사라져도 리더는 사라지지않는다. 미래지향적인 생각을 가졌으면 좋겠다. 참고자료아래는 ATDD이해를 위해 내가 추가적으로 학습한 자료이다. ATDD 개념 인수테스트 주도 개발 (Acceptance Test Driven Development)","link":"/2021/03/15/210316woowatechATDD/"},{"title":"Algorithm전체목록List","text":"🌊코드업 1011 : 문자 한 개 입력받아 그대로 출력하기 1012 : 실수 한 개 입력받아 그대로 출력하기, float실수소수점 표현하기 1014 : 문자 2개 입력받아 순서 바꿔 출력하기, Scanner vs BufferedReader 차이 1018 : 시간 입력받아 그대로 출력하기, next()와 nextLine()차이, parseInt, valueOf의 차이 1023 : 실수 1개 입력받아 부분별로 출력하기, split대신 StringTokenizer사용하기 1034 : 8진 정수 1개 입력받아 10진수로 출력하기(설명), Scanner로 2진수, 8진수 16진수 받기 1041 : 문자 1개 입력받아 다음 문자 출력하기(설명), Scanner로 char받기 1059 : 비트단위로 NOT 하여 출력하기(설명), Scanner로 2진수받기 1064 : 정수 3개 입력받아 가장 작은 수 출력하기(설명), 삼항연산자로 최소값찾기 1066 : 정수 3개 입력받아 짝/홀 출력하기(설명), Scanner 기본구분자, whitespace(화이트스페이스)뜻 1071 : 0 입력될 때까지 무한 출력하기1, goto말고while문사용 1082 : 16진수 구구단? 1084 : 빛 섞어 색 만들기(설명) 1093 : 이상한 출석 번호 부르기1(설명) 1097 : 바둑알 십자 뒤집기(설명) 1099 : 성실한 개미(설명) 🌊leetcode Easy레벨 전체 13. Roman to Integer 14. Longest Common Prefix 125. Valid Palindrome 136. Single Number 172. Factorial Trailing Zeroes 190. Reverse Bits 🌊Hackker Rank Easy레벨 Between Two Sets Picking Numbers Sherlock and Squares Two Characters Separate the Numbers Missing Numbers Big Sorting Grid Challenge Luck Balance Maximum Perimeter Triangle 🌊백준 11005번 진법 변환2 2562번 최댓값 10818번 최소, 최대 1110번 더하기 사이클 4344번 평균은 넘겠지 3052번 나머지 1065번 한수 11720번 숫자의 합 2908번 상수 2869번 달팽이는 올라가고 싶다 2751번 수 정렬하기2 🌊프로그래머스 문자열 내 p와 y의 개수 제일 작은 수 제거하기 모든 코드업(codeup)(CodeUp)100제 자바(java)(JAVA) 풀이 : 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999","link":"/2021/06/30/algorithmList/"},{"title":"[오픈소스컨트리뷰톤2020] Git List","text":"🍏GIT 전체 순서 Git config(깃설정), 오픈소스 참여를 위한 GIT 순서 (팀협업) 오픈소스 Git 기여순서(취소포함) 내 로컬저장소를 원격저장소를 반영하여 최신 베이스만들기 🍏GIT 활용 개발자가 오픈소스를 읽는 방법(Git log) add 취소, commit 명령어 수정, commit 취소, 라이센스 commit 생성, reset과 revert의 차이 특정 소스라인에 대해서 누가 마지막으로 수정을 했는지 찾기 git blame Git flow 전략 git bash내 특정 상황에서 빠져나가기 명령어 🍏Branch Git branch 기초 git reflog 기초 삭제한 옛날 branch 살리기 🍏Merge, Rebase, Pull rebase로 commit 추가,수정,삭제하기 내 로컬저장소를 원격저장소를 반영하여 최신 베이스만들기 Merge시 create a merge commit과 rebase and merge 차이 🍏git 공부사이트 visualizing-git learngitbranching GitHub Learning lab 🍏미팅 후기 7/25 첫번째 미팅 : 오픈소스컨트리뷰톤 킥오프미팅 후기 8/01 두번째 미팅 : 오픈소스컨트리뷰톤 온라인미팅1 후기 : 모던 js 오픈소스 기여순서 8/06 세번째 미팅 : 오픈소스컨트리뷰톤 온라인미팅2 후기 8/08 네번째 미팅 : 오픈소스컨트리뷰톤 온라인미팅3 후기 8/11 다섯번째 미팅 : 오픈소스 Git 기여순서(취소포함) + 내 로컬저장소를 원격저장소를 반영하여 최신 베이스만들기 8/22 여섯번째 미팅 : 오픈소스컨트리뷰톤 온라인미팅5 후기 : GIT 케이스 스터디 9/12 여덟번째 미팅 : 오픈소스컨트리뷰톤 온라인미팅7 후기 9/21 멘토링 : 프론트엔드 직무멘토링 9/23 멘토링 : IT편집자 직무멘토링 🍏추천 책 추천 : Http 완벽 가이드 : 다 읽어보진않더라고 1장부터 7장까지는 필수이다. 주니어 프론트앤드개발자 면접질문으로도 자주 나오므로 꼭 읽어볼 것. 책 추천 : 리눅스 커맨드라인 완벽입문서 책 추천 : 자바의 정석 오픈소스컨트리뷰톤 온라인미팅 중 현직꿀팁 모음집 책 추천 : 코딩을 지탱하는 기술","link":"/2020/09/13/opensourceList/"},{"title":"Oracle DB구조1 : Database","text":"오라클 데이터베이스 구조 오라클DB는 크게 인스턴스(SGA 메모리구조와 백그라운드 프로세스와 데이터베이스로 나뉜다. 인스턴스: 메모리 안에 만들어진다. 오라클 시스템의 논리적인 구조(로지컬 스트럭쳐) 데이터베이스: 하드드라이브 안에 만들어 진다. 오라클 시스템의 물리적인 구조이다.(피지컬스트럭쳐). 실제 오라클에 관련된 정보를 담고있는 파일을 칭함. 인스턴스와 데이터베이스는 동적으로 연결되어 있다. 필수파일들이 망가지는 경우 DB가 아예 작동하지 않는다. -&gt; 백업, 복구작업진행해야함. InstanceSGA(System Grobal Area)메모리구조Shared poolLibrary cache :- 최근에 실행된 sql구문과 실행계획이 저장되는 공간- LRU(Least Recently Used Algorithm) 알고리즘으로 관리됨.- 대소문자, 공백까지 일치가 되어야 hit됨.Data dictionary cache : - 최근에 사용된 DB 정의정보가 저장된 공간- 정의정보란 file, object, 권한, 제약조건 등- LRU(Least Recently Used Algorithm) 알고리즘으로 관리됨.DB buffer cache실제 실행 작업을 하는 메모리 구조-최근에 사용된 Data block이 저장된 곳-LRU 알고리즘으로 관리됨Redo log buffer-DB에서 발생된 변경작업의 로그정보(Redo data)가 기록되는 곳-순환형으로 관리됨Background ProcessPMON- User proc fail시 진행하던 트랜잭션 롤백 및 선점하고 있던 자원과 lock을 해제함SMON- Instance fail(= DB 비정삭적인 종료) 후 DB 재시작될 때 DB동기화를 시켜줌DBWR- DB buffer cache의 Dirty block을 datafile로 기록함- 체크포인트 발생시 기록함LGWR- commit이 발생될 때 redo log buffer의 로그정보(= redo data)를 redo log file로 기록함CKPT- 체크포인트 발생시 DBWR에게 알려줌.- DBWR기록 후 datafiles 헤더와 controlfile에 마지막 체크포인트 번호를 갱신함DatabaseDatabase 3대파일Data files실제 data가 저장되는 공간data dictionary가 저장되는 공간datafile 정보 조회 : v$datafile(영구data), v$tempfile(임시data)Control fileDB의 무결성 유지/관리할 수 있는 모든 동기화정보가 기록된 공간DB의 논리적/물리적 구조 정보, 마지막 작업번호 등이 저장DB당 하나이상 존재 -&gt; 최대8개까지 다중화기능제공오라클 권장 3개Control file 정보조회: v$controlfileRedolog filesDB에서발생된 변경 작업의 로그정보(Redo data)가 기록된 공간주목적 : Datafile recovery(복구)DB당 최소 2개이상 존재순환형 관리Redo log Group(논리적 구조) : DB당 2개이상Redo log Member(물리적 구조,file) : Redo log Group당 1개이상오라클 권장사항 : Group 3개, Member 2개씩Redolog files 정보조회 : v$log, v$logfileParameter fileInstance의 정의정보가 기록된 공간SGA할당정보, B/G proc정보 등DB의 여러 설정 정보가 기록된 공간위치 : $ORACLE_HOME/dbs이름 : spfileSID.ora 또는 initSID.oraPassword fileDB를 시작/종료할 수 있도록 인증해주는 공간.위치 : $ORACLE_HOME/dbs이름 : orapwSIDOptionalArchived log files- Redo log file의 오프라인 복사본- 주목적 : Datafile Recovery- log mode : Narchive log mode VS Archive log mode 중 선택- log mode 정보 조회 : v$database Database 5가지 필수물리적파일datafiles 실제 data가 저장되는 공간 =&gt; 따라서 관리를 잘해야한다. data dictionary가 저장되는 공간 datafile 정보 조회 : v$datafile, v$tempfile v$datafile : 영구데이터 v$tempfile : 임시데이터, DB를 끌때 같이 날라감. v$datafile, v$tempfile 라이브러리를 사용하여 정보조회가 가능하다. 1234567891011121314151617181920// v$datafile : 영구데이터desc v$datafileselect name, bytes from v$datafile;NAME BYTES--------------------------------------------------------------- ----------/u01/app/oracle/oradata/ORCL/datafile/o1_mf_system_fwvn49fw_.dbf 838860800/u01/app/oracle/oradata/ORCL/datafile/o1_mf_sysaux_fwvn5f1l_.dbf 545259520/u01/app/oracle/oradata/ORCL/datafile/o1_mf_undotbs1_fwvn66mp_.dbf 73400320/u01/app/oracle/oradata/ORCL/datafile/o1_mf_users_fwvn681o_.dbf 5242880// v$tempfile : 임시데이터desc v$tempfileselect name, bytes from v$tempfile;NAME BYTES------------------------------------------------------------ ----------/u01/app/oracle/oradata/ORCL/datafile/o1_mf_temp_fwvnbgvk_.tmp 135266304 Control file 데이터베이스의 무결성을 유지 관리할 수 있는 DB의 모든 동기화정보가 기록된 공간 DB의 논리적/물리적 구조 정보, 마지막 작업번호 등이 저장되어있음 DB당 하나만 존재하면 됨. 컨트롤파일이 날라갔다 = DB가 날라갔다, 컨트롤파일이 과거로 되돌아가는 것 = DB가 과거로 되돌아 가는 것 이렇듯 너무나 중요한 Control file은 백업으로는 역부족하여 데이터손실이 날 수 있으므로 Control file다중화를 통해서 동시 운영하는 것을 권장. Control file다중화 최대8개까지 다중화기능제공되고 오라클 3개권장 다중화가 많을 수록 안정성\u0018, 성능↓ (3개든5개든 다중화 갯수만큼 동시에 기록해야해서 성능떨어짐) 다중화가 적을 수록 안정성↓, 성능\u0018 다중화시킬때는 경로를 나눠서 운영해야함. 예를 들어 c드라이브와 d드라이브에 하나씩. Control file 정보조회 : v$controlfile 123456789101112131415161718//컨트롤파일 정보 조회SQL&gt; desc v$controlfile; Name Null? Type -------------------------- -------- --------------- STATUS VARCHAR2(7) NAME VARCHAR2(513) IS_RECOVERY_DEST_FILE VARCHAR2(3) BLOCK_SIZE NUMBER FILE_SIZE_BLKS NUMBER CON_ID NUMBERSQL&gt; select name from v$controlfile;NAME------------------------------------------------------------/u01/app/oracle/oradata/ORCL/controlfile/o1_mf_fwvn95xm_.ctl/u01/app/oracle/fast_recovery_area/orcl/ORCL/controlfile/o1_mf_fwvn96cd_.ctl 조회결과를 보면 .ctl컨트롤 파일이 2개이다. 따라서 다중화 개수도 2개이다. (online) Redo log files DB에서발생된 변경 작업의 로그정보(Redo data)가 기록된 공간 DB에서발생된 변경 작업이란 DML 후 COMMIT, 오토커밋까지 한 작업 이미 변경작업이 완료된 정보를 왜 로그 남길까? 주목적 : Datafile recovery(복구) DB당 최소 2개이상존재해야함 순환형으로 관리되는 파일 -&gt; 순환하면서 로그를 덮어쓴다. 다중화기능 제공. 다중화 개수 제한 없음. 다중화가 많을 수록 안정성\u0018, 성능↓ 기본 구조: Redo log Group(논리적 구조) : DB당 Redo log Group이 2개이상 존재해야함 Redo log Member(물리적 구조, 실질적인 file) : Redo log Group당 1개이상 존재해야함 오라클 권장사항 : Group 3개, Member 2개씩 Redolog files 정보조회 : v$log, v$logfile 12345678910111213141516171819202122232425//v$log 조회SQL&gt; desc v$log; Name Null? Type ---------------------------------- -------- ---------------- GROUP# NUMBER THREAD# NUMBER SEQUENCE# NUMBER BYTES NUMBER BLOCKSIZE NUMBER MEMBERS NUMBER ARCHIVED VARCHAR2(3) STATUS VARCHAR2(16) FIRST_CHANGE# NUMBER FIRST_TIME DATE NEXT_CHANGE# NUMBER NEXT_TIME DATE CON_ID NUMBERSQL&gt; select group#, members, status from v$log; GROUP# MEMBERS STATUS---------- ---------- -------------------------------- 1 2 INACTIVE 2 2 CURRENT 3 2 INACTIVE 조회결과를 보면 group은 3개와 각 group별 멤버 2개씩 있는 것을 확인 가능 current로 현재 사용중인 로그파일을 확인 가능 12345678910111213141516171819202122232425//v$logfile조회SQL&gt; desc v$logfile; Name Null? Type ----------------------------------------- -------- ---------------------------- GROUP# NUMBER STATUS VARCHAR2(7) TYPE VARCHAR2(7) MEMBER VARCHAR2(513) IS_RECOVERY_DEST_FILE VARCHAR2(3) CON_ID NUMBERSQL&gt; select group#, member from v$logfile order by group#; GROUP# MEMBER---------- ------------------------------------------------------------ 1 /u01/app/oracle/oradata/ORCL/onlinelog/o1_mf_1_fwvn9ddb_.log 1 /u01/app/oracle/fast_recovery_area/orcl/ORCL/onlinelog/o1_mf _1_fwvn9o6v_.log 2 /u01/app/oracle/oradata/ORCL/onlinelog/o1_mf_2_fwvn9ddv_.log 2 /u01/app/oracle/fast_recovery_area/orcl/ORCL/onlinelog/o1_mf _2_fwvn9l85_.log 3 /u01/app/oracle/oradata/ORCL/onlinelog/o1_mf_3_fwvn9t6z_.log 3 /u01/app/oracle/fast_recovery_area/orcl/ORCL/onlinelog/o1_mf _3_fwvn9xf6_.log Parameter file Instance의 정의정보(SGA할당정보, B/G proc정보 등)이 기록된 공간 DB의 여러 설정 정보가 기록된 공간 DB의 켜졌는지 유무는 instance를 보고 말함 -&gt; 인스턴스가 없으면 DB가 꺼져있는 것 위치 : $ORACLE_HOME/dbs 어느 기업의 DB든간에 위치가 정해져있다. 이름 : spfileSID.ora 또는 initSID.ora SID에는 DB명이 들어감. DB명은 DBA가 DB생성할 때 정함. 파일을 절대 일반적인 편집기로 열면 안됨. 바로 파일이 망가짐 파일을 열고 싶으면 오라클에게 따로 보여달라는 명령어를 내려야함. 추후 학습예정. 12345678910//존재하는 지만 체크. 절대 열면 안됨.SQL&gt; ! //sql에서눅스로 나가야함[oracle@localhost ~]$ echo $ORACLE_HOME //$ORACLE_HOME이 어디있는지 알려달라는 명령어/u01/app/oracle/product/12.2.0/dbhome_1[oracle@localhost ~]$ cd /u01/app/oracle/product/12.2.0/dbhome_1/[oracle@localhost dbhome_1]$ cd dbs[oracle@localhost dbs]$ lshc_orcl.dat hc_resp.dat init.ora lkORCL orapworcl spfileorcl.ora spfileorcl.ora파일이 존재하는 것을 확인할 수 있다. Password file DB를 시작/종료할 수 있도록 인증해주는 공간. 위치 : $ORACLE_HOME/dbs 어느 기업의 DB든간에 위치가 정해져있다. 이름 : orapwSID SID에는 DB명이 들어감. DB명은 DBA가 DB생성할 때 정함. 123456//존재하는 지 체크 `orapworcl`[oracle@localhost ~]$ echo $ORACLE_HOME //$ORACLE_HOME이 어디있는지 알려달라는 명령어/u01/app/oracle/product/12.2.0/dbhome_1[oracle@localhost ~]$ cd /u01/app/oracle/product/12.2.0/dbhome_1/[oracle@localhost dbs]$ lshc_orcl.dat hc_resp.dat init.ora lkORCL orapworcl spfileorcl.ora Archived log files (option) 수많은 옵션 데이터 베이스 중에서 알아둬야할 물리적파일이다. Redo log file의 오프라인 복사본이라고 생각하면 된다. 주목적 : Datafile Recovery log mode : Narchive log mode VS Archive log mode(권장) 중 선택 log mode 정보 조회 : v$database 안의 log_mode 123456SQL&gt; desc v$database //구조를 조회해서 필요한 컬럼만 출력한다.SQL&gt; select name, log_mode from v$database;NAME LOG_MODE------------------ ------------------------ORCL NOARCHIVELOG","link":"/2020/08/25/200826dbi/"},{"title":"Servlet구매하기2 : 구매하기","text":"OrderFrontController.java의 doProcess()의 주소비교 후 처리부분에 코드 추가 12345678910111213// 주소에 따른 처리 구분 (주소 매핑후 이동)if(command.equals(\"/OrderStar.or\")){ System.out.println(\"C: /OrderStar.or 호출\"); action = new OrderStarAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); } //주문하기}else if(command.equals(\"/OrderAdd.or\")){ System.out.println(\"C: /OrderAdd.or 호출\"); action = new OrderAddAction(); try { forward = action.execute(request, response); } catch (Exception e) { e.printStackTrace(); }} OrderStarAction.java 생성 구매페이지에 장바구니 정보 가져와서 뷰페이지에서 보여주기 12345678910111213141516171819202122232425262728293031323334public class OrderStarAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : OrderStarAction의 execute() 호출\"); // 로그인 정보 (로그인 처리필요) HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } //장바구니정보 저장 BasketDAO bkdao = new BasketDAO(); Vector total = bkdao.getBasketList(id); request.setAttribute(\"basketList\", total.get(0)); //장바구니에 저장된 상품정보 정보 request.setAttribute(\"goodsList\", total.get(1)); //구매회원정보 저장 MemberDAO mdao = new MemberDAO(); //MemberBean mb = mdao.getMember(id); 한 줄에 처리 request.setAttribute(\"memberbean\", mdao.getMember(id)); //페이지이동 forward.setPath(\"./goods_order/goods_buy.jsp\"); forward.setRedirect(false); return forward; }} OrderAddAction.java 생성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class OrderAddAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : OrderAddAction의 execute() 호출\"); // 로그인 정보 (로그인 처리필요) HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } // 전달된 정보를 저장 // 한글처리 // OrderDTO 객체 생성 -&gt; 정보 저장 OrderDTO odto = new OrderDTO(); odto.setO_m_id(id); odto.setO_receive_name(request.getParameter(\"o_receive_name\")); odto.setO_receive_phone(request.getParameter(\"o_receive_phone\")); odto.setO_receive_addr1(request.getParameter(\"o_receive_addr1\")); odto.setO_receive_addr2(request.getParameter(\"o_receive_addr2\")); odto.setO_receive_memo(request.getParameter(\"o_receive_memo\")); odto.setO_trade_payer(request.getParameter(\"o_trade_payer\")); odto.setO_trade_type(\"온라인 입금\"); //라디오버튼값 고정, 필요시 value를 받아서 set하기 BasketDAO bkdao = new BasketDAO(); Vector data = bkdao.getBasketList(id); // 장바구니 정보 List&lt;BasketDTO&gt; basketList = (List&lt;BasketDTO&gt;) data.get(0); // 상품정보 List&lt;GoodsDTO&gt; goodsList = (List&lt;GoodsDTO&gt;) data.get(1); // 결재 모듈(카카오,아임포트,U+) 추가영역 System.out.println(\"M : 결제모듈 성공\"); // OrderDAO 객체 생성 - addOrder(주문정보,장바구니정보,상품정보) OrderDAO odao = new OrderDAO(); odao.addOrder(odto, basketList, goodsList); System.out.println(\"M : itwill_order 테이블에 저장완료\"); //구매확정 메일이나 문자 , 카톡메세지 등을 유저에게 보내는 추가영역 System.out.println(\"M : 구매확정 내역 전송 완료\"); //상품정보 수정 - 구매 수량만큼 구매갯수 차감 GoodsDAO gdao = new GoodsDAO(); gdao.updateAmount(basketList); //장바구니 비우기(삭제) bkdao.deleteBasket(id); //페이지이동 forward.setPath(\"./OrderList.or\"); forward.setRedirect(true); return forward; }} OrderDAO.java 생성 후 addOrder()메서드 코드 추가 Calendar new로 객체생성은 할 수 없고 getInstance()로 만들어져있는 객체를 가져와다가 활용해야한다 이를 싱글톤패턴이라고 부른다 날짜정보 포맷 : SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMdd&quot;); 예시20200917 구매할 상품 번호는 basketList과 goodsList둘 다 있다. 어디서 가져와야할까? basketList안의 상품번호가 정확하다. List에서 정보를 꺼내오려면 get(인덱스)을 사용해서 거기서 또 GTO의 정보를 꺼내야한다 불편하기때문에 미리 DTO객체를 생성1234for(int i=0; i&lt;basketList.size(); i++){ //미리생성 BasketDTO bkdto = (BasketDTO) basketList.get(i); GoodsDTO gdto = (GoodsDTO) goodsList.get(i); 전체코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//주문등록하기public void addOrder(OrderDTO odto, List&lt;BasketDTO&gt; basketList, List&lt;GoodsDTO&gt; goodsList) { int o_num = 0; //일련번호 int trade_num = 0; //주문번호 //주문번호 계산시 사용 //Calendar new로 객체생성은 할 수 없고 getInstance()로 만들어져있는 객체를 가져와다가 활용해야한다 //이를 싱글톤패턴이라고 부른다 Calendar cal = Calendar.getInstance(); //시스템날짜 //날짜 정보를 포맷 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd\"); //예시20200917 try{ getCon(); //주문테이블(itwillbs_order) 번호 계산하기 sql = \"selct max(o_num) from itwill_order\"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); if(rs.next()){ o_num = rs.getInt(1)+1; } trade_num = o_num; System.out.println(\"trade_num= \"+trade_num); System.out.println(\"o_num= \"+o_num); //전달정보 사용해서 데이터베이스에 추가 for(int i=0; i&lt;basketList.size(); i++){ BasketDTO bkdto = (BasketDTO) basketList.get(i); GoodsDTO gdto = (GoodsDTO) goodsList.get(i); sql = \"insert into itwill_order values(?,?,?,?,?,\" + \"?,?,?,?,?,\" + \"?,?,?,?,?,\" + \"?,now(),?,now(),?)\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, o_num); pstmt.setString(2, sdf.format(cal.getTime())+\"-\"+trade_num); //20200917-숫자들 pstmt.setInt(3, bkdto.getB_g_num()); //구매할 상품 번호basketList과 goodsList둘다있다 pstmt.setString(4, gdto.getName()); pstmt.setInt(5, bkdto.getB_g_amount()); pstmt.setString(6, bkdto.getB_g_size()); pstmt.setString(7, bkdto.getB_g_color()); pstmt.setString(8, bkdto.getB_m_id()); pstmt.setString(9, odto.getO_receive_name()); pstmt.setString(10, odto.getO_receive_addr1()); pstmt.setString(11, odto.getO_receive_addr2()); pstmt.setString(12, odto.getO_receive_phone()); pstmt.setString(13, odto.getO_receive_memo()); // 상품의 금액 * 상품 구매갯수 pstmt.setInt(14, bkdto.getB_g_amount() * gdto.getPrice()); pstmt.setString(15, odto.getO_trade_type()); pstmt.setString(16, odto.getO_trade_payer()); pstmt.setString(17, \"\"); //운송번호 : 추후 운송장번호가 나오면 관리자가 기입 pstmt.setInt(18, 0);//주문상태 : 추후 상태에 맞춰서 관리자가 변경함 pstmt.executeUpdate(); o_num++; //일련번호를 증가시킴 //한 사람의 장바구니에 있는 모든 주문을 입력하기 전까지 계속해서 1씩 증가시킴 //유저가 바뀌는 경우 sql구문(max(o_num))이 시작번호를 계산한다 } System.out.println(\"DAO: 주문성공\"); }catch(Exception e){ e.printStackTrace(); }finally { closeDB(); }}//end of addOrder() GoodsDAO.java에서 updateAmount() 추가 작성 장바구니에 있던 상품이 구매가 완료되면 재고수량에서 구매수량만큼을 업데이트해줘야한다. 이퀄기호(=) 없는 for문을 쓰는 것이 좋다 i는 0부터 시작 권장 이퀄기호 없는 조건식 사용 권장 1234567891011121314151617181920//구매시 재고수량수정public void updateAmount(List&lt;BasketDTO&gt; basketList) { try{ getCon(); //이퀄기호 없는 for문을 쓰는 것이 좋다 for(int i=0; i&lt;basketList.size(); i++){ BasketDTO bkdto = basketList.get(i); //받아올때 제네릭으로 캐스팅해서 받아왔으므로 캐스팅안해도됨 sql = \"update itwill_goods set amount=amount-? where gno=?\"; pstmt = con.prepareStatement(sql); pstmt.setInt(1, bkdto.getB_g_amount()); pstmt.setInt(2, bkdto.getB_g_num()); pstmt.executeUpdate(); } System.out.println(\"DAO: 구매 후 재고수량수정완료\"); }catch (Exception e) { e.printStackTrace(); } finally { closeDB(); } }//end of updateAmount BasketDAO.java 생성 후 deleteBasket()메서드 오버로딩하여 추가123456789101112131415//장바구니 상품 전체 삭제 (오버로딩)public void deleteBasket(String id) { try{ getCon(); sql =\"delete from itwill_basket where b_m_id=?\"; pstmt = con.prepareStatement(sql); pstmt.setString(1, id); pstmt.executeUpdate(); System.out.println(\"DAO: 구매 후 본인 장바구니 전체 삭제 완료\"); }catch(Exception e){ e.printStackTrace(); }finally { closeDB(); }}//end of 장바구니전체삭제 goods_buy.jsp 생성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;%//OrderStarAction에 저장한 정보를 가져오기//장바구니정보 저장된 거 가져오기List basketList = (List) request.getAttribute(\"basketList\");//장바구니에 저장된 상품정보 정보저장된 거 가져오기List goodsList = (List) request.getAttribute(\"goodsList\");//구매회원정보 저장된 거 가져오기MemberBean mb = (MemberBean) request.getAttribute(\"memberbean\");%&gt;&lt;table border=\"1\"&gt;&lt;caption&gt;주문상세내역&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;사진&lt;/th&gt; &lt;th&gt;상품명&lt;/th&gt; &lt;th&gt;수량(단위: 개)&lt;/th&gt; &lt;th&gt;색상&lt;/th&gt; &lt;th&gt;사이즈&lt;/th&gt; &lt;th&gt;가격(단위: 원)&lt;/th&gt; &lt;/tr&gt;&lt;%for(int i=0; i&lt;basketList.size(); i++){ BasketDTO bkdto = (BasketDTO) basketList.get(i); GoodsDTO gdto = (GoodsDTO) goodsList.get(i);%&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=\"./upload/&lt;%=gdto.getImage().split(\",\")[0]%&gt;\" height=\"100px\"&gt;&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bkdto.getB_g_amount() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bkdto.getB_g_color() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bkdto.getB_g_size() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getPrice() %&gt;&lt;/td&gt; &lt;/tr&gt;&lt;%} %&gt;&lt;/table&gt;&lt;hr&gt;&lt;fieldset&gt;&lt;legend&gt;주문자정보&lt;/legend&gt;&lt;%%&gt;&lt;form action=\"./OrderAdd.or\" method=\"post\"&gt;&lt;/form&gt; 구매자 이름 : &lt;input type=\"text\" name=\"name\" value=\"&lt;%=mb.getName() %&gt;\" readonly&gt;&lt;br&gt; 구매자 연락처 : &lt;input type=\"text\" name=\"tel\" value=\"\"&gt;&lt;br&gt; 구매자 이메일 : &lt;input type=\"text\" name=\"email\" value=\"&lt;%=mb.getEmail()%&gt;\" readonly&gt;&lt;br&gt; &lt;h2&gt;배송지정보&lt;/h2&gt; 받는 사람 이름 : &lt;input type=\"text\" name=\"o_receive_name\" value=\"\"&gt;&lt;br&gt; 받는 사람 연락처 : &lt;input type=\"text\" name=\"o_receive_phone\" value=\"\"&gt;&lt;br&gt; 배송지 주소 : &lt;input type=\"text\" name=\"o_receive_addr1\" value=\"\"&gt;&lt;br&gt; 나머지 주소 : &lt;input type=\"text\" name=\"o_receive_addr2\" value=\"\"&gt;&lt;br&gt; 기타 요청사항 : &lt;input type=\"text\" name=\"o_memo\" value=\"\"&gt;&lt;br&gt; &lt;h2&gt;결제정보&lt;/h2&gt; &lt;input type=\"radio\" name=\"o\"&gt; 신용카드 &lt;input type=\"radio\" name=\"o\"&gt; 온라인입금 &lt;input type=\"radio\" name=\"o\"&gt; 휴대폰 결재 &lt;input type=\"radio\" name=\"o\"&gt; 문화상품권&lt;br&gt; 입급자명 (온라인 입금전용): &lt;input type=\"text\" name=\"o_trade_payer\" value=\"&lt;%=mb.getName()%&gt;\"&gt; &lt;br&gt; &lt;hr&gt; &lt;input type=\"submit\" class=\"btn\" value=\"결제하기\"&gt; &lt;input type=\"reset\" class=\"btn\" value=\"초기화\"&gt;&lt;/fieldset&gt; BasketListAction.java에서 장바구니에 정보가 하나도 없을 경우 예외처리 BasketList가 null인 경우 예외처리 - 아래 코드 추가 123456//장바구니에 정보가 하나도 없을 경우if(basketList.size() &lt;= 0){ request.setAttribute(\"basketListNull\", true);}else{ request.setAttribute(\"basketListNull\", false);} 전체코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class BasketListAction implements Action { @Override public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"M : BasketListAction의 execute() 호출\"); // 로그인 정보 (로그인 처리필요) HttpSession session = request.getSession(); String id = (String) session.getAttribute(\"id\"); ActionForward forward = new ActionForward(); if(id == null){ forward.setPath(\"./MemberLogin.me\"); forward.setRedirect(true); return forward; } //한글처리 request.setCharacterEncoding(\"UTF-8\"); //BasketDAO 이용하여 장바구니 정보(옵션, 구매수량)+해당 상품정보(이름,이미지,가격) 가져오는 메서드 호출 BasketDAO bkdao = new BasketDAO(); Vector totalData = bkdao.getBasketList(id); List&lt;BasketDTO&gt; basketList = (List&lt;BasketDTO&gt;) totalData.get(0); //장바구니에 정보가 하나도 없을 경우 if(basketList.size() &lt;= 0){ request.setAttribute(\"basketListNull\", true); }else{ request.setAttribute(\"basketListNull\", false); } //request에 저장 // request.setAttribute(\"totalData\", totalData); // List&lt;BasketDTO&gt; basketList // =(List&lt;BasketDTO&gt;) totalData.get(0); // request.setAttribute(\"basketList\", basketList); // =&gt; 원래 정보는 벡터에 저장되어 있지만, Action페이지에서 // 벡터의 정보를 꺼내서 각각 request에 저장해서 전달 // =&gt; View에서는 복잡한 연산을 피해야함. 바로 사용가능한 List형태로 전달하는것이 좋다. request.setAttribute(\"basketList\", totalData.get(0)); request.setAttribute(\"goodsList\", totalData.get(1)); //페이지이동 forward.setPath(\"./goods_order/goods_basket.jsp\"); forward.setRedirect(false); return forward; }} goods_basket.jsp에서 장바구니에 정보가 하나도 없을 경우 예외처리 BasketList가 null인 경우 예외처리 123456boolean listIsNull = (boolean) request.getAttribute(\"basketListNull\");if(listIsNull){ //전달된 리스트정보가 null인 경우}else{} 전체코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;%//한글처리request.setCharacterEncoding(\"UTF-8\");//List가 null인경우 처리boolean listIsNull = (boolean) request.getAttribute(\"basketListNull\");if(listIsNull){ //전달된 리스트정보가 null인 경우 %&gt; &lt;table border=\"1\"&gt; &lt;caption&gt;&lt;%=session.getAttribute(\"id\") %&gt;님의 장바구니&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;사진&lt;/th&gt; &lt;th&gt;상품명&lt;/th&gt; &lt;th&gt;크기&lt;/th&gt; &lt;th&gt;색상&lt;/th&gt; &lt;th&gt;수량&lt;/th&gt; &lt;th&gt;가격&lt;/th&gt; &lt;th&gt;삭제&lt;/th&gt; &lt;/tr&gt; &lt;%}else{ ////전달된 리스트정보가 null이 아닌 경우 //basketList에서 구현한 정보를 전달받아서 처리 List basketList = (List) request.getAttribute(\"basketList\"); List goodsList = (List) request.getAttribute(\"goodsList\"); BasketDTO bk = (BasketDTO) basketList.get(0);%&gt;&lt;!-- 장바구니 번호, 사진(대표이미지), 상품명, 사이즈,색상,수량,가격, 삭제 --&gt; &lt;table border=\"1\"&gt; &lt;caption&gt;&lt;%=bk.getB_m_id() %&gt;님의 장바구니&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;사진&lt;/th&gt; &lt;th&gt;상품명&lt;/th&gt; &lt;th&gt;크기&lt;/th&gt; &lt;th&gt;색상&lt;/th&gt; &lt;th&gt;수량&lt;/th&gt; &lt;th&gt;가격&lt;/th&gt; &lt;th&gt;삭제&lt;/th&gt; &lt;/tr&gt; &lt;% //EL태그는 FOR문과 상관없이 &lt;c:forEach&gt; 사용해서 출력해야한다. for(int i=0; i&lt;basketList.size(); i++){ BasketDTO bkdto = (BasketDTO) basketList.get(i); GoodsDTO gdto = (GoodsDTO) goodsList.get(i); %&gt; &lt;tr&gt; &lt;!-- 순차 넘버링 --&gt; &lt;td&gt;&lt;%=i+1%&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=\"./upload/&lt;%=gdto.getImage().split(\",\")[0] %&gt;\" height=\"100px\"&gt;&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bkdto.getB_g_size() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bkdto.getB_g_color() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=bkdto.getB_g_amount() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=gdto.getPrice() %&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=\"button\" class=\"btn\" value=\"[장바구니에서 삭제]\" onclick=\"location.href='./BasketDelete.ba?b_num=&lt;%=bkdto.getB_num()%&gt;'\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% } } %&gt; &lt;/table&gt;&lt;input type=\"button\" class=\"btn\" value=\"[구매하기]\" onclick=\"location.href='./OrderStar.or'\"&gt;&lt;input type=\"button\" class=\"btn\" value=\"[계속 쇼핑하기]\" onclick=\"location.href='./GoodsList.go'\"&gt;","link":"/2020/09/16/200917jspi/"},{"title":"[ITWILL : JSP] JSP전체목록List","text":"🌷프로그래밍기초 프로그래밍기초이론, 하드웨어 vs 소프트웨어 vs 펌웨어, 기억장치, 클라이언트 vs 서버 🌷JS기초 JS기초이론, Compile VS Interprete, 변수, js라이브러리,객체타입 JS를 문서에 나타내는 3가지방법, undefined VS null, 백의자리 Math.floor(), 복합대입연산자로table생성, A++과 ++A차이점, ==과===차이점, 논리표 JAVA SE/EE/ME 차이점, JAVA EE 설정. Tomcat 설치및설정, 이클립스 단축키 아이디와 비번입력, 새로고침location.reload(), 주석한번에 단축키, switch문 출력문 한줄리팩토링 반복문 for 순서 자세히, 개발자 도구로 디버깅, 기본 반복문암기, for문과 if문의 자리바꿈에 따른 변화, 반복문의 전위연산 VS 후위연산, do while문 무한반복문, 보조제어(break와continue)문, 익명함수, 재귀함수, 지역변수를 전역에서 사용하는 방법, 내장함수 🌷JS기초 : 객체 (내장객체, 브라우저객체모델(BOM), 문서객체모델(DOM)) Object객체 전체개념, tv채널객체함수, new를 쓰고 안쓰고의 차이 Date객체 자세히, 디데이구하는 함수 Array객체 (for ~ in구문, join(), reverse(), sort()) String객체, 짤라오는 함수 4종류 .substring(), slice(), substr(), charAt(), .indexOf()와 .lastIndexOf()차이, .concat(), .split(), ID자릿수를 제한하는 이메일 유효성검사 이벤트리스너와 이벤트핸들러, 브라우저객체모델, window객체전체 브라우저객체모델안의 Document객체 (bgColor와 fgColor사용, img태그에 접근하여 속성 사용, 랜덤 img 출력하기) 브라우저객체모델안의 location객체 브라우저객체모델안의 history객체, screen객체, navigator객체 문서 객체 모델안의 form태그, 페이지이동방식(get과 post), focus() vs blur() vs select() 문서 객체 모델안의 if문에 return;의 역할, radio태그, checkbox태그 🌷JS실습 js로 간단한 회원가입페이지 작성하기 🌷JSP기초 JSP 첫 프로젝트 톰캣과 연결 JSP 주석과 JSP directive, JSP 스크립트 요소 JAVA DATATYPE, Integer.parseInt(문자열), 동일한 파라미터의 값을 가지는 데이터가 여러개있을 경우 변수로 가져오기 커넥션풀(Connection Pool) Wrapper클래스, 오토 박싱과 오토 언박싱, hierarchy확인법 자바 클래스(객체) vs 추상클래스 vs 인터페이스 🌷JSP기초 : 내장객체 중 영역객체 내장객체 영역객체scope 영역객체 안에서 사용하는 속성(Attribute), 링크이동 방법별 전달가능한 영역(scope) JSP 디렉티브(directive) 중 include VS 액션태그 include, jspf확장자 파일 세션(Session) ==과 str.equals(str2) 차이, 객체와 클래스 쿠키(Cookie) 🌷MySQL MYSQL 설치, MYSQL환경변수설정, cmd에서 명령어 잘못입력해서 mysql못빠져나갈때 MYSQL 접속순서, DB명령어, 테이블명령어, 데이터명령어 MySQL 한글깨짐현상 두가지 해결방법 : cmd와 Workbench, 이클립스와 MYSQL연결 🌷JDBC JDBC활용 - import쓰는 이유, form페이지로 받은 데이터를 DB에 insert하는 방법 JDBC활용 - JAVA에서 DB 정보 지우기 2가지방법 JDBC활용 - DB에서 고객정보를 불러와서 HTML테이블에 담기 JDBC활용 - TIMESTAMP주의점, JDBC에서 데이터처리 JDBC활용 - 회원정보수정페이지만들기 JDBC활용 - 회원목록출력하는데 관리자는 빼고 출력하기, 자바 에러 두종류 🌷JAVABEAN Javabean : 기초 자바빈 실습1 : 회원가입페이지만들기 자바빈 실습2 : 로그인 및 로그아웃페이지만들기 자바빈 실습3 : 회원정보조회 및 수정페이지만들기 자바빈 실습4 : web.xml, 회원정보삭제페이지 자바빈 실습5 : 관리자만 확인할 수 있는 회원목록페이지만들기 자바빈 실습6 : 게시판만들기(글쓰기) 자바빈 실습7 : 게시판만들기(글 총 갯수, 글목록, 페이징처리) 자바빈 실습8 : 게시판만들기(글내용보기, 글수정하기) 자바빈 실습9 : 게시판만들기(글삭제하기) 자바빈 실습10 : 게시판만들기(답글쓰기) 🌷파일업로드와 다운로드 기능 구현 자바빈 실습11 : MultipartRequest클래스 자바빈 실습12 : 파일업로드 자바빈 실습13 : 파일다운로드 자바빈 실습14 : ServletContext 사용하여 파일업로드와 다운로드 🌷자료구조 자료구조1 : Collections Framwork(Set계열, List계열) 자료구조2 : Stack클래스, Queue인터페이스, Map인터페이스 🌷model1 홈페이지만들기 홈페이지만들기1 : 프로젝트 시작 설정 및 자바빈생성과 DB연결 홈페이지만들기2 : 아이디중복체크 포함한 회원가입기능 구현 홈페이지만들기3 : 로그인/로그아웃 기능 구현 홈페이지만들기4 : 게시판글쓰기구현 홈페이지만들기5 : 게시판에 글목록표시구현 🌷JQuery JQuery1 : JQuery 사용설정, 선택자, css() JQuery2 : attr(), html()와 text(), append()와 prepend() JQuery3 : setInterval()와 clearInteval(), CDATA VS PCDATA JQuery4 : click(), bind(), event.preventDefault(), unbind(), keyup(), 유효성체크(자바스크립트 vs 제이쿼리) JQuery5 : 유효성체크(자바스크립트 vs 제이쿼리), 제이쿼리 기본효과 JQuery6 : innerfade 라이브러리, animate(속성, 속도, 콜백함수) 🌷Ajax Ajax : Ajax특징, XMLHttpRequest클래스, txt 페이지 처리 Ajax : xml처리, json처리 Ajax : DB데이터를 불러와서 json형태로 변경하여 출력하기 🌷JSTL과 EL JSTL과 EL : JSTL과 EL개념, CORE 라이브러리(out) JSTL과 EL : CORE 라이브러리(set) JSTL과 EL : CORE 라이브러리(if, forEach, forTokens, choose) JSTL과 EL : fmt 라이브러리(formatDate, formatNumber) JSTL과 EL : EL태그로 동일한 name의 파라미터를 EL태그로 쉽게 가져오기 JSTL과 EL : EL태그 연산자 EL과 Servlet : RequestDispatcher.forward 로 페이지 이동 후 데이터별 출력방법 🌷model2(MVC패턴) 쇼핑몰만들기 Servlet : Servlet용어정리, model1과 model2(MVC구조) 개발방식 비교 쇼핑몰회원관리 Servlet회원관리1: 기본설정 및 가상주소생성 Servlet회원관리2: 회원가입 Servlet회원관리3: 로그인 Servlet회원관리4: 메인페이지와 로그아웃 Servlet회원관리5: 회원정보조회 Servlet회원관리6: 회원탈퇴 Servlet회원관리7: 회원전체목록조회(관리자기능) 게시판 Servlet게시판1: 기초 Servlet게시판2: 게시판 글쓰기 Servlet게시판3: 게시판 리스트·게시글전체목록·페이징처리 Servlet게시판4: 글 내용보기 Servlet게시판5: 글 수정하기 Servlet게시판6: 글 삭제하기 Servlet게시판7: 답글하기 Servlet게시판8: 파일업로드·파일보기 관리자전용 상품목록과 등록게시판 Servlet관리자전용상품1 : 기초 Servlet관리자전용상품2 : 상품등록 Servlet관리자전용상품3 : 상품목록·상품리스트 Servlet관리자전용상품4 : 상품수정·인기상품처리 Servlet관리자전용상품5 : 상품삭제 일반유저용 상품목록 Servlet일반상품1 : 기초 Servlet일반상품2 : 카테고리별 상품목록·상품리스트 Servlet일반상품3 : 상품상세정보 장바구니 Servlet장바구니1 : 기초 Servlet장바구니2 : 장바구니에 담기 Servlet장바구니3 : 장바구니리스트, 장바구니에서 상품삭제 구매하기 Servlet구매하기1 : 기초 Servlet구매하기2 : 구매하기 Servlet구매하기3 : 주문목록 Servlet구매하기4 : 주문상세정보페이지 관리자용 주문리스트 Servlet관리자용주문목록1 : 기초 Servlet관리자용주문목록2 : 고객주문목록 🌟Servlet관리자용주문목록3 : 고객주문목록에서 주문 상태 및 운송장정보 변경 Servlet관리자용주문목록4 : 고객주문목록에서 삭제 🌷스프링프레임워크 프레임워크란, Spring 특징과 기능, 컨테이너란 스프링(STS)설치 및 기본 설정 STS 단축키 추가하기(스프링 이클립스 단축키), System.out.printf()단축키 Spring 기본 동작순서, JSP와 SPRING의 차이점 제어의 역행(IoC)과 의존성 주입(DI) 회원관리프로그램예시를 통한 MODEL2방식에서 스프링방식으로 변경 관점 지향(AOP, Aspect-Oriented Programming) 총정리 스프링 MVC패턴 프로젝트, 주요 어노테이션(Annotation) MAVEN REPOSITORY, My(i)Batis설치 페이지이동하기, 파라미터가지고 페이지이동하기 redirect나forward로 페이지이동하기, JSON데이터처리하기 주니어레벨의 스프링MVC 개발순서, MyBatis(iBatis) 사용 방법 3가지 JDBC로그 라이브러리 설치 Spring MVC JUNIT TEST Failure와 Error차이 스프링 웹계층 : 서비스(비즈니스 로직), 컨트롤러(프레젠테이션) 한글처리 🌷스프링MVC 쇼핑몰만들기 회원가입 및 로그인 메인페이지, 로그아웃 회원정보조회, 회원정보수정, 회원정보삭제 관리자용 회원 리스트 스프링게시판 스프링게시판1: 기초 스프링게시판2: 파일구조와 DB테이블생성, 글쓰기테스트 스프링게시판3: 글쓰기 스프링게시판4: 글상세내용보기 스프링게시판5: 글수정,글삭제 스프링게시판6: Controller에서 예외처리 스프링게시판7: 게시판 페이징처리 🌷REST API REST란? RESTful이란? REST API란? ResponseEntity 타입 클래스 페이지전달방식","link":"/2020/11/16/jspList/"},{"title":"내가 이해한 MSA(MicroService Architecture)","text":"업무관리 협업툴로 Swit을 사용하고 있다. 이를 통해 내가 소속된 프로젝트에서 어떤 업무들이 진행되는 지 알 수 있다.나같은 신입에게 업무관리 협업툴이 좋은 이유는 동료들이 올린 업무를 보며 모르는 부분이지만 프로젝트를 위해서 필요한 부분을 스스로 찾아서 공부할 수 있다! 최근 MSA에 관한 업무카드가 올라왔다. 관련자료들도 링크를 달아두셨는데 놓치지않고 모두 읽었다.직접 찾아본 자료들과 함께 MSA에 대해 정리하고자한다. MSA란 MSA는 MicroService Architecture의 약어로 독립적으로 배포가 가능한 각각의 기능을 수행하는 서비스로 구성된 프레임워크 서비스가 잘 정의된 API를 통해서만 상호작용 가능 마이크로 서비스는 서비스의 end-point(접근점)을 API 형태로 외부에 노출하고, 실질적인 세부 사항은 모두 추상화한다. 내부의 구현 로직, 아키텍처와 프로그래밍 언어, 데이터베이스, 품질 유지 체계와 같은 기술적인 사항들은 서비스 API에 의해 철저하게 가려진다. 기존의 하나의 어플리케이션형태를 모노리틱아키텍쳐라고 한다. 모노리틱아키텍쳐(Monolithic Architecture)는 배포 및 테스트도 하나의 애플리케이션에서 수행하면 된다.따라서 성능 제약이 덜하고 운영관리가 용이하고 소규모 프로젝트에 적합하다.문제는 규모가 커지면 발생한다. 모노리틱아키텍쳐 문제점 빌드/테스트 시간이 길어짐: 작은 수정에도 시스템 전체를 빌드/테스트해야함 선택적 확장 불가능: 쇼핑몰인 경우 이벤트로 인해 서비스접속량이 폭증하는 경우 프로젝트 전체를 확장해야함 하나의 서비스가 모든 서비스에 영향 끼침: 이벤트서비스에 과부화가 걸리면 다른 모든 서비스도 마비됨 이를 해결할 수 있는 아키텍쳐가 바로 MSA이다. MSA 장단점 장점 빠르고 간단한 배포: 서비스간의 의존성이 없기때문에 독립적인 배포 가능 시스템의 선택적 확장 단점 높은 기술 복잡도 느린 속도: 하나의 애플리케이션에서 자기 자신의 메서드를 호출하는 것보다 다른 에플리케이션의 메서드를 호출하는 것임으로 속도가 느리다. MSA의 문제점 중 하나는 각 서비스가 분리 배포되어있기 때문에 서버 URL이 각기 다를 수 밖에 없다.이때 API Gateway가 필요하다. Spring Cloud Spring Cloud: 마이크로서비스의 개발, 배포, 운영에 필요한 아키텍처를 쉽게 구성할 수 있도록 지원하는 Spring Boot기반의 프레임워크 위의 이미지에서 동그라미로 표시된 컴포넌트만 Spring cloud framework 컴포넌트이다. MSA가 되면 각 독립적인 서비스들은 API 게이트웨이 뒤로 숨겨지게 된다. 외부에서 보면 모놀리식 애플리케이션과 동일하다.마이크로서비스는 점차 많아질 수 있고 이 서비스간 상호작용을 할 수 있어야한다.이는 각 마이크로서비스가 상대방의 네트워크 주소 정보를 유지해야한다. 서비스 디스커버리: 컴퓨터 네트워크상의 디바이스가 제공하는 디바이스와 서비스를 자동으로 감지하는 서비스다. 스프링 클라우드(1) - 개요에 아주 정리가 잘 되어있으므로 꼭 읽어보길 바란다. Spring Cloud Eureka한 마이크로서비스가 다른 마이크로서비스를 호출하려면 해당 IP를 알아야한다. 이걸 Service Discovery 서비스의 발견이라고 한다.kubernetes환경에서는 대상 IP가 언제라도 증감될 수 있다. https://bravenamme.github.io/2020/08/26/spring-cloud-eureka/ https://elky84.github.io/2018/09/23/java_zuul_use_story/ API GatewayAPI서버 앞 단에서 모든 API 서버들의 End-Point를 단일화하여 묶어주는 역할을 한다. API Gateway는 종류가 다양한데 이 중에서 zuul이 있다. https://alwayspr.tistory.com/22 참고 http://clipsoft.co.kr/wp/blog/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98msa-%EA%B0%9C%EB%85%90/ https://www.redhat.com/ko/topics/microservices/what-are-microservices https://docs.microsoft.com/ko-kr/azure/architecture/guide/architecture-styles/microservices https://12bme.tistory.com/506","link":"/2021/04/12/210415MSA/"},{"title":"[자바JAVA]백준 1065 한수 풀이","text":"문제어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.첫째 줄에 1,000보다 작거나 같은 자연수 N이 주어진다.첫째 줄에 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력한다. 입출력예시1 12345//입력110//출력99 입출력예시2 12345//입력1//출력1 입출력예시3 12345//입력210//출력105 입출력예시4 12345//입력1000//출력144 코드잘 생각해보면 한수가 되기 위해선 세 자리수이어야한다.한자리수의 한수 개수는 1부터 9까지로 총 9개이다.두자리수의 한수 개수는 1부터 99까지로 총 99개이다.따라서 100부터 한 수의 개수를 세어주면 된다. 예를 들어, 110의 한수 개수는 99개이고예를 들어, 111의 한수 개수는 100 (1부터 99 + 111 = 총 100개) memory 11496 run 84 123456789101112131415161718192021222324252627282930313233public class _1065 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int cnt; if(n &lt; 100 ){ System.out.println(n); }else{ cnt = 99; for(int i=100; i&lt;=n; i++){ int hundreds = i / 100 % 10; int tens = i / 10 % 10; int units = i % 10; // 등차수열인지 확인하기 if ((hundreds - tens) == (tens - units)) { cnt++; } } // 엣지케이스 if (n == 1000){ cnt--; } System.out.println(cnt); } }} 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/04/18/210418al-backjoon-1065/"},{"title":"[자바JAVA]백준 4344 평균은 넘겠지 풀이","text":"문제대학생 새내기들의 90%는 자신이 반에서 평균은 넘는다고 생각한다. 당신은 그들에게 슬픈 진실을 알려줘야 한다.첫째 줄에는 테스트 케이스의 개수 C가 주어진다.둘째 줄부터 각 테스트 케이스마다 학생의 수 N(1 ≤ N ≤ 1000, N은 정수)이 첫 수로 주어지고, 이어서 N명의 점수가 주어진다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.각 케이스마다 한 줄씩 평균을 넘는 학생들의 비율을 반올림하여 소수점 셋째 자리까지 출력한다. 입출력예시 1234567891011121314//입력55 50 50 70 80 1007 100 95 90 80 70 60 503 70 90 803 70 90 819 100 99 98 97 96 95 94 93 91//출력40.000%57.143%33.333%66.667%55.556% 코드 memory 13288 time 116 123456789101112131415161718192021222324252627282930313233343536373839public class _4344 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); //테스트 케이스 개수 int cntCase = Integer.parseInt(br.readLine()); StringTokenizer st; for(int i=0; i&lt;cntCase; i++){ st = new StringTokenizer(br.readLine(), \" \"); int cntStudent = Integer.parseInt(st.nextToken()); int[] score = new int[cntStudent]; int avg = 0; double ratio = 0.0; //배열에 성적 넣기 for(int j=0; j&lt;cntStudent; j++){ if(!st.hasMoreTokens()) break; score[j] = Integer.parseInt(st.nextToken()); avg += score[j]; } //평균값(소수점 넷째자리에서 반올림) avg = avg/cntStudent; //평균을 넘는 학생의 비율 for(int k=0; k&lt;cntStudent; k++){ if(score[k] &gt; avg){ ratio++; } } ratio = (ratio/cntStudent)*100.00; System.out.printf(\"%.3f\", ratio); System.out.println(\"%\"); } }} 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/04/13/210411al-backjoon-4344/"},{"title":"[자바JAVA]백준 3052 나머지 풀이","text":"문제두 자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 나머지는 1, 2, 0, 2이다.수 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 프로그램을 작성하시오.첫째 줄부터 열번째 줄 까지 숫자가 한 줄에 하나씩 주어진다. 이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다. 입출력예시 1234567891011121314//입력12345678910//출력10 코드1: BufferedReader와 리스트로 풀기 memory 11460 runtime 76 12345678910111213141516171819public class _3052 { public static void main(String[] args) throws IOException { // sol1. BufferedReader와 리스트로 풀기 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // 나머지값이 들어 갈 리스트 생성 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 리스트에 나머지값 넣기 for(int i = 0; i&lt; 10; i++) { int reminder = Integer.parseInt(br.readLine()) % 42; if (!list.contains(reminder)) { list.add(reminder); } } System.out.println(list.size()); }} 코드2: Scanner와 배열로만 풀기기1234567891011121314151617181920212223242526272829public class _3052 { public static void main(String[] args) throws IOException { Scanner sc = new Scanner(System.in); int[] num = new int[10]; //입력값이 들어갈 배열 int[] number = new int[1000]; // 전체배열 int a = 42; int count = 0; for (int i = 0; i &lt; 10; i++) { int n = sc.nextInt(); num[i] = n % a; } for (int i = 0; i &lt; num.length; i++) { number[num[i]]++; // num값을 number의 num값 배열에 넣어줘서 1씩 증가시킴 //System.out.printf(\"i: %d, num[%d]: %d, number[%d]: %d%n\", i, i, num[i], i, number[i]); } // 값이 있으면 1, 없으면 0이 됨 for (int i = 0; i &lt; number.length; i++) { if (number[i] != 0) { count++; } } System.out.println(count); }} 코드비교 방법 메모리(KB) 런타임(ms) BufferedReader와 리스트로 풀기 11460 76 Scanner와 배열로만 풀기기 18340 240 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/04/13/210411al-backjoon-3052/"},{"title":"[오류일지]네이버블로그 RSS에러 SEC7111 이(가) HTTPS 보안을 위협합니다 해결방법","text":"문제웹 네이버 블로그 RSS기능을 구현하는 도중 아래와 같은 에러가 발생했다. 1SEC7111: http://www.feedrapp.info/?callback=jQuery21408054871432163133_1612485326379&amp;q=https%3A%2F%2Frss.blog.naver.com ~~~ 이(가) HTTPS 보안을 위협합니다. 원인분석SEC7111 에러란 무엇일까?MS DOCS에서 확인할 수 있듯이 https와 관련된 에러이다.http에서 https 부를때는 아무 문제가 없지만 https에서 http를 부를 때 HTTPS 보안 위협이나 크로스도메인같은 문제가 생긴다. 어떻게 해결해야할까?해결방법도 친절히 적혀있다. 1Make sure all content in the page, including scripts, stylesheets, and images, are from HTTPS sources. 해결방법feedrapp 깃헙레포의 how to host it on HTTPS 이슈를 통해서 해결방법을 찾을 수 있었다. 기존 feedrapp JS라이브러리의 원본 소스에서 ssl 설정을 false → true로 변경해준다. 1234567//기존 코드this.options = $.extend({ ssl: false,//수정한 코드this.options = $.extend({ ssl: true, 해결!","link":"/2021/04/18/210419js-error-sec7111/"},{"title":"[자바JAVA]백준 11720 숫자의 합 풀이","text":"문제N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.입력으로 주어진 숫자 N개의 합을 출력한다. https://www.acmicpc.net/problem/11720 입출력예시1 123456//입력11//출력1 입출력예시2 123456//입력554321//출력15 입출력예시3 123456//입력257000000000000000000000000//출력7 입출력예시4 123456//입력1110987654321//출력46 풀이1: 배열사용 memory 11652 runtime 84 String array로 입력을 받은 뒤 int array에 담아서 누적합 해준다. 123456789101112131415161718192021public class _11720 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int cnt = Integer.parseInt(br.readLine()); String[] nums = br.readLine().split(\"\"); int sum = 0; //Convert String array to int array int[] intNums = new int[cnt]; for(int i=0; i&lt;cnt; i++){ intNums[i] = Integer.parseInt(nums[i]); } //Sum for(int n : intNums){ sum += n; } System.out.println(sum); }} 풀이2: 배열사용하지않고 풀기 -&gt; getBytes()사용 memory 11480 runtime 80 getBytes()는 String을 Byte로 변환해준다. Java String getBytes() 참고 링크 위 표를 보면 숫자 0은 Decimal 48임을 알 수 있다. byte를 int로 변환하기 위해서는 48 또는 ‘0’을 빼주면 된다. 1234// n이 byte형이기때문에 아래 두 식은 같은 의미 (n-48) == (n-'0')// int형으로 합을 하기 위해서 아스키코드에서 숫자 1은 49부터 시작하기때문에 숫자 0인 48을 빼줘야 함.sum += (n - 48);sum += (n - '0'); 전체 코드는 아래와 같다.배열을 사용한 것과 큰 차이는 안나지만 배열없이도 문제를 풀 수 있음을 배웠다. 12345678910111213public class _11720 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); br.readLine(); // cnt는 사용하지 않으므로 입력만 받음 int sum = 0; for(byte n : br.readLine().getBytes()){ sum += (n - 48); //sum += (n - '0'); // n-48과 n-'0'은 같은 의미인데 그 이유는 아스키코드에서 숫자 1은 49부터 시작하기때문에 숫자 0인 48을 빼줘야 함. } System.out.println(sum); }} 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/04/18/210419al-backjoon-11720/"},{"title":"[Hexo]헥소블로그 구글애드센스설정(초간단)","text":"Hexo 블로그에 구글애드센스를 설정해보자. 구글애드센스 가입구글애드센스에서 시작하기 버튼을 클릭한 뒤 아래 정보를 입력한다. 웹사이트: 자신의 헥소 블로그 주소 이메일주소: 자신의 구글 이메일주소 저장하고 계속하기를 클릭하면 구글 애드센스 코드를 입력하라는 안내메세지가 나온다.여기서 클라이언트ID를 복사한다.참고로 client_id는 ‘ca-알파벳세글자-숫자여러개’로 구성된다. 헥소블로그에 구글애드센스 아이디 넣기블로그 프로젝트에서 _config.yml를 연다. 혹시나 _config.yml이 두 개인 경우 사용하는 테마내의 _config.yml를 열어주면 된다.헷갈릴 경우 _config.yml 둘 다 연뒤 AdSense 키워드로 검색해서 검색결과가 있는 _config.yml를 찾으면 된다.복사해둔 클라이언트ID를 작은 따옴표 안에 붙여넣고 DEPLOY해준다.구글봇이 내 블로그가 구글애드센스에 적합한지 체크를 한 뒤 구글애드센스를 이용할 수 있다. 이 과정은 최대 2주일정도 소요된다고한다.나는 5일정도 걸렸다. 123456789# Google AdSense unit configurations- # Where should the widget be placed, left sidebar or right sidebar position: left type: adsense # AdSense client ID client_id: '웹게시자 ID입력' # AdSense AD unit ID slot_id: '고객 ID입력' slot_id넣기구글 애드센스가 정상적으로 등록되었다면 구글 애드센스에서 로그인하면 대시보드를 볼 수 있다.여기서 [계정] - [계정정보]를 클릭하면 웹게시자ID와 고객 ID를 확인할 수 있다.이때 고객 ID를 복사 한뒤 사용하는 테마내의 _config.yml를 열고 slot_id의 작은 따옴표 안에 붙여넣는다.slot_id는 오로지 숫자여러개로 구성되어있다. 123456789# Google AdSense unit configurations- # Where should the widget be placed, left sidebar or right sidebar position: left type: adsense # AdSense client ID client_id: '웹게시자 ID입력' # AdSense AD unit ID slot_id: '고객 ID입력' 이렇게 설정하면 끝!","link":"/2021/04/25/210426hexoblog-googleAdSense/"},{"title":"MariaDB로 웹과 앱 둘 다 사용가능할까","text":"최근 회사에서 팀과제를 받았다. 보통 회사에서 개인과제를 주기마련인데 우리 회사는 통도 크게(?) 팀과제를 주었다.팀원은 신입개발자3명과 디자이너1명이다.팀과제인만큼 규모도 크고 모르는 거 투성이에다가 6월이라는 기간까지 주어져서 마음이 매우 조급했다.기술문서를 읽어봐도 구글링해봐도 감도 안 오고, 모르는 단어 옆에 또 모르는 단어가 있을때 얼마나 스스로가 한심하던지… 나는 아직 한참 부족하구나싶으면서도 어떻게하면 더 빨리 그리고 잘 이해할 수 있을 까를 고민했다.성장은 어떻게 이루어지는 것일까?개발자, 성장이라는 검색어로 꽤 많은 유튜브와 블로거들의 글을 읽고 또 읽었다.다양한 방법과 경험들이 오갔지만 그들의 경험속에 공통점 한 가지를 발견할 수 있었다.바로 질문하라는 것이다. 대충 이렇게 쓰는 구나하며 어영부영 넘어가지말고 끝까지 파고 들고 그래도 정 모르겠으면 꼭 선임에게 물어보라고했다.그리고 머리를 치게 만드는 띵언을 들었다. “It’s better to look stupid now than remaining stupid forever” 동기부여가 팍팍되는 명언이었다.혼자 끙끙 거리지말고 도저히 모르겠으면 기초라도 그냥 물어보자 마음먹었다. 💬오늘의 대화 팀장님 나 팀장님 바쁘시죠…현재 리액트네이티브앱과 웹에서 함께 사용할 수 있는 DB가 필요한데요. 마리아DB로 잡고 스키마짜고있는데 구글링해보니 앱은 Realm, SQLLITE, firebase같은 DB를 사용해야한다고해서요. 마리아DB는 사용할 수 없는건가요? 음 시나리오에 따라 달리 사용하는 거예요. API만들거니까 마리아DB를 사용해도 됩니다. 웹은 DB → API → 웹으로 데이터를 주고받는 건 아는데 앱도 동일 할 수 있나요? 그럼요 DB → API → 웹/앱 가능합니다. ✍️배움포인트완전 기초라도 도저히 감이 안 잡히면 물어보자!하루종일 구글링했던 얽히고 설킨 토막 지식들이 팀장님과의 1분대화로 한 방에 촤르륵 순서대로 정리되었다.역시 물어보길 잘했어. 리액트네이티브 FE: 리액트 ↘↖ 스프링부트 RESTAPI ↗↙ ↕ MariaDB","link":"/2021/04/26/210427appDB/"},{"title":"[자바JAVA]백준 2908 상수 풀이(memory와 runtime비교)","text":"문제상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다.상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다.두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오. https://www.acmicpc.net/problem/2908 입출력예시 12345//입력734 893//출력437 코드 memory 11488 runtime 76 1234567891011121314151617181920212223public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] nums = br.readLine().split(\" \"); String[] convertNum = new String[]{\"\", \"\"}; // 숫자 거꾸로 만들기 for(int i=0;i&lt;2;i++){ char[] originNum = nums[i].toCharArray(); for(int j=2; j&gt;=0; j--){ convertNum[i] += originNum[j]; } } // 최대값구하기 -&gt; 4가지방식을 사용할 수 있다. int max = Integer.parseInt(convertNum[0]); if(max &lt; Integer.parseInt(convertNum[1])){ max = Integer.parseInt(convertNum[1]); } System.out.println(max); }} 최대값 구하는 방법에 따른 성능 비교최대값은 정말 다양한 방식으로 구할 수 있다.메모리와 런타임에 얼마나 영향을 미치는 지 궁금하여 최대값부분만 4가지 방법으로 바꿔서 각각 성능을 비교해보았다. ### 코드1: 변수1개+if문사용 123456// 최대값구하기int max = Integer.parseInt(convertNum[0]);if(max &lt; Integer.parseInt(convertNum[1])){ max = Integer.parseInt(convertNum[1]);}System.out.println(max); ### 코드2: 모두 변수로 처리 12345678// 최대값구하기int num1 = Integer.parseInt(convertNum[0]);int num2 = Integer.parseInt(convertNum[1]);if(num1 &gt; num2){ System.out.println(num1);}else{ System.out.println(num2);} ### 코드3: 모두 변수 + 삼항연산자 1234// 최대값구하기int num1 = Integer.parseInt(convertNum[0]);int num2 = Integer.parseInt(convertNum[1]);System.out.println(num1 &gt; num2 ? num1 : num2); ### 코드4: 변수사용없이 Math.max()사용 12// 최대값구하기System.out.println(Math.max(Integer.parseInt(convertNum[0]), Integer.parseInt(convertNum[1]))); 방법 memory runtime 변수1개+if문사용 11488 76 모두 변수로 처리 11448 76 모두 변수 + 삼항연산자 11540 76 변수사용없이 Math.max()사용 11468 80 나머지 방법들은 다 비슷비슷한데 삼항연산자는 메모리를 많이 사용한다는 것을 알 수 있었다. 앞으로 자재해야겠다.한 번만 쓰는 변수는 만들지 않으려고 하는 편인데 변수 처리하니까 오히려 메모리가 조금 개선됨을 알 수 있다. 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/04/28/210429al-backjoon-2908/"},{"title":"[MariaDB&#x2F;MySQL]SQL Query","text":"📣 테이블테이블 생성12create table [테이블명] (id int, name varchar(20), isDeleted boolean not null default 0); 테이블명 수정1alter table [테이블명] rename [변경할_테이블명]; 테이블삭제1drop table [테이블명]; 📣 컬럼테이블에 컬럼추가여러 개 추가시 컴마로 구분하기 123alter table [테이블명] add [컬럼명] varchar(20) not null default 'N/A',add [컬럼명] boolean not null default 0; 컬럼명 및 컬럼타입 변경12alter table [테이블명] change [컬럼명] [변경할_컬럼명] int; 컬럼삭제1alter table [테이블명] drop [컬럼명]; 컬럼순서변경123alter table [테이블명]modify [컬럼명] INTafter [앞에_위치시키고싶은_컬럼명] 📣 제약조건제약조건확인12select * from information_schema.table_constraints where TABLE_SCHEMA = [스키마명]; 제약조건 추가(PK)12alter table [테이블명] add constraint primary key [컬럼명]; 제약조건 추가(FK)123alter table [테이블명] add constraint [제약조건이름] foreign key [컬럼명] references [부모테이블명] [pk컬럼명] on delete cascade / on update cascade; 제약조건 삭제1alter table [테이블명] drop constraint [제약조건명]; 📣 데이터insert 필드순서와 데이터값의 순서가 일치할때12INSERT INTO 테이블이름VALUES (데이터값1, 데이터값2, 데이터값3, ...) 필드순서와 데이터값의 순서가 불일치할때12INSERT INTO [테이블이름] (필드이름1, 필드이름2, 필드이름3, ...)VALUES (데이터값1, 데이터값2, 데이터값3, ...) update123UPDATE [테이블이름]SET [필드이름1]=[데이터값1], [필드이름2]=[데이터값2], ...WHERE [필드이름=데이터값]; delete12DELETE FROM [테이블이름]WHERE [필드이름]=[데이터값];","link":"/2021/05/02/210503MariaDB-SQLQuery/"},{"title":"[MySQL]날짜 데이터타입에서 Timestamp를 쓰는 경우","text":"DB를 설계하면서 등록일자, 삭제날짜등의 날짜 데이터타입을 지정해야했다.날짜 데이터타입으로는 크게 Date, Datetime, Time, Timestamp 4가지가 있다. Date vs Time Date Time 설명 날짜만 출력 시간만 출력 예시 YYYY-MM-DD HH:MM:SS 범위 from 1000-01-01 to 9999-12-31 from -838:59:59 to 838:59:59 내가 필요한 데이터타입은 날짜뿐만 아니라 시간도 함께 필요하기때문에 Datetime, Timestamp 둘 중에서 무엇을 써야 좋을 지 고민했다. Datetime vs Timestamp이 둘의 가장 큰 차이점은 time zone의 영향을 받는지 안 받는지이다.Timestamp는 서버 타임존에 영향을 받기 때문에 시스템 타임존이 변경되면 저장된 데이터도 변경된다. DATETIME TIMESTAMP 설명 날짜와 시간 둘다 출력 날짜와 시간 둘다 출력 예시 YYYY-MM-DD HH:MM:SS YYYY-MM-DD HH:MM:SS 범위 from 1000-01-01 00:00:00 to 9999-12-31 23:59:59 from 1970-01-01 00:00:01 UTC to 2038-01-19 03:14:07 UTC 현재시간 호출 now() default로 current_timestamp를 사용하여 자동 입력 데이터 타입 문자형 숫자형 용량단위 8byte 4byte 🤔 그럼 항상 Datetime만 사용하면 되는거 아닐까?정답은 NO이다.글로벌 서비스를 하면 DB 서버가 해당 지역 타임존을 따를 수 있다.따라서 적절하게 선택하여 사용해야한다.","link":"/2021/05/02/210504Datetypediff/"},{"title":"[MyBatis]springboot aliases-package 오류 해결방법(UnsatisfiedDependencyException해결)","text":"Mapper.xml에서 resultType을 전체 패키지명이 아닌 간단하게 파일명으로 쓰고 싶었다.참고로 스프링부트 프로젝트 구조는 아래와 같다. src/main/java 하위에 controller, service, mapper, dto 폴더가 있고 그 하위에 java파일이 있다. src/main/resources 하위에 mappers 폴더가 있고 그 하위에 xml파일이 있다. 시도구글링을 해보니 대부분 application.properties파일에서 설정하길래 나도 따라해봤다. application.properties 파일 1234# mybatis 매핑 type을 짧게 쓰기 위한 설정mybatis.type-aliases-package=com.test.dtomybatis.mapper-locations=mappers/*Mapper.xmlmybatis.configuration.map-underscore-to-camel-case=true 그 결과 컨트롤러와 서비스등에서 UnsatisfiedDependencyException 에러가 발생했다. 123//결과 콘솔org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'userController': Unsatisfied dependency expressed through field 'service';... 해결매퍼파일에서 패키지명 전체를 입력할 수 있지만, 약어로 쓰고싶은 마음에 끝까지 해결방법을 파고들었고 드디어 방법을 알아냈다.(😆해피)myBatis SqlSessionFactory를 설정하는 파일에서 setTypeAliasesPackage()로 진행하면 해결된다! 나의 경우 SpringBootApplication에서 바로 SqlSessionFactory를 연결해줬으므로 setTypeAliasesPackage(&quot;com.test.dto&quot;)을 아래와 같이 코드를 기입했다. 123456789101112131415161718192021@SpringBootApplicationpublic class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } // MyBatis를 App전체에서 활용할 수 있도록 Application Class에서 초기화 @Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); Resource[] res = new PathMatchingResourcePatternResolver().getResources(\"classpath:mappers/*Mapper.xml\"); sessionFactory.setMapperLocations(res); sessionFactory.setTypeAliasesPackage(\"com.test.dto\"); //여기 추가 return sessionFactory.getObject(); }} 테스트도 정상적으로 된다!드디어 해결🧐","link":"/2021/05/06/210507Mybatis-alias-error/"},{"title":"[자바JAVA]백준 2869 달팽이는 올라가고 싶다 풀이","text":"문제땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오. 입출력예시1 12345//입력2 1 5//출력4 입출력예시2 12345//입력5 1 6//출력2 처음 시도한 코드 시간초과로 실패 123456789101112131415161718192021222324252627import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] input = br.readLine().split(\" \"); int A = Integer.parseInt(input[0]); // 낮에 올라가는 높이 int B = Integer.parseInt(input[1]); // 밤에 미끄러지는 높이 int V = Integer.parseInt(input[2]); // 정상 높이 int oneDay = A - B; // 하루동안 올라갈 수 있는 높이 int day = 0; int sum = 0; // 누적 높이 while (sum &lt; V) { sum += oneDay; if (sum == V) { break; } day++; } System.out.println(day); }} 두번째로 시도한 코드BufferedReader를 쓴 뒤로 시간초과에 잘 걸리지 않았었는데 당황스러웠다.그래서 String[]대신 StringTokenizer를, System.out.println()대신 BufferedWriter를 사용해봤다. 시간초과로 실패 하지만 또 시간초과로 실패했다. 1234567891011121314151617181920212223242526272829303132import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); StringTokenizer st = new StringTokenizer(br.readLine(), \" \"); int A = Integer.parseInt(st.nextToken()); // 낮에 올라가는 높이 int B = Integer.parseInt(st.nextToken()); // 밤에 미끄러지는 높이 int V = Integer.parseInt(st.nextToken()); // 정상 높이 int oneDay = A - B; // 하루동안 올라갈 수 있는 높이 int day = 0; int sum = 0; // 누적 높이 while (sum &lt; V) { sum += oneDay; if (sum == V) { break; } day++; } bw.write(String.valueOf(day)); bw.flush(); bw.close(); }} 성공한 코드런타임을 확실히 줄여 줄 무언가가 필요했다.시간초과의 원인은 String[]아니고 System.out.println()도 아닌 바로 반복문이었다.반복문을 제거하고 하니 System.out.println()을 써도 바로 통과되었다. memory 11500 runtime 76 1234567891011121314151617181920import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine(), \" \"); int A = Integer.parseInt(st.nextToken()); // 낮에 올라가는 높이 int B = Integer.parseInt(st.nextToken()); // 밤에 미끄러지는 높이 int V = Integer.parseInt(st.nextToken()); // 정상 높이 int day = (V - B) / (A - B); if((V - B) % (A - B) != 0){ day++; } System.out.println(day); }} 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/05/08/210508al-backjoon-2869/"},{"title":"[GIT]기존 프로젝트를 github에 연결하기","text":"프로젝트를 한창 만들다가 또는 다 만든 뒤 해당 프로젝트를 깃허브에 올리고 싶을 때 어떻게 해야할까?git bash를 이용한 방법을 알아보자. 프로젝트 폴더 내 git init 생성기존 프로젝트가 있는 폴더 열기 -&gt; 마우스 우클릭 -&gt; git bash here 클릭하기그럼 git bash창이 열리고 아래 명령어를 통해 git 초기화를 한다. 1git init git bash창에서 주소줄 옆에 (master)가 생겼다면 잘 생성된 것이다. GITHUB repository 연결깃허브에 가서 레포지토리를 생성한 뒤 초록색 code 버튼을 클릭하여 깃헙 레포지토리URL을 복사한다.그 다음 git bash창에서 아래 명령어를 통해 깃헙 레포지토리와 연결한다. 1git remote add origin 복사해온깃헙레포url 잘 연결되었는지 확인하고 싶다면 아래 명령어를 입력한다.참고로 -v는 version의 약어이다. 1git remote -v pullgit bash창에서 아래 명령어를 통해 깃헙 레포지토리를 먼저 PULL 받는다. 1git pull origin main pull에러가 발생한다면?위 명령어를 입력했는데 아래와 같은 error가 발생했다면 어떻게 해야할 까? 12345error: The following untracked working tree files would be overwritten by merge: .gitignore README.mdPlease move or remove them before you merge.Aborting .gitignore와 README.md파일이 중복되어 pull이 오류가 난 것이므로 로컬에서 해당 파일을 지워주자.지우기전에 필요한 내용이 있다면 어디 복사해놓은 뒤 pull완료 후 붙여넣기 하면 된다! checkout main (선택사항)깃헙정책 변경으로 기본 브랜치 이름이 master에서 main으로 변경되었다.나는 master가 아닌 main 브랜치로 push를 하고자 브랜치 체크아웃을 진행했다.원하는 브랜치 명을 만들어서 push해도 된다. 123456git branch maingit checkout maingit branch -d master// 브랜치 뭐뭐 있는 지 확인git branch 잘 되었다면 git bash창의 주소줄 맨 오른쪽이 (master)에서 (main)으로 변경된다. IDE 프로젝트 우클릭 Team &gt; share Project이제 IDE로 돌아가보자.올리고 싶은 프로젝트를 우클릭 한뒤 Team &gt; share Project를 클릭하고 Finish버튼을 클릭한다.이로써 git 레포지토리와 로컬에 있는 기존 프로잭트가 잘 연결된 것이다. 잘 연결되었는 지 어떻게 확인할 수 있을까?이에 두 가지 방법이 있다. 프로젝트명 옆에 [깃헙레포명 브랜치명]이 추가되어있는 것을 확인할 수 있다. Perspective를 Java에서 Git으로 변경하면 왼편 Git Repositories에 깃헙레포가 추가된 것을 확인할 수 있다. git ignore 먼저 commit 후 push하기연결만 되었을 뿐 로컬에 있는 소스코드를 github에 업로드하지 않았다. 이제 업로드해보자! 프로젝트 폴더를 보면 자동으로 .gitignore이 생성되어있다.만약 보이지 않는 경우 Perspective를 Java에서 Git으로 변경하면 해당 파일을 찾을 수 있다. https://www.toptal.com/developers/gitignore 를 통해 ignore 사항들을 추가한 뒤 전체 코드를 복사한다.업로드할 프로젝트에 관련된 것들을 입력하면 되는데 나는 주로 java, Eclipse, Maven을 입력한다.기존 .gitignore파일에 복사한 코드를 붙여준다. 그 뒤 아래 3가지 명령어를 차례대로 입력한다. 123git add .gitignoregit commit -m \"git ignore 추가\"git push 깃허브 레포지토리에서 .gitignore이 보인다면 정상적으로 푸쉬한 것이다. 기존 프로젝트를 스테이지에 올리고 commit 후 push하기123git add .git commit -m \"소스코드 추가\"git push 여기서 잠깐!git add . 와 git add * 차이가 무엇일까?GIT: git add . 와 git add * 차이 포스팅에서 확인할 수 있다. 이로서 깃허브 레포지토리에서 올린 소스코드들이 보인다면 깃허브에 프로젝트 올리기 완료!","link":"/2021/05/09/210510git-connectProject/"},{"title":"[스프링부트]Springboot + Spring Security + JWT 기본 dependencies 추천","text":"스프링부트 + 스프링시큐리티 + JWT + MyBatis + MariaDB로 진행하는 API프로젝트에서 참고하면 좋은 프로젝트 구조와 pom.xml을 공유하고자한다.프로젝트 구조와 사용하는 의존성에는 완벽이란 없다. 자신의 프로젝트에 맞게 알아서 골라서 사용하면 된다. 프로젝트구조 src/main/java config: 시큐리티설정파일, DB연결설정파일 controller dao dto exception payload: 성공이나 실패등이 일어났을때 내가 챙겨 보고 싶은 message를 뜻한다. 추천 참고링크 - JSON과 Payload security service mapper: mapper interface파일 src/main/resources mappers: mapper xml파일 pom.xml 의 dependencies1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt; &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- add --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 의존성 명칭 기능 주요 사용 추천 참고링크 spring-boot-starter-actuator Spring Boot Application의 상태 관리 CORS설정 링크 spring-boot-devtools 스프링 부트에서 제공하는 개발 편의를 위한 모듈 자동재시작, liveLoad commons-lang3 문자열 효율적인 처리 링크 spring-boot-starter-validation 효과적인 유효성 검사 @NotNull @NotBlank @NotEmpty @AssertTrue @Min @Max 링크 여담난 인복이 좀 타고난 편이다. 주변에 좋은 지인들이 참 많고, 일터에서도 좋은 사람들을 더 많이 만났다. 참 감사한 삶이다.이번 팀장님도 역시나 최고다…👍이번에 내가 맡은 프로젝트는 내가 처음 해보는 것 투성이었다.내가 해본게 몇개있겠냐만은 정말 어려운 개념들이라 주말을 불사하고 이해하려고 노력했다.시간이 갈수록 조급해지고 얼마나 답답하던지… 프로젝트 셋팅을 하는 입장에서 프로젝트 구조와 의존성 추가하는 부분이 가장 어려웠다.특히 어디에 어떤 폴더를 생성하고 그 폴더에는 무슨 파일을 넣으면 좋을지 난감했다.팀장님이 내 마음을 어떻게 아시고 갑자기 자리로 부르셨다.그리고 내 프로젝트 상황에 맞게 프로젝트구조부터 코드리팩토링할 수 있도록 하나부터 열까지 설명해주셨다.물론 설명을 알아듣진 못했지만… 못 알아들은 부분들은 열심히 필기했다.길을 알려주셨으니 이제 열심히 걸어가기만 하면 된다. 이 자리를 빌어(?) 배움의 길잡이를 해주신 팀장님 다시한번 감사드립니다! 최고최고👍","link":"/2021/05/09/210510springboot-pom/"},{"title":"[이클립스&#x2F;STS] &#x2F;&#x2F; TODO 주석말고 다른 거, 뭐 없을까?","text":"기능구현을 하다보면 시간에 쫓기거나 우선순위때문에 잠깐 미뤄둬야 할 일들이 있다.모든 걸 다 기억해놓을 수도 없고, 그냥 주석을 쓰면 눈에 잘 띄지않는다.이때 도움이 되는 것이 Task tag 기능이다.이클립스나 STS에 자체적으로 있는 기능으로 하단에 Tasks 탭을 확인할 수 있다. Task tag로 메모해놓으면 바로 확인할 수 있고 클릭시 해당 소스코드로 바로 이동하여 정말 편하다. 또한 해당 소스코드 왼쪽편에 노트와 연필모양으로 표시까지 해준다 Tasks 탭 열기Tasks탭이 하단에 없는 경우 아래 경로를 통해서 볼 수 있다. 이클립스나 STS -&gt; Window -&gt; Show View -&gt; Tasks Task tag 종류기본적으로 3종류가 있다. TODO : 좀더 최적화시키고 리팩토링시킬 수 있을만한 구석이 있을때. 미래에 뭔가 의미있는 작업을 더 해야 할 필요성을 느낄때. FIXME : 문제가 있는것이 확실하지만, 그걸 지금 당장 그것을 수정할 필요는 없을 때. XXX : 해당 부분에 대해서는 더 생각해볼 필요성이 있을 때. 또는 해당 부분에 질문이 생길 때. 또는 코드에서 문제가 일어날만한 부분을 강조 표기할때. 완벽하게 정확히 구현되지 않은 부분이 있을 때. 나중에 고쳐야만하는 부분일 때. 주로 팀보단 자신을 위한 용도로 사용. 예시 TODO: How about auto-correcting small spelling errors? FIXME: This won’t work if the file is missing. XXX: This method badly needs refactoring: should switch by core type. 커스텀 tag 추가하기기존 3종태그뿐만아니라 나만의 커스텀태그를 추가할 수 있다. Window -&gt; Preferences -&gt; Java -&gt; Compiler -&gt; Task Tags New와 Edit, Remove를 이용하여 태스크 태그를 추가, 수정,삭제할 수 있고 각 우선순위도 상/중/하로 설정할 수 있다. 출처 https://dzone.com/articles/to-do-lists-with-eclipse-tasks-view http://egloos.zum.com/rucaus/v/2455594","link":"/2021/05/12/210513Eclipse-tasks/"},{"title":"REST API 컨트롤러 Mapping을 어떻게 하지?","text":"스프링부트로 RestAPI를 구현하고 있다. Mapping 어노테이션에서 URI를 지정시 어떤 규칙으로 적용해야할까? web api규칙이를 잘 정리해 둔 블로그가 있다. 이 블로그를 통해 감을 잡을 수 있었다. https://www.mimul.com/blog/web-api-design-from-apigee/?fbclid=IwAR1Q5QmdYTLpgc9c5w9IKQM2i49JBsNuEwyJHntYjWytEYQK89m2fJUMPAE 모든 내용들이 다 좋았지만 그 중에서도 직관적으로 바로 이해가는 세가지는 아래와 같다. Nouns are good; verbs are bad. Plural nouns and concrete names. 복수명사를 사용하고 구체적인 이름을 사용하기. Simplify associations - sweep complexity under the ‘?’. 자원간의 관계, 매개 변수 및 속성과 같은 복잡한 것은 HTTP 물음표 뒤에 가지고 가자. 위 규칙은 Web API Design - Crafting Interfaces that Developers Love과 위 블로그에서 발췌했다. OData (Open Data Protocol)번역하면 공공 데이터 규약 즉, 데이터를 주고 받는데 있어 지켜야하는 규약을 의미한다.OPEN API들은 보통 이 규약을 준수한다. https://docs.microsoft.com/en-us/graph/use-the-api?view=graph-rest-1.0 마이크로소프트사의 페이지를 가보면 Access data and methods, Paging등에 관한 API예시가 있다.이를 참조하여 오픈 API 틀을 잡는데 도움이 된다. 참고 https://www.odata.org/getting-started/basic-tutorial/ https://www.ibm.com/docs/ko/license-metric-tool?topic=api-rest-resources-http-methods","link":"/2021/05/25/210526RESTfulAPI-Odata/"},{"title":"[MyBatis] select한 값을 바로 insert할 수 있을까?","text":"DB Mapper를 코딩하면서 일회성으로 쓸 쿼리를 계속 만들어야하는가에 대한 의문이 생겼다.예를 들어 아래와 같은 UserDTO가 있다고하자.user테이블에 idx, name, dept_code만 넣고 싶다. dept_code는 department테이블에서 user_id로 알아낼 수 있다. 그렇다면 가장 쉽게 생각나는 방법은 dept_code를 찾는 쿼리와 insert하는 쿼리로 2가지 쿼리 만드는 방법이다.하지만 dept_code를 찾는 쿼리는 insert하는 쿼리하기위해 한번만 사용되는 일회성 쿼리라면 굳이 쿼리를 나눠서 작성할 필요가 있을까?여기서 내 궁금증은 커져만 갔고 한 개의 쿼리를 만들고 싶다는 마음이 강해졌다. 공통코드12345678@Data public class UserDTO{ private int idx; private String name; @NotBlank @Size(min=13, max=14) private String user_id; private String dept_code; } 기존코드UserDTO를 선언하고 findDeptCode 쿼리 실행하여 나온 result값을 dept_code에 넣어주고 난 뒤 insertUser쿼리를 실행하면 된다. 123456789101112&lt;!-- dept_code를 찾는 쿼리 --&gt;&lt;select id=\"findDeptCode\" parameterType=\"String\" resultType=\"String\"&gt; SELECT dept_code from department WHERE user_id = #{user_id}&lt;/select&gt; &lt;!-- insert 쿼리 --&gt;&lt;insert id=\"insertUser\" parameterType=\"UserDTO\"&gt; insert into user (idx, name, dept_code) values ( #{idx}, #{name}, #{dept_code} )&lt;/insert&gt; 직관적인 쿼리들이지만 나는 하나의 쿼리로 만들고 싶었다.한 기능에서만 딱 한 번 그리고 세트로 실행되는데 여러 개 쿼리를 나눈 것이 비효율적이라고 느껴졌기때문이다.findDeptCode 쿼리와 insertUser 쿼리는 세트이기때문에 유지보수를 위해서도 한 쿼리로 관리하고 싶었다. 다른 방법이 없을까 구글링하던 끝에 주임님께 조심스럽게 내 생각을 전해보았다.주임님은 바로 이해하시고는 selectkey를 알려주셨다.주임님은 겸손하면서 다정하게 잘 알려주신다.다 가졌어.겸손까지…그저 완벽. selectkey사용한 코드짜잔! 한 쿼리로 다 관리할 수 있다. 이를 조금 고급스럽게 표현하면 Mybatis 동적쿼리라고 부른다. 123456789&lt;insert id=\"insertUser\" parameterType=\"UserDTO\"&gt; &lt;selectKey id=\"findDeptCode\" resultType=\"String\" keyProperty=\"dept_code\" order=\"BEFORE\"&gt; SELECT dept_code from department WHERE user_id = #{user_id} &lt;/selectKey&gt; insert into user (idx, name, dept_code) values ( #{idx}, #{name}, #{dept_code} )&lt;/insert&gt; selectkey 사용법 keyProperty : 컬럼명이므로 DTO에 있는 동일한 명을 입력하면 된다. order=&quot;BEFORE&quot; : insert전에 selectKey문이 실행된다. order=&quot;AFTER&quot; : insert후에 selectKey문이 실행된다. 여담주임님 덕분에 오늘 난 한 걸음 더 성장했다!될지 안 될지 알 수 없는 상황에서 구글링해도 안 나오니까 그냥 안 되나보다하고 포기하지않고 끝까지 물어보길 잘했다.아 스트레스도 많이 받지만 이럴땐 정말 재밌다 코딩하나하나 알게 되는 기쁨이 이루 말할수없다.앞으로도 이렇게 성장해나가야지!그나저나 주임님 정말 천재!! 참고 https://yookeun.github.io/java/2014/07/11/mybatis-selectkey/","link":"/2021/06/03/210604MyBatis-selectKey/"},{"title":"[자바JAVA]백준 2751 수 정렬하기2 풀이","text":"문제N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다. 입출력예시 1234567891011121314//입력554321//출력12345 처음시도한 코드시간초과로 실패Arrays.sort()는 dual-pivot Quicksort 알고리즘사용한다. 평균 시간복잡도가 O(nlogn) 으로 좋은 알고리즘이지만 최악 시간복잡도는 O(n2) 이기때문에 퀵정렬이라고해서 다 좋은 것은 아니다. 123456789101112131415161718public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); // 배열에 숫자 넣기 int[] arr = new int[N]; for(int i=0; i&lt;N; i++){ arr[i] = Integer.parseInt(br.readLine()); } // 오름차순 정렬 Arrays.sort(arr); // 출력 for(int n : arr){ System.out.println(n); }} 성공한 코드 memory 160156 runtime 1396 Collections.sort()는 Arrays.sort()와 달리 Timesort정렬을 사용한다. Timesort정렬는 삽입정렬과 반복합병 알고리즘 2개를 함께 사용하여 최악 시간복잡도 O(nlogn)을 보장한다.참고로 System.out.println()만으로 출력하면 시간초과 발생하므로 꼭 StringBuilder 사용해줘야한다. 1234567891011121314151617181920public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); StringBuilder sb = new StringBuilder(); // 리스트에 숫자넣기 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; N; i++) { list.add(Integer.parseInt(br.readLine())); } // 오름차순 정렬 Collections.sort(list); // 출력 for(int value : list) { sb.append(value).append('\\n'); } System.out.println(sb);} 풀이 메서드 알고리즘명 평균시간복잡도 최악 시간복잡도 Arrays.sort() 퀵정렬dual-pivot Quicksort O(nlogn) O(n2) Collections.sort() Timesort정렬 O(n) O(nlogn) 아래 블로그에서 항상 도움을 많이 얻고 있다. 자바로 알고리즘 공부하는 사람에게는 바이블적인 블로그가 아닐까싶다. 일단, 최악의 경우에도 O(nlogn) 을 보장하거나 혹은, O(n) 에 가까운 정렬 알고리즘을 사용해야 한다. 이에 대한 해결 방법은 두 가지가 있다.첫 번째는 Collections.sort() 를 쓰는 방법이다. Collections.sort() 은 Timsort이다. Timsort 의 경우 합병 및 삽입정렬 알고리즘을 사용한다.이렇게 두 가지가 섞여있는 정렬 알고리즘을 hybrid sorting algorithm 이라고 하는데, 합병정렬(Merge Sort)의 경우 최선, 최악 모두 O(nlogn) 을 보장하고. 삽입정렬(Insertion sort)의 경우 최선의 경우는 O(n) , 최악의 경우는 O(n2) 이다.그리고 두 정렬 모두 안정 정렬(stable sort)이기 때문에 Timsort를 hybrid stable sorting algorithm이라고도 한다.즉, 합병정렬의 최악의 경우와 삽입정렬의 최선의 경우를 짬뽕한 알고리즘이 Timsort 라는 것이다. 실제로 파이썬이나 기타 정렬 알고리즘에서 가장 많이 쓰이는 알고리즘이기도 하다.시간복잡도 O(n) ~ O(nlogn) 을 보장한다는 장점이 있다.출처: https://st-lab.tistory.com/106 여담최근 st-lab 티스토리를 운영하고 있는 블로거 ST님에게서 연락을 받았다.제목은 포스팅 내용 변경건.내가 잘 못 포스팅한 게 있었나? 내 포스팅이 마음에 안들어서 내려달라고 연락하신걸까? 네이버블로거들 사이에서보단 뭐 기업과 블로거의 법적대응 뭐 이런건가. 그런 영화같은 일이 소시민인 나에게…?오만가지 생각을 하며 열어 본 이메일에는 나는 박수를 칠 수 밖에 없었다. 세상에 이렇게 멋있는 사람이 있나 싶어서. 이메일의 주 내용은 원글에 수정사항이 있는데 자칫 오해할 수 있는 내용이 있어 수정했으며 내용을 참고하신 분들에게 잘못된 내용을 전달될 수 있을까봐 해당 내용을 확인 후 반영해달라는 것이었다.세상에 이렇게 멋진 사람이 있다니.그의 책임감에 감탄했다.그는 지식공유자를 넘어 신뢰감있는 전문가였다.ST님같은 전문가가 되고 싶다. (원문 수정내용을 반영 완료) 백준의 다른 문제 풀이가 보고싶다면? 백준 java 풀이 모음","link":"/2021/06/05/210606al-backjoon-2751/"},{"title":"[GIT]git add의 차이","text":"GIT명령어 비슷한 것들도 많고 여간 헷갈리는 것이 아니다. 헷갈리는 김에 정리해보았다. git add . 와 git add * 차이 git add .: .gitignore에 기재된 것 고려하여 모두 추가 git add *: .gitignore에 기재된 것 상관없이 모두 추가 따라서 그냥 git add .를 사용하자","link":"/2021/06/08/210609Gitadddiff/"},{"title":"[MySQL] selet 컬럼명을 조건에 따라 다르게 출력할 수 있을까?","text":"오늘 쿼리를 작성하다가 궁금증이 생겼다.예를 들어 학교 교직원 및 학생 정보를 user테이블에 다 있다고 생각해보자.relation테이블을 이용하여 학생의 담임교사와 학부모정보를 출력하고 싶었다.user테이블에서 자기 자신을 계속 join하는 상황에서 상황별 학생정보를 출력하려면 어떻게 해야할까? 첫 시도와 문제점 ☝️123456789101112// 모든 정보가 다 있는 경우select u1.name, u1.tel, --학생정보 u2.name, u2.tel, --학부모정보 u3.name, u3.tel --담임교사정보FROM user u1join user_relation uron u1.tel = ur.학생telJOIN user u2ON ur.학부모tel = u2.telJOIN user u3ON ur.교사tel = u3.telWHERE u1.tel = #{학생tel} 위 쿼리의 문제점은 크게 2가지이다. 학부모정보가 없는 경우 학생정보가 아예 출력 안됨. 담임교사 정보가 없는 경우 학생정보가 아예 출력 안됨. 학무보정보나 담임교사정보가 없는 상황에서도 학생정보를 출력하고 싶다면 어떻게 해야할까? 모든 쿼리를 다 만들면 어때? 🤔먼저 if나 case절을 생각했는데 아무래도 select값이 변경되어야하기때문에 사용하기가 힘들었다.그렇다면 모든 경우의 수별로 쿼리를 다 만들어보는 방법이 있다.예를 들면 아래와 같다. 모든 정보가 다 있는 경우 123456789101112// 모든 정보가 다 있는 경우select u1.name, u1.tel, --학생정보 u2.name, u2.tel, --학부모정보 u3.name, u3.tel --담임교사정보FROM user u1join user_relation uron u1.tel = ur.학생telJOIN user u2ON ur.학부모tel = u2.telJOIN user u3ON ur.교사tel = u3.telWHERE u1.tel = #{학생tel} 담임정보가 없는 경우 123456789// 담임정보가 없는 경우select u1.name, u1.tel, --학생정보 u2.name, u2.tel, --학부모정보FROM user u1join user_relation uron u1.tel = ur.학생telJOIN user u2ON ur.학부모tel = u2.telWHERE u1.tel = #{학생tel} 학부모정보가 없는 경우 123456789// 학부모정보가 없는 경우select u1.name, u1.tel, --학생정보 u3.name, u3.tel --담임교사정보FROM user u1join user_relation uron u1.tel = ur.학생telJOIN user u3ON ur.교사tel = u3.telWHERE u1.tel = #{학생tel} 담임정보도 없고 학부모정도 없는 경우 1234// 담임정보도 없고 학부모정도 없는 경우select u1.name, u1.telFROM user u1WHERE u1.tel = #{학생tel} 보시다시피 너무 비효율적이다.한 쿼리로 해결하는 방법이 없을까? 구글링하다가 도저히 모르겠어서 팀장님께 조심스럽게 물어봤는데 바로 해결방법을 알려주셨다! 한 쿼리로 해결 😎해결책은 바로 left outer join이었다! 1234567891011select u1.name, u1.tel, --학생정보 u2.name, u2.tel, --학부모정보 u3.name, u3.tel --담임교사정보FROM user u1left outer join user_relation uron u1.tel = ur.학생telleft outer JOIN user u2ON ur.학부모tel = u2.telleft outer JOIN user u3ON ur.교사tel = u3.telWHERE u1.tel = #{학생tel} 위에서 내가 작성한 join 앞에 아무것도 적지않았으므로 기본적으로 inner조인이 된다. 즉 교집합만 보여주는 쿼리가 된다.outer조인에는 크게 3가지가 있고 그 중 left outer join을 실무에서 가장 많이 사용한다고 한다.아무리 쉬워보이는 거라도 용기내서 물어보길 잘했다! 덕분에 확실히 개념이 잡혔다. 룰루! outer join이란?아래 그림을 보면 이해하기가 쉽다. join = inner join : 교집합 outer join 종류 left outer join : 실무에서 가장 많이 사용 right outer join full outer join SQL NULL 처리하기팀장님께서 추가로 null값이 들때 default값을 설정할 수 있는 COALESCE()도 함께 알려주셨다. 바로가기: SQL에서 컬럼값이 NULL처리는 어떻게 하면 좋을까? 참고 더 많은 join","link":"/2021/06/13/210614leftouter/"},{"title":"[MySQL] SQL에서 컬럼값이 NULL처리는 어떻게 하면 좋을까?","text":"SQL에서 컬럼값이 NULL이 출력되었을 경우 default값이나 원하는 값으로 치환해주고싶을때가 있다.이럴때 어떻게 하면 좋을까? 컬럼값이 Null인 경우를 처리해주는 함수들 MySQL: IFNULL, CASE Orcale: NVL() 모든 DBMS : COALESCE ISNULL() 기본 12// 기본SELECT IFNULL(컬럼명, \"Null일 경우 대체 값\") FROM 테이블명; 예시: 학부모연락처가 NULL인 경우 “학부모없음”을 출력, NULL이 아닌 경우 학부모tel을 출력 12SELECT IFNULL(학부모tel, \"학부모연락처없음\")FROM user CASE문 기본 1234567// 기본CASE WHEN 조건식1 THEN 식1 WHEN 조건식2 THEN 식2 ... ELSE 조건에 맞는경우가 없는 경우 실행할 식END 예시 123456SELECT CASE WHEN 학부모tel IS NULL THEN \"학부모연락처없음\" ELSE 학부모tel ENDFROM user COALESCE() 기본컬럼1이 null인경우 컬럼2를 출력하고 컬럼2도 null인 경우 컬럼3을 출력한다.컬럼3도 null이면 컬럼4를 출력하고, 마지막 컬럼까지 null인 경우 그냥 null을 출력한다. 12SELECT COALESCE(컬럼1, 컬럼2, 컬럼3, 컬럼4, ...)FROM 테이블명 예시12SELECT COALESCE(학부모tel, 학부모tel2, \"비상연락처도없음\")FROM user","link":"/2021/06/13/210614sqlNull/"},{"title":"[MyBatis] update할때 컬럼명 바꿀 수 없을까?","text":"😫 너무 비효율적이야!동일한 테이블에서 컬럼명에 따라 값이 달라지는 update 구문을 만들고 싶었다.물론 컬럼명마다 update구문을 만들 수 있지만 동일테이블인데 그건 너무 비효율적이다.그래서 단순하게 아래 쿼리를 작성한 뒤 String값 2개 name과 수정할이름을 넘겨주었다. 1234&lt;update id=\"updateUserOneByOne\" parameterType=\"String\"&gt; update user set #{column_name} = #{value}&lt;/update&gt; 그 결과는 아래처럼 오류가 발생했다. name을 컬럼이 아닌 String으로 받아들여졌기때문에 생긴 오류였다. 12java.sql.SQLSyntaxErrorException: (conn=9442) You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ''name' = '수정할이름' 이를 어떻게 해결할 수 있을까? 😎Mybatis 컬럼명 동적쿼리이를 조금 고급스럽게 표현하면 Mybatis 동적쿼리라고 부른다.#에서 $로 바꿔줬을뿐인데 정상작동한다! 1234&lt;update id=\"updateUserOneByOne\" parameterType=\"String\"&gt; update user set ${column_name} = #{value}&lt;/update&gt; 정리 ${}: 파라미터값 그대로 입력 #{}: 파라미터값이 ‘ ‘으로 감싸져서 문자열로 입력","link":"/2021/06/23/210624MybatisColumnChange/"},{"title":"신입개발자 6개월 회고","text":"내가 백엔드 개발을 6개월 동안 하면서 배운 것들회사에 입사를 한지도 6개월이 넘었다. 사실은 12월에 입사를 했기때문에 7개월차이다.하지만 스스로 6개월이라고 정의하고 6개월차 회고를 쓰는 이유는 12월은 정말 아무것도 못 하고 눈만 뜨고 있었기때문이다.정말 바쁘다바빠- 적응하고 코드이해하고 하느라 정신없는 한달이었다. 정말 바빴는데 매달 어떤 일이 있었을까? 한 줄로 정리해보고싶어졌다.더불어 내가 얼마나 성장했는 지 정리해보려고한다. 🗓️ 6개월 동안 무엇을 했을까? 12월: 시스템개발팀으로 입사 + 눈만 뜨고 있었음. 1월: 학사시스템 프로젝트 참여 + 배포 2월: 학사시스템 프로젝트 유지보수 + 교육 3월: 연구개발팀으로 발령 + 신규프로젝트 대기하면서 리액트스터디 4월: 리액트스터디 5월: 다른 신규 프로젝트 백엔드개발자로 참여 6월: 다른 신규 프로젝트 백엔드개발자로 참여 학사프로젝트12월, 1월은 나에게 참 정신없는 달이었다.입사와 동시에 프로젝트 막바지였던 학사시스템 프로젝트에 투입되었다.막바지라는 의미는 거의 다 끝났다는 의미임과 동시에 해결할 것이 엄청나게 많이 남아있어 막판 스퍼트를 해야함을 의미했다.입사하자마자 한달내내 야근을 했다. 집에 도착하면 밤 11시여서 씻고 자고 눈뜨면 바로 출근하는 정말 힘든 한달을 보냈다.IT업계는 야근이 많다던데 진짜 이정도일 줄이야…신입이었던 나는 주로 어드민페이지 수정와 이미지게시판 구현, 팝업기능 구현, 슬라이드기능 구현, SNS API로 실시간 글 호출기능구현과 그밖의 자잘한 오류들을 해결했다. 리액트스터디수습기간을 거쳐 정직원이 된 후 연구개발팀으로 팀이동을 했다.나는 백엔드개발자로 입사했지만 신규 프로젝트에서는 리액트 개발을 담당하게 되었다.어떻게?그냥 하라고 하면 하는 거다. 그것이 직장생활…😎자바와 JSP를 주력으로 다뤄본 나에게 리액트를 배워볼 수 있는 좋은 기회라는 생각이 들었다.신규 프로젝트가 기획되는 동안 주어진 업무에 최선을 다하기위해 열심히 리액트 공부를 하며 회의때 쏟아지는 용어들을 공부했다. 새로운 프로젝트 백엔드 개발위에서 말한 신규 프로젝트 작업이 생각보다 늦어지면서 다른 새로운 프로젝트를 맡게되었다.생체정보를 활용한 웹/앱 서비스를 만드는 프로젝트이다.(이하 막프)지금도 진행되고 있는 막프는 6월까지해서 개발을 끝내는 것이 스프린트의 목표인데 연계되어있는 디바이스업체와 AI연구소와의 조율때문에 시간이 더 걸릴 것 같다. 😘 6개월동안 성장한 것1 서버와 클라이언트사이에서 HTTP통신에 대한 확실한 이해현재 진행중인 막프덕분에 프론트엔드와 백엔드의 상호작용 흐름을 확실하게 이해할 수 있게 되었다.POSTMAN을 이해하고 쓸 수 있다.특히 Path Variable, Query Parameter, ResquestBody를 필요한 상황에 따라 정확히 구분하여 사용할 수 있다. 2 RestAPI 이해도 향상예전엔 그냥 구글링해서 따라했다면 이젠 RestAPI를 정확히 인지하고 어떻게 사용하면 좋을지 고민하는 단계까지 왔다.앞으로 적절한 디자인패턴을 적용하고 RestAPI 규칙을 완전히 따르는 카카오나 MS, 공공API와 같은 RestAPI 만들어보고 싶다. 관련 포스팅 : REST API 컨트롤러 Mapping을 어떻게 하지? 3 개발과 문서화를 쉽게 할 수 있도록 도와주는 라이브러리들과 친밀도 향상LOG4J와 SWAGGER를 자유자재로 사용할 수 있다.Logback로 SQL 쿼리문을 콘솔에 출력하여 개발 효율성이 한증 증가했다. 4 커스텀 예외 클래스로 예외처리 가능단순한 예외처리뿐만아니라 커스텀예외클래스를 생성하여 예외처리를 할 수 있다.NPE 처리는 여전히 어렵지만 if(object != null)이 아닌 StringUtils, isEmpty() 또는 equals()를 사용하고 toString() 대신 String.valueOf()를 사용하여 예방할 수 있다.또한 아예 쿼리를 이용해서 NPE를 예방할 수 있다. 관련포스팅: SQL에서 컬럼값이 NULL처리는 어떻게 하면 좋을까? 5 Springboot security와 JWT 경험이번 막프에서 나를 가장 많이 애먹인 부분이다.팀장님의 도움없이는 이렇게까지 절대 이해하지 못했을것이다. 이자리를 빌어 다시한번 감사드린다고 말하고싶다.팀장님 진짜 감사합니다!Springboot security는 여전히 어려운 부분이 많지만 기본 개념을 이해하고 사용하는 데는 문제가 없으며 Session이 아닌 JWT를 통해 인증기능을 구현할 수 있다. 6 공통코드테이블 구현 가능테이블의 관계를 파악하고 공통코드테이블을 구현할 수 있다. 7 JOIN과 동적쿼리 실력 향상INNER JOIN과 OUTER JOIN을 구분하여 사용할 수 있다.Mybatis의 동적쿼리인 selectKey는 물론 ${}와 #{}를 구분하여 사용할 수 있다. 관련포스팅: selet 컬럼명을 조건에 따라 다르게 출력할 수 있을까? 관련포스팅: update할때 컬럼명 바꿀 수 없을까? 관련포스팅: select한 값을 바로 insert할 수 있을까? 8 리액트 이해도 향상아직 부족하지만 그래도 CRA를 이용해 리액트 프로젝트를 만들고 리액트hook과 Material-ui를 활용하여 간단한 게시판 구현을 할 수 있다. 🖐️ 6개월 동안에 업무외로 내가 실천한 것들과 그 성과취업하고서도 1일 1커밋을 목표로 매일 알고리즘 한 문제씩 풀려고 노력했다.그결과 아래처럼 멋진 잔디를 가질 수 있게 되었다.앞으로도 취미처럼 1일1커밋을 실천해나갈것이다. 1일1커밋코딩을 취미화 그리고 습관화하기 위해 취업후에도 1일 1커밋을 계속 실천하고 있다.커밋은 알고리즘 한문제씩 풀거나 오늘 배웠던 TWIL이나 개발정보정리글 위주로 했다.노력한 끝에 아래와 같이 멋진 잔디밭을 가질 수 있게 되었다. 알고리즘스터디취준때부터 친한 개발자언니와 100문제 알고리즘 스터디를 만들어 진행하다가 취업후에도 멈추지않고 계속도전하였다. 그 결과 17주안에 100문제 풀기에 성공했다.스터디가 끝난 이후에도 혼자서 지속적으로하여 현재 50문제를 추가로 더 풀었고앞으로도 매일 한문제씩 쭉 도전할 예정이다. - Rhythming-Algorithm 스터디 깃헙레포 - 나혼자하는 알고리즘 깃헙레포","link":"/2021/06/27/210627Memoir6months/"},{"title":"안드로이드 스튜디오 AVD에 APK연결하기","text":"앱을 개발 후 테스트를 위해서 안드로이드 스튜디오 AVD를 이용해 테스트 해보기로 했다. 안드로이드 스튜디오 다운로드안드로이드 스튜디오를 다운로드 한다. AVD Manger 클릭 Create Virtual Device를 클릭하여 원하는 Phone을 선택한다. 기본은 Pixel 2. Next클릭 후 만든 앱의 일치하는 API Level과 일치하는 Release를 다운로드한다. 예) 29버전이면 API Level이 29인 Q를 다운로드 한다. 다운로드 완료된 Release name을 클릭하고 Next를 클릭한다. 원하는 Verify 설정을 진행하면 끝! 원하는 설정이 없는 경우 기본 그대로 진행하면 된다. cmd에서 apk 다운로드 진행 AVD를 켜놓는다. cmd를 연다. 안드로이드 스튜디오 sdk를 다운로드한 경로로 이동한다. 12// 예시cd C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\\platform-tools apk의 경로를 복사한 뒤 아래 명령어 뒤에 입력한다. install : adb install 앱이름.apk uninstall : adb uninstall 앱이름.apk reinstall : adb install -r 앱이름.apk 12345// apk 경로 예시C:\\Users\\사용자명\\Downloads\\앱이름.apk// install 명령어adb install C:\\Users\\사용자명\\Downloads\\앱이름.apk 정상적으로 설치되면 아래처럼 출력된다. 12Performing Streamed InstallSuccess 1분정도 기다리면 자동적으로 내가 만든 앱이 뜬다! AVD 안드로이드 가상 디바이스 GUI로 간단하게 apk 설치 및 제거 apk파일 설치위처럼 cmd에서 install, uninstall 명령어 칠 필요없이 안드로이드 가상 디바이스 (이하 AVD)로 apk파일을 드래그 앤 드롭하면 설치가 된다! apk파일 삭제AVD에서 삭제를 원하는 앱을 꾸욱 누르면 APP INFO가 상단에 뜬다.이를 클릭한 다음 중앙의 Uninstall을 클릭해주면 정상적으로 삭제된다.","link":"/2021/06/29/210630avd/"},{"title":"[Eclip&#x2F;STS]특정 파일이  커밋이 안 될때, 파일아이콘에 체크표시가 되어있을때","text":"STS에서 열심히 코딩하고 커밋하려고 하는데 특정 파일만 자꾸 Git Staging에 올라오지도 않고 index에 추가되지도 않으며 Commit도 되질 않았다.도대체 문제가 뭘까.설정을 확인하며 파일을 유심히 보는데 오 홀리!!! 해당 파일의 작은 아이콘 모양이 다른 파일들과 달랐다.왕년의 다른그림찾기실력이 여기서 쓰일 줄이야. 😂 원인다른 파일들은 노란 네모 아이콘이 있는데 해당 파일에만 체크 아이콘이 있었다.이 작은 아이콘을 가볍게 여겨선 안된다.Assume unchanged라는 의미로 git에서 해당 파일이 무슨 변화가 있든 변화가 없다고 받아드리겠다는 의미이다.그러니 내가 아무리 코드를 수정해도 git은 수정사항이 없다고 판단하고 staging에 올리지도 않았다. ICON 뜻 알아보기아래 이미지의 순서대로 아이콘의 의미를 알아보자. floder앞에 닫는 태그 &gt; (dirty) : 이 폴더 안의 적어도 하나 이상의 파일이 dirty 하다. 즉 변화가 있는 파일이 있다. 노란 네모 (tracked) : Git 레포지토리에 해당 파일를 추적 중이다. ? (untracked) : Git 레포지토리에서 처음 보는 파일이다. 즉 신규 파일을 생성한 경우 이렇게 뜬다. 아이콘 없음 (ignored) : .gitignore 파일 안에 명시된 파일이나 git에 올라가지 않는 무시되고있는 파일이다. 설정 및 확인방법 1. 파일 우클릭-&gt;Team-&gt;ignore 설정 및 확인방법 2. preference-&gt;Team-&gt;Ignored Resources dirty.txt앞에 닫는 태그&gt; (dirty) : 인덱스 및 레포지토리에 추가되지 않은 변경사항이 있는 파일이다. * (staged) : 해당 파일이 인덱스에 추가되었다. *와 &gt; (partially-staged) : 해당 파일의 수정사항이 인덱스에 추가된 후 해당 파일에 변경사항이 있다. + (added) : 해당 파일이 인덱스에 추가되었다. x (removed) : 해당 파일이 로컬 디렉토리에서 삭제되면서 버전이 변경되었다. 이 표시는 프로젝트 구조가 아닌 Git staging 메뉴에서 확인할 수 있다. 빨간 마름모 (conflict) : 해당 파일에 merge 충돌이 있다. 파란 ✓ (assume-valid) : 해당 파일에 무슨 변화가 있더라도 변화가 없다고 판단한다. 설정방법 : Team -&gt;Assume unchanged 또는 Not Assume unchanged GUI로 해결하기 체크 아이콘이 있는 파일 우클릭 아래 이미지처럼 Team -&gt; Advanced -&gt; No Assume Unchanged 클릭 2번을 실행해도 여전히 체크 아이콘이 있을 것이다. 당황하지 않고 😁 STS/이클립스를 재시작해준다. 재시작 후 확인해보면 해당 파일의 체크 아이콘이 노란 네모 아이콘으로 바뀐 것을 확인할 수 있다! 해결! CLI로 해결하기CLI로 설정하는 방법은 특정 파일만 커밋하지 않기(–assume-unchanged)를 참고하면 된다. 참고 https://wiki.eclipse.org/EGit/User_Guide/State","link":"/2021/07/07/210708sts-icon-meaning/"},{"title":"String으로 날짜 가지고 놀기","text":"String으로 날짜를 받은 뒤 하루를 더하거나, 하루를 빼거나, 그 달의 마지막 날을 구하거나 첫번째 날을 구하는 등 날짜 연산을 하는 법을 알아보자.사용할 라이브러리는 총 3가지이다. import java.text.SimpleDateFormat; import java.util.Date; import java.util.Calendar; String으로 날짜 연산하기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051SimpleDateFormat sdfYMDHms = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");SimpleDateFormat sdfYMD = new SimpleDateFormat(\"yyyy-MM-dd\");String test = \"2021-07-16\";//String을 날짜 연산을 위해 Date 객체로 변경Date date = sdfYMD.parse(test); //날짜 연산을 위한 Calendar객체 생성 후 date 대입Calendar cal = Calendar.getInstance();cal.setTime(date);// add 하기cal.add(Calendar.MILLISECOND, 10); //10밀리초 더하기System.out.println(\"10밀리초 더하기: \"+sdfYMDHms.format(cal.getTime()));cal.add(Calendar.MINUTE, 10); //10분 더하기 System.out.println(\"10분 더하기: \"+sdfYMDHms.format(cal.getTime()));cal.add(Calendar.MINUTE, -10); //10분 빼기 System.out.println(\"10분 빼기: \"+sdfYMDHms.format(cal.getTime()));cal.add(Calendar.HOUR, 1); //1시간 후 System.out.println(\"1시간 후: \"+sdfYMDHms.format(cal.getTime()));cal.add(Calendar.HOUR, -1); //1시간 전 System.out.println(\"1시간 전: \"+sdfYMDHms.format(cal.getTime()));cal.add(Calendar.DATE, 1); // 1일 더하기System.out.println(\"1일 더하기: \"+sdfYMD.format(cal.getTime()));cal.add(Calendar.DATE, -1); // 1일 빼기 System.out.println(\"1일 빼기: \"+sdfYMD.format(cal.getTime()));cal.add(Calendar.MONTH, 1); // 한달 더하기System.out.println(\"한 달 더하기: \"+sdfYMD.format(cal.getTime()));cal.add(Calendar.MONTH, -1); // 한달 빼기 System.out.println(\"한 달 빼기: \"+sdfYMD.format(cal.getTime()));// set 하기cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); // 해당 일자가 있는 주의 월요일 구하기System.out.println(\"해당 일자가 있는 주의 월요일 구하기: \"+sdfYMD.format(cal.getTime())); cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH)); // 해당 월 마지막날 구하기System.out.println(\"해당 월 마지막날 구하기: \"+sdfYMD.format(cal.getTime())); // 해당 일자 무슨 요일인지 구하기 일요일:0 월요일 1 ~ 토요일 7System.out.println(\"해당 월 마지막날의 요일 구하기: \"+ cal.get(Calendar.DAY_OF_WEEK)); 출력값은 아래와 같다. 12345678910111210밀리초 더하기: 2021-07-16 00:00:00.01010분 더하기: 2021-07-16 00:10:00.01010분 빼기: 2021-07-16 00:00:00.0101시간 후: 2021-07-16 01:00:00.0101시간 전: 2021-07-16 00:00:00.0101일 더하기: 2021-07-171일 빼기: 2021-07-16한 달 더하기: 2021-08-16한 달 빼기: 2021-07-16해당 일자가 있는 주의 일요일 구하기: 2021-07-12해당 월 마지막날 구하기: 2021-07-31해당 월 마지막날의 요일 구하기: 7","link":"/2021/07/14/210715Calendar/"},{"title":"[웨비나후기]7월 우아한테크세미나 : AAA","text":"웨비나 소개 및 후기아키텍처라는 말에 어려울까봐 지레 겁먹고 웨비나를 듣지 않으려고 했다.하지만 현재 회사에서 MSA로 진행중이며 인프라와 아키텍처를 구축하는 팀장님들이 겁나 멋있어보였기에 궁금해졌다.나도 언젠가 팀장님들처럼 척척 만들어보고싶다고 생각하면서 중간에 듣다가 너무 어려우면 알고리즘이나 풀어야지하면서.그러나 왠걸. 너무 재밌다! 특히 레거시와 요구사항의 문제상황을 주고 15초동안 이 문제를 어떤 순서로 풀어갈 것인지 생각하는 부분에서 정말 많은 것을 배웠다.연사님은 문제상황을 척척 해결해나가는 슈퍼개발자였다. 정말 멋있고 나도 그렇게 되고 싶었다.웨비나 듣길 정말 잘했다. Software Architect 두 분류 Architectus Reloaded 시스템의 무결성을 보장하는 한 명의 아키텍트 아키텍트 혼자 유일한 결정권자이기때문에 아티텍트가 처리해야 할 업무가 프로젝트의 병목이 됨 초반에 결정되고 다른 사람들은 그 계획을 따라가는 구조 Architectus Oryzus 프로젝트의 전반이 어떻게 돌아가는 지를 잘 알고, 이슈들을 발견하고 큰 문제가 되기 전에 미리 조치를 취할 수 있는 사람 개발자의 협력을 이끌어내는 아키텍트 개발팀의 멘토 역할을 하고 개발팀의 수준을 높여서 더 복잡한 이슈를 해결할 수 있도록 만드는 사람 한마디로 가이드! 좋은 아키텍트가 되기 위해서는 항상 공부해야한다.연사님의 공부방법은 아래와 같다. 인프런 Medium Likedin: 좋은 아티클 공유 Udemy: 한 달에 유료 강좌 1개정도는 들으려고 노력함 Book: 읽었던 기술 서적을 정리해 놓으면 좋다. ex) Lighthouse Architecture란? 노련한 개발자가 나눠주는 시스템 디자인에 대한 이해 변경하기 힘든 것들 쉽게 바뀌어서는 안되고, 충분히 이해하고 만들어야 하면서도 중요한 것들 MSA패턴이 무조건 좋은 건 아니며 쿠버네티스를 쓴다고 다 MSA가 아니라고도 말씀해주셨다.차라리 잘 키운 모노리스 하나 열 마이크로 서비스 안 부럽다고 한다. 사례1: CI/CD없는 4년된 사용 프로그램을 오픈소스로 전환하는 프로젝트어떤 순서로 접근하면 좋을까? 스프링부트를 띄어서 가장 어려운 서비스부분을 PoC(Proof Of Concept: 사전에 검증하는 것)함 Jenkins를 써서 CI/CD부터 구축 OOP(Object-oriented programming: 객체지향 프로그래밍)/DDD(Domain Driven Design) 설계 설계는 아키텍트, 개발은 외주업체 용역 여기서 설계란 메소드, 클래스 외주업체 개발자가 아예 클래스를 만들 수 없도록 구조를 만듬. 만약 클래스 만들고 싶다면 아키텍트와 상의 후 아키텍트가 직접 배치를 고민하고 만들지 결정함) DB 어려운 조회는 VIEW로 만들고 CQRS CUD는 JPA R는 MyBatis 애자일방식으로 진행하며 TODO LIST는 스크럼방식 사용 사례2: B2C인데 장애가 많고 바로 배포하는 프로젝트1달만에 장애보고서 2번쓸 정도로 숫자가 맞지않고 개발하면 바로 배포하는데 공유하지는 않으며 코드리뷰는 하지만 설계는 하지 않는 상황.어떤 순서로 접근하면 좋을까? 애자일이라서 항상 배포하는 게 맞지만 이건 전제조건이 있음. 단위테스트와 DDD, 통합테스트가 잘 되어있어서 CI/CD안에서 자동화되어있을 때 바로 배포할 수 있음 -&gt; 그래서 정규배포로 변경함 User Story를 다시 작성함. 다시 AC(액셉턴스 크리테리아: 참과 거짓을 판단할 수 있는 명확항 문장)작성함. 우아한 ATDD 영상 추천 : https://www.youtube.com/watch?v=ITVpmjM4mUE User Story(Value Statement, Acceptance Criteria, Definition Of Done 포함)를 먼저 개발자가 작성 -&gt; PM에게 확인을 받음 -&gt; 소스 코드작성. PO님과 핫도그를 먹으며 현 문제점과 해결을 위한 지속적인 노력함. 대화를 정말 많이했음. DB를 같이 보면서 숫자를 맞춤 코드리뷰보다는 설계리뷰를 해봅시다 코드리뷰는 후행적이다 사례3: 10년이 넘은 레거시 프로그램으로 부하가 극단적으로 많은 프로젝트새로운 시스템도 기존의 시스템과 연동해야 하며 Oracle중심으로 이루어져있고 수강신청시스템처럼 부하가 극단적으로 왔다갔다하는 상황.어떤 순서로 접근하면 좋을까? 여기서 Oracle중심이라는 의미는 비즈니스 로직이 대부분 오라클에 있다는 뜻으로 변경이 까다롭다는 의미이다. 배우면서 하는 프로젝트는 생각보다 더더더 굉장히 빡시다는 것을 깨달았다고 하셨다. 극단적으로 부하가 왔다갔다하니까 서버리스가 훨씬 효과적일 수 있음 -&gt; NoSQL로 선택 근데 서버리스로 가면 Java랑 맞지 않음 -&gt; why? 워밍업시간이 오래걸림 따라서 node로 진행 -&gt; But java개발자들이 바로 node로 업무하기에는 버겁기때문에 typescript를 사용 타입스크립트로 DDD -&gt; java개발자들에게 도움을 주기 위해 직접 예시를 작성함 리액트를 새로 배울 시간에 그냥 템플릿 구매함으로서 프로젝트 시간 절감 오라클을 최대한 유지하면서 이벤트만 사용 사례4: 공통모듈이 있는 MSA인데 코드리뷰없고 단위테스트도 없는 프로젝트어떤 순서로 접근하면 좋을까? 배포 의존보다 코드 중복이 나을 수 있음 공통모듈은 비즈니스 로직이 빠져있으면서도 절대 바뀌지않을 애들(유효성체크등)만으로 만들어야 함. 만약 이를 어긴 채 비즈니스 로직이 있는 공통모듈을 배포한다면 배포폭풍이 일어남. 차라리 코드중복이 낫다. 시스템 비용의 80%는 유지보수에서 나옴 -&gt; 오픈소스로 감당할 수 있을지 오픈 소스 도입전 충분히 생각해야함 비즈니스 코드가 기술보다 더 중요할 수 있음 코드리뷰, 단위테스트도 없기때문에 소나큐브를 사용함 CI할때 인텔리제이에서 Sonarqube 플러그인 설치하거나 CI 과정중에 자동화된 것을 넣는 것도 좋은 방법! 추천 아키텍쳐 사이트 https://marimba.team: 미로보다 기능이 많지 않지만 깔끔하고 통합적임 https://www.archunit.org: 아키텍트 제한할 수 있음 https://docs.fitnesse.org: 로직의 정합성에 대해서 사용자가 위키를 작성하고 그 위키기반으로 테스트 작성이 가능함. 서버리스 프레임워크할때 엔터프라이즈급으로도 충분히 사용가능한 기본적인 ci/cd를 구성해줌 QnA MSA로 전환할 때에 도메인, 조직의 규모, 모듈/서비스별 스케일 등을 고려하여 전환 전략을 짜고 분리된 시스템간의 상호작용을 어떤 방식으로 가져갈지를 선택하게 될 텐데, 이에 대해 참고할만한 가이드같은 것이 있을까요? 서비스를 잘못나눠두면 엄청고생하니, 먼저 크게 나눠놓고 모듈러 모노리스로 시작해서, 서비스를 정확하게 분리해야하는 상황이 오면 분리하세요조직이 워터풀이거나 프로젝트기간이 정해져있거나, MSA 전환에 있어 strict한 개발방법론을 사용하면 안 맞을 수 있어요 작은 스타트업에서 홀로 백엔드 개발을 하고 있습니다. 가끔은 제 아키텍쳐의 방향이 올바른지 코드는 직관적인지 리뷰를 받고 싶은데 이런 활동을 할 수 있는 한국의 커뮤니티 플랫폼이나 유료 서비스가 있을까요? 저자에게 직접 연락해 조언을 요청하는 것도 방법입니다. 이메일을 통해 사정을 설명한 뒤 도움을 주실 수 있는 지 물어봤습니다. 누가 먼저 와서 도와주지 않기 때문에 내가 먼저 다가가서 물어봐야 합니다 개발 방법론을 언급해 주셨는데, agile 관련 전문성도 있으신데, 한 마디 해주세요 :) 칸반. 스크럼 등 잘 들여다보고 우리 조직에 무엇이 맞을지를 생각해봐야 할 것같습니다비즈니스에 가장 많은 가치를 줄 수 있는 것에 가장 많은 우선순위를 두고 개발을 하게되는데, 여기에 애자일을 쓸 때 더 가치있습니다 애자일이란 공통모듈을 먼저 개발하는 것이 아니라 가장 중요한 핵심 서비스 먼저 만드는 것이라는 연사님의 말씀이 와닿았다. 강연추천마틴 파울러의 소프트퉤어 아키텍처를 설명할 때는... 추천 책 추천 열혈강의 소프트웨어 아키텍처 설계 가이드 마이크로서비스 도입, 이렇게 한다 Building Microservices Clean Architecture 개발자에서 아키텍트로","link":"/2021/07/21/210721woowacourse-architecture/"},{"title":"DBeaver 단축키 추천","text":"오늘 팀장님께 쿼리질문하나 했다가 엄청난 단축키를 알게 되었다. 와 이걸 모르고 DBeaver를 사용하다니 나는 정말 바보였다.여러 단축키 중에서도 실무에서 가장 많이 사용되는 단축키 3개는 필수로 암기하고 있으면 일찍 퇴근할 수 있다. 🔑 추천 단축키 alt + shift + a : 열편집단축키를 클릭하면 화면이 살짝 커지면서 열편집 화면으로 전환이 된다.이때 마우스로 원하는 열을 드래그하면 해당 열이 선택되고 문자 삽입삭제등 다양한 작업을 선택한 모든 열에 적용할 수 있다. 다만 한글인 경우 쿼리가 삭제되는 오류가 있으니 문자 입력시 꼭 영문자로 입력해야한다.열편집화면에서 나오고 싶을때도 동일한 단축키를 눌리면 된다. ctrl + shift + x : 대문자블록을 지정한 뒤 단축키를 누르면 블록안의 모든 문자는 대문자로 바뀐다. ctrl + sjoft + y : 소문자블록을 지정한 뒤 단축키를 누르면 블록안의 모든 문자는 소문자로 바뀐다. 🔑 더 많은 단축키가 궁금하다면? DBeaver 단축키 docs","link":"/2021/07/21/210722DEeaver-shortcutkey/"},{"title":"[패스트캠퍼스]올인원패키지 기술면접 인강 솔직 후기","text":"패스트캠퍼스 올인원패키지 중 기술면접 완전 정복 강의를 듣고 요약 정리 및 후기를 작성해보았다. 후기추천도(5점만점):⭐⭐특별할 것없이 구글링만해봐도 나오는 내용만 하기때문에 초반에는 살짝 지루했다.실제 모의면접 음성을 들으면서 조언하는 부분이 인상적이었다. 이부분이 없었다면 그냥 유투브의 기술면접 팁 영상들과 비슷한 느낌이다. 최근 기술 면접 형태: 손코딩 테스트손코딩 테스트를 통해 확인하고자 하는 것은 크게 3가지이다. 커뮤니케이션이 되는가? 꼼꼼하게 작성하는가? 예를 들어 데이터를 처리하시오 라는 애매모호한 문제를 출제했다면 그 데이터가 정수인지, 부동소수점은 있는지, 문자열인지 등을 확인하고 작성하는 지 확인 Problem Solving Logic이 합리적인가? 그럼 손코딩 테스트는 어떻게 해결하면 좋을까? 아래 5단계를 따라하면 좋다. 문제 듣기 예제를 통해 문제 이해하기 무식하게 풀기 질문자와 커뮤니케이션을 통해 개선하기 마이너한 부분의 최적화 검토하기 자기소개질문 팁채용자는 시간이 없다. 조직이 원하는 기능을 개발할 수 있는 지, 함께 일하는데 문제가 없는 지를 보는 질문이다.성장과정, 성격을 중점을 둘 필요없고 지원동기에 중점을 두고 말하면 된다.비전공자인 점을 먼저 얘기할 필요가 없다. 가장 중요한 점을 먼저 얘기해야한다.즉 개발경험을 먼저 얘기해야한다. 프로젝트시 어려운 점과 극복방법시간압박, 마감기한의 어려움보다는 기술적인 애로점을 만났고 스스로 익혀서 극복했다고 한 점을 말하는 것이 더 좋다. CS 기본지식주요질문1: 프로세스와 스레드 차이 프로세스: 운영체제로부터 자원을 할당받아 실행 스레드: 프로세스로부터 자원을 할당받아 실행추가로하나의 프로세스 안에서 여러 스레드 생성 가능하며, 각 스레드별 개별 스택을 가지고 있고 프로세스의 전역 메모리 공간을 공유하며 프로그램을 실행한다. 프로세스는 코드/데이터/스택/힙 메모리 영역을 기반으로 실행 스레드는 프로세스 안에서 개별적인 스택을 가지고 코드/데이터/힙 영역을 공유하며 실행 주요질문2: 스크립트 언어와 컴파일 언어 차이 스크립트언어: 파이썬, 루비, PHP등 컴파일 단계없이 실행 단계에서 한 줄씩 기계어로 번역 후 실행되므로 통상 컴파일 언어보다 실행이 느림 컴파일언어: C계열, JAVAE등 컴파일러를 통해 사전에 컴파일되어 기계어 상태되므로 실행이 빠름 주요질문3: 동기식과 비동기식 차이 동기식: 요청에 대한 응답을 기다린 후, 응답이 오면 다음 요청을 하는 방식 비동기식: 요청에 대한 응답을 기다리지않고, 다음 동작은 진행하는 방식추가로 장단점을 설명하면 좋다. 동기식 장점: 구성이 단순, 순서대로 실행가능 단점: 멀티태스킹 불가 비동기식 장점: 멀티태스킹 가능 단점: 일정 시간당 요청량이 많아질 경우 부하 발생 -&gt; 이를 해결하기 위한 추가 처리 필요 주요질문4: DB에서 인덱스를 사용하는 이유와 장단점 인덱스: 데이터를 논리적으로 정렬해서 검색과 정렬 속도를 높이기 위해 사용 단점: 데이터 삽입 및 변경이 수시로 일어나면 매번 인덱스를 변경해야 하므로 성능 저하를 막기 위한 고려가 필요함 주요질문5: TCP와 UDP 차이점과 장단점 UDP: 비연결형 프로토콜과 흐름제어, 오류제어를 하지않음 -&gt; 송수신에 적은 데이터가 필요 TCP: 연결혈 프로토콜로 흐름제어, 오류제어를 함 -&gt; 데이터 송수신에 신뢰성을 가짐TCP는 신뢰성있는 데이터 전송에서 사용 -&gt; 로직이 들어가기에 상대적으로 느림UDP는 유실이 조금 되어도 상관없는 데이터 전송에서 사용 -&gt; 로직이 적게 들어가기때문에 상대적으로 빠름더 자세한 내용은 TCP통신 vs UDP통신 차이점포스팅 참고 자바질문주요질문1: JVM과 JAVA 프로그램 실행 과정을 설명해보세요 JVM: Java Virtual Machine(자바 가상 머신)의 약자로, 자바 프로그램을 자바 API를 기반으로 실행하는 역할 JAVA 프로그램 실행과정: 프로그램 실행하면 JVM이 OS로부터 필요한 메모리만큼 할당 받고 -&gt; 자바 클래스파일을 실행한다. 주요질문2: Garbage Collection이 필요한 이유java 프로그램은 메모리를 명시적으로 지정해서 해제하지 않기 때문에, Garbage Collection을 통해 필요없는 객체를 찾아 지우는 작업을 수행한다. 주요질문3: Overriding vs overloading overriding: 상속관계일때 사용. 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용 메서드 이름 및 파라미터수 동일 overloading: 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술 더 자세한 오버로딩과 오버라이딩은 차이가 있으니 용어에 주의하자 포스팅을 참고하면 된다. 주요질문4: Interface 와 Abstract Abstract: 추상클래스는 추상 메서드 1개이상을 가진 클래스 상속시 추상메서드를 반드시 구현하게 해야할 때 사용 단일 상속. 클래스끼리 다중 상속 안됨 new로 객체 생성 안됨 Interface: 상수와 메서드의 집합. implements 받은 곳에서 모두 구현을 강제함 인터페이스끼리 다중 상속 가능 주요질문5: 디자인패턴이 무엇인지 싱글톤에 대해 간단히 설명공부했던 패턴보다 어떤 프로젝트를 할때 이러한 패턴을 사용해봤습니다라는 식으로 답변하는 것이 좋다. 디자인패턴: 공통적인 소프트웨어 코드 작성 문제를 해결하는데 도움이 될 수 있느 코드 패턴 싱글톤: 전체 프로그램에서 단 1개의 객체를 생성해서 공유할 수 있는 코드 패턴 운영체제 및 데이터베이스 주요 질문아래 질문들은 스스로 찾아봐야하는 질문이다.따라서 내가 찾은 답변들을 적어보려고 한다. deadlock의 개념 및 해결방법 뮤텍스와 세마포어의 차이점 가상메모리란? 컨텍스트 스위칭이란? 트랜잭션이란? RDBMS와 NoSQL 차이점 네트워크 주요 질문아래 질문들은 스스로 찾아봐야하는 질문이다.따라서 내가 찾은 답변들을 적어보려고 한다. OSI 7계층이란? HTTP와 HTTPS 차이점 쿠키와 세션의 차이점 RESTfUl 개념 TCP의 3-way-handShake와 4-way-handShake 차이점 자료구조와 알고리즘 주요 질문아래 질문들은 스스로 찾아봐야하는 질문이다. 따라서 내가 찾은 답변들을 적어보려고 한다.참곻로 자료구조와 알고리즘은 코딩테스트를 통해서 검증하는 경우가 더 많다. 배열과 링크드 리스트의 장단점에 대해 간략히 설명해주세요 BST의 최악의 시간 복잡도와 최악의 시간이 걸리는 케이스에 대해 설명해주세요 해쉬 테이블에 대해 설명해주세요 Fibonacci 공식을 recursive와 dynamic programming으로 구현시 차이점에 대해 설명해주세요. DFS와 BFS이란? 참고 https://fastcampus.co.kr/dev_online_algo","link":"/2021/07/24/210725skillinterview/"},{"title":"[MyBatis] insert할때 자동으로 키 생성하기(useGeneratedKeys과 selectKey방식 차이점)","text":"😎 insert할때 자동으로 번호를 올리고 싶어방금 insert한 autoincrement가 걸린 PK값을 바로 사용하고싶다면 어떻게 해야할까?두가지방식이 있다. useGeneratedKeys와 keyProperty 사용하기 selectKey 사용하기이름을 어떻게 부르는 지 몰라서 그냥 내가 지어보았다. 방법1: useGeneratedKeys와 keyProperty항상 useGeneratedKeys와 keyProperty는 함께 사용하면 된다. useGeneratedKeys : insert나 update됨가 동시에 자동생성된 키를 가져올 수 있는 속성으로 true로 설정 (default: false) keyProperty : 리턴 될 key property 설정. 즉 values나 set 다음에 오는 컬럼명과 동일하게 설정하면 됨. 여러개를 사용한다면 ,(콤마)를 구분자로 설정 12345public exampleVO { int userCode; String name; String email;} 123456&lt;insert id=\"insertExample\" useGeneratedKeys=\"true\" keyProperty=\"userCode\" parameterType=\"exampleVO\"&gt; INSERT INTO example (name, email ) VALUES (#{name}, #{email} ) &lt;/insert&gt; userCode가 자동 증감되어 DB에 등록된다.따로 set해주지 않더라도 exampleVO.getUserCode()를 하면 autoIncrement된 값을 get할 수 있다!세상 간편하다!insert 나 update return받을 때 주로 사용할 수 있다. 방법2: selectKey마이바티스는 자동생성키 칼럼을 지원하지 않는 다른 데이터베이스를 위해 다른 방법 또한 제공한다.바로 selectKey를 이용하는 것이다.아래 예제에서 selectKey구문이 먼저 실행되고 userCode 최대값에서 1씩 증가되게끔 셋팅된다. 그리고 나서 insert 구문이 실행된다. 이건 복잡한 자바코드 없이도 데이터베이스에 자동생성키의 행위와 비슷한 효과를 가지도록 해준다. 123456789&lt;insert id=\"insertExample\"&gt; &lt;selectKey keyProperty=\"userCode\" resultType=\"int\" order=\"BEFORE\"&gt; SELECT IFNULL(MAX(userCode+1),1) FROM example &lt;/selectKey&gt; INSERT INTO example (userCode, email) VALUES (#{userCode}, #{email})&lt;/insert&gt; selectKey에 대한 추가설명은 아래 포스팅을 참고하면 된다. select한 값을 바로 insert할 수 있을까? 방법1과 방법2의 차이위의 두 예시는 최근 userCode에서 +1을 해주는 결과를 나타낸다.결과가 같은데 왜 방식이 두개일까? 사용방향에 따라 차이점이 존재하기때문이다. 방법 1은 DBMS의 도움이 필요하다. 즉 auto increment가 되는 DBMS만 사용가능하다.만약 사용하는 DBMS는 AUTO INCREMENT를 지원해주지 않는다면 방법 2를 써야한다. auto increment를 지원해주는 DBMS라 하더라도 단순히 +1 증감이 아닌 뭔가 커스텀하게 증가시키고싶다면 2번을 사용해야한다.커스텀하게 증가시키는 게 무엇일까?아래 예시처럼 항상 5자리로 userCode를 등록할 수 있다. 12345678910&lt;insert id=\"insertExample\"&gt; &lt;selectKey resultType=\"int\" keyProperty=\"userCode\" order=\"BEFORE\"&gt; SELECT lpad(cast((IFNULL(MAX(userCode), 0) + 1) as char),5,'0') FROM example &lt;/selectKey&gt; INSERT INTO example (userCode, email) VALUES (#{userCode}, #{email})&lt;/insert&gt; 만약 현재 userCode의 최대값이 12라면 다음 userCode는 selectKey 실행에 의해 00013으로 DB에 등록된다. 요약 방법1: DBMS가 auto increment를 지원하고 특정 컬럼에 +1하는 로직인 경우 사용 방법2: DBMS가 auto increment를 지원하지 않는 경우 사용 DBMS가 auto increment를 지원하지만 특정 규칙으로 컬럼값을 증가시키는 로직인 경우 사용 참고 https://mybatis.org/mybatis-3/sqlmap-xml.html","link":"/2021/07/26/210727MyBatis-keyProperty/"},{"title":"Spring 들여다보기: IoC, AOP","text":"IoC란스프링에서 일반적으로 Java 객체를 new로 생성하여 Spring Container에게 관리를 맡긴다.즉, 개발자에서 프레임워크로 객체 제어의 권한이 넘어 갔으므로 제어의 역전(Inversion of Control)이라고 한다. 스프링이 알아서 객체의 생명주기를 관리한다면 개발자는 어떻게 그 객체를 사용할 수 있을까?DI를 통해서 사용할 수 있다. DI(Dependency Injection)의존성 주입이란 객체를 직접 생성/제어하는 것이 아니라, 제어의 역행을 사용해서 특정 객체를 필요한 객체의 외부에 가져다가 연결하는 것을 뜻한다.객체가 필요한 어떤 객체를 생성자 혹은 setter를 통해 주입하는 것을 말한다. DI 두가지 방법 예시 빈(Bean)이란?스프링 컨테이너에서 관리되는 객체들을 모두 빈이라고 한다. DI된 빈 사용하는 방법 @SpringBootApplication: 등록된 빈을 확인할 수 있다. @Component: 해당 어노테이션이 붙은 클래스는 스프링에서 빈으로 생성하여 자동적으로 관리한다. @Qualifier(“빈이름”): @Component가 여러 개가 있는 경우 스프링이 어느 것을 선택해야할 지 헷갈리므로 @Qualifier로 이름을 지정해서 빈을 사용하면 된다. 이렇게 빈으로 등록한 클래스를 어떻게 가져와서 사용할까?먼저 ApplicationContextAware를 구현한 ApplicationProvider클래스를 생성한 뒤 @Component를 통해서 빈 등록을 한다. 123456789101112131415@Componentpublic class ApplicationProvider implements ApplicationContextAware { private ApplicationContext context; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.context = applicationContext; } public static ApplicationContext getContext(){ return context; }} new로 생성할 필요없이 @Component로 등록된 빈들은 getBean()메서드를 통해서 접근할 수 있다. 12345// 기존 방법: 개발자가 직접 new로 클래스 생성Example ex1 = new Example(클래스명);// 스프링에게 loC한 방법Example ex1 = context.getBean(빈등록한클래스명.class); 한 클래스에서 여러 개 빈 생성하고 싶은 경우 @Configuration: 한 클래스에서 여러 개의 빈을 등록하겠다는 의미. @Component와 동일한 동작이지만 여러 개 빈을 한 클래스에 등록할 수 있다. @Bean(“빈이름”): @Configuration를 사용한 클래스 안에서 여러 개의 빈을 @Bean으로 등록할 수 있다. 스프링이 헷갈리지 않도록 각각 빈이름을 붙여줘야한다. 한 클래스에서 여러 개의 빈 생성하는 예시를 보자.여기서 return에 new로 생성한 것은 예시일뿐 실무에서는 set메서드, 생성자, 변수에 @Autowird, Inject등의 방법을 통해서 객체를 받아온 뒤 진행한다. 12345678910111213@Configurationpublic class AppConfig{ @Bean(\"빈이름1\") public Example ex(FirstBaseClass firstBaseClass){ return new Example(firstBaseClass); } @Bean(\"빈이름2\") public Example ex(SecondBaseClass secondBaseClass){ return new Example(secondBaseClass); }} 위에서 생성한 빈 중 FirstBaseClass를 사용하는 예시이다 1Example ex1 = context.getBean(\"firstBaseClass\" , Example.class); AOP( Aspect Oriented Programming)란AOP는의 관점 지향 프로그래밍으로 반복되는 코드들을 한 곳으로 모아서 사용할 수 있게하는, 즉 모듈화하겠다는 개념이다. 자주 사용하는 어노테이션은 아래와 같다. @Aspect: AOP를 정의하는 Class에 할당 @Pointcut: 기능을 어디에 적용시킬지, 예를 들어 메서드에 적용시킬 지, 어노테이션에 적용시킬지와 같은 AOP를 적용시킬 지점을 설정 @Before (이전) : 메서드 실행하기 이전 @After (이후) : 메서드의 결과에 관계없이(즉 성공, 예외 관계없이) 메서드가 완료 되면 실행 @AfterReturning 메서드호출 성공 실행 시 @AfterThrowing (예외 발생 이후) : 메서드호출 실패 예외 발생시 @Around (메소드 실행 전후) : Before / After 모두 제어 ObjectMapperobjectMapper 클래스를 통해서 Json node에 접근 할 수 있다. 참고: https://www.baeldung.com/jackson-object-mapper-tutorial","link":"/2021/07/27/210728Spring/"},{"title":"TCP통신 vs UDP통신 차이점","text":"두 통신의 차이점에 대해서는 면접은 물론 실무에서도 알고있어야하는 내용으로 이에 대해 알아보자 TCP통신 vs UDP통신TCP통신 신뢰성있는 통신: 보낸 데이터를 잘 받았다고 ACK를 보내지 않으면 다음 데이터를 보내지 않고 계속 기다린다. request가 잘 왔는지 ACK를 통해 꼭 확인하고 response를 한다. 속도 느림 예) 모든 웹통신 UDP통신 신뢰성없는 통신: 보낸 데이터가 중간에 유실이 되어도 확인하지 않고 다음 데이터를 보낸다. ACK를 받지 않고 보내고싶은 데이터를 마구 보낼 수 있다. 속도빠름 사람이 이해할 수 있는 모든 것들은 UDP통신을 하면 됨 예) 전화","link":"/2021/07/30/210730TCPVSUDP/"},{"title":"Springboot validation annotation parttern 정규식 오류 해결","text":"Spring 프로젝트에서 서비스단에서 처리하는 유효성체크를 VO에서 처리하고 싶었다.내가 원하는 바는 String depart컬럼에 null은 허용하지만 빈값과 white space는 허용하지 않는 유효성체크를 하고 싶었다.만약 빈값과 white space가 들어온다면 null로 변경해서 DB에 저장해야하는 로직이었다. 기본 어노테이션들NULL체크를 위해 기본으로 제공되는 어노테이션들이 있다. NULL 빈칸(“”) White Space(“ “) @NotNull 허용X 허용O 허용O @NotEmpty 허용X 허용X 허용O @NotBlank 허용X 허용X 허용X 내 경우는 NULL은 허용해주어야했기에 위의 어노테이션들을 전부 사용할 수 없었다. 기존코드 VO코드 123public class exampleVO{ String depart;} SERVICE 클래스의 checkVal메서드서비스에서 null은 허용되면서도 isBlank가 참인 조건으로 만들었다. 정상작동하지만 마음에 들지 않았다. 1234567public boolean checkVal(String depart){ if(exampleVO.getDepart() != null &amp;&amp; exampleVO.getDepart().isBlank()) { exampleVO.setDepart(null); } //비즈니스 로직} 정규표현식 코드정규식 테스트 사이트를 이용하여 원하는 정규식인 [0-9a-zA-Z가-힣]를 만들었다.혹시 정규표현식이 처음이라면 정규표현식 기초 포스팅을 참고하자 내가 만든 정규식 [0-9a-zA-Z가-힣]은 아래와 같이 처리한다. 허용: 숫자와 영대소문자, 한글, NULL 허용하지않음: 빈칸, 공백 첫시도 =&gt; 실패123456public class exampleVO{ @Pattern(groups = {ValidationGroups.insert.class, ValidationGroups.update.class} , regexp = \"[0-9a-zA-Z가-힣]\", message = \"빈값이나 공백이 들어갈 수 없습니다.\") String depart;} 포스트맨을 통해서 아래와 같이 테스트를 해봤는데 문자열을 입력할때 &quot;빈값이나 공백이 들어갈 수 없습니다.&quot;가 응답되면서 에러가 발생했다. 파라미터 정상작동여부 설명 null O DB에 null값이 정상적으로 insert, update됨 빈값(“”) O @Pattern message속성에 걸어둔 메시지가 출력됨 white space(“ “) O @Pattern message속성에 걸어둔 메시지가 출력됨 숫자,영대소문자,한글이 포함된 문자열 X @Pattern message속성에 걸어둔 메시지가 출력됨 도대체 왜일까? 에러를 이해하지못해서 삽질하고 있었는데 과장님이 간단하게 해결해주셨다.과장님 감사합니다.🙏 성공코드글자수{0,64}만 추가하면 된다!! 123456public class exampleVO{ @Pattern(groups = {ValidationGroups.insert.class, ValidationGroups.update.class} , regexp = \"[0-9a-zA-Z가-힣]{0,64}\", message = \"빈값이나 공백이 들어갈 수 없습니다.\") String depart;} 파라미터 정상작동여부 설명 null O DB에 null값이 정상적으로 DB에 insert, update됨 빈값(“”) O @Pattern message속성에 걸어둔 메시지가 출력됨 white space(“ “) O @Pattern message속성에 걸어둔 메시지가 출력됨 숫자,영대소문자,한글이 포함된 문자열 O 문자열값이 정상적으로 DB에 insert, update됨 세상 간단한 에러였는데 내 눈에는 보이지 않는 것이 참 이상했다.앞으로는 절대 빼먹을 일 없겠다! 과장님 다시한번 감사합니다! 여담이지만 사실 이렇게 사소한 오류일지를 적어야할지 고민이 많았다.하지만 사소한 것일수록 남겨놔야 나중에 시간을 단축시킬 수 있고, 또 누군가는 나처럼 삽질할 수 도 있으니 단 한 명에게라도 도움을 줄수있다면 아주 사소한 오류일지라도 적여야겠다는 생각이 들었다.주니어개발자 여러분 우리 모두 화이팅합시다.","link":"/2021/08/01/210802Pattern-regexp/"},{"title":"[Spring]validation라이브러리, 커스텀 validation annotation만들기","text":"일반적으로 validation을 진행할 때 아래와 같이 서비스단에서 null값을 체크해준다.파라미터가 3개이상인 경우나 여러 상황에서 한계점이 존재한다. 1234567891011public void example(String 파람1, String 파람2, int 파람3){ if(파람1 == null || 파람2 == null){ return } if(파람3 == 0){ return } // 비즈니스 로직시작} 예상할 수 있는 한계점 검증해야 할 파라미터가 많은 경우 코드가 길어짐 구현에 따라 Service Logic과 분리가 필요할 수 있음 흩어져 있는 경우 어디에서 검증하는 지 알기 어려움 재사용의 한계 존재 이럴때는 spring-boot-starter-validation 라이브러리를 사용할 수 있다. 끄적끄적님의 어노테이션 포스팅에 자세한 설명과 예시가 나와있다. BindingResult객체해당 객체를 통해 예외처리 가능하다. 참고: https://jhparkkk.tistory.com/12 validation 커스텀 어노테이션 만들기YearMonth형태가 yyyyMM형태인 어노테이션을 만들어보자. 1. Annotation 클래스 생성하기 new Annotation을 생성하고 아래처럼 작성하면 된다. 1234567891011121314@Documented@Constraint(validatedBy ={ YearMonthValidator.class }) // 어떠한 클래스를 가지고 유효성 검사를 할 것인지 작성해야함@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})@Retention(RetentionPolicy.RUNTIME)public @interface YearMonth { String message() default \"yyyyMM 형식에 맞지 않습니다.\"; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {}; String pattern() default \"yyyyMMdd\"; //기본패턴이 yyyyMM이지만 validator에서 Datetime으로 받기 때문에 yyyyMMdd를 넣어줘야함.} 2. Validator 로직 작성하기 위에서 만든 어노테이션을 활용하여 유효성체크를 하는 클래스를 만들어야한다. new Java Class를 생성하고 아래처럼 작성하면 된다. 12345678910111213141516171819public class YearMonthValidator implements ConstraintValidator&lt;YearMonth, String&gt;{ private String pattern; @Override public void initialize(YearMonth constratintAnnotation) { this.pattern = constratintAnnotation.pattern(); } @Override public boolean isValid(String value, ConstraintValidatorContext cxt) { LocalDate l = LocalDate.parse(value+\"01\", DateTimeFormatter.ofPattern(this.pattern)); return true; }} 3. 사용하기 그리고 사용법은 VO에서 패턴을 걸어주면된다. 1234// VO 일부@YearMonthprivate String reqDate;","link":"/2021/08/01/210802Spring-Validation/"},{"title":"@의 의미와 ROWNUM으로 활용하기","text":"MySql에서 사용하는 @의 의미는 무엇일까? 사용자 정의 변수이다.게시판 글번호 매기는 기능은 화면에서 할 수 있지만 MySQL에서도 할 수 있다. 사용자 정의 변수접두사 @는 사용자정의함수를 의미한다.아래처럼 변수를 초기화할 수 있고 초기화시 NULL값이 할당된다. 12//변수 abc 선언SELECT @abc; MySQL은 NULL을 리턴한다.사용자 정의 변수는 하나의 커넥션상에서 공유되기때문에 변수를 사용하고 초기화하지않으면 다른 쿼리 결과에 영향을 미칠 수 있다.따라서 사용자 정의 변수 사용시 변수값을 항상 초기화해줘야한다. 사용자 정의 변수 초기화사용자 정의 변수에 할당할 수 있는 데이터 타입은 5가지이다.별도의 타입을 지정하는 것은 아니고 스크립트언어처럼 저장하는 값에 의해 타입이 정해진다. 문자열 정수 십진수 부동 소수점 NULL 사용자 정의 변수 초기화 방법에는 3가지가 있다. SET 이용 SELECT 이용 + FROM절에서 초기화 SELECT 이용 + WHERE절에서 초기화 이때 명령문 2가지를 사용할 수 있는데 두 명령문은 동일하다. SET이용시 @변수명=값 또는 @변수명:=값 SELECT이용시 @변수명:=값 1234567// 1. SET이용하여 변수 abc 초기화SET @abc=77; SET @abc:=77;// set한 변수 사용 예시SELECT @abc as '순번'FROM example; 123// 2. SELECT이용 + FROM절에서 변수 abc를 77로 초기화 후 10씩 증가SELECT @abc:=@abc+10FROM example t1, (SELECT @abc:=77) t2; 123456789101112// 3. SELECT 이용 + WHERE절에서 변수 abc를 77로 초기화 후 10씩 증가SELECT @abc:=@abc+10FROM example t1WHERE (@abc:=77) = 77;// 결과8797107... ROWNUM 사용123// FROM절에서 초기화SELECT @rowNum:=@rowNum+1 as '순번'FROM example t1, (SELECT @rowNum:=0) t2; 실제로 내가 업무에서 사용하고 있는 방식은 WHERE절에서 초기화하는 방식이다. 1234// WHERE절에서 초기화SELECT @rowNum:=@rowNum+1 as '순번'FROM exampleWHERE (@rowNum:=0) = 0; 추가로 역순으로 나타내고 싶을 때 사용할 수 있는 방법이 있다. 1234567// 역순 정렬SELECT A.no as '순번'FROM ( SELECT @rowNum := @rowNum + 1 AS 순번 FROM example t1, (SELECT @rowNum:=0) t2; ) AORDER BY 순번 DESC 여기서 하나 의문점은 select절 별칭부분에 따옴표를 넣어 as '순번'을 사용하고 order by '순번' desc를 한다면 정렬이 되지 않는 다.여러 테스트를 해본 결과 DBtool이 아닌 MariaDB문제인 것 같다.왜 순번은 되고 '순번'은 안될까?구글링해도 뚜렷한 답이 나오지 않아 issue를 보내려고 했으나 레포에 issue창은 없고 PR창만 있어서 기여는 다음에 언젠가 하는 걸로…. 참고 https://three-pleasure.tistory.com/256 https://wakestand.tistory.com/556 https://dev.mysql.com/doc/refman/8.0/en/user-variables.html","link":"/2021/08/03/210804rownum/"},{"title":"[스프링Spring]에러 커스텀하기","text":"예외처리 어노테이션 @ControllerAdvice: 글로벌 예외처리 속성 basePackageClasses @ControllerAdvice(특정패키지명): 괄호안에 특정 package명을 기재하면 해당 package만 예외처리함 @ControllerAdvice(“com.test.springeprjt”): excom.test.springeprjt를 라는 특정 package 예외처리 @ExceptionHandler: 특정 controller예외처리 Exceprion이 발생했을 때 어떤 부분의 예외인지 그 이름을 알고 싶을때 Exception클래스 내 e.getClass().getName()메서드를 사용할 수 있다. 다른 개발자가 봐도 알기쉽도록 메시지를 꾸며보자 ErrorResponse.java한 파라미터에 조건이 여러 개가 있을 수 있으므로 List로 에러필드와 에러메시지를 받을 필요가 있다. 12345678910@Datapublic class ErrorResponse { String statusCode; String requestUrl; String code; String message; String resultCode; List&lt;Error&gt; errorList;} Error.java 123456@Datapublic class Error { private String field; //파라미터명 private String message; //오류메시지 private String invalidValue; //입력한 값} 이제 제일 중요한 컨트롤러 부분을 보자. ApiControllerAdvice.javaString으로 각각 에러값을 받은 다음 위에서 선언한 Error클래스에 set해준 뒤 list에 add해준다.각 예외클래스마다 사용할 수 있는 것들이 다르니 디버그나 공식문서를 통해서 원하는 내용을 찾으면 된다! 아래 예시는 가장 기본이 되는 방식 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 다른 컨트롤러들말고 오로지 ApiController에서만 사용하고싶을때 basePackageClasses속성을 사용한다@RestControllerAdvice(basePackageClasses = ApiController.class)public class ApiControllerAdvice { @ExceptionHandler(value = MethodArgumentNotValidException.class) public ResponseEntity methodArgumentNotValidException(MethodArgumentNotValidException e, HttpServletRequest httpServletRequest){ List&lt;Error&gt; errorList = new ArrayList&lt;&gt;(); BindingResult bindingResult = e.getBindingResult(); bindingResult.getAllErrors().forEach(error -&gt; { FieldError field = (FieldError) error; String fieldName = field.getField(); String message = field.getDefaultMessage(); String value = field.getRejectedValue().toString(); Error errorMessage = new Error(); errorMessage.setField(fieldName); errorMessage.setMessage(message); errorMessage.setInvalidValue(value); errorList.add(errorMessage); }); ErrorResponse errorResponse = new ErrorResponse(); errorResponse.setErrorList(errorList); errorResponse.setMessage(\"\"); errorResponse.setRequestUrl(httpServletRequest.getRequestURI()); //현재 api주소 errorResponse.setStatusCode(HttpStatus.BAD_REQUEST.toString()); errorResponse.setResultCode(\"FAIL\"); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse); } @ExceptionHandler(value = ConstraintViolationException.class) public ResponseEntity constraintViolationException(ConstraintViolationException e, HttpServletRequest httpServletRequest){ List&lt;Error&gt; errorList = new ArrayList&lt;&gt;(); e.getConstraintViolations().forEach(error -&gt;{ Stream&lt;Path.Node&gt; stream = StreamSupport.stream(error.getPropertyPath().spliterator(), false); List&lt;Path.Node&gt; list = stream.collect(Collectors.toList()); String field = list.get(list.size() -1).getName(); String message = error.getMessage(); String invalidValue = error.getInvalidValue().toString(); Error errorMessage = new Error(); errorMessage.setField(field); errorMessage.setMessage(message); errorMessage.setInvalidValue(invalidValue); errorList.add(errorMessage); }); ErrorResponse errorResponse = new ErrorResponse(); errorResponse.setErrorList(errorList); errorResponse.setMessage(\"\"); errorResponse.setRequestUrl(httpServletRequest.getRequestURI()); //현재 api주소 errorResponse.setStatusCode(HttpStatus.BAD_REQUEST.toString()); errorResponse.setResultCode(\"FAIL\"); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse); } @ExceptionHandler(value = MissingServletRequestParameterException.class) public ResponseEntity missingServletRequestParameterException(MissingServletRequestParameterException e, HttpServletRequest httpServletRequest){ List&lt;Error&gt; errorList = new ArrayList&lt;&gt;(); String fieldName = e.getParameterName(); String invalidValue = e.getMessage(); Error errorMessage = new Error(); errorMessage.setField(fieldName); errorMessage.setMessage(e.getMessage()); ErrorResponse errorResponse = new ErrorResponse(); errorResponse.setErrorList(errorList); errorResponse.setMessage(\"\"); errorResponse.setRequestUrl(httpServletRequest.getRequestURI()); errorResponse.setStatusCode(HttpStatus.BAD_REQUEST.toString()); errorResponse.setResultCode(\"FAIL\"); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse); }} 결과만약 valid 설정을 아래와 같이 했다면 예외 메시지는 어떻게 나올까? User.java 123456789@Datapublic class User { @NotEmpty @Size(min=1, max=10) private String name; @Min(1) @NotNull private Integer age;} ApiController.java 1234567891011@RestController@RequestMapping(\"/api/user\")@Validated public class ApiController { @PostMapping(\"\") public User post(@Valid @RequestBody User user) { System.out.println(\"@ post call\"); return user; }} 위처럼 유효성체크를 설정한 뒤 POST맨을 통한 결과를 알아보자.name에 빈값을 넣었고, age에는 0을 넣었다. 사진처럼 다른 개발자가 보아도 이해하기 쉬운 에러메시지를 확인할 수 있다. 출처 https://github.com/steve-developer/fastcampus-springboot-introduction/tree/master/06.%20%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98%20%EA%B8%B0%EB%8A%A5%EC%9D%84%20%ED%99%9C%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90/SourceCode/exception","link":"/2021/08/03/210804springbootError/"},{"title":"delete mapper에서 여러 테이블의 데이터 한꺼번에 삭제 오류","text":"개인정보와 같은 경우 회원 탈퇴를 할때 여러 테이블에 있는 해당 사용자 정보를 전부 다 삭제해야한다.이를 한꺼번에 아래 코드처럼 처리할 수 있다. 다중쿼리아래는 user id를 가지고 userinfo테이블, payment테이블, authority테이블, board테이블, 총 4개의 테이블에서 해당 유저정보를 삭제하는 다중쿼리이다. 12345678910111213&lt;delete id=\"deletePersonalData\" parameterType=\"String\"&gt; DELETE FROM userinfo WHERE user_id = #{userId}; DELETE FROM payment WHERE user_id = #{userId}; DELETE FROM authority WHERE user_id = #{userId}; DELETE FROM board WHERE user_id = #{userId};&lt;/delete&gt; delete메서드이다보니 조심스럽게 run을 돌렸는데 syntax에러가 나타났다! 해당 쿼리를 전혀 읽지 못하고 있었다.구글링으로 엄청 삽질하다가 과장님께 물어보니 멀티 쿼리 허용했는 지를 물어보셨다내 대답은 아뇨…였다. 과장님 감사합니다🙏 멀티쿼리 허용하기application.properties에 기재되어있는 DB주소 정보 뒤에 멀티쿼리를 설정해줘야한다! allowMultiQueries=true 아래는 코드 예시이다. 1jdbc:log4jdbc:mariadb://DB서버IP주소/DatabaseName?allowMultiQueries=true 설정해야지만 쓸 수 있는 것이 다중쿼리이다!까먹지말고 DB주소 뒤에 설정하자!","link":"/2021/08/04/210805MyBatis-multiqueries/"},{"title":"[Spring]@Transactional 쓰는 이유","text":"세상에 이렇게 재밌는 일이 또 있을까?습관처럼 쓰던 것들이 왜 써야하는 지 알게될 때의 그 재미.정말 겪어 본 사람만 안다. 이럴때 있으시죠?Service에서 mapper로 여러 SQL쿼리를 처리할 때 그 중 하나가 오류가 난 경우 그 전에 실행되었던 SQL 쿼리들이 다 롤백되어야한다.이를 트랜잭션 처리라고 부른다.트랜잭션 처리는 SQL에서 할 수도 있고 Spring에서 할수도 있다. Spring에서 트랜잭션을 설정하는 2가지 방법 xml파일에서 AOP + tx:advice 태그 활용 어노테이션 @Transactional 트랜잭션처리를 하면 transaction begin, commit을 자동 수행해준다. 만약 예외가 생겼다면 rollback 처리를 자동 수행해준다.정말 간편! Springboot에서 @Transactional 설정어노테이션은 클래스뿐만 아니라 인터페이스, 클래스 내 메서드위에도 붙일 수 있다.세상 간편! 주로 아래 에시코드처럼 서비스 클래스 위에 붙여준다.이걸로 설정 끝! 1234567891011@Service@Transactional(rollbackFor = Exception.class)public class UserServiceImpl implements UserService { @Override public void insertUser(UserDTO user) throws Exception{ // 비즈니스 로직 } // 기타 메서드} 위 예시 코드의 rollbackFor속성외에도 @Transactional에는 다양한 속성이 있다. 하누모카님의 @Transactional 포스팅에 알기 쉽게 적혀있다. 꼭 읽어보자! 그리고 rollbackFor 속성을 꼭 붙여줘야하는 이유는 kdhyo님의 @Transactional Annotation 알고 쓰자 포스팅에 정말 자세하게 나와있으니 꼭 읽어보자. 정말 좋은 글이다. 요약요약하자면 @Transactional은 기본적으로 Unchecked Exception, Error를 rollback한다.try catch로 명시해준 에러인 경우 Checked Exception이기 때문에 트랜잭션이 일어나지 않을 수 있다.따라서 rollbackFor = Exception.class속성을 통해서 Unchecked Exception, Error뿐만 아니라 checked Exception도 트랜잭션 처리를 가능하게할 수 있다!","link":"/2021/08/04/210805Spring-Transactional/"},{"title":"[Spring]Filter","text":"스프링에서 필터에 대해 알아보자. Filter Filter란 웹 어플리케이션에서 관리되는 영역 스프링부트 프레임워크에서 요청/응답의 최초와 최종단계에 위치 필터를 통해 요청/응답 정보 변경 가능 유일하게 ServletRequest, ServletResponse 객체를 변환할 수 있음 주로 인증로직과 logging용도로 활용 보통 실무에선 logging용도로 사용되고 intercepter가 인증단계로 사용됨 전역 Filter설정방법과 특정 컨트롤러에만 Filter를 설정하는 방법을 예제 코드와 함께 보자.차이점으로는 특정 컨트롤러 필터사용시 아래 두 어노테이션을 사용한다는 점이다. @ServletComponentScan @WebFilter(&quot;/api2/user/*&quot;) Filter 공통 코드 User.java 123456@Slf4j@Datapublic class User { private String name; private int age;} 전역 Filter 코드 예제 FilterApplication.java 123456789@Slf4j@SpringBootApplicationpublic class FilterApplication { public static void main(String[] args) { SpringApplication.run(FilterApplication.class, args); }} controller1.java 1234567891011@Slf4j@RestController@RequestMapping(\"/api\")public class ApiController { @PostMapping(\"/user\") public User user(@RequestBody User user){ log.info(\"user1: {}\", user); return user; }} GlobalFilter1.java 12345678910111213141516171819202122232425@Slf4j@Componentpublic class GlobalFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //전처리 ContentCachingRequestWrapper req = new ContentCachingRequestWrapper((HttpServletRequest) request); ContentCachingResponseWrapper res = new ContentCachingResponseWrapper((HttpServletResponse) response); chain.doFilter(req, res); String url = req.getRequestURI(); //후처리 String reqContent = new String(req.getContentAsByteArray()); //default가 UTF-8 log.info(\"respone url: {}, reqBody: {}\", url, reqContent); String resContent = new String(res.getContentAsByteArray()); //default가 UTF-8 log.info(\"respone resBody: {}\", resContent); // 필수: 한 번 읽었기때문에 원래대로 copy 돌려놓아야한다. res.copyBodyToResponse(); }} 특정 컨트롤러 Filter 코드 예제 FilterApplication.java 12345678910@Slf4j@SpringBootApplication@ServletComponentScan //2번방법용public class FilterApplication { public static void main(String[] args) { SpringApplication.run(FilterApplication.class, args); }} controller2.java 12345678910111213// 이 컨트롤러에만 필터적용@Slf4j@RestController@RequestMapping(\"/api2\")public class Api2Controller { @PostMapping(\"/user\") public User user(@RequestBody User user){ log.info(\"Api2Controller 컨트롤러에만 GlobalFilter2 필터 적용\"); log.info(\"user2: {}\", user); return user; }} GlobalFilter2.java 12345678910111213141516171819202122232425@Slf4j@WebFilter(\"/api2/user/*\") //특정 컨트롤러에만 사용 가능하도록 설정public class GlobalFilter2 implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //전처리 ContentCachingRequestWrapper req = new ContentCachingRequestWrapper((HttpServletRequest) request); ContentCachingResponseWrapper res = new ContentCachingResponseWrapper((HttpServletResponse) response); chain.doFilter(req, res); String url = req.getRequestURI(); //후처리 String reqContent = new String(req.getContentAsByteArray()); //default가 UTF-8 log.info(\"respone url: {}, reqBody: {}\", url, reqContent); String resContent = new String(res.getContentAsByteArray()); //default가 UTF-8 log.info(\"respone resBody: {}\", resContent); // 필수: 한 번 읽었기때문에 원래대로 copy 돌려놓아야한다. res.copyBodyToResponse(); }}","link":"/2021/08/06/210807Spring-filter/"},{"title":"[Spring]Interceptor","text":"스프링에서 인터셉터에 대해 알아보자. Interceptor Filter와 매우 유사한 형태지만 차이점은 Spring Context에 등록됨. Controller 영역 안에 존재 AOP와 유사한 기능 제공 가능 주로 인증 단계를 처리하는데 사용 (조직에 따라 Logging용도로 사용) 인터셉터를 선/후처리함으로써, 서비스 비즈니스 로직과 분리시킴. @RequiredArgsConstructor: final로 선언된 객체들을 생성자에서 주입받을 수 있도록 해줌","link":"/2021/08/08/210809Spring-interceptor/"},{"title":"STS git clone 깃허브연동하여 스프링 maven프로젝트 가져오기","text":"프로젝트 셋팅을 자주하지 않기때문에 헷갈릴 염려가 있어 아예 순서를 적어두려고 한다.github 레포지토리의 springboot maven(메이븐)프로젝트를 가져오는 방법이다. 1 STS에서 Perpectives를 git으로 변경 STS 또는 이클립스에서 Perspectives의 돋보기 아이콘을 클릭한다. git 검색 Perpectives git 선택 2 Clone a Git repository Clone a Git repository 클릭 깃헙 레포에서 복사한 clone URI를 붙여넣기한다.깃헙에서 초록색 Code버튼을 클릭한 뒤 URI를 복사했다면 붙여넣지 않아도 자동적으로 기입된다. NEXT를 클릭한 뒤 Clone을 원하는 브랜치를 선택한다.기본값은 main 또는 master 브랜치가 체크되어 있다.Tag fetching strateguy는 기본값으로 진행하나 필요에 따라 바꾸면 된다. LocalDestination의 Directory를 선택한다.저장은 원하는 곳에 설정하면 된다. 나는 보통 D 드라이브로 경로를 설정한다. 이제 깃헙 연동이 끝났다!잘 가져왔는 지 어떻게 확인할까?아래 이미지에서 체크한 부분을 보자. STS의 Progress탭을 보면 클론이 진행중인 걸 확인할 수 있다.프로젝트 크기에 따라 시간이 꽤 걸릴 수 있다. 3-1 STS에서 Perpectives를 git으로 그대로 유지한채로 진행하는 방법 클론한 git repository에서 Working Tree 를 클릭한다 import projects를 클릭하고 위치를 맞추면 끝! 3-2 STS에서 Perpectives를 java로 변경해서 진행하는 방법 import projects 클릭 maven 검색 Existing Maven Projects선택 Browe 선택 후 위에서 저장된 경로 선택나는 D에 저장햇으므로 D에 있는 파일 경로를 선택했다. pom.xml 선택 확인자동적으로 pom.xml이 검색되고 체크되므로 확인한다. finish 버튼조금만 기다리면 불러오기가 완료된다!끝! gradle 프로젝트라면?1,2번은 동일하게 진행하면 되고 3번에서 maven이 아니라 gradle폴더를 선택한 후 Existing Gradle Project를 클릭하면 된다!참 쉽죠?!","link":"/2021/08/09/210810STSgitClone/"},{"title":"Springboot Excel파일 업로드 후 DB에 저장","text":"스프링프로젝트에서 엑셀파일을 업로드 한 뒤 각 열을 DB 컬럼과 맞춰서 저장하는 기능을 구현해보자. 엑셀데이터 예시 아이디 비밀번호 사용자이름 sea 1234 김바다 sun 5678 박태양 wind 1234 이바람 3행 3열로 이루어진 데이터를 DB에 넣어보려고한다. pom.xml먼저 dependency를 추가해야한다. 메이븐 레포지토리 사이트에서 원하는 버전과 프로젝트를 선택한다. 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt;&lt;/dependency&gt; userController.java123456@RequestMapping(value = \"/addExcel\", method = RequestMethod.POST)public ResponseEntity&lt;? extends BasicResponse&gt; addExcel(HttpServletRequest request, HttpServletResponse response, MultipartFile file) { return ResponseEntity.ok().body(service.insertExcel(file));}; userService.java확장자 유효성 검사는 1안과 2안이 있는데 2안이 훨씬 좋다.그 이유는 이름만 xls, xlsx로 바꿀 수 있기때문이다 아예 contentType이 XLSX인 것을 확인하는 것이 좋다. FilenameUtils.getExtension(file.getOriginalFilename()).toLowerCase()로 한 뒤 xlsx이나 xls이 일치하는 지 확인 file.getFile().getContentType()을 변수에 담아서 ConstContentType.XLSX과 일치하는 지 확인 아래는 userService안의 addExcel 메서드 소스 코드이다.BasicResponse클래스는 그냥 response클래스이므로 생략하고 mapper클래스도 생략한다. 로직 순서이다. 파라미터에 파일이 있는지 확인 -&gt; 없으면 return 에러 확장자가 엑셀인지 확인 -&gt; 아니면 return 에러 엑셀테이터를 가져와서 각 행마다 VO객체에 저장 -&gt; list에 저장 list를 DB에 insert 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@AutowiredExcelUtil excelUtil; public BasicResponse addExcel(MultipartFile file) { BasicResponse res = new BasicResponse(); // 파일 존재하지 않는 경우 if (file.isEmpty()) { res.setEmpty(); res.setMessage(\"Excel 파일을 선택해주세요.\"); return res; } // 확장자 유효성 검사 -&gt; 엑셀파일만 가능 //1안: tring ext = fileUtil.getExtension(file.getOriginalFilename()); //2안 String contentType = file.getFile().getContentType(); //1안: if (!ext.equals(\"xlsx\") &amp;&amp; !ext.equals(\"xls\")) { //2안 if(!contentType.equals(ConstContentType.XLSX)) { res.setEmpty(); res.setMessage(\"Excel 파일을 선택해주세요.\"); return res; } List&lt;UserVO&gt; listUser = new ArrayList&lt;UserVO&gt;(); // 엑셀의 셀데이터를 가져와서 VO에 담기 List&lt;Map&lt;String, Object&gt;&gt; listMap = excelUtil.getListData(file, 1, 3); for (Map&lt;String, Object&gt; map : listMap) { UserVO userInfo = new UserVO(); // 각 셀의 데이터를 VO에 set한다. userInfo.setUserId(map.get(\"1\").toString()); userInfo.setPassword(map.get(\"2\").toString()); userInfo.setUserName(map.get(\"3\").toString()); listUser.add(userInfo); } // 리스트에 담은 VO를 DB에 저장 for (UserVO oneUser : listUser){ userMapper.insertUser(oneUser); }} getListData(file, 1, 3)의 의미엑셀파일의 1번째 행부터 3번째 열까지의 데이터를 listMap에 담는다.0번째 행부터 하지 않는 이유는 보통 0번째행은 머리글행으로 제목이나 구분명칭을 작성하기 때문이다.3인 이유는 엑셀데이터에 3열이 있기때문이다.가지고 있는 엑셀데이터에 따라 변경하면 된다. ExcelUtil.java제일 중요한 엑셀유틸객체이다. getListData 메서드의 파라미터 정의 startRowNum : 시트 시작 행 번호이다. 시트 행은 0부터 시작한다. columnLength : 시트 열의 총 개수 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Componentpublic class ExcelUtil { // 각 셀의 데이터타입에 맞게 값 가져오기 public String getCellValue(XSSFCell cell) { String value = \"\"; if(cell == null){ return value; } switch (cell.getCellType()) { case STRING: value = cell.getStringCellValue(); break; case NUMERIC: value = (int) cell.getNumericCellValue() + \"\"; break; default: break; } return value; } // 엑셀파일의 데이터 목록 가져오기 (파라미터들은 위에서 설명함) public List&lt;Map&lt;String, Object&gt;&gt; getListData(MultipartFile file, int startRowNum, int columnLength) { List&lt;Map&lt;String, Object&gt;&gt; excelList = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); try { OPCPackage opcPackage = OPCPackage.open(file.getInputStream()); @SuppressWarnings(\"resource\") XSSFWorkbook workbook = new XSSFWorkbook(opcPackage); // 첫번째 시트 XSSFSheet sheet = workbook.getSheetAt(0); int rowIndex = 0; int columnIndex = 0; // 첫번째 행(0)은 컬럼 명이기 때문에 두번째 행(1) 부터 검색 for (rowIndex = startRowNum; rowIndex &lt; sheet.getLastRowNum() + 1; rowIndex++) { XSSFRow row = sheet.getRow(rowIndex); // 빈 행은 Skip if (row.getCell(0) != null &amp;&amp; !row.getCell(0).toString().isBlank()) { Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); int cells = columnLength; for (columnIndex = 0; columnIndex &lt;= cells; columnIndex++) { XSSFCell cell = row.getCell(columnIndex); map.put(String.valueOf(columnIndex), getCellValue(cell)); logger.info(rowIndex + \" 행 : \" + columnIndex+ \" 열 = \" + getCellValue(cell)); } excelList.add(map); } } } catch (InvalidFormatException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return excelList; }} 파일 업로드 사이즈 초과 에러파일 사이즈를 초과해서 업로드할 수 있으므로 예외처리를 해준다.@RestControllerAdvice를 사용한 BadRequestHandler 클래스에서 예외처리를 해주었다. 1234567891011@RestControllerAdvicepublic class BadRequestHandler { @ExceptionHandler({MaxUploadSizeExceededException.class}) public ResponseEntity&lt;? extends BasicResponse&gt; uploadException(MaxUploadSizeExceededException exc, HttpServletRequest request, HttpServletResponse response) { return ResponseEntity.status(HttpStatus.PAYLOAD_TOO_LARGE).body(new ErrorResponse(String.valueOf(HttpStatus.PAYLOAD_TOO_LARGE.value()), \"파일 사이즈를 초과하였습니다. (10MB 이하의 파일을 선택해주세요.)\")); }}","link":"/2021/08/09/210810Spring-excel/"},{"title":"[Spring]RestTemplate 활용","text":"클라이언트와 서버끼리 RestTemplate객체를 사용하여 JSON을 주고받을 수 있다. 클라이언트클라이언트에서 GET방식, POST방식으로 서버에 응답을 요청해보자. ClientApiController.java1234567891011121314151617181920212223242526272829303132@Slf4j@RestController@RequestMapping(\"/api/client\")public class ClientApiController { @Autowired private RestTemplateService service; @GetMapping(\"\") public UserResponse getHello() { log.info(\"get메서드 호출\"); return service.hello(); } @PostMapping(\"\") public void post() { log.info(\"post메서드 호출\"); service.post(); } @GetMapping(\"/exchange\") public UserResponse exchange() { log.info(\"exchange메서드 호출\"); return service.exchange(); } @GetMapping(\"/genericExchange\") public Req&lt;UserResponse&gt; genericExchange() { log.info(\"genericExchange메서드 호출\"); return service.genericExchange(); }} RestTemplateService.java UriComponentsBuilder: 원하는 uri를 만들 수 있는 객체 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156@Servicepublic class RestTemplateService { public UserResponse hello() { //클라이언트이므로 주소를 만들어서 리턴해야한다 -&gt; 이때 URI컴포넌트를 주로 사용함. URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:9090\") .path(\"/api/server\") //쿼리파람을 사용할 수 있다. .queryParam(\"name\", \"신경숙\") .queryParam(\"age\", 22) .encode() .build() .toUri(); System.out.println(\"@ uri.toString(): \" + uri.toString()); /* ===================================================================== * getForObject()와 getForEntity()의 차이 * 여기서 get은 가져온다의 get이 아니라 HTTP GET 메서드의 get이다. * getForObject(): Object형태 * getForEntity(): Entity형태로 getStatusCode(), getBody()를 확인할 수 있어 유용 * * ===================================================================== * 두 방식 다 동일한 결과를 나타냄 * 1. String으로 테스트 * 호출: http://localhost:8083/api/client * 결과: 안녕 나는 클라이언트야, 내가 사라져볼께 얍! 안녕 나는 서버야 * * 2. UserResponse로 json 받기 * 호출: http://localhost:8083/api/client * 결과: { * \"name\": \"신경숙\", * \"age\": 22 * } */ // 상세정보를 알기 위해서 ResponseEntity를 받는 것을 추천 RestTemplate rt = new RestTemplate(); // String result1 = rt.getForObject(uri, String.class); UserResponse result1 = rt.getForObject(uri, UserResponse.class); System.out.println(\"@ result1: \"+result1.toString()); // ResponseEntity&lt;String&gt; result2 = rt.getForEntity(uri, String.class); ResponseEntity&lt;UserResponse&gt; result2 = rt.getForEntity(uri, UserResponse.class); System.out.println(\"@ HTTP CODE확인: \"+result2.getStatusCode()); System.out.println(\"@ BODY 확인: \"+result2.getBody()); return result2.getBody(); } public void post() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:9090\") .path(\"/api/server/user/{userId}/name/{userName}\") .encode() .build() //위 PathVariable과 expand()안 콤마로 순서대로 매칭 .expand(\"wony\", \"choi\") .toUri(); System.out.println(\"@ uri.toString(): \" + uri.toString()); UserRequest req = new UserRequest(); req.setAge(44); req.setName(\"최정원\"); RestTemplate rt = new RestTemplate(); ResponseEntity&lt;UserResponse&gt; res = rt.postForEntity(uri, req, UserResponse.class); System.out.println(\"@ HTTP CODE확인: \"+res.getStatusCode()); System.out.println(\"@ HTTP Header확인: \"+res.getHeaders()); System.out.println(\"@ BODY 확인: \"+res.getBody()); } public UserResponse exchange() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:9090\") .path(\"/api/server/user/{userId}/name/{userName}\") .encode() .build() //위 PathVariable과 expand()안 콤마로 순서대로 매칭 .expand(\"wony\", \"choi\") .toUri(); System.out.println(\"@ uri.toString(): \" + uri.toString()); UserRequest userReq = new UserRequest(); userReq.setAge(44); userReq.setName(\"최정원\"); // requestEntity로 header에 원하는 데이터를 넣어서 보낼 수 있다. RequestEntity&lt;UserRequest&gt; reqEntity = RequestEntity .post(uri) .contentType(MediaType.APPLICATION_JSON) .header(\"x-authorization\", \"abc\") .header(\"custom-header\", \"ABC\") .body(userReq); RestTemplate resTemplate = new RestTemplate(); ResponseEntity&lt;UserResponse&gt; res = resTemplate.exchange(reqEntity, UserResponse.class); return res.getBody(); } // 내가 원하는 Req&lt;UserResponse&gt; 타입의 JSON형태 주고 받기 /*{ \"header\": { \"resCode\": null }, \"responseBody\": { \"name\": \"가나다\", \"age\": 55 } }*/ public Req&lt;UserResponse&gt; genericExchange() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:9090\") .path(\"/api/server/user/{userId}/name/{userName}\") .encode() .build() //위 PathVariable과 expand()안 콤마로 순서대로 매칭 .expand(\"wony\", \"choi\") .toUri(); System.out.println(\"@ uri.toString(): \" + uri.toString()); UserRequest userReq = new UserRequest(); userReq.setAge(55); userReq.setName(\"가나다\"); Req&lt;UserRequest&gt; req = new Req&lt;&gt;(); req.setHeader(new Req.Header()); req.setResponseBody(userReq); // requestEntity로 header에 원하는 데이터를 넣어서 보낼 수 있다. RequestEntity&lt;Req&lt;UserRequest&gt;&gt; reqEntity = RequestEntity .post(uri) .contentType(MediaType.APPLICATION_JSON) .header(\"x-authorization\", \"abc\") .header(\"custom-header\", \"ABC\") .body(req); RestTemplate resTemplate = new RestTemplate(); // 제네릭에는 class를 사용할 수 없다 즉, Req&lt;UserResponse&gt;.class -&gt; 오류발생 -&gt; 따라서 RestTemplate의 ParameterizedTypeReference를 사용해야한다. // ResponseEntity&lt;Req&lt;UserResponse&gt;&gt; res = resTemplate.exchange(reqEntity, Req&lt;UserResponse&gt;.class); ResponseEntity&lt;Req&lt;UserResponse&gt;&gt; res = resTemplate.exchange(reqEntity, new ParameterizedTypeReference&lt;Req&lt;UserResponse&gt;&gt;(){}); return res.getBody(); } } UserResponse.java응답 DTO이다. 12345@Datapublic class UserResponse { private String name; private int age;} UserRequest.java요청 DTO이다. 12345@Datapublic class UserRequest { private String name; private int age;} Req.javaDTO이다. 제네릭타입으로 원하는 JSON형태를 만들 수 있다. 12345678910@Datapublic class Req&lt;T&gt; { private Header header; private T responseBody; @Data public static class Header{ private String resCode; } 서버클라이언트의 요청에 적절한 응답을 할 수 있다. ServerApiComtroller.java 순수한 HttpEntity을 파라미터 변수로 받으면 디버깅 등에 유용하다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Slf4j@RestController@RequestMapping(\"/api/server\")public class ServerApiComtroller { @GetMapping(\"\") public User hello(@RequestParam String name, @RequestParam int age) { User u = new User(); u.setName(name); u.setAge(age); return u; } // @PostMapping(\"/user/{userId}/name/{userName}\") public User post(@RequestBody User user, @PathVariable String userId, @PathVariable String userName) { log.info(\"client req: {}\", user); log.info(\"userId: {}, userName: {}\", userId, userName); return user; } // @PostMapping(\"/user/{userId}/name/{userName}\") public User exchange(@RequestBody User user, @PathVariable String userId, @PathVariable String userName, @RequestHeader(\"x-authorization\") String xAuthorization, @RequestHeader(\"custom-header\") String customHeader ) { log.info(\"client req: {}\", user); log.info(\"userId: {}, userName: {}\", userId, userName); log.info(\"xAuthorization: {}, customHeader: {}\", xAuthorization, customHeader); return user; } // 순수한 HttpEntity&lt;String&gt;을 파라미터 변수로 받으면 디버깅 등에 유용하다 @PostMapping(\"/user/{userId}/name/{userName}\") public Req&lt;User&gt; genericExchange(// HttpEntity&lt;String&gt; entity, @RequestBody Req&lt;User&gt; user, @PathVariable String userId, @PathVariable String userName, @RequestHeader(\"x-authorization\") String xAuthorization, @RequestHeader(\"custom-header\") String customHeader ) {// log.info(\"entity 순수한 : {}\", entity); log.info(\"HttpEntity&lt;String&gt; 디버깅 등에 유용: {}\", user); log.info(\"userId: {}, userName: {}\", userId, userName); log.info(\"xAuthorization: {}, customHeader: {}\", xAuthorization, customHeader); // 원하는 json형태로 응답하기 /*{ \"header\": { \"resCode\": null }, \"responseBody\": { \"name\": \"가나다\", \"age\": 55 } }*/ Req&lt;User&gt; response = new Req&lt;&gt;(); response.setHeader(new Req.Header()); response.setResponseBody(user.getResponseBody()); return response; }} User.java @Data: @ToString, @EqualsAndHashCode, @Getter(모든 필드), @Setter(정적 필드가 아닌 모든 필드), @RequiredArgsConstructor @NoArgsConstructor: 파라미터가 없는 기본 생성자 생성 @AllArgsConstructor: 모든 필드 값을 파라미터로 받는 생성자 생성 1234567@Data@NoArgsConstructor@AllArgsConstructorpublic class User { private String name; private int age;} Req.javaDTO이다. 제네릭타입으로 원하는 JSON형태를 만들 수 있다. 1234567891011@Datapublic class Req&lt;T&gt; { private Header header; private T responseBody; @Data public static class Header{ private String resCode; }}","link":"/2021/08/11/210812Spring-resttemplate/"},{"title":"[Spring]Junit","text":"Junit 사용법을 예시와 함께 확인해보자 Junit java 기반의 단위 테스트를 위한 프레임워크 어노테이션기반으로 테스트 지원 Assert를 통해서 예상과 실제를 비교하여 검증 MockMock이란 실제 사용되어야하는 객체의 대체객체로 실제 객체를 만들어서 하기엔 시간이 부족하고 비용이 높은 경우, 구현이 까다로울 경우에 가짜 객체를 만들어서 사용하는데 그중 하나가 Mock객체이다. 행위를 검증하기 위해 사용되는 객체 직접 만들거나 스프링프레임워크를 통해서 간단하게 만들수 있음 @Mock Mockito 라이브러리에 위치 주로 @injectMocks 조합으로 사용 give, when, then으로 Mock객체의 행위 정의함 @MockBean Springboot 테스트 패키지 내에 위치 테스트를 하려는 객체 내에서 기존에 등록된 Bean이 아닌, MockBean을 주입함. 주로 @SpringbootTest, @WebMVCTest와 함께 사용 give, when, then으로 Mock객체의 행위 정의함 Jacoco자바코드의 코드 커버리지를 체크하는 라이브러리로 결과를 html로 확인 가능하다. 플러그인 id에 jacoco를 추가하기만하면 끝! build.gradle 12345plugins { (중략) id 'jacoco'}","link":"/2021/08/12/210813Spring-junit/"},{"title":"[Springboot]Springfox Boot Starter","text":"Swagger는 다양한 라이브러리가 있다. 그 중 Swagger2와 Swagger-ui 조합이 현재 가장 많이 사용된다.오늘 포스팅에서는 스프링부트환경에서 Swagger2 라이브러리보다 쉽게 사용할 수 있는 Springfox Boot Starter를 소개하려고한다. Springfox Boot Starter 라이브러리Maven Repository Springfox Boot Starter에서 메이븐 또는 그레들 중 원하는 소스를 복사한다. Gradle 12// https://mvnrepository.com/artifact/io.springfox/springfox-boot-starterimplementation group: 'io.springfox', name: 'springfox-boot-starter', version: '3.0.0' 실행하기서버를 실행한 뒤 http://localhost:8080/swagger-ui/에서 바로 확인할 수 있다. Annotation 종류 자주 사용하는 속성 설명 @Api tags 해당 클래스를 Swagger에 표시함, API 클래스명을 한글로 제공 가능 @ApiParam value 파라미터 설명(Description) @ApiImplicitParams @ApiImplicitParam와의 조합으로 파라미터 설명(Description) @ApiImplicitParam name, value, dataTape @ApiImplicitParams의 조합으로 파라미터 설명(Description) @ApiResponses code, message, response @ApiResponse 조합으로 API 응답 지정 @ApiModelProperty value, example, required 모델의 변수 설명 @ApiResponses로 응답지정시 주의점이 있다.만약 code = 400 응답을 2개만들고 싶다면 어떻게 해야할까? 12345@ApiResponses(value = { @ApiResponse(code = 201, message = \"리턴 성공\", response = UserRes.class), @ApiResponse(code = 400, message = \"사용자 이름이 10자리 이상인 경우\"), @ApiResponse(code = 400, message = \"사용자 나이가 15살 이하인 경우\")}) 위와 같이 동일 코드에 @ApiResponse를 2개이상 작성하면 message는 최상단 1개밖에 보이지 않는다.즉 사용자 이름이 10자리 이상인 경우만 표시된다. 따라서 사용자 나이가 15살 이하인 경우도 표시하고 싶은 경우 아래처럼 message에 기입해야한다. 1234@ApiResponses(value = { @ApiResponse(code = 201, message = \"리턴 성공\", response = UserRes.class), @ApiResponse(code = 400, message = \"1.사용자 이름이 10자리 이상인 경우 \\t\\n 2.사용자 나이가 15살 이하인 경우\")}) 예시이제 전체 코드와 이미지 예시를 보자. Controller.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Api(tags = \"사용자 컨트롤러\")@RestController@RequestMapping(\"/api\")public class ApiController { @GetMapping(\"/hi\") public String hi() { return \"안녕\"; } @GetMapping(\"/plus/{x}\") public int plus(@ApiParam(value = \"x 값\") @PathVariable int x, @ApiParam(value = \"y 값\") @RequestParam int y) { return x+y; } @ApiImplicitParams({ // 필수속성: name, value, dataType @ApiImplicitParam(name = \"x\", value = \"x2 값\", dataType = \"int\"), @ApiImplicitParam(name = \"y\", value = \"y2 값\", dataType = \"int\") }) @GetMapping(\"/plus2/{x}\") public int plus2(@PathVariable int x, @RequestParam int y) { return x+y; } @ApiOperation(value = \"사용자 이름과 나이를 리턴하는 메서드\") @ApiResponses(value = { @ApiResponse(code = 201, message = \"리턴 성공\", response = UserRes.class), /* 동일코드 @ApiResponse를 작성하는 경우 첫번째 작성한 메시지만 노출된다.// @ApiResponse(code = 400, message = \"사용자 이름이 10자리 이상인 경우\"),// @ApiResponse(code = 400, message = \"사용자 나이가 15살 이하인 경우\") * 따라서 하나의 메시지안에서 구분을 줘야한다. * */ @ApiResponse(code = 400, message = \"1.사용자 이름이 10자리 이상인 경우 \\t\\n 2.사용자 나이가 15살 이하인 경우\") }) @GetMapping(\"/user\") public UserRes userGet(UserReq req) { return new UserRes(req.getName(), req.getAge()); } @ApiOperation(value = \"사용자 이름과 나이를 리턴하는 메서드\") @PostMapping(\"/user\") public UserRes userPost(@RequestBody UserReq req) { return new UserRes(req.getName(), req.getAge()); }} dto.java 12345678910@Data@NoArgsConstructor@AllArgsConstructorpublic class UserRes { @ApiModelProperty(value = \"사용자 이름\", example = \"가나다\", required = true) private String name; @ApiModelProperty(value = \"사용자 나이\", example = \"100\", required = true) private int age;} 1 컨트롤러 전체 및 사용자 컨트롤러의 메서드 내가 만든 컨트롤러는 사용자 컨트롤러(Api Controller)인데 basic-error-controller는 도대체 뭘까?basic-error-controller는 Springfox Boot Starter라이브러리에서 기본적으로 제공되는 컨트롤러이다.사용자 컨트롤러(Api Controller)를 클릭하면 위 코드에서 작성한 GET메서드 4개와 POST메서드 1개를 확인할 수 있다.그리고 @ApiOperation를 이용한 경우 메서드 URI옆에 설명이 기재됨을 확인할 수 있다. 2 /api/plus/{x}메서드, /api/plus2/{x} 메서드 GET메서드 /api/plus/{x}와 /api/plus2/{x}는 동일하게 swagger에 표시된다.둘의 차이는 @ApiParam로 스웨거에 표시했는 지 @ApiImplicitParams로 스웨거에 표시했는 지이다. 3 /api/user 메서드 @ApiModelProperty로 기재한 설명과 example속성에 있는 내용도 잘 표기되어있다.@ApiResponses로 표기한 각 코드마다의 message를 확인할 수 있다.","link":"/2021/08/15/210816Spring-springfoxswagger/"},{"title":"[Lombok]@build, @Data 차이","text":"자바프로젝트를 사용하면서 없어선 안될 라이브러리가 바로 롬복이다.스프링부트프로젝트로 생성시 롬복 라이브러리를 바로 추가할 수 있다.또는 사이트에서 jar를 다운로드받아 외부라이브러리로 import하여 사용할 수 있다. Lombok 사이트 이제 어노테이션별 차이를 살펴보자. 롬복 어노테이션 구분 설명 @Data @Getter + @Setter + @RequiredArgsConstructor + @ToString + @EqualsAndHashCode 를 한꺼번에 제공 @Builder @AllArgsConstructor와 비슷하게 객체를 생성하고 필드값을 주입해주는데 빌더의 형식을 제공함 @NoArgsConstructor 파라미터가 없는 생성자 제공. JPA 사용시 필수 @AllArgsConstructor 필드의 모든 변수가 있는 생성자 제공 예시 User.java 12345678910@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class User { private String name; private String email; private LocalDateTime createdAt = LocalDateTime.now(); private LocalDateTime updatedAt;} 위 클래스를 jUnit으로 테스트해보자. UserTest.java 123456789101112131415161718192021222324252627282930class UserTest { @Test void test() { // setter 사용 User u1 = new User(); u1.setName(\"마리아\"); u1.setEmail(\"maria@example.com\"); u1.setCreatedAt(LocalDateTime.now()); u1.setUpdatedAt(LocalDateTime.now()); System.out.println(\"@ test u1: \"+u1); // @AllArgsConstructor 생성자로 생성 User u2 = new User(\"가나다\", \"ganada@example.com\", LocalDateTime.now(), LocalDateTime.now()); System.out.println(\"@ test u2: \"+u2); // @NoArgsConstructor 생성자로 생성 User u3 = new User(); System.out.println(\"@ test u3: \"+u3); // @Builder 로 생성 User u4 = User.builder() .name(\"마바사\") .email(\"mabasa\") .updatedAt(LocalDateTime.now()) .build(); System.out.println(\"@ test u4: \"+u4); }} User객체 4개가 생성되었고 그 결과는 아래와 같다. 1234@ test u1: User(name=마리아, email=maria@example.com, createdAt=2021-08-18T22:01:39.588614800, updatedAt=2021-08-18T22:01:39.588614800)@ test u2: User(name=가나다, email=ganada@example.com, createdAt=2021-08-18T22:01:39.588614800, updatedAt=2021-08-18T22:01:39.588614800)@ test u3: User(name=null, email=null, createdAt=2021-08-18T22:01:39.588614800, updatedAt=null)@ test u4: User(name=마바사, email=mabasa, createdAt=null, updatedAt=2021-08-18T22:01:39.589613600) 결론상황에 맞는 롬복을 사용하면 된다!","link":"/2021/08/17/210818Lombok-build/"},{"title":"application.properties과 application.yml 차이","text":"스프링부트 프로젝트를 설정하다보면 application.properties 또는 application.yml 혹은 둘 다 만날때가 있다.이 둘은 외부 속성을 설정하는 파일이다. 그럼 둘의 차이점은 무엇일까? application.properties키-밸류형식을 사용하여 외부 구성의 속성을 설정할 수 있다. 123spring.datasource.url=jdbc:h2:DB이름spring.datasource.username=유저이름spring.datasource.password=비밀번호 application.ymlYAML기반으로 외부 구성의 속성을 설정할 수 있다.반복되는 접두사가 없어 가독성이 좋다. 12345spring: datasource: url: jdbc:h2:DB이름 username: 유저이름 password: 비밀번호 결론application.yml이 계층적으로 잘 표현할 수 있어 편리하다.","link":"/2021/08/17/210818Spring-applicationyml/"},{"title":"[JPA] 기초 Query Method(쿼리메서드)와 Entity(엔티티)","text":"JPA(Java Persistnece API)란JPA를 왜 사용할까? SQL 중심적인 개발에서 객체중심으로 개발이 가능하고 CRUD와 같은 간단한 메서드 생산성이 올라간다.JPA VS JDBC 포스팅에 DB CONNECT 프로그램에 대해 자세히 정리해놓았다. Query Method 예시Query Method는 예시를 통해 공부하는 것이 좋다.별 어려움없이 Method이름 그대로 결과값이 출력된다. User.javaEntity의 경우 @Data보다 @Getter와 @Setter를 주로 사용한다. 하지만 @Getter만 쓰는 것이 좋다. @Setter를 사용하면 어디서든 값을 변경시킬 수 있기 때문에, Entity의 불변성을 지키기 위해 필요한 필드 변경은 함수를 따로 생성하여 관리해야한다. 이는 DTO, Entity의 빌더패턴 적용기에서 참고했다. 1234567891011121314151617@NoArgsConstructor@AllArgsConstructor@RequiredArgsConstructor@Getter @Setter@Entity@Builderpublic class User { @Id @GeneratedValue private Long id; @NonNull private String name; @NonNull private String email; private LocalDateTime createdAt; private LocalDateTime updattedAt; } UserRepository.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public interface UserRepository extends JpaRepository&lt;User, Long&gt;{ // 1 jpa는 optional, set 등 굉장히 많은 return 타입을 제공하고 있다. User findByName(String name); //Optional&lt;User&gt; findByName(String name); //Set&lt;User&gt; findByName(String name); // 2 nameing규칙 extends로 User를 받았다면 필드 전체를 사용가능 User findByEmail(String email); User getByEmail(String email); User readByEmail(String email); User queryByEmail(String email); User searchByEmail(String email); User streamByEmail(String email); User findUserByEmail(String email); User findSomethingByEmail(String email); // 3 List&lt;User&gt; findFirst2ByName(String name); List&lt;User&gt; findTop2ByName(String name); List&lt;User&gt; findLast1ByName(String name); // 4 조건절 and, or List&lt;User&gt; findByEmailAndName(String email, String name); List&lt;User&gt; findByEmailOrName(String email, String name); // 5 시간 비교 List&lt;User&gt; findByCreatedAtAfter(LocalDateTime yesterday); List&lt;User&gt; findByIdAfter(Long id); List&lt;User&gt; findByCreatedAtGreaterThan(LocalDateTime yesterday); List&lt;User&gt; findByCreatedAtGreaterThanEqual(LocalDateTime yesterday); List&lt;User&gt; findByCreatedAtBetween(LocalDateTime yesterday, LocalDateTime tomorrow); List&lt;User&gt; findByIdBetween(Long id1, Long id2); List&lt;User&gt; findByIdGreaterThanEqualAndIdLessThanEqual(Long id1, Long id2); // 6 List&lt;User&gt; findByIdIsNotNull(); // 잘 사용하지 않음 주의) 문자열의 empty가 아닌 collection의 empty를 체크한다 // List&lt;User&gt; findByAddressIsNotEmpty(); // 7 in, not in 실무에서 자주 사용함 List&lt;User&gt; findByNameIn(List&lt;String&gt; names); // 8 LIKE List&lt;User&gt; findByNameStartingWith(String name); List&lt;User&gt; findByNameEndingWith(String name); List&lt;User&gt; findByNameContains(String name); List&lt;User&gt; findByNameLike(String name); List&lt;User&gt; findTop1ByName(String name); List&lt;User&gt; findTopByNameOrderByIdDesc(String name); List&lt;User&gt; findFirstByNameOrderByIdDescEmailAsc(String name); List&lt;User&gt; findFirstByName(String name, Sort sort);} UserRepositoryTest.javasrc/test/java 경로에 UserRepositoryTest.java를 생성한다.jUnit을 통해서 Test를 해보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@SpringBootTestpublic class UserRepositoryTest { @Autowired UserRepository userRepository; @Test void crud() { // 1. save userRepository.save(new User(null, \"가나다\", \"ganada@fast.com\", LocalDateTime.now(), LocalDateTime.now())); userRepository.save(new User()); userRepository.save(new User(null, \"마바사\", \"mabasa@fast.com\", LocalDateTime.now(), LocalDateTime.now())); userRepository.save(new User(null, \"ma\", \"ma@slow.com\", LocalDateTime.now(), LocalDateTime.now())); userRepository.save(new User(null, \"라\", \"ra@slow.com\", LocalDateTime.now(), LocalDateTime.now())); userRepository.findAll().forEach(System.out::println); // 2. matcher ExampleMatcher matcher1 = ExampleMatcher.matching().withIgnorePaths(\"name\").withMatcher(\"email\", endsWith()); Example&lt;User&gt; example1 = Example.of(new User(\"ma\", \"ma@fast.com\"), matcher1); userRepository.findAll(example1).forEach(System.out::println); } @Test void select() { userRepository.save(new User(null, \"가나다\", \"ganada@fast.com\", LocalDateTime.now(), LocalDateTime.now())); userRepository.save(new User()); userRepository.save(new User(null, \"마바사\", \"mabasa@fast.com\", LocalDateTime.now(), LocalDateTime.now())); userRepository.save(new User(null, \"ma\", \"ma@slow.com\", LocalDateTime.now(), LocalDateTime.now())); userRepository.save(new User(null, \"ma\", \"ma@slow.com\", LocalDateTime.now(), LocalDateTime.now())); userRepository.save(new User(null, \"라\", \"ra@slow.com\", LocalDateTime.now(), LocalDateTime.now())); userRepository.findAll().forEach(System.out::println); // 1 System.out.println(userRepository.findByName(\"마바사\")); // 2 System.out.println(\"@ findByEmail : \" + userRepository.findByEmail(\"ra@slow.com\")); System.out.println(\"@ getByEmail : \" + userRepository.getByEmail(\"ra@slow.com\")); System.out.println(\"@ readByEmail : \" + userRepository.readByEmail(\"ra@slow.com\")); System.out.println(\"@ queryByEmail : \" + userRepository.queryByEmail(\"ra@slow.com\")); System.out.println(\"@ searchByEmail : \" + userRepository.searchByEmail(\"ra@slow.com\")); System.out.println(\"@ streamByEmail : \" + userRepository.streamByEmail(\"ra@slow.com\")); System.out.println(\"@ findUserByEmail : \" + userRepository.findUserByEmail(\"ra@slow.com\")); System.out.println(\"@ findSomethingByEmail : \" + userRepository.findSomethingByEmail(\"ra@slow.com\")); // 3 System.out.println(\"findTop2ByName : \" + userRepository.findTop2ByName(\"ma\")); System.out.println(\"findFirst2ByName : \" + userRepository.findFirst2ByName(\"ma\")); System.out.println(\"findLast1ByName : \" + userRepository.findLast1ByName(\"ma\")); // 4 조건절 and, or System.out.println(\"findByEmailAndName : \" + userRepository.findByEmailAndName(\"ma@slow.com\", \"ma\")); System.out.println(\"findByEmailOrName : \" + userRepository.findByEmailOrName(\"ma@slow.com\", \"마바사\")); // 5 시간 비교 System.out.println(\"findByCreatedAtAfter : \" + userRepository.findByCreatedAtAfter(LocalDateTime.now().minusDays(1L))); System.out.println(\"findByIdAfter : \" + userRepository.findByIdAfter(4L)); System.out.println(\"findByCreatedAtGreaterThan : \" + userRepository.findByCreatedAtGreaterThan(LocalDateTime.now().minusDays(1L))); System.out.println(\"findByCreatedAtGreaterThanEqual : \" + userRepository.findByCreatedAtGreaterThanEqual(LocalDateTime.now().minusDays(1L))); System.out.println(\"findByCreatedAtBetween : \" + userRepository.findByCreatedAtBetween(LocalDateTime.now().minusDays(1L), LocalDateTime.now().plusDays(1L))); System.out.println(\"findByIdBetween : \" + userRepository.findByIdBetween(1L, 3L)); System.out.println(\"findByIdGreaterThanEqualAndIdLessThanEqual : \" + userRepository.findByIdGreaterThanEqualAndIdLessThanEqual(1L, 3L)); // 6 System.out.println(\"findByIdIsNotNull : \" + userRepository.findByIdIsNotNull()); System.out.println(\"findByIdIsNotEmpty : \" + userRepository.findByAddressIsNotEmpty()); // 7 in, not in 실무에서 자주 사용함 System.out.println(\"findByNameIn : \" + userRepository.findByNameIn(Lists.newArrayList(\"ma\", \"가나다\"))); // 8 LIKE System.out.println(\"findByNameStartingWith: \" + userRepository.findByNameStartingWith(\"m\")); System.out.println(\"findByNameEndingWith : \" + userRepository.findByNameEndingWith(\"다\")); System.out.println(\"findByNameContains : \" + userRepository.findByNameContains(\"나\")); System.out.println(\"findByNameLike : \" + userRepository.findByNameLike(\"%\" + \"나\" + \"%\")); }} JpaRepository 메소드 Retrurn 타입JPA는 optional, set 등 굉장히 많은 return 타입을 제공하고 있다. 1234567// 리턴타입 3가지User findByName(String name); Optional&lt;User&gt; findByName(String name);Set&lt;User&gt; findByName(String name);// 결과: 세 가지 모두 동일한 결과[User(id=4, name=ma, email=ma@slow.com, createdAt=2021-08-20T21:14:05.439217, updattedAt=2021-08-20T21:14:05.439217), User(id=5, name=ma, email=ma@fast.com, createdAt=2021-08-20T21:14:05.439217, updattedAt=2021-08-20T21:14:05.439217)] 메서드 nameing 규칙 위 이미지처럼 다양한 네이밍 규칙이 있고 실무에서 가장 자주 사용하는 규칙은 select코드인 find…By, read…By, get…By, query…By, search…By, stream…By이다.왜이렇게 여러이름일까? 1234567891011User findByEmail(String email);User getByEmail(String email);User readByEmail(String email);User queryByEmail(String email);User searchByEmail(String email);User streamByEmail(String email);User findUserByEmail(String email);User findSomethingByEmail(String email); -&gt; 이상없이 동작함!// 결과값[User(id=4, name=ma, email=ma@slow.com, createdAt=2021-08-20T21:14:05.439217, updattedAt=2021-08-20T21:14:05.439217)] 위 코드 전두 동일한 결과값이 나온다. 따라서 코드가독성이 가장 잘 어울리는 이름을 선택해서 사용하면 된다. Query Keywords 날짜와 시간을 비교하는 키워드 키워드 설명 비교 AFTER, BEFORE 날짜와 시간에만 사용하는 조건, EQUALS(=)포함하지 않음 초과 또는 미만 GREATER_THAN 모든 숫자값, 날짜값 사용가능한 AFTER보다 범용적인 조건 초과 GREATER_THAN_EQUALS GREATER_THAN에서 EQUALS(=)이 포함된 조건 이상 BETWEEN 모든 숫자값, 날짜값 사용가능. EQUALS(=)이 포함된 조건 이상과 이하 빈값에 대한 키워드 키워드 설명 쿼리 IS_NOT_NULL NULL이 아닌 것을 출력하는 조건 WHERE A IS NOT NULL IS_NOT_EMPTY 주의) 문자열의 empty가 아닌 collection의 empty를 체크함. 잘 사용하지 않는 쿼리 WHERE exists (select id from 테이블 where id = id and address = address) Entity 어노테이션 설명 @Id Entity는 PK가 필수적으로 필요하다. 이를 나타내주는 어노테이션 @GeneratedValue @Id값을 null로 insert하면 AUTO_INCREMENT함 @Table 기본값으로 Entity이름과 동일한 table name을 사용 -&gt; name속성: 원하는 테이블로 매핑가능 @Colum name속성: 원하는 컬럼으로 매핑가능, nullable속성: NULL을 허용할 지 말지 결정, updateable: update구문실행시 해당 필드를 함께 수정할지 결정 @Transient 영속성 대상에서 해당 컬럼을 제외한다. 해당 객체와 생명주기를 같이한다. DB에 반영하지않고 필드를 쓰고 싶을때 사용 @Enumerated 열거형을 사용할 때는 EnumType.STRING속성을 주로 사용 @PrePersist manager persist 의해 처음 호출될 때 실행, 현재시간을 자동으로 DB에 insert할때 주로 사용 @PreUpdate SQL UPDATE 전에 실행, 현재시간을 자동으로 DB에 update할때 주로 사용 실무에서 자주 사용하는 어노테이션 3가지 @Id @GeneratedValue(strategy=GenerationType.AUTO): PK 자동증감 @Colum(nullable=false): 값에 NULL허용하지 않음 @Enumerated(EnumType.STRING): 꼭 STRING속성을 설정해주어야 Enum에 값이 추가되었을때 순서변경이 없음 -&gt; 실무에서도 실수를 많이 하는 부분! 참고 https://docs.spring.io/spring-data/jpa/docs/2.5.4/reference/html/#populator.namespace-reference 참고로 잘 정리해 논 블로그 글을 찾았다.2. leyuri - Spring-boot JPA 어노테이션3. 탁구치는 개발자 - @Enumerated","link":"/2021/08/19/210820spring-jpa/"},{"title":"캐치개발자커리어콘: 개발자취업 어떻게 하나요?","text":"캐치라는 채용사이트에서 많은 개발자커리어콘을 진행하고 있다.그 중 관심있는 것들만 신청해서 들었다. 무료로 세미나들을 선택해서 들을 수 있어 정말 유익했다.역시 세미나들은 일단 들어보는 게 무조건 도움이 된다! 최대한 많이 들어놓자! 개발자취업 어떻게 하나요?는 2가지 세션으로 구성된다. 서비스 중심 IT회사가 원하는 개발자 BY 서오석 연사님 대기업SI직무에서 네이버개발자로 BY 김성일 연사님 두 세션 다 유익했다!주제 서비스 중심 IT회사가 원하는 개발자 로 강연을 한 서오석 연사님는 카카오모빌리티 개발 파트장이자 13년차 개발자이고 김성일 연사님은 네이버 백엔드개발자 6년차개발자이다.나도 연사님들 정도의 연차가 쌓이면 이렇게 영감을 줄 수 있는 강연을 해야겠다고 다짐했다.열심히 공부하고 또 공부해야지!아래 내용은 강연을 들으면서 필기한 내용이다. 🎤서비스 중심 IT회사가 원하는 개발자 BY 서오석 연사님자체 서비스를 개발하는 파트장은 비슷하게 고민하는 부분크게 2가지를 보는 편: 문제해결능력, 테크니컬 스킬 서비스 중심 IT회사가 원하는 개발자 역량 2가지1 문제해결능력가장 중요한 능력이자 오늘의 강의의 결론개발자니까 코드로 문제를 해결하는 능력이 필요본인은 깃헙의 커밋로그까지 상세하게 보는 편 → 커밋메세지를 통해 의사소통능력을 확인할 수 있음프로젝트에 한번 커밋한 것보단 계속 고도화하는 것이 중요 2 Techical skill두번째로 많이 보는 것은 techical skill문제해결을 위한 주된 언어가 무엇인지 확인하는 편해당 언어로 뿐만아니라 프레임워크(ex JVM, Spring, Django, 플라스크, 리액트, 타입스크립트, 뷰)를 사용해서 문제해결 할 수 있는지가 중요온라인 강의등 교육이수는 지식을 얻기위함인거지 자신의 경력이나 이력이 될 수 없음. 따라서 교육을 몇시간 이수 이런건 자소서에 적지 말고 문제해결 한 내용을 적는 것이 좋다. 그럼 테크니컬 스킬은 어떻게 쌓는게 좋을까?여러 지식을 얕게 아는 것보다 하나의 공부를 깊게 아는 것이 중요책을 볼 때는 14일전문가되기 이런거보다 특정한 기술셋하나를 제대로 보는 것을 추천개발서적을 한 권을 사서 처음부터 끝까지 깊이 공부하면 좋다. 문제해결능력과 테크니컬 스킬이 다 있으면 내가 경력이지 신입이겠어?테크니컬 스킬에서 따라오는 2가지: Ownership &amp; Tenacity(끈기)해당 능력을 향상시키기위해 노력하자 지원자의 깃헙에서 면접관이 보는 것은?리드미도 읽긴하지만 실제 소스코드를 바로 보기도 한다.따라서 필요없는 주석은 달지말되(for 클린코드) 필요한 주석은 꼭 남기자.코드의 변수명을 어떻게 작성하는 지도 중요하게 본다.코테할때 변수명을 a,b,c로 쓰지말 것 → 습관이되어야한다. 🎤대기업SI직무에서 네이버개발자로 BY 김성일 연사님대기업SI직무에서 네이버개발자로 이직한 방법코테준비시 잘 못풀겠는 문제 위주로 푼다. ex) 스택이나 큐를 못한다 → 집중적으로 코테 준비코테를 시간내푸는 방법에 익숙해진다. ex) 1문제당 30분내 채용과정 팁 포트폴리오는 미리 준비하기: 지금 내가 진행하고 있는 프로젝트에 대해서 가장 잘 아는 사람은 현재의 나 면접에서는 ‘나 혼자’ 잘 하는 게 아닌 면접관과의 교감이 중요: 모르는 문제가 있으면 면접관에게 힌트 얻기 불합격 통보를 받더라도 낙심하지말자. → 면접 오답노트를 만들자 개발자는 항상 공부해야한다. 네이버 입사시 면접을 3차례 한시간씩 총 3시간 봤는데 모든 면접관들이 손코딩문제를 3번봤다. 메서드가 정확히 기억이 안나는 경우 키워드를 적은 뒤 주석으로 상세설명을 달아준 뒤 면접관에서 설명을 잘 하면 된다. ex)Arrays.sort()가 기억이 안나는 경우 sort까지만 적고 주석에 이런 어레이를 내림차순으로 정렬하는 것이라고 설명하면 됨 마지막으로 김성일 연사님의 한마디가 큰 울림을 주었다. \" 자신감을 가질수있을만큼 충분히 공부한다면 대기업 면접시 떨리지않습니다. \"","link":"/2021/04/18/210419Catchcon-review/"},{"title":"호스팅 용어 차이","text":"호스팅을 검색하면 서버호스팅, DB호스팅, 웹호스팅, 클라우드 등등 정말 다양한 호스팅이 나온다.혼란하다 혼란해.정리해보면 생각보다 간단한 개념인데 용어가 많다보니 차근차근 정리해보았다. 호스팅이란? 종류 설명 웹호스팅 서버의 일정 공간을 여러 이용자가 나눠서 임대 서버호스팅 서버를 단독으로 임대 쇼핑몽호스팅 웹호스팅 + 쇼핑몰 솔루션 제공 메일호스팅 도메인 메일 서버의 일정 공간을 임대 DB호스팅 DB서버 임대 호스팅과 클라우드 차이점? 클라우드는 유동적인 서버가 필요할 때 사용하는 것이 가장 큰 차이점이다.","link":"/2021/08/29/210828hosting/"},{"title":"ngrok를 아시나요?","text":"오늘 팀장님이 되게 흥미로운 프로그램을 알려주셨다. 바로https://ngrok.com/이다. ngrok란외부에서 로컬 접근을 가능하게 만들 수 있는 프로그램이다.어떨때 주로 사용할까?내 로컬에서 외부로 리다이렉트받을때 사용할 수 있다. 외부에서 로컬 접근을 왜 해?웹훅을 사용하게 된다면 필수로 필요한 기능이다.웹훅이 무엇인지는 아래 한 장의 이미지로 정리할 수 있다. 방화벽넘어 외부에서 로컬에 접속 가능하게 하는 터널프로그램이다.아래 명령어로 간단히 실행할 수 있다! 1ngrok http 포트번호","link":"/2021/08/31/210831ngrok/"},{"title":"불안할때는","text":"오늘 팀장님이 좋은 말씀을 해주셨다. 불안할떄는 뭐든 준비를 해놓는게 제일 안심이 될겁니다","link":"/2021/08/31/210901insecure/"},{"title":"[디자인패턴]생성패턴의 종류와 빌더패턴을 사용해야하는 이유","text":"JPA 테스트코드를 공부하면서 패턴에 대해 궁금해졌다.DTO를 Entity(참고: Entity와 DTO차이)로 변경할 때 주로 3가지 생성 패턴이 쓰인다. 각각의 장단점을 함께 살펴보고 JPA에 적합한 패턴이 무엇인지 찾아보자아래 엔티티 예시를 통해 패턴을 적용하는 방법이다. ReviewEntity.java아래 코드 주석으로 적어놓았다. 1234567891011121314151617181920@Table(name = \"review\")@Entity@Getter @Setter // XXX 자바빈즈 패턴@NoArgsConstructor(access = AccessLevel.PROTECTED) @AllArgsConstructor // XXX 생성자 패컨@Builder(builderMethodName = \"ReviewEntityBuilder\")// XXX 빌드 패턴public class ReviewEntity extends TimeEntity { @ApiModelProperty(value = \"게시글 번호\") @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ApiModelProperty(value = \"이메일\", example = \"example@example.com\", required = true) @Column(name = \"email\", nullable = false) private String email; @ApiModelProperty(value = \"내용\", example = \"심장이 떨렸습니다.\", required = true) @Column(name = \"content\") private String content; } 자바빌드패턴: @Getter @Setter 생성자패턴: @NoArgsConstructor, @AllArgsConstructor 빌더패턴: @Builder(builderMethodName = “ReviewEntityBuilder”) 위 코드에서 빌더 패턴만 사용하기 위해 builder 메서드를 추가하면 아래와 같다. 123456789101112131415161718192021222324252627282930313233343536@Table(name = \"review\")@Entity@Builder(builderMethodName = \"ReviewEntityBuilder\") // 빌드 패턴public class ReviewEntity extends TimeEntity { @ApiModelProperty(value = \"게시글 번호\") @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ApiModelProperty(value = \"이메일\", example = \"example@example.com\", required = true) @Column(name = \"email\", nullable = false) private String email; @ApiModelProperty(value = \"내용\", example = \"심장이 떨렸습니다.\", required = true) @Column(name = \"content\") private String content; public static ReviewEntityBuilder builder(ReviewDto dto) { return ReviewEntityBuilder() .id(dto.getId()) .email(dto.getEmail()) .age(dto.getAge()) .gender(dto.getGender()) .vaccineType(dto.getVaccineType()) .shotDate(dto.getShotDate()) .shots(dto.getShots()) .fever(dto.getFever()) .ache(dto.getAche()) .sneeze(dto.getSneeze()) .bleeding(dto.getBleeding()) .chills(dto.getChills()) .diarrhea(dto.getDiarrhea()) .content(dto.getContent()); } } 결론객체를 생성하는 대부분의 경우에는 빌더 패턴을 적용하는 것이 좋다.생성자패턴보다 가독성을 높이고 휴먼에러를 줄일 수 있으며 인수 확장에 용이하기 때문이다. 가독성이 좋다고? 코드가 길어지기만 하던데? 하며 의아해할 수 있지만 예시를 보는 순간 한방에 이해할 수 있다.가독성예시를 보자. 12// 생성자패턴User user = new User(&quot;홍길동&quot;, 22, 1, 5000); 생성자를 이용하여 객체를 생성한 위의 코드에서는 숫자 22, 1, 3000이 어떤 인자를 나타내는 지 알기 어렵다.만약 빌더패턴을 사용한다면? 1234567// 빌더패턴User user = User.builder() .name(&quot;홍길동&quot;) .age(22) .yearOfExperience(1) .salary(5000) .build(); 이렇듯 어떤 인수인지 한 눈에 확인 가능하다. 빌더 패턴을 사용하면 좋은 경우 인자들이 최소 4개이상으로 많은 경우 선택적 인자들이 많은 경우 앞으로 추가될 인자들이 많은 경우","link":"/2021/09/06/210907DesignPattern-builder/"},{"title":"[JPA] Entity VS DTO","text":"JPA프로젝트를 구글링하다보면 Entity와 DTO를 필드가 거의 똑같은데 나눠서 작성한다.왜 그렇게 해야할까?Entity 클래스를 데이터베이스와 맞닿은 핵심 클래스로 Request/Response 클래스로 사용하면 안되기 때문이다. Entitybuilder메서드(참고: 빌더패턴을 사용해야하는 이유)를 통해서 DTO를 entity로 변환할 수 있다.참고로 @ApiModelProperty는 swagger와 관련된 어노테이션으로 JPA와 관련이 없으므로 무시해도 된다. ReviewEntity.java 1234567891011121314151617181920212223242526@Table(name = \"board\") // 자동으로 DB테이블을 생성해준다. JPA사랑해...@Entity@Getter @Setter // XXX 자바빈즈 패턴@NoArgsConstructor(access = AccessLevel.PROTECTED) @AllArgsConstructor // XXX 생성자 패컨@Builder(builderMethodName = \"ReviewEntityBuilder\")// XXX 빌드 패턴public class ReviewEntity extends TimeEntity { @ApiModelProperty(value = \"게시글 번호\") @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ApiModelProperty(value = \"이메일\", example = \"example@example.com\", required = true) @Column(name = \"email\", nullable = false) private String email; @ApiModelProperty(value = \"게시글내용\", example = \"심장이 떨렸습니다.\", required = true) @Column(name = \"content\") private String content; public static ReviewEntityBuilder builder(ReviewDto dto) { return ReviewEntityBuilder() .id(dto.getId()) .email(dto.getEmail()) .content(dto.getContent()); }} Dto ReviewDto.java 123456789@AllArgsConstructor@NoArgsConstructor@Datapublic class ReviewDto { private Long id; private String email; private String content; } 컨트롤러에서는 뭘 받아야할까? DTO? ENTITY?컨트롤러에선 DTO로 받아야하며 서비스단에서 ENTITY로 변환 후 DB에 전달하면 된다. Entity 클래스와 DTO 클래스를 분리하는 이유 View Layer와 DB Layer의 역할을 철저하게 분리하기 위해 실무에서 서비스가 요청을 처리하고 클라이언트로 반환할때 모델(model) 자체를 그대로 리턴하는 경우는 별로 없고 DTO로 대부분 변환한다.why? 비즈니스 로직 캡슐화를 위해: 보통 모델은 DB테이블구조와 비슷해서 외부인에게 노출되길 원치않음 쿨라이언트에게 필요한 정보를 모델이 다 가지고 있지 않아서: ex)에러메시지 참고 https://gmlwjd9405.github.io/2018/12/25/difference-dao-dto-entity.html https://velog.io/@swchoi0329/Spring-Boot%EC%97%90%EC%84%9C-JPA-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0","link":"/2021/09/06/210907Jpa-entityVSDto/"},{"title":"[GIT]&#96;git add .&#96; 와 &#96;git add *&#96; 차이","text":"간단한 내용이지만 적어두지않으면 잊어버리기 쉽다. git add . 와 git add * 차이 git add .: .gitignore에 기재된 것 고려하여 모두 추가 git add *: .gitignore에 기재된 것 상관없이 모두 추가 따라서 git add .를 사용하자.","link":"/2021/09/08/210909GIT-add-VSadd/"},{"title":"[JPA] @Autowired보다 생성자 주입을 사용해야하는 이유","text":"MVC패턴 스프링프로젝트에서 Controller에서 Service를 의존성 주입할때 대부분 @Autowired로 필드주입을 한다.하지만 JPA를 사용하는 경우 @Autowired 필드 주입보다는 생성자 주입 사용을 권장한다.그 이유가 무엇인지 알아보자. 필드 주입(Field Injection)이란?사용법이 매우 간단하여 많은 개발자들이 사용한다. 필드에 @Autowired만 붙여주면 끝!해당 필드에 자동으로 의존성이 주입된다. ApiController.java12345@RestControllerpublic class ApiController { @Autowired NoticeService noticeService;} 생성자 주입(Constructor Injection)이란?생성자로 의존성을 주입한다. 방법은 총 두가지이다. 첫번째 방법: 정석 ApiController.java12345678@RestControllerpublic class ApiController { NoticeRepository noticeRepository; public ApiController(NoticeRepository noticeRepository) { this.noticeRepository = noticeRepository; }} 두번째 방법: @RequiredArgsConstructor + final사용위의 방법을 쉽게 할 수 있는 스프링프레임워크의 어노테이션이 있다!바로 @RequiredArgsConstructor를 넣은 뒤 필드를 final로 선언해주면 된다. ApiController.java123456@RestController@RequiredArgsConstructorpublic class ApiController { private final NoticeRepository noticeRepository;} 스프링팀에서 쉬운 필드 주입보다 생성자 주입은 권장하는 이유는? 순환참조 방지해서 애플리케이션이 뻗어버리는 걸 방지 final선언이 가능해서 불변성 확보","link":"/2021/09/09/210910Jpa-autowiredVSconstructorInjection/"},{"title":"[DB설계]공통코드는 어떻게 만들까?(예시)","text":"회사에서 스터디를 진행하고있다. 스터디속에 부장님의 특급 강의도 함께 있어서 정말 많이 배우고있다.스터디 넘 재밌다!!!스터디동안에 각자 만들 사이트를 하나씩 정했다. 나는 백신후기웹사이트!!DB설계를 보여드리고 피드백은 받았다. 내가 작성한 리뷰테이블 내가 처음 작성한 리뷰테이블이다.백신종류와 6가지정도 되는 증상이 함께 들어가 있다. 백신종류 백신종류 값 AZ 아스트라제네카 DO 모더나 PH 화이자 JA 얀센 증상(강도보단 유무를 받기로 함) 발열유무 통증(근육통,두통,몸살)유무 기침유무 부정출혈유무 오한유무 설사유무 이렇게 내가 짠 프로그램을 설명드리니 부장님은 아래와 같은 피드백을 주셨다. 💬 부장님: 공통코드로 만들어보세요 공통코드?공통코드란 데이터 속성에 사용되는 공통적인 값을 코드로 표현하는 것이다.공통코드를 사용하면 좋은 장점은 무엇일까? 공통코드 장점 데이터 유연성: 현재 4개의 백신종류에서 추가 승인 받은 백신이 생겼다면? 공통코드에서는 코드 하나만 추가하면 끝이기때문에 유연성이 높다. 데이터 명칭의 일관성: 아스트라제네카를 누군가는 아스트라 제네카라고 띄어 쓸 수 도 있다. 코드를 통해 명칭의 일관성을 유지하여 데이터 정합성을 높일 수 있다. 내가 작성한 공통코드 테이블 열심히 구글링해서 아래와 같이 공통코드를 구성해보았다. 아래와 같은 궁금증이 생겼다. 의문점 백신타입을 공통코드로 써야하는 이유가 뭘까? 어차피 한 컬럼에 한 개의 값만 들어가는데..굳이.. 공통코드를 사용한다면 증상이 1개 이상 있는 사람은 어떻게 db에 넣지? -&gt; 리뷰테이블에서 증상부분들을 하나로 합치고 Varchar값으로 콤마로 구분해서 넣을까? -&gt; 그럼 어떻게 보여주지? 보여줄땐 split해서 보여주면 될까? 고민하다가 팀장님께 물어봤는데 바로 해결책을 알려주셨다.팀장님은 역시 천재…빛과 소금😀 😎 의문점에 대한 팀장님의 명쾌한 조언 💬 김팀장님:테이블은 성격이 다른 컬럼은 다른 테이블로 나누어야합니다.현재 리뷰테이블은 성격이 다른 컬럼들이 한 곳에 모여있어서 여러 의문점이 생기신 것 같아요.컬럼의 성격에 따라 분류해보세요증상은 성격이 다르니까 다른 테이블로 뺀 뒤 reviewId와 함께 PK를 걸면 좋을거예요. 일대다의 관계.공통코드테이블을 위처럼 작성하면 명칭이 헷갈릴 수 있어요. 코드그룹, 코드, 코드명, 사용여부, 정렬순번을 기본적으로 사용하는 게 어때요? 공통코드 테이블내가 고민했던 모든 것은 테이블을 다시 설계하면 다 해결되는 문제였다!팀장님의 조언을 토대로 테이블을 다시 나누었다.","link":"/2021/09/14/210915DB-commonCodeGrup/"},{"title":"[JPA&#x2F;MariaDB]errno: 150 Foreign key constraint is incorrectly formed 해결방법","text":"MariaDB와 JPA로 복합키이면서 그 중 하나는 FK인 테이블을 만들고 싶었는데 계속해서 FK 에러가 발생했다. 위 ERD와 같이 symptom테이블을 만들고 싶었다.모든 키가 복합키이면서 review_id키는 FK 제약조건을 걸고싶었다.create해서 테이블은 잘 생성되지만 FK를 걸다가 에러를 발생했다. 에러코드 1234567Hibernate: alter table symptom add constraint FKct400cemwq2cjh9mdfusfieko foreign key (review_id) references review (id)GenerationTarget encountered exception accepting command : Error executing DDL \"alter table symptom add constraint FKct400cemwq2cjh9mdfusfieko foreign key (review_id) references review (id)\" via JDBC Statementorg.hibernate.tool.schema.spi.CommandAcceptanceException: Error executing DDL \"alter table symptom add constraint FKct400cemwq2cjh9mdfusfieko foreign key (review_id) references review (id)\" via JDBC Statement(중략)Caused by: java.sql.SQLTransientConnectionException: (conn=115300) Can't create table `boostshot`.`symptom` (errno: 150 \"Foreign key constraint is incorrectly formed\") 에러 150을 해결하는 방법 4가지아래 4가지 조건에 부합해야한다. 데이터 타입이 일치해야 함 NOT NULL or NULL 여부가 동일해야 함 참조받는 데이터가 unique key / primary key 이어야함 두 테이블의 charset 이 같아야함 참고 포스팅 : 박스님 - errno: 150 “Foreign key constraint is incorrectly formed 기존 테이블 위 4가지 조건에서 1번과 4번조건이 부합하지않는다. 데이터 타입이 BIGINT와 VARCHAR임 조합이 UTF-8 한쪽만 설정되어 있음 해결복합키를 위해 생성한 클래스에서 데이터 타입이 잘못 지정되어있었다.String타입을 Long타입으로 변경하여 일치 시켜주니 정상 작동했다! 123456789@NoArgsConstructor @AllArgsConstructor@EqualsAndHashCodepublic class SymptomId implements Serializable { // 기존 // private String reviewId; // 변경: String -&gt; Long private Long reviewId; private String symptomCode;} 정상작동한 테이블 모습 여담이지만 이 별것도 아닌 에러를 가지고 2시간이나쓰고 그것도 모자라서 과장님께 한번만 도와달라고 부탁까지했다.과장님은 단 5분만에 데이터 타입이 다른 것을 찾아주셨다…그저 빛🌞역시 물어보길 잘했다. 완벽하게 이해했기때문에 이 에러는 다시는 만나지 않을 것 같다. 참고에러부분 말고 전체 코드는 JPA: Entity에 복합키와 FK 제약조건 넣기 포스팅에서 확인할 수 있다.","link":"/2021/09/15/210916JPA-FKincorrectlyformed/"},{"title":"[JPA&#x2F;MariaDB]Entity에 복합키와 FK 제약조건 넣기","text":"JPA에서 복합키에서 식별관계를 매핑 즉, 복합키를 설정한 뒤 복합키 중 하나는 FK조건을 걸어보자. 만들고 싶은 테이블은 아래와 같이 3개이다 1 reviewEntity 생성먼저 중심이 되는 review테이블을 생성한다.날짜는 다른 곳에서 자주 사용하므로 TimeEntity를 따로 생성했다. ReviewEntity.java 1234567891011121314151617181920212223242526272829303132@Table(name = \"review\")@Entity@Getter @Setter // XXX 자바빈즈 패턴@NoArgsConstructor(access = AccessLevel.PROTECTED) @AllArgsConstructor // XXX 생성자 패컨public class ReviewEntity extends TimeEntity { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 게시글 번호 @Column(name = \"email\", nullable = false) private String email; @Column(name = \"age\", nullable = false) private int age; @Column(name = \"gender\", nullable = false) private Boolean gender; @Column(name = \"shots\", nullable = false) private int shots; @Column(name = \"shot_date\", nullable = false) @DateTimeFormat(pattern = \"yyyy-MM-dd\") private LocalDate shotDate; @Column(name = \"vaccine_type_code\", nullable = false) private String vaccineTypeCode; @Column(name = \"content\") // 접종후기 private String content; } } TimeEntity.java@MappedSuperclass는 테이블로 매핑하지 않고 자식 entity에게 매핑정보를 상속하는 에노테이션이다.@EntityListeners(AuditingEntityListener.class)은 JPA에게 해당 Entity는 auditing기능을 사용한다고 알리는 에노테이션이다. 123456789101112@Getter @Setter@MappedSuperclass@EntityListeners(AuditingEntityListener.class)public class TimeEntity { @Column(name = \"create_at\", updatable = false) @CreatedDate private LocalDateTime createAt; //게시글 작성일 @Column(name = \"update_at\") @LastModifiedBy private LocalDateTime updateAt; //게시글 수정일} 2 SymptomEntity 생성 SymptomEntity.java12345678910111213141516@Table(name = \"symptom\")@Entity@Getter @Setter@NoArgsConstructor(access = AccessLevel.PROTECTED) @AllArgsConstructor@IdClass(SymptomId.class)public class SymptomEntity { @Id // XXX 연관관계의 주인은 FK(외래키)가 명시된 Entity클래스로 설정 @ManyToOne @JoinColumn(name=\"review_id\") private ReviewEntity reviewId; //게시글 번호 @Id @Column(name = \"symptom_code\") private String symptomCode; //증상코드} 1 외래키reviewEntity와 SymptomEntity는 1대다의 관계이다.FK로 연관관계를 맺을때는 누가 주인이 될지를 고민해봐야한다.해당 고민을 도와줄 포스팅은 siyoon210님 - JPA Entity간의 연관관계(방향) 설정하기를 참조하면 된다. 나는 FK가 걸리는 테이블을 주인으로 삼았다. 그래야 연관관계의 주인이 되어 오류없이 수정 및 삭제가 가능하기 때문이다. @ManyToOne: symptom클래스와 review클래스는 다 대 1의 관계에 해당하는 어노테이션을 달아주었다. @JoinColumn(name=”review_id”): FK로 매핑을 해주는 어노테이션이다. name속성의 구성은 테이블명_컬럼명이다. 즉, 여기선 review테이블의 id를 FK로 삼겠다는 의미이다. 2 복합키 @IdClass(SymptomId.class): 복합키를 설정하는 어노테이션이다. 복합키를 매핑하기 위해 식별자 클래스(여기선 SymptomId.class)를 별도로 만들어야 한다.이는 아래에서 자세히 설명하겠다. 복합키를 설정하는 곳에 동일하게 @Id를 붙여준다. 나는 모든 필드가 복합키를 주고싶으므로 둘 다 @Id 를 달아줬다. 3 SymptomId 생성복합키를 매핑하기 위해 식별자 클래스를 별도로 만들어야 한다. 식별자 클래스의 필수 조건 5가지 필드명 일치 Serializable 인터페이스구현 equals, hashcode 구현 기본생성자 필요 식별자 클래스는 public이어야함 이제 식별자 클래스 코드를 보자. SymptomId.java123456@NoArgsConstructor @AllArgsConstructor@EqualsAndHashCodepublic class SymptomId implements Serializable { private Long reviewId; private String symptomCode;} 여담이 구조를 파악하기위해 꼬박 하루가 걸렸다. 특히 FK키 에러가 발생해서 2시간이나 써버렸다. 해당 내용은 [JPA: errno: 150 Foreign key constraint is incorrectly formed 해결방법] 포스팅에 상세히 적어두었다.그냥 바로 DDL구문으로 생성했다면 훨씬 빨랐겠지만 JPA만을 이용하여 생성하려니 여간 답답한게 아니었다. 기본으로 알아야하는 지식들도 많아서 시간이 오래걸렸다.시간이 오래 걸린만큼 기초가 확실해진 느낌이다.가장 큰 힘이 된 것은 바로 구글링도 포스팅도 아닌 바로 책 김영한지음 - 자바 ORM 표준 JPA 프로그래밍이었다.처음에는 무슨소리인지 도저히 모르겠다😵‍💫였는데 이제는 확실히 알겠다.역시 하다보면 된다.이런게 학습의 기쁨일까?! 알고나니 JPA가 더 재밌다😁더이상 복합키와 FK키 두렵지 않다!","link":"/2021/09/15/210916Jpa-entityPKFK/"},{"title":"[jQuery] 3depth가 있는 ul의 검색기능 구현","text":"제이쿼리를 이용하여 3뎁스 검색기능을 추가하고 싶었다.구글링한 예시들은 죄다 1뎁스여서 내가 원하는대로 만들 수 없었다.내가 원하는 것은 검색어입력시 1뎁스와 2뎁스는 그대로 노출되고 3뎁스에 검색이 적용되어 결과가 노출되는 것이다. html코드123456789101112131415161718192021222324252627282930&lt;input type=\"text\" placeholder=\"메뉴 검색\" id=\"searchInput\" onkeyup=\"func.filter();return false\"&gt;&lt;ul id=\"top\"&gt; &lt;li&gt; &lt;h5&gt;&lt;div style=\"display:inline;\"&gt;전체메뉴&lt;/div&gt;&lt;/h5&gt; &lt;ul style=\"display: block;\" id=\"topLevel\"&gt; &lt;li data-menu-nm=\"댑스1\" data-depth=\"1\"&gt; &lt;h5&gt;메뉴1&lt;/h5&gt; &lt;ul style=\"\"&gt; &lt;li data-menu-nm=\"메뉴1-1\" data-depth=\"2\"&gt; &lt;h5&gt;메뉴1-1&lt;/h5&gt; &lt;/li&gt; &lt;li data-menu-nm=\"메뉴1-2\" data-depth=\"2\"&gt; &lt;h5&gt;메뉴1-2&lt;/h5&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li data-menu-nm=\"댑스1\" data-depth=\"1\"&gt; &lt;h5&gt;메뉴2&lt;/h5&gt; &lt;ul style=\"\"&gt; &lt;li data-menu-nm=\"메뉴2-1\" data-depth=\"2\"&gt; &lt;h5&gt;메뉴2-1&lt;/h5&gt; &lt;/li&gt; &lt;li data-menu-nm=\"메뉴2-2\" data-depth=\"2\"&gt; &lt;h5&gt;메뉴2-2&lt;/h5&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; js코드123456789101112131415let func;$(document).ready(function() { func = { filter: function(){ $(\"#top ul\").slideDown(100); if($('#searchInput').val()==\"\") $(\"#topLevel ul li\").css('display',''); else{ $(\"#topLevel ul li\").css('display','none'); $(\"#topLevel ul li[data-menu-nm*='\"+$('#searchInput').val()+\"']\").css('display',''); } return false; } }}); 예시result 탭에서 메뉴검색 인풋에 2-1을 검색하면 전체메뉴, 메뉴1, 메뉴2 그리고 메뉴2-1가 잘 출력되는 것을 확인할 수 있다. See the Pen by sowon-dev (@gracehopperdev) on CodePen. 여담제이쿼리로 선택자와 그 하위 태그 선택을 하는데 있어 많이 헷갈렸다.구글링하다가 에라이 던질뻔했다.그냥 get방식으로 where 조건절 걸어서 db 다시 다녀올까 했지만 이미 list뿌리면서 가져온 데이터인데 굳이 db까지 다시 다녀오는 건 자원낭비라는 생각이 들었다.어떻게든 제이쿼리로 끝내고싶어서 열심히 구글링하였다.포기하지않고 끝까지 해낸 나자신 칭찬해!이 경험으로 선택자에 대해 깊이 알 수 있었다.","link":"/2021/10/05/211006Jquery-search/"},{"title":"[MySQL&#x2F;MariaDB] Union all 사용법","text":"동일한 컬럼을 가지고 있는 두 테이블은 JOIN과 ON절을 이용해서 합칠 수 있다.하지만 동일한 컬럼을 가지고 있지 않은데 검색결과를 함께보고싶다면 고려해봐야할 것이 바로 union all을 사용해보자. JOIN: 수직결합 UNION: 수평결합 UNION: 중복데이터 제거 UNION ALL: 중복여부와 상관없이 모든 데이터 출력 만약 과일가게테이블과 편의점테이블이 아래처럼 있다고 생각해보자. 과일가게테이블 12345678과일가게테이블+--------+--------+| 품 명 | 가 격 |+--------+--------+| 바나나 | 1500 || 딸기 | 2000 || 사과 | 2000 |+--------+--------+ 편의점테이블 12345678편의점테이블+--------+--------+| 품 명 | 가 격 |+--------+--------+| 바나나 | 1500 || 사과 | 2500 || 하리보 | 2000 |+--------+--------+ UNION중복데이터 제거한 결과가 출력된다. 123456789101112131415SELECT * FROM 과일가게테이블 UNION SELECT * FROM 편의점테이블;// 결과+--------+--------+| 품 명 | 가 격 |+--------+--------+| 바나나 | 1500 || 딸기 | 2000 || 사과 | 2000 || 바나나 | 1500 || 사과 | 2500 || 하리보 | 2000 |+--------+--------+ UNION ALL중복여부와 상관없이 모든 데이터 출력된다. 1234567891011121314SELECT * FROM 과일가게테이블 UNION ALLSELECT * FROM 편의점테이블;// 결과+--------+--------+| 품 명 | 가 격 |+--------+--------+| 바나나 | 1500 || 딸기 | 2000 || 사과 | 2000 || 사과 | 2500 || 하리보 | 2000 |+--------+--------+","link":"/2021/10/18/211019SQL-unionall/"},{"title":"[MySQL&#x2F;MariaDB] WITH RECURSIVE 초간단 설명","text":"MySQL에서 재귀쿼리를 사용해야한다면? with recursive문을 사용할 수 있다.with recursive는 UNION ALL과 함께 사용하며 UNION ALL은 관련 포스팅인 Union all 사용법을 참조하면 된다. 기본 쿼리12345678with recursive 테이블명 as ( select 초기값 as 별명1 union all select 별명1 반복_할_계산식 from 테이블명 where 반복을_멈출_제어문)select * from 테이블명 코드예시코드를 보자.menu테이블이 있고 menu테이블은 계층형구조로 이루어져있다.상위 메뉴ID와 하위 메뉴ID를 동일한 menu테이블에서 가져오는 재귀쿼리로 활용할 수 있다. 123456789101112131415161718with recursive cte as ( SELECT MENU_ID , UPPER_MENU_ID , MENU_NM FROM menu UNION ALL SELECT m.MENU_ID , m.UPPER_MENU_ID , m.MENU_NM FROM cte INNER JOIN menu m ON cte.MENU_ID = m.UPPER_MENU_ID)SELECT *FROM menu M","link":"/2021/10/19/211020SQL-recurisve/"},{"title":"세번째 팀 프로젝트를 끝내며 코드리뷰가 내게 남긴 것","text":"한달동안 내내 매달렸던 세번째 팀 프로젝트가 오늘부로 끝났다.매일 야근하는 삶이었다. 프로젝트가 끝나고보니 가을이 성큼 다가오다못해 성큼 지나가고 있었다.🍁이번 프로젝트는 끝나고 나서 다음 프로젝트까지 여유가 있어 코드리뷰 시간을 가졌다.현재 회사에서 이번 프로젝트까지 총 3개의 프로젝트를 진행했었는데 코드리뷰는 처음이라 무척 신났다.항상 해보고싶었어 코드리뷰🤩 코드리뷰 시간을 잘 활용하기 위한 생각 팁!어떻게 하면 코드리뷰 시간을 잘 활용하여 더 많이 성장할 수 있을까?코드리뷰 시간을 잘 활용하기 위해선 내 코드 돌아보기 뿐만 아니라 다른 팀원분들의 코드도 훑어봐야한다.코드를 보면서 아래와 같이 2가지만 생각하면 끝!! 나한테 맡겨지면 나는 어떻게 구현했을까? 왜 이 라이브러리를 사용했을까? 코드리뷰 어땠어?첫 코드리뷰는 성공적이었다.궁금했던 부분, 애매했던 부분들을 물어볼 수 있는 좋은 기회였고 왜 해당 라이브러리를 사용했는지, 왜 서비스단에서 처리했는지, 컨트롤러에서 하면 뭐가 안 좋은지 등등 궁금증을 와르르 쏟아냈다.다들 프로젝트가 끝나서 그런지(?) 친절하게 알려주셨다. 듣는 내내 오른쪽 뇌의 한 부분이 깨어나는 기분이었다.아하 아하의 연속!너무 재밌어!!! 코드리뷰를 통해서 내가 배운 내용들을 정리해보았다.보안상 모든 내용을 기록할 순 없지만 대중적인 부분들을 골라 적었다.잊어버리지 않도록!똑같은 실수를 하지 않도록! 동영상에 iframe을 쓰지 않은 이유iframe을 사용하면 동적제어가 되지 않는다. 따라서 iframe을 쓰지 않고 video.js 를 사용했다. iframe예시 123456&lt;iframe id=\"inlineFrameExample\" title=\"Inline Frame Example\" width=\"300\" height=\"500\" src=\"동영상url\"&gt;&lt;/iframe&gt; video.js 예시비디오보기 버튼을 클릭시 video.js를 이용하여 모달에 비디오가 출력되는 예시이다. 12345678910&lt;button type=\"button\" name=\"비디오보기\"&gt;&lt;/button&gt;&lt;div class=\"modal-body\" id=\"videoModalView\"&gt;&lt;/div&gt;&lt;script&gt;$(function() { $(\"button[name=비디오보기]\").click(function() { let videojs = `&lt;video style=\"height:500px;width:300px\" class=\"video-js vjs-big-play-button vjs-fluid vjs-time-control\" controls autoplay=\"false\" preload=\"auto\" data-setup=\"{}\" controlsList=\"nodownload\"&gt;&lt;source src=\"${동영상url}\"/&gt;`; $(\"#videoModalView\").html(videojs); }});&lt;/script&gt; try catch를 했으면 꼭 예외처리를 해야한다.예외처리 정책을 몰라서 catch 부분에서 error를 log찍고 throw로 던졌다.log만 찍으면 예외가 처리된 것이 아니기때문에 아예 없는 것이 낫다.차라리 try catch문을 없애면 500에러가 발생해서 문제 발생시 바로 확인 및 처리가 가능하다. 컨트롤러현재 상태로는 로그에 에러가 찍히지만 서버는 계속 돌아가므로 에러를 확실히 잡을 수 없다. 12345678910111213@DeleteMapping(\"/{id}\")public ResponseEntity&lt;String&gt; delete(@PathVariable(name = \"id\") int id) throws Exception { String msg = \"\"; try { sampleService.delete(id); msg = \"정상적으로 삭제되었습니다.\"; } catch (Exception e) { // TODO: 예외처리정책 필요 log.error(\"삭제 중 오류가 발생하였습니다.\", e); throw e; } return ResponseEntity.status(HttpStatus.OK).body(msg);} 코드리뷰 후 컨트롤러try catch문을 아예 없애 500을 발생시켜 서비스가 멈추도록 했다.global error 처리단계에서 500에러인 경우, 잡아서 500에러 페이지를 보여준다. 12345@DeleteMapping(\"/{id}\")public ResponseEntity&lt;String&gt; delete(@PathVariable(name = \"id\") int id) { sampleService.delete(id); return ResponseEntity.status(HttpStatus.OK).body(\"정상적으로 삭제되었습니다.\");} 다중 insert시 서비스에서 처리할 지, 퀴리에서 처리할 지?경우에 따라 다르다.insert 후 바로 수정, 삭제시 id값이 있어야하는 경우, 쿼리에서 for each 돌리는 것보다 서비스에서 for문으로 insert해주는 것이 낫다. 쿼리 parameterType과 resultType에 DTO가 들어가도 되는 지?VO는 readonly이니 쿼리에서 사용해도 될지 고민스러웠다.DTO와 VO를 구분하여 사용한다면 쿼리에 parameterType에는 DTO를 resultType에는 VO를 넣어도 된다. DB요청은 적을수록 좋다.상황에 따라 다르지만 기본적으로 DB요청이 적을수록 성능이 빨라진다. 쿼리에서 부등호 연산을 한다면 CDATA 구문 말고 대신쿼리에서 부등호로 연산을 한다면 CDATA대신 &amp;lt; 와 &amp;gt;를 사용하는 것이 간편하다. 잘못 사용한 예CDATA를 사용할때 if조건등이 있는경우 꺽쇠가 있어서 쿼리가 실행 되지않는 오류가 생기기 쉽다. 1234567891011121314&lt;select id=\"selectList\" parameterType=\"testVO\" resultType=\"testVO\"&gt; /* selectList by sowon-dev 2021.11.23 */ &lt;![CDATA[ SELECT id , user_name , user_no FROM testTable WHERE 1 = 1 &lt;if test=\"startSearchDate != null and endSearchDate != null\"&gt; AND regist_dt &gt;= date_format(#{startSearchDate}, '%Y-%m-%d %H:%i:%s') AND regist_dt &lt;= date_format(#{endSearchDate}, '%Y-%m-%d %H:%i:%s') &lt;/if&gt; ]]&gt;&lt;/select&gt; CDATA 잘 사용한 예따라서 해당 부등호에만 CDATA를 적용하는 것을 습관화하면 좋다. 123456789101112&lt;select id=\"selectList\" parameterType=\"testVO\" resultType=\"testVO\"&gt; /* selectList by sowon-dev 2021.11.23 */ SELECT id , user_name , user_no FROM testTable WHERE 1 = 1 &lt;if test=\"startSearchDate != null and endSearchDate != null\"&gt; AND regist_dt &lt;![CDATA[ &gt;= ]]&gt; date_format(#{startSearchDate}, '%Y-%m-%d %H:%i:%s') AND regist_dt &lt;![CDATA[ &lt;= ]]&gt; date_format(#{endSearchDate}, '%Y-%m-%d %H:%i:%s') &lt;/if&gt;&lt;/select&gt; &amp;lt;, &amp;gt;를 사용한 예CDATA문을 사용하지 않고 HTML방식으로도 가능하며 CDATA문보다 간편하다. 123456789101112&lt;select id=\"selectList\" parameterType=\"testVO\" resultType=\"testVO\"&gt; /* selectList by sowon-dev 2021.11.23 */ SELECT id , user_name , user_no FROM testTable WHERE 1 = 1 &lt;if test=\"startSearchDate != null and endSearchDate != null\"&gt; AND regist_dt &amp;gt;= date_format(#{startSearchDate}, '%Y-%m-%d %H:%i:%s') AND regist_dt &amp;lt;= date_format(#{endSearchDate}, '%Y-%m-%d %H:%i:%s') &lt;/if&gt;&lt;/select&gt;","link":"/2021/11/16/211117PrjtReview/"},{"title":"[JPA]@CreatedDate에 날짜가 안 담길때 오류","text":"@CreatedDate를 사용하여 save()메서드로 데이터를 insert하는데 날짜가 null로 나왔다.이런 오류는 대부분 auditing이 제대로 적용되지 않았을때 발생한다. 원인 Entity클래스에 @EntityListeners 추가되어있지 않아서 Auditing기능이 작동하지않았다. Sample.java123456789101112131415161718@Getter@Setter@Builder@NoArgsConstructor@AllArgsConstructor@Entitypublic class Sample { @Id @GeneratedValue(strategy =GenerationType.IDENTITY) protected Long id; private String name; private Integer age; @CreatedDate private LocalDateTime createdAt;} 해결 패키지Application.java에 @EnableJpaAuditing 어노테이션 추가JpaAuditing 기능을 사용하기 위해서는 패키지Application.java파일에서 @EnableJpaAuditing 추가해줘야한다. 12345678910@EnableJpaAuditing // 추가@SpringBootApplicationpublic class 패키지Application { public static void main(String[] args) { System.out.println(\"@아아\"); SpringApplication.run(패키지Application.class, args); }} Entity클래스에 @EntityListeners 추가이걸 빼먹으면 @CreatedDate등 Auditing기능이 작동하지않는다. Sample.java12345678910111213141516171819@Getter@Setter@Builder@NoArgsConstructor@AllArgsConstructor@Entity@EntityListeners(AuditingEntityListener.class) // 추가public class Sample { @Id @GeneratedValue(strategy =GenerationType.IDENTITY) protected Long id; private String name; private Integer age; @CreatedDate private LocalDateTime createdAt;}","link":"/2021/11/29/211130Jpa-auditing/"},{"title":"DDD는 디자인패턴인가 아키텍처인가?","text":"DDD(Domain-driven design)으로 프로젝트를 진행하게 되면서 DDD가 무엇인지 궁금해졌다.DDD는 디자인패턴일까 아키텍처일까?사소한 하나하나 다 궁금할 시기이지. 암암 그렇고말고.구글링을 아무리 해봐도 뚜렷한 구분이 나오지 않았다. 그래서 공부한 내용을 바탕으로 팀장님께 문의를 드렸고 팀장님도 함께 고민해주셨다.참 감사하다!이번 포스팅은 스스로 공부하면서 작성한 포스팅이므로 정답이 아닐 수 있다. 나에게 가장 익숙한 프로젝트 구조는 MVC패턴으로 프레젠테이션로직, 비즈니스로직, 데이터베이스 로직을 구분한 구조이다. 이를 3계층 구조라고 부른다고 하셨다.디자인패턴으로 보면 MVC패턴이지만 아키텍처관점에서는 3Tier Architecture라는 것이다. 디자인 패턴이란? 🤠 정의: 어떤걸 해결할려고 할때 효율적인 방법에 대해서 정해놓은 규칙 문제를 해결하기 위한 방법을 가이드 크기로 보면 패턴이 좀 더 아키텍쳐 보단 작은 느낌 소프트웨어 아키텍처란? 🤠 정의: 시스템, 컴포넌트 간의 관계가 어떻게 되어있냐 그런 구조적인 측면에서 정의한 것 특징: 언어적 혹은 시스템 구조적 등 여러가지 환경에 따라 구조가 달라서 해당 구조에서 사용할 수 있는 패턴도 달라짐 인프라 아키텍쳐(가장 광범위) -&gt; 시스템 아키텍쳐 -&gt; 소프트웨어 아키텍쳐(좁은범위) 디자인패턴 VS 소프트웨어 아키텍처 예시 디자인패턴 아키텍처 대표 예시 MVC모델, Commnad, Factory, DAO 데이터중심 스타일, 규칙기반스타일, 분산스타일, 파이프와 필터스타일 내가 내린 결론다시 본래 질문으로 돌아가자.DDD는 디자인패턴일까 아키텍처일까?여기서 내가 내린 결론은 소프트웨어 아키텍처이다.왜냐하면 DDD는 디자인패턴 같으면서도 구조적이다. 비즈니스와 디자인패턴, 아키텍쳐까지 포함하기에 디자인패턴보다는 큰 개념인 아키텍처에 적합하다. 참고 팀장님 지식 https://incheol-jung.gitbook.io/docs/q-and-a/architecture/ddd https://m.blog.naver.com/limoremo/220073573980 http://www.jidum.com/jidums/view.do?jidumId=1002","link":"/2021/12/31/2201013tier-archVSddd/"},{"title":"이벤트루프(Event loop)와 메인스레드(Main thread)","text":"탄탄한 자바스크립트 기본기를 다지기 위해 이벤트 루프에 대해 알아보자. 이벤트루프모델이벤트 루프 모델은 여러 스레드를 사용한다.Node.js 프로세스에서 메인 스레드는 1개이며, 한 순간에 한 줄씩만 실행하지만 워커스레드(Worker thread)는 여러개이다.이벤트 루프는 앞에 있는 콜백이 전부 처리가 끝나야 다음 콜백을 처리할 수 있다. 용어정리 메인스레드: 자바스크립트 코드가 실행되는 스레드 워커스레드: 파일입출력스레드, 네트워크스레드등 메인스레드 외의 일을 하는 스레드 콜스택: 현재까지 불린 함수들의 스택 스택: 스택자료구조로 후입선출의 특성을 가진다.","link":"/2022/01/04/220104JS-eventloop/"},{"title":"클로저(Closure)란","text":"탄탄한 자바스크립트 기본기를 다지기 위해 클로저에 대해 알아보자. Closureclosure = function + environment클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미한다.함수(function)가 하나 생길때마다 클로저는 하나씩 생성된다.일반적으로 외부 함수의 실행이 끝나면 외부 함수가 소멸된다. 하지만 클로저는 외부 함수가 소멸된 이후에도 내부 함수가 외부함수의 변수에 접근할 수 있는 구조이다. 아래 문제를 풀어보자 123456789101112131415function 이름부르기() { let name = \"나혜석\"; return function() { alert(name); };}let name = \"권기옥\";// create a functionlet 인사 = 이름부르기();// 나혜석과 권기옥 중 누구의 이름이 불리게 될까?인사(); 여기서 정답은 바로 나혜석이다.만약 이름부르기함수에서 let name = &quot;나혜석&quot;;이 없었다면 alert창은 권기옥으로 나올 것이다. 어떻게 이게 가능한걸까?바로 자바스크립트의 함수는 숨겨진 프로퍼티인 [[Environment]]를 이용해 자신이 어디서 만들어졌는지를 기억하기 때문이다. 참고 https://ko.javascript.info/closure https://edu.goorm.io/learn/lecture/557/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-node-js/lesson/21731/%ED%81%B4%EB%A1%9C%EC%A0%80","link":"/2022/01/05/220105JS-closure/"},{"title":"사내 101번서버에 접속하세요라는 의미(DNS 정보조회)","text":"한참 모든 것이 궁금한 시기인 나는 오늘도 궁금한 점이 생겼다.오늘 팀장님이 사내서버에 프로젝트를 올렸으니 101번(임의번호)서버로 접속해서 확인해보라고 하셨다. 사내 서버의 도메인을 이미 알고있었기때문에 해당 도메인인 link.sowonDev.com(임의도메인)으로 접속하니 잘 접속이 되었다.여기서 궁금증한 건 사내도메인 link.sowonDev.com을 왜 101번서버라고 부르는 지였다. 도메인 정보를 조회하는 명령어 nslookup: 도메인 이름에 대한 정보를 조회할 때 사용할 수 있는 명령어이다. cmd를 열어 아래와 같이 nslookup명령어를 입력하면 DNS서버에 해당 도메인정보를 요청하는 것이고 응답으로는 도메인정보가 나온다.요청을 끝내고 싶으면 exit을 통해서 명령어작성에서 빠져나오면 된다. 12345678910111213//명령어$ nslookup [정보를알고싶은도메인]//명령어 예시$ nslookup link.sowonDev.com//응답권한 없는 응답:이름: link.sowonDev.comAddress: 123.000.00.101//명령종료$ exit 자 이제 왜 101서버라고 불리는 지 감이 잡혔다.응답을 보면 address부분의 제일 마지막 IP가 101이기 때문이다!다른 사이트들도 궁금해졌다. 12345678$ nslookup naver.com권한 없는 응답:이름: naver.comAddress: 223.130.200.107 223.130.195.200 223.130.200.104 223.130.195.95 네이버 예시에서 알 수 있듯 네이버급의 규모가 큰 프로젝트는 4개의 서버를 사용한다.신기해👍 그리고 좀 더 구글링해보니 굳이 cmd가 아니더라도 DNS recode를 조회할 수 있는 사이트를 찾을 수 있었다.IPv4 Address뿐만 아니라 회사위치와 회사명도 나온다! https://www.nslookup.io/ 위 사이트에서 google.com을 검색하면 IPv4는 물론 AAAA records인 IPv6 address도 확인할 수 있다!재밌다😎 결론새로운 지식 습득은 언제나 재밌다.그려려니 넘어가지말고 꼭 구글링해보자!","link":"/2022/01/05/220106Server-nslookup/"},{"title":"Prototype","text":"js는 프로토타입기반 언어이다.여기서 프로토타입이 무엇일까? java나 python등 객체지향언어에는 Class(클래스)가 존재한다. 클래스를 가지고 상속등의 기능을 구현한다.여기서 중요한 점은 js도 객체지향언어라는 점이다. 하지만 js에는 클래스라는 개념이 없다. 그렇다면 상속등의 기능은 어떻게 할 수 있을까? 이때 프로토타입을 사용한다. 기존의 객체를 clone하여 새로운 객체를 생성하는 것이다. 프로토타입 상속사람(person)객체에는 sleep이라는 값이있다.학생(student)객체에도 sleep이라는 값이 있고 person을 상속한다. 이를 student의 프로토타입은 person이라고 말한다. 아래 아주 간단한 예시를 보자. 3가지 물음표에는 각각 어떤 값이 나올까? 123456789101112131415161718let person = { sleep: null};let student = { __proto__: person, sleep: true, study: true,};alert( student.sleep ); // ? (1)delete student.sleep;alert( student.sleep ); // ? (2)delete person.sleep;alert( student.sleep ); // ? (3) 답은 아래와 같다. true null undefined 이를 잘 활용하면 효율적인 객체생성이 가능하다. 이를 Class와 비교해보자! 1234567891011121314151617function Pesrson(name){ this.name = name}Person.prototype.sleep = function sleep(){ return `${this.name}는 자는 중`;}function Student(name){ this.__proto__.constructor(name)}Student.prototype.study = function study(){ return `${this.name}는 공부중`;}Object.setPrototypeOf(Student.prototype, Person.prototype) //set해줘야함 위와 아래는 똑같다! 1234567891011121314151617181920212223class Person(){ constructor(name){ this.name = name } sleep(){ return `${this.name}는 자는 중`; }}class Student extends Pesrson{ constructor(name){ super(name) } study(){ return `${this.name}는 공부중`; }}var me = new Student(\"sowon-dev\");console.log(me.study());console.log(me.sleep()); 유용한 메서드 메서드명 리턴값 설명 a instanceof b boolean a가 b를 상속하는지 확인할 수 있음 참고 https://ko.javascript.info/prototype-inheritance","link":"/2022/01/09/220109JS-proto/"},{"title":"경로(절대경로, 상대경로, ., ~)","text":"경로란 파일 위치를 알려줘서 연결할 때 사용한다.이번에 ~라는 경로를 보았다. 항상 .만 보았기때문에 어떤 경로인지 궁금했다. 경로만약 아래와 같인 디렉토리 구조가 있다고 가정하자 123456789101112131415161718192021222324252627282930project│ README.md│ exam1.txt│└───webroot│ │ favicon.ico│ ││ └───css│ │ │ maim.css│ │ │ common.css│ │ │ ...│ ││ └───js│ │ maim.js│ │ common.js│ │ ...│└───controller│ │ HomeController│ │ UserController│└───view│ │ │ └───Home│ │ Home.html│ │ │ └───User│ │ Create.html│ │ Edit.html│ │ ... 현재 Create.html에서 경로를 작성한다고 생각한다면 절대경로와 상대경로 예시는 아래 표와 같다. 표현 의미 위치예시 / 루트, 가장 최상위 디렉토리 project ~/ 루트, 가장 최상위 디렉토리 project ./ 현재 위치 User ../ 현재 위치의 상단 폴더 view ../../ 현재 위치의 상단 폴더의 상단폴더 project","link":"/2022/01/13/220114path/"},{"title":"let과 const와 Var의 차이, 어떻게 쓰면 좋을까?","text":"js에서 변수를 선언할때는 let과 const와 Var를 쓸 수 있다.이들 중 어떨때 무엇을 사용하면 좋을까? 이는 block scopting에 해답이 있다. Block scopting아래 var로 선언한 예시를 보자. 123456var x = 1{ var x = 2 console.log(x) //2}console.log(x) //2 var는 block scoping 자체를 갖지 않기 때문에 두번째 x 선언자체가 첫번째 x의 로컬 scope로 가게된다.따라서 var로 선언한 두 변수는 같은 변수가 되고 가장 마지막에 선언한 값으로 결정된다. 이제 let과 const를 보자.let과 const는 같은 scoping 룰을 따른다. 123456const x = 1{ const x = 2 console.log(x) //2}console.log(x) //1 block 안과 밖을 구분하는 blcok scoping을 따른다. 결론위의 예시에서 알 수 있듯 let과 const는 예측 가능성이 높고 유지보수성이 var보다 뛰어나다.따라서, const를 기본으로 사용하고 필요한 경우에 let을 사용하자 var는 절대 쓰지말자.","link":"/2022/01/14/220115JS-letConstVar/"},{"title":"spread operator (...) 점 세 개를 알아보자","text":"온점 세 개를 찍어서 표현하는 spread syntax(…)라고 한다.이 spread operator는 S2015에서 새로 추가된 systax으로 병합, 구조 분배 할당(destructuring)등에 다양하게 활용할 수 있다. 객체/배열 병합객체와 배열의 병합에 사용할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041const newDBinfo = { DATABASE_HOST: '나혜석', DATABASE_PASSWORD: '나혜석123',}const config = { DATABASE_HOST: '유관순', DATABASE_PASSWORD: '유관순123', DATABASE_USERNAME: 'user', ... newDBinfo,}const config2 = { ... newDBinfo, DATABASE_HOST: '유관순', DATABASE_PASSWORD: '유관순123', DATABASE_USERNAME: 'user',}console.log(config)/*{ DATABASE_HOST: \"나혜석\" DATABASE_PASSWORD: \"나혜석123\" DATABASE_USERNAME: \"user\" [[Prototype]]: Object}*/console.log(config2)/*/*{ DATABASE_HOST: \"유관순\" DATABASE_PASSWORD: \"유관순123\" DATABASE_USERNAME: \"user\" [[Prototype]]: Object}*/ 이 결과값으로 알 수 있듯 spread syntax(…)의 위치에 따라 덮어쓰기가 가능하다. 객체/배열 reset객체와 배열을 자를 수 있다. 객체예시12345678910const person = { name: '유관순', age: '17',}const {age, ...independenceData} = personconsole.log(independenceData)/*{name: \"유관순\"}*/ 배열 예시123const [one, ...others] = [1,2,3]console.log(one) // 1console.log(others) // [2,3]","link":"/2022/01/14/220115JS-spreadoperator/"},{"title":"Promise 프로미스","text":"프로미스에 대해 알아보자. 개념Promise객체는 자바스크립트에서 비동기 처리에 사용되는 객체이다. 프로미스의 3가지 상태 용어 뜻 설명 Pending 대기 비동기처리를 하지도, 거부하지도 않은 초기 상태 Fulfilled 이행 비동기처리가 성공적으로 완료됨 Rejected 거부 비동기처리가 실패함 실무사용실무에서는 ajax등의 비동기를 동기화시킬때 사용한다.예를 들어 onclick이벤트시 A메서드를 무조건 실행하고 난 뒤 B메서드를 실행하고 싶다면 콜백함수를 사용하면 되는데 만약 A함수를 호출한 뒤 B함수, 그 뒤 C함수 그 뒤 D함수를 사용해야한다면 콜백지옥이 펼쳐질것이다. 이를 예방하기 위해서 프로미스를 사용할 수 있다. 123456789101112131415161718192021222324$(document).ready(function() { $(\"a[data-role=formTag]\").click(async function() { await customFormValidation('성명', 'name'); await customFormValidation('연락처', 'mobile'); await customFormValidation('나이', 'age'); $('form').submit(); }});function customFormValidation(label, inputName){ return new Promise(function (resolve, reject) { if($('form').find('input[name='+inputName+']').val() == '' || $('form').find('input[name='+inputName+']').val() == 0){ $('form').find('input[name='+inputName+']').parents('dd').addClass(\"reconfirm\"); $('form').find('input[name='+inputName+']').focus(); resolve(false) return false; } else { $('input[name='+inputName+']').parents('dd').removeClass(\"reconfirm\"); resolve(true) } })} 참고 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise","link":"/2022/01/16/220116JS-promise/"},{"title":"닷넷프로젝트를 끝내며 코드리뷰가 내게 남긴 것","text":"한 달간 진행되었던 네번째 프로젝트가 끝이 났다!처음 사용하는 C#에다가 닷넷프레임워크, 그리고 Visual Studio, MSSQL, Azure까지!모든 것이 새롭게 다가왔고 정말 열심히 배웠고 큰 성장을 이루어냈다.잠깐만 갑자기 C#에다가 닷넷??! 그렇게 됐다.회사의 일은 가끔(또는 자주) 내 뜻대로 되지 않는 법. 이번에 맡은 프로젝트는 닷넷 프레임워크를 사용했다.아직 스프링프레임워크도 깊게 보지 못한 내게 새로운 언어와 새로운 프레임워크는 혼돈의 카오스 그 자체였다.절망하기보단 이왕 해야 할 거! 최선을 다해 빨리 성장하자 하나라도 더 알자는 마음가짐으로 열정적으로 임했다.그래서 그런지 정말 많은 것들을 배울 수 있었다. DDD도 처음이고 CQRS도 처음이었다. 혼자 부트스트랩으로 페이지도 만들고 저장 프로시저 이용해서 쿼리도 짜고 EF도 이용해봤다.성장하고자하는 마음 하나로 한달닷넷프레임워크의 여러 장점 중 가장 좋았던 점은 시간연산이 굉장히 편하다는 점이다!! 날짜 포맷팅도 .ToString(&quot;yyyy-MM-dd&quot;) 이런식으로 정말 간단하다! 최고 Keep현재 만족하고 있는 부분과 계속해서 이어갔으면 하는 부분 명확한 단어 사용을 위한 단어 합의를 위해 노력했다.기존 4개의 역할(Admin / Owner / Super / Member)이 있었다. 한 눈에 봐도 Super의 역할이 모호했다.프로젝트 구조와 요구사항을 파악하고 나서 역할의 이름을 Super에서 Manager로 변경을 제안했다.몇몇 기능 개발이 되어있던 상태였기때문에 변경에 있어서 고민이 많았지만 “지금이라도 잡아야 나중에 유지보수까지 편해집니다”라는 의견을 피력했고 다행히 내 의견이 받아들여졌고 초반에 합의한 덕분에 후반부 작업이 훨씬 수월해졌다! CSR와 SSR 구분 명확하게 할 수 있다.서버사이드랜더링(SSR)과 클라이언트사이드랜더링(CSR)을 확실하게 구분할 수 있고 나만의 우선순위도 생겼다. 우선순위: SSR &gt; CSR꼭 필요한 경우가 아니면 서버사이드랜더링을 사용하는 것이 좋다.그 이유로는 첫째, 최초 로딩 속도가 빠르다 두번째, SEO최적화, 크롤러에 대응하기 용이하다는 점이 있다. 닷넷프레임워크에서는 서버사이드랜더링으로 Razor를 사용해보았다. @를 사용하며 간단한 처리는 컨트롤러를 통하지않고 html에서 직접 서비스를 호출하여 처리할 수도 있다. Bootstrap을 자유자재로 구사할 수 있다.항상 템플릿을 가져와서 써봤지 직접 bootstrap으로 화면을 구현한 적은 처음이다.처음에는 내가 원하는 대로 row와 col 나누는 게 너무 어려웠는데 한 번 적응하고 나니 훨씬 편했다.또 기존에는 style속성으로 각 태그에 css를 변경하곤 했으나 비효율적이며 통일성이 떨어졌다. Bootstrap class를 사용하니 훨씬 편했다. 참고: Bootstrap Docs Auth policy등 enum타입으로 사용하여 휴먼에러를 줄였다. Problem개선이 필요하다고 생각되는 부분 DDD의 심도깊은 이해와 EF 사용이번에 처음 CQRS를 사용하면서 ORM(object-relational mapper)인 Entity Framework를 사용해봤다.Application Layer는 다루었으나 Domain Layer는 많이 다루지 못해 아쉬움이 있다.EF는 아주 간단한 Include와 Where만을 사용했다. 조금 복잡하다싶으면 나에게 익숙한 저장 프로시저를 이용했다. EF만 잘 사용한다면 효율적인 쿼리를 구현할 수 있었을텐데 아쉬움이 남는다. 참고: ORM vs SQL Mappeer 참고: DDD Application Layer란? UnitTest를 못한 점프로젝트기한이 촉박해 UnitTest를 거의 하지 못해서 아쉬움이 무척 남는다. TryProblem의 해결책이 될 수 있는 부분 DDD의 여러 사례 공부와 Domain Layer 공부하기Entity Framework Docs UnitTest를 손에 익히기손에 익으면 프로젝트 기한이 촉박해도 빠르게 test code를 짤 수 있다. 코드리뷰이번 코드리뷰는 질문과 답변을 통해 이루어졌다. 회사코드라서 모든 걸 다 적을 수 없고 적을 수 있는 것만 포편적인 예시를 들어 적어보려고 한다. 페이지 이동할 때 3가지 방식 중 우선순위가 있나요?페이지 이동할 때 3가지 방식이 있다. razor : @Url.Action(&quot;Board&quot;, &quot;Admin&quot;, new {id=@id}) asp.net: &lt;a asp-action=&quot;Board&quot; asp-controller=&quot;Admin&quot; asp-route-id=&quot;@id&quot;&gt; js: location.href=&quot;/Admin/Board/&quot;+@id 이 중 razor와 asp-action을 이용한 방식은 SSR이고 js는 CSL이다.세 가지 방식 중에 우선순위가 있는 방식은 없다. 상황에 맡게 사용하면 된다!","link":"/2022/01/19/220119prjtreview/"},{"title":"[OS]메모리vs드라이브vsCPU 코어 쉽게 이해하자","text":"소스코드를 일절 건드리지않았는데 운영서버의 사이트가 500에러가 났다.팀장님은 드라이브 문제일수있다고 하셨다.💾여기서 드라이브란? 스토리지드라이브를 뜻하며 HDD나 SDD가 해딩된다.메모리와 드라이브 개념을 확실히하기 위해 글을 찾아봤는데 비유가 가장 적합한 글을 찾았다.기업소개사이트인데 Aricles폴더 안에 메모리 개념들이 잘 포스팅되어있다. 컴퓨터 메모리(RAM)란 무엇이며 어떤 역할을 합니까? 위 글에 따르면 메모리는 책상과 비슷하다고 한다. 책상안에서 서류작성, 파일보관, 업무전화등 다양한 작업을 진행할 수 있다.이때 책상이 크면 클수록 더 많은 작업을 한꺼번에 펼쳐놓고 처리할 수 있어서 서류 보관 캐비넷(드라이브)에 빠르게 접근이 가능하다.책상이 크다면 이미 책상 위에 올려져있을테니까! 그렇다면 CPU 코어는 뭘까? 😮코어가 많을수록 메모리가 많을수록 작업이 빨라진다던데 메모리와 코어, 이 둘은 어떻게 다를까?이에 관해 팀장님이 비유적으로 설명해주셨다.CPU 코어는 책상앞의 사람의 수로 비유할 수 있다고 한다.👍 사람수가 많을수록 작업이 빨라지니까 CPU 코어가 많을수록 속도가 빨라진다. 와 역시 팀장님이다. 이해 쏙쏙!!!😆 정리 📀 메모리: 책상 드라이브: 서류 보관 캐비넷 CPU 코어: 일을 처리하기 위해 책상앞에 앉아있는 사람 예를 들어 CPU 6코어면 6명의 사람이 일처리를 위해 책상 앞에 있다고 생각하면 됨 CPU 스레드: 사람의 손 예를 들어 CPU 2코어 4스레드이면 2명의 사람이 4가지 작업을 동시에 할 수 있다고 생각하면 됨 한 손에 한 작업씩 진행중인 느낌. 참고 https://www.crucial.kr/articles/about-memory/support-what-does-computer-memory-do 팀장님 설명","link":"/2022/02/23/220224CS-cpuMemoryDrive/"},{"title":"NoSQL이 뭐길래","text":"NoSQL이란 무엇일까?SQL문을 아예 안쓴다는 말일까?Nope! 🏷️ NoSQL = Not Only SQL스키마없이 데이터를 표현하는 것이 주된 특징인 일련의 데이터베이스들을 의미한다. 🏷️ 일반적인특징 정해진 스키마가 없다. DB종류에 따라 그 특성이 매우 다르다. (RDBMS가 비슷비슷한 것과는 다름) 🏷️ 장점 높은 수평 확장성 더 많은 인스턴스를 만들어 더 큰 로드를 감당할 수 있음 초기 개발의 용이성 스키마 설계의 유연성 🏷️ 단점 표준의 부재 표준이 없어서 마이그레이션할때 각각 다 맞춰야 함 SQL에 비해 약한 query capability 복잡한 쿼리는 힘듬 -&gt; 단순한 쿼리만 가능 스키마가 없기때문에 data consistency를 어플리케이션 레벨에서 보장해야 함 🏷️ 종류 Key-value 예: Redis, AWS DynamoDB 모든 레코드는 Key-value의 페어이다. NoSQL의 가장 단순한 형태 Document-based 예: DynamoDB, CouchDB,몽고DB 각 레코드가 하나의 문서가 된다. key-value종류보다 문서가 구조적이기때문에 쿼리 최적화, 활용성 높은 API가 제공됨 Graph 예: Neo4j, AWS Neptune 그래프 이론을 바탕으로 데이터베이스를 그래프로 표현함 그래프는 node(객체)와 edge(관계) 그리고 property(객체의 속성)로 이루짐 관계가 first-class citizen이기 때문에 관계 기반 문제(실시간 추천등)에 유리","link":"/2022/02/26/220226NoSQL/"},{"title":"[이클립스&#x2F;STS] 보기 편하게 code style 설정하기 - 포맷팅설정","text":"이클립스나 STS 기본 코드 스타일은 너무 많은 tab공백 등으로 지저분해보이기도 한다.보기 편하도록 신규 프로젝트 시작시 코드 스타일을 적용하고 있다. 코드 스타일 적용 단축키: Ctrl + Shift + F 아래는 내가 주로 사용하는 코드 스타일이다. JAVA code style 🎀자바코드스타일은 구글 스타일을 사용하고 있다.먼저 google/styleguide 레포지토리안의 eclipse-java-google-style를 선택하여 xml파일로 다운로드한다. 이클립스 상단의 Windows &gt; Preferences Formatter 검색 후 Java &gt; Code Style &gt; Formatter 클릭 Import 버튼 클릭 후 미리 다운로드한 eclipse-java-google-style.xml 파일을 선택한 후 apply 버튼 클릭 자바 코드 스타일 적용 끝! JavaScript code style 🎀jsp에서 script태그를 이용해 js를 사용하는 경우 이 설정도 함께 해줘야 보기 편하다. 이클립스 상단의 Windows &gt; Preferences Formatter 검색 후 JavaScript &gt; Code Style &gt; Formatter 클릭 New 버튼 클릭 후 Profile name: 원하는 이름 기입하고 Initialize settings with the following profile: Eclipse[built-in] 선택 후 OK버튼 Indentation 에서 Tab policy : Spaces only와 Indentation size : 2, 그리고 Tab size : 2를 기입 Line Wrapping &gt; Maximem line width : 180 기입 자바스크립트 코드 스타일 적용 끝! HTML code style 🎀 이클립스 상단의 Windows &gt; Preferences html 검색 후 Web &gt; HTML Files &gt; Editor 클릭 Line width : 120 Indent using spaces 체크 Indentation size = 2 Inline Elements &gt; 인라인으로 보이기 싫은 태그들 선택 &gt; Remove 나는 주로 select, tr, td를 remove한다. apply 버튼 클릭 후 OK버튼 클릭 HTML 코드 스타일 적용 끝! JSP Validation OFF 🎀JSP파일이 많다면 Validation OFF를 하는 게 로딩도 빠르고 보기 편하다. Window &gt; Preference &gt; Web &gt; JSP Files &gt; Validation Validate JSP fragemtns 체크해제 끝!","link":"/2022/03/01/220302STS-formatSetting/"},{"title":"[톰캣서버]Tomcat 내부 구조와 설정파일","text":"클라이언트가 요청을 보내면 톰캣 내부에서는 어떤 일이 일어날까? 톰캣 서버 내부 구조 Tomcat Server안에 Service가 있고 그 서비스를 처리하는 것이 Engine(Catalina)이다.Engine안에는 Host가 여러 개가 있을 수 있다.Host안에는 여러 개의 Context가 있을 수 있다.여기사 Context란 쉽게 말해 스프링프로젝트라고 생각하면 된다.Context안에 있는 Servlet이 여러개 있는데 각 Servlet은 쉽게 Controller로 생각할 수 있다. 클라이언트가 먼저 url을 요청하면 Thread Pool로 간다. Thread Pool은 요청을 받은 후에 만들면 늦으니까 요청을 받기 전 미리 만들어 놓는다.그 중 요청을 처리하고 있지 않은 Thread 하나가 요청을 받게된다.요청 프로토콜에 따라 Connector가 동일한 프로토콜을 연결해주며 보통 HTTP1.1 프로토콜이다.프로토콜이 프로세스를 처리해서 Engline(Catalina)을 거치고 요청 받은 Host안의 Context까지 찾은 다음 해당 Servlet을 호출한다.Dispatcher Servlet이 요청받은 Controller의 method를 찾아 호출한다. 설정파일 톰캣설치경로/conf/server.xml : 톰캣 서버 설정 파일 톰캣설치경로/conf/web.xml : 톰캣의 모든 프로젝트의 공통설정 파일 프로젝트이름/WEB-INF/web.xml : 프로젝트(Context)의 개별 설정 공통설정파일이 먼저 적용된 후 프로젝트 개별 설정파일이 적용된다. 참고 https://tomcat.apache.org/tomcat-9.0-doc/architecture/overview.html https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html 웹서버(WEB SERVER) VS 웹어플리케이션서버(WAS, Web Application Server) Servlet : Servlet용어정리","link":"/2022/03/07/220307Server-tomcat/"},{"title":"바이너리 파일이란? 텍스트파일이랑 뭐가 다를까? ft.MIME","text":"바이너리 파일이란 무엇일까?바이너리 파일은 텍스트파일과 비교하면 이해가 쉽다. 표로 간단하게 정리해볼 수 있다. Text File Binary File 정의 문자만 저장된 파일 문자와 숫자가 저장된 파일 읽기 특징 문자만 읽을 수 있음. 전부 문자로 읽음 데이터를 있는 그대로 읽음 쓰기 특징 문자만 쓸 수 있음. 숫자를 쓴 경우 모두 문자로 변환 후 씀 데이터를 있는 그대로 씀 text파일에 숫자를 쓰는 예를 들어보자.앞서 text파일에은 숫자를 문자로 변환 후 쓴다고 했다.만약 숫자 17을 썼다면 text파일은 17을 ‘1’과 ‘7’로 변환 후 저장한다. 이로 인해 메모장(텍스트에디터)으로 특정 문서를 열면 깨지는 경우가 생긴다. 이렇게 바이너리 데이터를 텍스트기반인 HTTP 프로토콜에 보내려면 방법이 두 가지가 있다. MIME 타입으로 바이너리 데이터를 그대로 보내기 Base64로 바이너리 데이터를 텍스트로 변환하여 보내기 장점: 안전하게 전송가능 단점: 데이터이 사이즈가 커짐 MIME(Multipurose Internet Mail Extensions)MIME은 마임이라고 읽으며 텍스트기반 프로토콜에서 바이너리 데이터(예를 들어 이미지, 동영상, 파일)를 전송하기 위해 HTTP의 Context-Type 헤더에 데이터 타입을 명시하여 사용한다.마임타입의 형태는 타입/서브타입으로 기입하면 된다. 인코딩: Base64 vs ASCII바이너리 데이터를 텍스트 데이터로 변환할때 크게 두 가지 방식이 있다. 아스키코드와 Base64이다. 갯수 진법 비트 어떤 텍스트데이터가 있는지? Base64 64개 = 2^6 64진법 6비트 0-9 a-z A-Z + / 가 포함됨 ASCII 128개 = 2^7 128진법 7비트 0-9 a-z A-Z + / 와 특수문자 포함 ASCII는 Base64에서 특수문자가 포함되어있는데 몇몇 특수문자는 출력이 되지않으므로 ASCII로 변환하면 제대로 되지 않을 수 있다.어떤 인코딩이라든지 Base64의 데이터들은 다 있다. 따라서 안정적인 Base64인코딩을 사용하면 된다.","link":"/2022/03/09/220309binaryfile/"},{"title":"[STS] 자바버전 안 바뀔때 해결! 자바버전 바꾸는 방법(1.8에서 11로)","text":"자바버전을 깔~끔하게 1.8에서 11로 바꿔보자! 1 Preferences 설정Window -&gt; Preferences -&gt; 검색어: Compiler -&gt; Java 하위 Compiler클릭 -&gt; JDK Compliance에서 Compiler compliance level에서 1.8을 11로 변경 2 pom.xml 설정pom.xml을 더블클릭하여 연 뒤 아래 2가지를 수정한다. properties 하위 java-version을 1.8에서 11로 변경 plugins 하위 artifactId가 maven-compiler-plugin를 찾은 뒤 그 하위 source와 target을 ${java-version} 으로 변경 ${java-version}으로 설정해놓으면 1번에서 설정한 java-version을 그대로 따라가므로 11로 변경하든 16으로 변경하든 다시 1.8로 변경하든 동일한 자바 버전을 바라봐서 추후 변경할 필요가 없다.","link":"/2022/03/11/220311STS-changeJavaVersion/"},{"title":"DispatcherSerlvet 씹어먹기","text":"SpringMVC에선 DispatcherSerlvet가 아주 중요한 역할을 한다.잠깐 SpringMVC란 무엇일까?Spring프레임워크에 Model, View, Controller를 븐리한 디자인 패턴을 말한다. Spring 프레임워크는 개발을 지원하기 위해 다양한 clas를 제공하는데 그 중 아래 3가지를 이번 글에서 다룰 것이다. DispatcherServlet HandlerMapping ViewResolver 용어 역할 예시 DispatcherServlet 클라이언트의 요청을 받아서 HandlerMapping에 넘긴다 HandlerMapping Key-Value구조로 URL-메서드를 저장한 table에서 클라이언트의 요청을 처리할 Controller를 찾는 역할 @RequestMapping(“/url”) annotaion사용하면 Controller URL Mapping한다. ViewResolver Controller가 리턴한 View Name에 prefix와 suffix를 적용하여 반환한다. SpringMVC 요청 처리 과정 클라이언트가 요청을 한다. ex) /admin/post/add DispatcherServlet는 어떤 메서드가 좋은지 HandlerMapping에게 물어본다. HandlerMapping는 URL매칭테이블에서 뒤져서 해당 url과 일치하는 메서드를 반환한다. ex) add() DispatcherServlet는 받은 메서드를 가지고 어떤 HandlerAdapter가 처리할 수 있는 지 확인후 특정 HandlerAdapter에 넘겨준다. HandlerAdapter가 받은 정보로 Controller에게 전달한다. ex) @RequestMapping(“/admin/post/add”) public String add(){ return “addForm” } 스프링의 큰 특징은 관심사의 분리이다. DispatcherServlet이 직접 Controller를 호출하는 것보다 HandlerAdapter를 통함으로써 느슨한 연결이 된다. 느슨한 연결은 어떤 변경에서든지 유리하게 대처할 수 있다. =&gt; 즉, 변경의 유리한 설계 Controller 반환값을 HandlerAdapter에게 넘겨준다. ex) addForm HandlerAdapter는 그 값을 DispatcherServlet에게 전달한다. ex) addForm DispatcherServlet는 ViewResolver에게 전달한다. ex) addForm ViewResolver는 prefix와 suffix를 적용한 뒤 실제 화면을 알아내서 DispatcherServlet에게 반환한다. ex) /WEB-INF/views/addForm.jsp DispatcherServlet은 해당 뷰를 호출하면서 Model도 함께 전달한다. 화면은 Model객체를 가져와서 응답결과를 만들고 클라이언트에게 응답결과를 전달한다.","link":"/2022/03/16/220316DispatcherServlet/"},{"title":"예약가능여부 SQL쿼리로 알아보는 주니어 개발자와 시니어 개발자의 차이","text":"예약시간표를 만들고싶었다.예악가능한 시간대는 10시와 13시, 15시가 총 3가지이고 예약상태가 예약승인, 예약취소 총 3가지가 있다.예약이 한 번도 없거나, 예약취소가 된 경우 예약이 가능하며 예약승인인 경우 예약이 불가능하다.이때 특정 날짜를 달력에서 선택했을때 시간대별로 예약가능한지 불가능한지를 알고싶었다. 예를 들어 달력에서 3월 22일 클릭했을때 예약상태가 null이거나 예약취소이면 예약이 가능하고 예약상태가 예약승인경우에 예약이 불가능하다. 예약시간대와 예약상태는 DB 데이터로 존재하므로 쿼리를 잘 짜서 예약가능여부를 출력하고 싶었다. 선택한날짜(searchDate) 예약시간대 예약상태 예약가능여부 2022-03-22 10시 예약승인 X 2022-03-22 13시 null O 2022-03-22 15시 예약취소 O 내 쿼리예약상태 값이 있든 없든 출력되어야하므로 먼저 left join을 생각했었다. 하지만 기준테이블을 뭘로 잡으면 좋을지 고민해봤지만 주니어의 머리속엔 아무것도 떠오르지 않았다.그래서 고민하다가 union이 떠올랐다. union에 관해서는 2번적도 포스팅을 한 적이 있었는데 언젠가 내 머리속에서 버로 떠올랐으면 했었는데 드디어 떠올랐다. 짜릿해😆배운 지식이 머리속에서 떠오르는 건 짜릿한 경험이다. 123456789101112131415161718192021222324252627select date , ifnull(예약시간대, '10:00') , ifnull(count(예약상태), 0)from exampletablewhere 예약시간대 = '10:00'and date = #{searchDate}and 예약상태 = '예약승인'union select date , ifnull(예약시간대, '13:00') , ifnull(count(예약상태), 0)from exampletablewhere 예약시간대 = '13:00'and date = #{searchDate}and 예약상태 = '예약승인'union select date , ifnull(예약시간대, '15:00') , ifnull(count(예약상태), 0)from exampletablewhere 예약시간대 = '15:00'and date = #{searchDate}and 예약상태 = '예약승인' ifnull을 이용하여 예약이 한 번도 되지 않은 날짜인 경우 0이 출력되도록 했다.해당 일자에 예약이 있었던 경우에는 ‘예약승인’상태가 몇 개인지 count했다.즉 count로 1이상 나오는 경우 예약이 불가능하다. 0이면 예약가능하다. union이 머리속에 나온건 좋았지만 중복이 너무 많은 쿼리이다.아쉽고도 아쉬웠다.중복을 없앨 수 있지 않을까? 더 좋은 쿼리가 있을건데! 분명히!구글링을 통해 여러 방법을 따라하면서 고민해보다가 결국 팀장님께 여쭤봤다. 중복을 제거한 쿼리팀장님이 union쿼리도 이해하기 쉽게 잘 짰다고 칭찬해주셨다.난 참 운도 좋아! 매일 칭찬해주시는 팀장님 그저 빛… 칭찬은 주니어를 춤추게 해🕺“음 중복을 없애고 싶다면 이렇게는 어때요?” 하면서 1분만에 중복이 제거된 쿼리를 짜주셨다.😯솔직히 1분도 안 걸린듯하다. 팀장님. 천재. 그저 빛….바쁘신 와중에 도와주셔서 정말 감사했다. 12345678910111213141516171819SELECT a.v_dt, a.v_tm b.cntFROM (SELECT # {searchDate} v_dt, '10:00' v_tm UNION SELECT # {searchDate}, '13:00' UNION SELECT # {searchDate}, '15:00') a LEFT JOIN (SELECT date, 예약시간대, Count(*) cnt FROM exampletable WHERE 예약상태 = '예약승인' GROUP BY date, 예약시간대) b ON a.v_dt = b.date AND a.v_tm = b.예약시간대; from절에 서브쿼리를 사용했는데 서브쿼리안에 from 테이블이 없다. 이는 무조건 출력하겠다는 의미이다.선택한 날짜와 예약시간대 3가지는 항상 출력되야하므로 union을 사용했다.특정 시간대에 아무런 예약상태가 없어 null이 나올 수 있도록 left join을 걸었고 이때 where조건인 예약승인을 넣는다. 서브쿼리가 들어가고 그 안에 join절이 나오면 어떻게 SQL formatting해야 가독성이 좋아지는지 잘모르겠다. Javascript 코드 포맷터인 Pretieer처럼 SQL도 다수가 사용하는 format형식같은 게 있었으면 좋겠다.","link":"/2022/03/22/220322SQLdiff/"},{"title":"try catch와 throws, throw의 차이","text":"예외처리기법은 크게 3가지가 있다. try catch를 통한 예외처리 throw로 그냥 예외발생시키기 throws 키워드를 통한 예외처리 위임 이 중 try catch와 throw의 차이는 무엇일까? try catch와 throws의 차이throws의 예외를 던지는 것, 즉 위임이다. 이는 처리와는 다르다.try catch는 예외를 받아서 처리하는 것이다. 이는 처리이다. catch구문에서 사용자가 흐름을 능동적으로 제어할 수 있다. throwsthrows는 메서드에서 처리해야 할 하나 이상의 예외를 메서드를 호출한 곳으로 던져버린다.이러한 위임은 처리와는 다르다.try catch사용시 catch블록에서 예외를 처리해서 없애버린다.BUT 위임은 예외를 없애지 못하고 그냥 호출한 곳으로 예외를 전달만 한다.예외를 전달받은 메서드는 다시 예외 처리 책임이 발생한다. throws를 쓰면 예외처리를 해줘야하는 번거로움이 있는데 왜 사용할까?주로 개발자가 직접 정의하는 예외를 발생시키고 싶은 경우 사용한다. 1234567891011121314public class Main { public static void customThrowExample() throws Exception { // 다시 예외처리해줘야한다. throw new Exception(); } public static void main(String[] args) { try { customThrowExample(); } catch (Exception e){ System.out.println(\"catch구문은 잡히지않는다. try에서 customThrowExample으로 직접 예외를 발생시킴\"); } }} 참고 자바 Error와 Exception","link":"/2022/04/13/220413trycatchvsthrow/"},{"title":"ODBC란","text":"오늘 CentOS에 odbc Connect를 다운로드해야할 일이 있었다.JDBC(링크)는 익히 들어 알고 있는데 ODBC는 무엇일까? ODBCOpen Database Connectivity의 약자로 DB에 접근하기 위한 API이다. Open이라는 단어가 주는 느낌처럼 어떤 종류의 DB든 접속할 수 있는 표준화된 규격으로 Microsoft에서 만들었다고 한다.규격이 왜 필요할까?세상에는 수많은 DB가 있고 각 DB마다 그들의 규격이 있다. 예를 들면 MariaDB는 MariaDB에서 만든 접근API를 사용해야한다.너무나도 다른 규격들을 하나로 통일하고자 Micro soft는 ODBC를 만들었다.이름 그대로 Open Database Connectivity이니 모든 DB회사들은 이 ODBC API와 통신할 수 있는 DB Driver를 만들게 되는데 그것이 바로 MYSQL ODBC Driver, MSSQL ODBC Driver등이 되었다. 참고 https://docs.microsoft.com/en-us/sql/odbc/microsoft-open-database-connectivity-odbc?view=sql-server-ver15 https://www.techtarget.com/searchoracle/definition/Open-Database-Connectivity https://bramhyun.tistory.com/63","link":"/2022/04/15/220415ODBC/"},{"title":"ECMAScript","text":"오늘 고객사로부터 사이트의 달력이 제대로 작동되지 않는다는 연락을 받았다. 내 머신에서는 잘만 되는데 왜그럴까? 유심히 찾아보고있는데 팀장님께서 호환성 문제라고 말씀해주셨다.요구사항을 구현하면서 Promise를 사용했는데 IE는 해당 기능을 지원하지 않아서 제대로 작동하지 않았던 것이다. 이번 프로젝트에서는 IE는 지원하지 않기로 이미 협의했는데 고객사 담당자가 모르고 있었던 것! 이번 기회에 팀장님이 ES6에 대해 설명해주셨는데 더 궁금해서 찾아봤다. ES6ES6이란 ECMAScript 2015 의 약어로 ES2015라고도 불린다.European Computer Manufacturer’s Association(이하 ECMA)에서 js와 Node.js의 기초가 되는 범용 프로그래밍 언어인 ECMAScript를 제정한다. 즉, 스크립트 언어(링크)가 어떻게 생겨야 하는 지에 관한 기준이다. 대표적인 ES6문법 const변수와 let변수 화살표 함수 템플릿 리터럴:백틱을 사용해 문자열 내 변수 사용가능1234// 화살표함수와 템플릿 리터럴 예시const myIntro = (name, mobile) =&gt; { return `안녕하세요. 이름은 ${name}이고 제 연락처는 ${mobile}입니다.`} 프로미스(Promise) 객체 비구조화: 배열 또는 객체의 값을 새 변수에 쉽게 할당 가능12// 객체 비구조화 예시let {name, mobile} = user; JavaScript와 ECMAScript 관계실상 두 용어는 혼용되곤 한다.왜냐하면 JavaScript는 1996년에 만들어졌고 이를 표준화하기 위해 ECMAScript가 1997년에 만들어졌다. 그 후 ECMAScript를 준수하면서 JavaScript가 발전해왔다.즉 서로가 서로를 바라보고 있는 셈이다. 배운점사실 어떤 기능을 사용하건 다양한 브라우저의 호환성 문제를 항상 먼저 확인해야한다.크롬브라우저에서 된다고 모든 브라우저에서 다 되는 게 아니니까! 따라서 프로젝트기획때부터 어떤 브라우저 버전까지 지원할지를 명확히 하는 습관이 필요하다!난중에 시니어가 된 후 프로젝트 계약시 꼭 호환성 문제를 특약으로 명시해야겠다. 그나저나 만약 호환성문제가 있다면 사용했던 ES6기능을 눈물을 머금고 싹 다 걷어내야하는걸까??NOPE!세상에는 천재들이 많고 그 천재들이 이미 호환성 문제를 해결해주는 라이브러리들을 만들어놨기때문이다.예를 들어 IE에서 Promise를 사용하고 싶은 경우 bluebirdjs(링크)라는 라이브러리를 사용하면 된다. 참고 https://en.wikipedia.org/wiki/ECMAScript https://www.educative.io/edpresso/what-is-ecmascript https://wormwlrm.github.io/2018/10/03/What-is-the-difference-between-javascript-and-ecmascript.html https://www.freecodecamp.org/news/write-less-do-more-with-javascript-es6-5fd4a8e50ee2/","link":"/2022/04/18/220418ECMAScript/"},{"title":"input 공백 입력방지하는 가장 쉬운 방법","text":"input태그의 value가 공백일 경우 유효성체크를 해야한다.머릿속에는 여러 가지 방법이 둥둥 떠올랐다. 정규표현식으로 아예 패턴을 만들까? 그냥 trim을 쓸까? validation 라이브러리를 쓸까?이 중 가장 접근이 빠른 방법은 무엇일까?프로젝트는 이미 제이쿼리를 쓰고 있었기에 그냥 trim을 쓰는 것이 에너지를 아껴 다른 코드를 더 집중해서 볼 수 있는 길이라고 판단했다. 기존 코드기존 코드는 value가 빈 값인지만 확인하기 때문에 공백을 입력할 경우 if 조건절에 걸리지 않는다. 12345678910$(document).ready(function() { $(\"button[data-role=submit]\").click(function() { if($('input[name=\"nm\"]').val() == ''){ toastr.info('이름은 필수 입력입니다.'); $('input[name=\"nm\"]').val(''); $('input[name=\"nm\"]').focus(); return false; } })}); 공백 입력시 유효성 체크 코드trim()만 넣어주면 해결! 12345678910$(document).ready(function() { $(\"button[data-role=submit]\").click(function() { if($('input[name=\"nm\"]').val().trim() == ''){ toastr.info('이름은 필수 입력입니다.'); $('input[name=\"nm\"]').val(''); $('input[name=\"nm\"]').focus(); return false; } })});","link":"/2022/04/19/220419trim/"},{"title":"input태그에 스크립트 방지하는 방법(XSS 방지)","text":"프로젝트 테스트기간이라 몇가지 수정해달라는 요청받았다.엑셀로 받았는데 수정사항 내용이 글제목에 태그가 입력됨. 으로 왔길래 무슨 말일까 고민하고있었다.팀장님이 “XSS방어하면 돼요~”라고 말씀해준 뒤에야 이해할 수 있었다. 아 html태그를 말하는 거였구나.태그가 입력된다는 말이 진짜 html태그가 들어간다는 말이었구나. XSS란?XSS란 Cross-site scriptiong에 약어로 input태그에 자바스크립트 함수등의 실행코드를 고의로 작동시켜 해당 사이트를 마음대로 컨트롤하며 Data등을 빼내갈 수 있는 공격법이다.예를 들어 게시글을 수정할때 input태그에 &lt;script&gt;alert('XSS테스트');&lt;/script&gt; 를 입력한 뒤 글 수정버튼을 클릭하면 서버사이드랜더링으로 출력되는 값을 그대로 실행하기 때문에 XSS되어 alert창이 실행된다.간단한 alert창이어서 망정이지 DB를 접근하거나 아예 사이트를 제어하는 스크립트를 실행시키는 경우 보안상 큰 문제가 발생할 수 있다. 1 Service에서 XSS 방어하기XSS를 방어하기 위해서 서버측에서 필터링을 걸어야한다.구글링을 통해 다양한 방법을 찾을 수 있다.보통 script, iframe, embed는 보안에 취약할 수 있기에 꼭 삭제해줘야한다. XssUtil.java123456789101112131415public class XssUtil { public static String cleanXSS(String value) { String returnVal = value; returnVal = returnVal.replaceAll(\"&lt;\", \"&amp;lt;\").replaceAll(\"&gt;\", \"&amp;gt;\"); returnVal = returnVal.replaceAll(\"\\\\(\", \"&amp;#40;\").replaceAll(\"\\\\)\", \"&amp;#41;\"); returnVal = returnVal.replaceAll(\"'\", \"&amp;#39;\"); returnVal = returnVal.replaceAll(\"eval\\\\((.*)\\\\)\", \"\"); returnVal = returnVal.replaceAll(\"[\\\\\\\"\\\\\\'][\\\\s]*javascript:(.*)[\\\\\\\"\\\\\\']\", \"\\\"\\\"\"); returnVal = returnVal.replaceAll(\"script\", \"\"); returnVal = returnVal.replaceAll(\"iframe\", \"\"); returnVal = returnVal.replaceAll(\"embed\", \"\"); return returnVal; }} 그리고 호출은 서비스에서 진행하면된다. BoardServiceImpl.java1234567@Override@Transactionalpublic void updateBoard(BoardInfo info) { info.setSubject(XssUtil.cleanXSS(info.getSubject())); // 중략 boardDao.updateBoard(info);} 2 JAVA fILTER를 통해 XSS 방어 XSSFilter.java 12345678910111213141516171819public class XSSFilter implements Filter {public FilterConfig filterConfig; public void init(FilterConfig filterConfig) throws ServletException { this.filterConfig = filterConfig; } public void destroy() { this.filterConfig = null; } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { chain.doFilter(new RequestWrapper((HttpServletRequest) request), response); }} RequestWrapper.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final class RequestWrapper extends HttpServletRequestWrapper { public RequestWrapper(HttpServletRequest servletRequest) { super(servletRequest); } public String[] getParameterValues(String parameter) { String[] values = super.getParameterValues(parameter); if (values==null) { return null; } int count = values.length; String[] encodedValues = new String[count]; for (int i = 0; i &lt; count; i++) { encodedValues[i] = cleanXSS(values[i]); } return encodedValues; } public String getParameter(String parameter) { String value = super.getParameter(parameter); if (value == null) { return null; } return cleanXSS(value); } public String getHeader(String name) { String value = super.getHeader(name); if (value == null) return null; return cleanXSS(value); } private String cleanXSS(String value) { String returnVal = value; returnVal = returnVal.replaceAll(\"&lt;\", \"&amp;lt;\").replaceAll(\"&gt;\", \"&amp;gt;\"); returnVal = returnVal.replaceAll(\"\\\\(\", \"&amp;#40;\").replaceAll(\"\\\\)\", \"&amp;#41;\"); returnVal = returnVal.replaceAll(\"'\", \"&amp;#39;\"); returnVal = returnVal.replaceAll(\"eval\\\\((.*)\\\\)\", \"\"); returnVal = returnVal.replaceAll(\"[\\\\\\\"\\\\\\'][\\\\s]*javascript:(.*)[\\\\\\\"\\\\\\']\", \"\\\"\\\"\"); returnVal = returnVal.replaceAll(\"script\", \"\"); returnVal = returnVal.replaceAll(\"iframe\", \"\"); returnVal = returnVal.replaceAll(\"embed\", \"\"); return returnVal; }} web.xml 에 필터설정 추가12345678&lt;filter&gt; &lt;filter-name&gt;XSS&lt;/filter-name&gt; &lt;filter-class&gt;com.test.api.XSSFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;XSS&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3 lucy 라이브러리 사용네이버에서 만든 lucy-xss-filter(링크) 라이브러리가 있다.링크에 접속하면 한국어로 친절히 설명되어있다.pom.xml파일과 web.xml파일, lucy-xss-servlet-filter-rule.xml파일을 설정해주면 된다!가장 사용하기 좋은 방법이 아닐까한다. 실제로 1번 방식으로 했다가 3번방식으로 바꿨다!","link":"/2022/04/20/220420XSS/"},{"title":"Async await를 Deferred로 걷어내기","text":"ES6문법으로 작업한 내용을 다 걷어내고 ES5문법에 맞춰 작업할 일이 생겼다.Async await를 쓴 것들을 싹 걷어냈다. ES6에서 ES5로 바로 문법을 변환해주는 사이트(링크)도 있다.이런 일은 사실 생기면 안 되는건데… 인생은 어쩔수없다. Async await 사용12345678function setSelectBox(nextSelectTagId, parntsId) { return new Promise(function(resolve, reject) { $.get(\"/admin/tree?parntsId=\" + parntsId, function(data, status) { // 코드생략 resolve(); }); });} 위 함수는 아래처럼 사용가능하다. 123456async function show(e) { var checkedDateset = e.dataset; await setSelectBox('lev2ClId', checkedDateset.clid1); await setSelectBox('lev3ClId', checkedDateset.clid2); // 코드 생략} DeferredPromise 선언한 부분은 Deferred로 대체했다.Deferred는 제이쿼리에서 프로미스를 사용할때 쓰는 객체이다.먼저 $.Deferred()로 deferred 객체를 만들고 성공시 resolve호출하면 프로미스의 done이 연결되고, 실패시 reject를 호출하면 fail로 연결된다.그리고 함수의 리턴은 항상 dfd.promise();로 해야한다. 123456789function setSelectBox(nextSelectTagId, parntsId) { var dfd = $.Deferred(); $.get(\"/admin/tree?parntsId=\" + parntsId, function(data, status) { // 코드생략 dfd.resolve(); }); return dfd.promise();} 위 함수를 아래처럼 사용하면 된다. 12345678function show(e) { var checkedDateset = e.dataset; setSelectBox('lev2ClId', checkedDateset.clid1).then(function() { return setSelectBox('lev3ClId', checkedDateset.clid2); }).then(function() { // 코드 생략 }}","link":"/2022/04/24/220424AwaitToDeferred/"},{"title":"el태그 대신 &lt;c:out&gt; 사용하는 이유","text":"jsp에서 다양한 방식으로 서버사이드 데이터를 출력할 수 있다.그 중 가장 많이 쓰는건 el태그인데 그 이유는 el태그 사용법이 ${}로 매우 간단하기때문이다. el태그만 써도 화면에 값이 잘 출력되는데 왜 굳이 &lt;c:out&gt;를 사용할까? 결론: XSS 방어하기 위해! &lt;c:out&gt;를 사용하면 escapeXml속성을 활용할 수 있다. escapeXml를 true로 설정함으로써 가장 간단하게 XSS(링크)를 방어할 수 있다. 12345// 1.escapeXml = true 인 경우(디폴트)&lt;c:out value=\"&lt;script type='text/javascript'&gt;alert('테스트');&lt;/script&gt;\"/&gt;// 2.escapeXml = false 인 경우 == el태그와 동일&lt;c:out value=\"&lt;script type='text/javascript'&gt;alert('테스트');&lt;/script&gt;\" escapeXml=\"false\"/&gt; escapeXml = true의 경우, text 그대로 출력된다. escapeXml = false 인 경우나 el태그인 경우, alert창이 실행된다. 따라서 XSS 방어하기 위해서는 &lt;c:out&gt;을 사용하는 게 좋다.","link":"/2022/04/26/220426-xssCout/"},{"title":"Docker는 어떻게 HostOS와 다른 운영체제에서 돌아갈까?","text":"오늘 VM에 대해 팀장님과 이야기하다가 문득 Docker로 어떻게 리눅스OS를 쓸 수 있는지가 궁금해졌다.HostOS가 원도우 환경에서 VM은 GuestOS를 원하는 대로 설치할 수 있으니 리눅스든 우분투든 원하는 OS를 쓸 수 있다.하지만 Docker는? Docker는 GuestOS를 설치하지 않고 HostOS를 활용한다. 그래서 VM보다 훨씬 가볍고 빠르다. HostOS가 원도우 환경인 Docker에서 어떻게 리눅스OS를 사용할 수 있을까?여러 구글링을 끝에 내가 내린 결론이다. 따라서 정확하지않을 수 있다. (잘못된 부분은 댓글로 알려주시면 이 글을 읽는 모두에게 도움이 됩니다. 감사하겠습니다!)Docker Desktop for Windows(링크)를 다운로드 받으면 리눅스 엔진이 함께 설치된다.이 리눅스엔진을 통해서 리눅스OS나 우분투OS를 사용할 수 있다! 같이 읽으면 좋은 글 컨테이너, 도커, 쿠버네티스","link":"/2022/04/27/220427DockerDefinition/"},{"title":"ajax랑 axios는 무슨 차이가 있을까?","text":"프로젝트를 진행하다보면 클라이언트와 서버간의 데이터를 요청응답받기 위해 HTTP통신을 하게 된다.이때 자주 사용하는 라이브러리로는 jQuery.ajax와 axios가 있다.이 둘의 차이점은 무엇일까? ajax는 라이브러리인가?wikipedia(링크)에 따르면 ajax는 라이브러리가 아니라 비동기 통신 웹 개발 기술이다. 123456789101112Ajax (also AJAX /ˈeɪdʒæks/; short for \"Asynchronous JavaScript and XML\")[1][2] is a set of web development techniques that uses various web technologies on the client-side to create asynchronous web applications. With Ajax, web applications can send and retrieve data from a server asynchronously (in the background) without interfering with the display and behaviour of the existing page. By decoupling the data interchange layer from the presentation layer, Ajax allows web pages and, by extension, web applications, to change content dynamically without the need to reload the entire page.[3] In practice, modern implementations commonly utilize JSON instead of XML.Ajax is not a technology, but rather a programming concept. HTML and CSS can be used in combination to mark up and style information. The webpage can be modified by JavaScript to dynamically display—and allow the user to interact with the new information. The built-in XMLHttpRequest object is used to execute Ajax on webpages, allowing websites to load content onto the screen without refreshing the page. Ajax is not a new technology, nor is it a new language. Instead, it is existing technologies used in a new way.by wikipedia ajax 이 기술을 구현한 라이브러리가 바로 jQuery.ajax()와 axios이다. jQuery.ajax()사용법은 아래와 같다. 12345678$.ajax({ method: \"POST\", url: \"some.php\", data: { name: \"John\", location: \"Boston\" }}) .done(function( msg ) { alert( \"Data Saved: \" + msg ); }); axiosaxios 공식문서(링크)에 따르면 axios는 node.js와 브라우저를 위한 프로미스기반의 HTTP통신 라이브러리이다. 123Axios is a promise-based HTTP Client for node.js and the browser. It is isomorphic (= it can run in the browser and nodejs with the same codebase). On the server-side it uses the native node.js http module, while on the client (browser) it uses XMLHttpRequests. 사용법 예시는 아래와 같다. 1234567891011121314151617181920212223242526272829303132333435363738394041const axios = require('axios');// Make a request for a user with a given IDaxios.get('/user?ID=12345') .then(function (response) { // handle success console.log(response); }) .catch(function (error) { // handle error console.log(error); }) .then(function () { // always executed });// Optionally the request above could also be done asaxios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }) .then(function () { // always executed }); // Want to use async/await? Add the `async` keyword to your outer function/method.async function getUser() { try { const response = await axios.get('/user?ID=12345'); console.log(response); } catch (error) { console.error(error); }} fetch도 있던데?fetch는 axios와 마찬가지로 promise기반 비동기 HTTP 클라이언트이다. 모던 브라우저에 내장되어있기에 바로 사용할 수 있다.사용법은 axios와 거의 유사하고 성능은 fetch가 조금 빠르다고 한다(링크).실무에선 아직 한 번도 사용해본적이 없는데 fetch는 몇몇 브라우저에선 지원이 안되기때문이다(링크). 12345678fetch(url, { method: 'GET', // other options: POST, PUT, DELETE, etc. headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}),}).then((response) =&gt; response.json()) .then((data) =&gt; console.log(data)) 참고하면 좋은 글 Ajax 는 라이브러리 인가요?","link":"/2022/04/30/220430JS-axiosVsajax/"},{"title":"전자정부프레임워크3.8에 CSRF 설정하기","text":"CSRF란 Cross Site Request Forgery로 보안 이슈이기때문에 꼭 해결해야한다. 스프링부트로는 CORS 설정을 한 적이 있는데 이번 프로젝트는 전자정부프레임워크를 사용해야해서 조금 새로웠다.전자정부프레임워크 공식문서(링크)에 spring security CSRF 간편설정이 있지만 왜인지 설정이 잘 되지않아 그냥 spring security를 pom.xml에 추가했다. pom.xml 에 의존성 추가프로젝트에 spring security를 추가한다. 1234567891011121314151617181920212223242526272829&lt;properties&gt; &lt;spring.maven.artifact.version&gt;4.3.16.RELEASE&lt;/spring.maven.artifact.version&gt; &lt;egovframework.rte.version&gt;3.8.0&lt;/egovframework.rte.version&gt; &lt;security.version&gt;4.2.13.RELEASE&lt;/security.version&gt;&lt;/properties&gt;(중략) &lt;!-- spring security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;${security.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;${security.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;${security.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;${security.version}&lt;/version&gt; &lt;/dependency&gt;(생략) web.xml 추가아래 필터를 추가한다. 123456789&lt;!-- spring security --&gt;&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; context-security.xml 생성context 설정에 따라 이름에 맞는 시큐리티 config xml파일을 생성한다. 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:sec=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd\"&gt; &lt;sec:authentication-manager alias=\"authenticationManager\" /&gt; &lt;!-- 인증예외처리 --&gt; &lt;sec:http pattern=\"/admin/**\" security=\"none\" /&gt; &lt;sec:http pattern=\"/css/**\" security=\"none\" /&gt; &lt;sec:http pattern=\"/img/**\" security=\"none\" /&gt; &lt;sec:http pattern=\"/js/**\" security=\"none\" /&gt; &lt;sec:http pattern=\"/uploads/**\" security=\"none\" /&gt; &lt;sec:http pattern=\"/file/**\" security=\"none\" /&gt; &lt;!-- 접근경로 권한처리 --&gt; &lt;sec:http use-expressions=\"true\"&gt; &lt;!-- 로그인 페이지 정보 --&gt; &lt;sec:form-login /&gt; &lt;sec:csrf disabled=\"false\" /&gt; &lt;/sec:http&gt;&lt;/beans&gt; form-login 로그인 페이지를 연결하면 CSRF를 방어할 수 있다.커스텀한 로그인 로직을 사용하기때문에 &lt;sec:form-login /&gt;해당 부분을 빼고 싶었는데 해당 코드를 빼면 서버 에러가 나서 입력만 하고 연결하지 않았다.참고로 disabled=”false”가 CSRF를 사용하겠다는 의미이다. 토큰을 jsp화면에 넣기form태그 아래에 넣어주면 된다! 1&lt;sec:csrfToken&gt;","link":"/2022/05/02/220502springsecurity-CSRF/"},{"title":"괄호가 &amp;#41;로 자동으로 바뀌어버릴때 해결법(ft.EscapeHtml)","text":"jsp페이지에서 검색을 하는데 자동으도 괄호가 escape되어 쿼리에서 where 조건절이 검색되지않았다. 🥨 문제 상황아래 예시를 보자. option의 value값에 괄호가 들어가있다. 그결과 브라우저가 자동으로 jsp페이지 123456789(코드 생략)&lt;form name=\"searchFrm\" method=\"get\" action=\"/example\"&gt; &lt;select name=\"calType\"&gt; &lt;option value=\"\"&gt;:: 전체 ::&lt;/option&gt; &lt;option value=\"달력(움력)\" &lt;c:if test=\"${searchInfo.calType eq '달력(움력)'}\"&gt;selected&lt;/c:if&gt;&gt;달력(움력)&lt;/option&gt; &lt;option value=\"달력(양력)\" &lt;c:if test=\"${searchInfo.calType eq '달력(양력)'}\"&gt;selected&lt;/c:if&gt;&gt;달력(양력)&lt;/option&gt; &lt;/select&gt;&lt;/form&gt;(코드 생략) sql쿼리 12345678SELECT *FROM tb_exampleWHERE 1 = 1AND USE_AT = 1AND CAL_TYPE = #{calType} 실행결과 CAL_TYPE 조건이 달력(음력)이 아닌 달력&amp;#40;음력&amp;#41;으로 where 조건절이 들어갔기에 원하는 데이터가 나오지않았다. 12345678SELECT *FROM tb_exampleWHERE 1 = 1AND USE_AT = 1AND CAL_TYPE = '달력&amp;#40;음력&amp;#41;' 🥨 원인이는 브라우저에서 자동으로 문자열 escape를 하기 때문이다. 문자열 escape란? 브라우저에서 get방식 전송시 브라우저 자체적으로 UTF-8문자를 escape한다. 🥨 해결방법따라서 unescape를 해주면 해결된다.크게 3가지 방법이 있다. org.springframework.web.util.HtmlUtils.htmlUnescape org.apache.commons.lang.StringEscapeUtils.escapeHtml replace메서드 사용 1 HtmlUtils.htmlUnescape 사용컨트롤러에서 받은 파라미터를 unescape한다. 123(중략)param.setCalType(HtmlUtils.htmlUnescape(param.getCalType()));(생략) 2 StringEscapeUtils.escapeHtml 사용컨트롤러에서 받은 파라미터를 unescape한다. 123(중략)param.setCalType(StringEscapeUtils.escapeHtml(param.getCalType());(생략) 3 replace() 사용컨트롤러에서 받은 특정 파라미터를 replace메서드를 이용해 바꿔준다. 1234(중략)param.getCalType().replace(\"&amp;#40;\", \"(\");param.getCalType().replace(\"&amp;#41;\", \")\");(생략) 🥨 선택현재 전자정부프레임워크3.8환경이므로 스프링프레임워크에서 제공하는 htmlUnescape메서드를 사용했다.내 상황에서는 escape가 1번했는데도 정상출력이 되지않아 찾아보니 escape가 2번 되어있었다. 왜일까…?암튼 unescape를 2번해서 해결했다. Controller.java 1234(중략)String calTypeUnescape = HtmlUtils.htmlUnescape(param.getCalType());param.setCalType(HtmlUtils.htmlUnescape(calTypeUnescape));(생략) 적용한 뒤 콘솔을 보니 아래처럼 쿼리가 원하는대로 정상출력됐다. 12345678SELECT *FROM tb_exampleWHERE 1 = 1AND USE_AT = 1AND CAL_TYPE = '달력(음력)' 해결!","link":"/2022/05/05/220506EscapeHtml/"},{"title":"전자정부프레임워크프로젝트를 끝내며 내가 배운 것","text":"전자정부프레임워크(링크)는 이번 프로젝트에서 처음 사용해보았다. 사실 특별히 새로울 건 없었다. 왜냐하면 Spring프레임워크와 거의 똑같기 때문이다. 전자정부프레임워크란 “효율적인 정보시스템 개발을 위한 코드 라이브러리, 인터페이스규약, 설정정보 등의 뼈대를 제공하는 표준프레임워크”라고 한다.즉, egovframework는 Spring프레임워크 + MyBatis + MySql + Jsp + Jquery 조합에다가 전자정부프레임워크가 제공하는 라이브러리나 클래스가 추가되어있다고 보면 된다. Keep현재 만족하고 있는 부분과 계속해서 이어갔으면 하는 부분 가능한 많은 기능을 담당하고자 한 것!팀장님이 일이 많아서 팀장님이 담당하시는 기능 중 일부를 받아냈다. 덕분에 하나의 프로젝트에서 다양한 기능을 담당하여 개발할 수 있었다! 야근도 꽤 했지만 많이 성장했다! 뿌듯해! 프로젝트 설정을 추가한 것!프로젝트 진행 중 CSRF 방어가 필요했는데 여러 방법으로 해결할 수 있었다. 각 페이지마다 하거나 form태그마다 할수도 있었지만 프로젝트 차원에서 해결하는 방법이 가장 좋다고 판단이 들어 Spring Security도입을 건의했다. 다행히 잘 받아들여져서 프로젝트 설정을 직접 추가하는 경험을 할 수 있었다. 프로젝트 진행 중간에 프로젝트 셋팅을 건든다는 게 살짝 두려웠던 건 사실이다. 혹시나 내가 추가한 설정들때문에 잘되던 동작들이 꼬일까봐 걱정했는데 다행히 잘 작동해서 정말 뿌듯했다. XSS와 CSRF의 차이를 명확히 안 것!CSRF(링크)는 사이트 간 요청 위조 약자로 공격대상이 Server이다.XSS(링크)는 사이트 간 스크립팅의 약자로 공격대상이 Client이다. ES5와 ES6 차이를 정확히 안 것!브라우저 호환성과 ES5와 ES6 차이(링크)를 확실히 알게되었다. 검색조건 유지를 위해 return url을 사용 한 것!필수기능이라고도 할 수 있는 검색조건 유지기능 시작 전에는 어려울 줄 알았는데 막상해보니 간단하게 끝났다! return url을 사용하여 목록화면에서 상세화면으로 들어갔다가 뒤로 가기를 해도 페이징과 검색조건이 그대로 유지되도록 구현했다. 달력 라이브러리를 커스텀해서 썼다.디자인팀에서 퍼블을 하는데 달력을 넣기 힘들다고 지원요청을 받았다. 달력 라이브러리를 구글링하며 제일 적합하고 커스텀할 수 있는 라이브러리를 선택해서 적용하고 특정 날짜를 클릭하지 못하게 막는다던지, DB에 저장된 날짜는 클릭안되게 달력에 처리한다든지 등 프론트와 백을 넘나들며 기능을 완성했다. library docs가 충분하지않아서 영어로도 엄청 검색을 하면서 구현했는데 꽤나 재미있는 경험이었다. Problem개선이 필요하다고 생각되는 부분 트리구조 메뉴를 개발하는데 쿼리로 애를 많이 먹었다. 서버로 재귀호출을 돌리면서 tree데이터를 json으로 만들어 화면에 던진 뒤에 jsTree라이브러리(링크)를 사용해 개발을 완료할 수 있었다. 고급 SQL에 대한 공부가 필요하다. egovframework를 충분히 활용하지 못했다. 시간도 없을뿐더라 기존 CMS를 건들이지 않는 선에서 다루느라 egovframework의 많은 기능을 활용하지못해 아쉽다. 프로젝트 전체 흐름을 이해하는 데 꽤나 시간이 걸렸다. 중간중간에 고객사 요구사항이 바뀌기도 했고 내가 담당해야하는 페이지가 계정 권한별로 달라서 초반에 헷갈렸다. 이윽고 적응했지만 더 빠르게 프로젝트 전체 그림을 파악하고 싶다. TryProblem의 해결책이 될 수 있는 부분 recursive등 고급 SQL을 더 깊게 공부할 것 프로젝트셋팅때부터 질문을 미친듯이 할 것 프로젝트를 한 눈에 빨리 파악하기 위해서는 역시 다양한 프로젝트를 접해본 경험이 중요하다. 앞으로도 성장할 수 있는 기회가 보인다면 미리 걱정하지말고 기회를 잡을 것. 코드리뷰 및 질의응답팀장님께 부탁드려서 코드리뷰를 진행했다! 바쁘신 와중에도 코드리뷰와 프로젝트리뷰 제안을 흔쾌히 수락해주셨다. 감사합니다 팀장님😀코드리뷰시간을 알차게 사용하기 위해서는 준비를 철저히 해야한다. 팀장님이 구현한 기능들을 쭈욱 살피고 궁금했던 점들과 구글링을 통해 나오지 않는 질문들, 그리고 구현하던 중 궁금했던 모든 것들을 미리 한 데 모아 노션에 정리했다. pathvariable보다는 query parameter를 사용하는 게 더 나은가요?이번에 디테일페이지를 들어갈때 pathvariable를 사용했는데 중간에 로직수정이 필요한 바람에 전부 query parameter를 사용하게 되었다.그럼 처음부터 query parameter를 사용하는 게 나았을까하는 의문이 들었다. 네이버나 다음같은 대형사이트들도 대부분 query parameter를 사용하길래 pathvariable은 덜 사용되는 건지 궁금해서 문의드렸다.팀장님이 답변해주시길 RESTful API에 맞게 설계하려면 pathvariable를 사용하면 되고 그게 아니라면 query parameter가 더 나은 프로젝트들도 있다고 답변해주셨다! async await는 비동기일때 사용할 것!이번에 async await를 이용하여 코드를 구현했는데 팀장님이 코드개선을 한 번해주셨다. 비동기작업이 없는 경우 async await보다는 flag변수를 선언해서 사용하면 빠르고 간단하게 동기작업을 할 수 있다! HashMap 사용시 파라미터 정리를 쉽게할 수 있다.파라미터가 많지 않은 경우 HashMap을 사용하여 DAO내에서 파라미터를 제대로 분리해주면 편리하게 사용할 수 있고 각 클래스의 역할도 완벽히 나눌수있다! MariaDB나 MySQL에서는 group by 사용시 모든 select 컬럼을 넣지 않아도 되는 이유?기본적으로 group by 사용시 select절의 모든 컬럼을 넣어줘야하는데 MariaDB나 MySQL에서는 넣지 않아도 정상작동한다.그 이유가 무엇일까? 바로 sql_mode에 only_full_group_by속성을 on한 경우(참고글) 모든 컬럼을 넣지않아도 DB가 알아서 group by시 필요한 컬럼들을 챙긴다.하지만 select절의 모든 컬럼을 넣지 않은 쿼리를 다른 DB에서 실행시 오류가 발행하므로 웬만하면 모든 컬럼을 다 기입하는 버릇을 들이는 것이 좋다. 구글링을 통해 알게된 정보들 중 좋은 글을 어떻게 판단할까요?프로젝트를 할때마다 구글링을 정말 많이하게되는데 관련 글을 읽다보면 서로 반대되는 주장을 하는 글이나 뭐보단 뭐가 더 좋다는 비교글이 많이 있다. 이때 어떤 것이 옳은 것인지 판단이 잘 안 설때가 종종 있어 팀장님께 정보글 판단 기준에 대해 여쭤보았다.팀장님의 경우 일단 수용 → 직접 테스트코드 작성 → 겪어봐야 알게 됨 주로 이 루트로 판단한다고 하셨다. 나도 글만 읽지말고 Test Unit등을 작성해보는 습관을 들여야겠다.","link":"/2022/05/09/220509prjtreview5/"},{"title":"JSP에서 엑셀다운로드할때 한글깨짐현상을 해결하는 가장 간단한 방법","text":"JSP에서 엑셀다운로드를 할때 한글깨짐 현상이 나타났다. 이를 해결할 수 있는 가장 간단한 방법이 있다. 원인이럴때는 meta태그에 utf-8이 잘 설정되어있는지 확인하면 된다.만약 utf-8설정을 찾을 수 없다면 코드를 head사이에 추가하면 된다. 해결1234&lt;head&gt;// (중략)&lt;meta http-equiv='Content-Type' content='application/vnd.ms-excel; charset=utf-8'/&gt;&lt;/head&gt;","link":"/2022/05/10/220511ExcelKoreanError/"},{"title":"[JS]scope 스코프","text":"이번에 프로젝트를 진행하면서 버그가 발생했는데 알고보니 스코프문제였다.이번 기회에 스코프에 대해 확실히 정리해보고자 한다. 스코프란?w3school에 따르면(링크) Scope란 변수의 유효한 범위이다. &lt; 스코프종류 &gt; Global scope Local Scope Block scope Function scope ES6이전에는 js는 Global Scope and Function Scope만 있었다.ES6전에는 var만 있었는데 ES6이후로 let과 const가 생겨나면서 block scope 개념도 함께 생겨났다. 1 Global scope 블록스코프이름그대로 변수가 전역에 선언된 경우이다.어디서든 접근이 가능하다. 어디서나 접근가능하기때문에 편리한 장점이 있지만 코드가 길어질수록 휴먼에러가 날 확률이 높아진다. 123456let carName = \"Volvo\";// code here can use carNamefunction myFunction() {// code here can also use carName} 2 Block scope 블록스코프블록스코는 브라켓{}블록안에서만 변수가 유효할때를 뜻한다. 아래 비교예시를 보자. var 키워드 사용 1234{ var x = 2;}// x CAN be used here let 또는 const 키워드 사용 1234{ let x = 2;}// x can NOT be used here 위 두 예시의 차이에서 알 수 있듯이 브라켓 {}을 벗어나도 선언한 변수를 호출할 수 있는지 없는지로 블록스코프인지를 확인할 수 있다.var변수는 블록스코프가 아니기때문에 변수관리에 있어 문제를 초래하기도 한다. 3 Function Scope 로컬스코프말그대로 함수 안에서 선언한 변수로 함수안에서만 호출가능하고 함수 밖에서는 호출할 수 없다. 12345678// code here can NOT use carNamefunction myFunction() { let carName = \"Volvo\"; // code here CAN use carName}// code here can NOT use carName Static Scoping (Lexical Scoping)JavaScropt, C, Java 등에서는 Static Scoping을 따른다. 즉, 함수를 어디서 선언했는지에 따라 상위 스코프를 결정하는 것이다.var를 사용하여 변수를 선언했을때 어떻게 값이 나올까? 1234567891011var num = 7;function a(){ var num = 17; b();}function b(){ console.log(num);} a(); //값은?b(); //값은? output 1277 a()의 호출값이 17이 아니고 왜 7인 걸까? 함수가 언제 호출되는지에 따르는 게 아니라 함수를 어디에 선언했냐에 따라 상위 스코프가 결정되기 때문이다.num은 이미 두 함수보다 먼저 선언했으므로 7은 17로 덮어써지지않고 그대로 7로 출력된다. 참고로 함수 호출에 따라 스코프가 결정되는 것을 Dynamic Scope라고 한다. Perl, Bash Shell 등에서 사용된다.","link":"/2022/05/16/220517JSscope/"},{"title":"[리액트]Error: Cannot find module loader에러 해결","text":"리액트가 궁금해 정적사이트를 하나 만들고 있다.script를 정의하고 npm run start를 했는데 아래와 같은 오류가 발생했다. 123456789101112131415node:internal/modules/cjs/loader:361 throw err; ^Error: Cannot find module '/workspace/프로젝트명/node_modules/finalhandler/node_modules/debug/src/index.js'. Please verify that the package.json has a valid \"main\" entry at tryPackage (node:internal/modules/cjs/loader:353:19) at Function.Module._findPath (node:internal/modules/cjs/loader:566:18) at Function.Module._resolveFilename (node:internal/modules/cjs/loader:919:27) at Function.Module._load (node:internal/modules/cjs/loader:778:27) at Module.require (node:internal/modules/cjs/loader:1005:19) at require (node:internal/modules/cjs/helpers:102:18) code: 'MODULE_NOT_FOUND', path: '/workspace/프로젝트명/node_modules/finalhandler/node_modules/debug/package.json', requestPath: 'debug'} 에러를 보면 알수있듯 loader에서 err가 잡혔다.구글링하니 nodejs 레포의 이슈(링크)로 많은 개발자들이 해결방법을 주고받은 걸 확인할 수 있었다.이 여러 방법중 나는 아래의 방법으로 해결했다. 해결방법 npm cache clean --force 명령어로 캐시를 삭제한다. node_modules 폴더를 삭제한다. package-lock.json 파일을 삭제한다. npm install 명령어를 입력하면 node_modules와 package-lock.json가 다시 설치된다. 위 조치를 취한 후 npm run start를 하니 잘 실행된다.해결!","link":"/2022/05/22/220523ReactLoaderError/"},{"title":"[닷넷] Url.Action사용해서 원하는 URL연결하기","text":"cshtml에서 Url.Action으로 a태그 href를 변경하고 싶었다. 파일구조 Areas Student Controller LearningController.cs View Index.cshtml Professor Controller StudyController.cs View Index.cshtml 내가 원하는 것은 아래처럼 2개의 a태그에 각각 다른 컨트롤러의 url이다. 123// url결과/Student/Learning/Professor/Study 기존코드12&lt;a href=\"@Url.Action(\"Index\",\"Learning\")\" id=\"menuUrl\"&gt;&lt;a href=\"@Url.Action(\"Index\",\"Study\")\" id=\"menuUrl\"&gt; url결과는 아래와 같다 123// url결과/Student/Learning/Student/Study Action(string, string)은 처음 URI를 잡고있기때문에 Professor의 Study가 아니라 Student에서 Study를 찾는다. 해결법 Action(String, String, Object)routeValues를 사용해서 area를 지정해주었다. 12&lt;a href=\"@Url.Action(\"Index\", \"Learning\", new { area = \"Student\" })\" id=\"menuUrl\"&gt;&lt;a href=\"@Url.Action(\"Index\", \"Study\", new { area = \"Professor\" })\" id=\"menuUrl\"&gt; new 연산자로 area를 지정했기에 해당 area아래의 Url을 각각찾느다 123// url결과/Student/Learning/Professor/Study 참고MS사의 docs는 예시도 많이 없고 UI자체도 가독성이 많이 떨어진다. 그래도 docs 질은 괜찮은 건지 블로그글이 많이 없다. 닷넷개발자들은 영어고수인게 틀림없다. https://docs.microsoft.com/en-us/dotnet/api/system.web.mvc.urlhelper.action?view=aspnet-mvc-5.2#system-web-mvc-urlhelper-action(system-string-system-string-system-object)","link":"/2022/05/24/220525dotnet-Urlhelper/"},{"title":"[Vue]체크박스 모두 선택 기능 구현하기","text":"Vue.js를 이용하여 체크박스의 모두선택기능 기능을 만들어보자. 화면코드1234567891011121314151617181920212223242526&lt;table&gt; &lt;colgroup&gt; &lt;col width=\"10%\"&gt; &lt;col width=\"*\"&gt; &lt;col width=\"*\"&gt; &lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;input type=\"checkbox\" name=\"checkAll\" v-model=\"isCheckAll\"&gt;&lt;/th&gt; &lt;th&gt;고유번호&lt;/th&gt; &lt;th&gt;이름&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody v-if=\"mainDataset.getRowCount() == 0\"&gt; &lt;tr&gt; &lt;td colspan=\"8\"&gt;조회 된 데이터가 없습니다.&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody v-else&gt; &lt;tr v-for=\"(item, idx) in mainDataset.data\"&gt; &lt;td&gt;&lt;input type=\"checkbox\" v-model=\"userList\" :value=item.userNo&gt;&lt;/td&gt; &lt;td&gt;{{item.userNo}}&lt;/td&gt; &lt;td&gt;{{item.userNm}}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 스크립트 코드모달창을 열때마다 isCheckAll를 false로 초기화해주고 watch로 isCheckAll의 value가 변할때 메서드 checkAll()를 실행한다.여기서 핵심은 watch로 기존 값과 변경된 값을 지켜보고있다는 점이다. 1234567891011121314151617181920212223242526272829303132333435363738var app = new Vue({ el: '#userPopup', data: { searchParams: { searchText: \"\", pageNumber: 1 }, isCheckAll: false, userList: [], mainDataset: new Dataset(), mainDatasetPaging: new PagingSet(5, 10), }, watch: { \"isCheckAll\": { handler: function(val, oldVal) { this.checkAll(); } } }, mounted: function() { var self = this; $(this.$refs.userPopup).on(\"shown.bs.modal\", function() { self.isCheckAll = false; }); }, //중략 methods: { checkAll: function() { var self = this; app.userList = []; if (self.isCheckAll) { _.forEach(self.mainDataset.data, function(obj) { app.userList.push(obj.userNo); }); } }, }}) 이렇게해면 체크박스 전체선택시 각 체크박스의 userNo값이 userList배열에 담긴다!","link":"/2022/06/02/220603VueJS-checkall/"},{"title":"DOM과 가상DOM","text":"React나 Vue.js를 쓸때 가상돔을 많이 얘기한다.가상돔을 제대로 알고 싶어 DOM이 뭔지 공부해봤다. DOM(Document Object Model)DOM은 문서객체모델로서 xml이나 html문서에 접근하기 위한 일종의 인터페이스이다. DOM 종류 Core DOM 모든 문서 타입을 위한 DOM 모델, HTML DOM HTML 문서를 위한 DOM 모델, 모든 HTML 요소는 HTML DOM를 통해 접근가능 XML DOM XML 문서를 위한 DOM 모델, 모든 XML 요소는 XML DOM를 통해 접근가능 HTML태그들을 작성하면 자바스크립트는 어떻게 읽을까? 한 번쯤 궁금했을 것이다.자바스크립트는 HTML, head, body등의 요소를 구조화 한다.구조화에는 다양한 방식이 있다.이때 DOM은 트리구조를 형성한다. 즉 상위 노드와 하위 노드가 트리처럼 연결되어 있는데 여기서 만약 서른마흔다섯번째 노드를 update시키면 어떻게 될까?DOM은 수많은 노드들 중에서 특정 노드를 찾게 되고 그 과정에서 비용이 발생한다.만약 한 번의 update가 연결된 다른 500개의 노드들에 변경을 일으킨다면? 점점 더 많은 비용이 발생하게 된다. 이를 해결하기 위해 등장한 것이 바로 가상돔(Virtual DOM)이다. 가상돔(Virtual DOM)가상돔은 이름 그대로 실제DOM이 아닌 가짜DOM(HTML돔의 추상화)이다.웹페이지에서 사용자에 의해 이벤트가 발생된다면(update) 실제돔을 바로 수정하지않고, 가상돔을 랜더링한 뒤 이전의 돔과 비교해서 변경된 부분만 실제돔에 반영한다. 이로써 실제돔의 변경을 최소화하여 성능을 향상시킬 수 있다.","link":"/2022/06/05/220605VitualDOM/"},{"title":"findAsync와 find의 차이점","text":"닷넷프레임워크를 사용하다보면서 find 메서드를 사용했는데 비주얼스튜디오가 FindAsync를 추천해줬다.사용해보니 둘 다 동일한 결과가 나왔는데 둘의 차이점이 궁금해서 공부해보았다. Find비교적 간단한 구문이다.모든 문서를 한 번에 조회한다.따라서 데이터양이 작을 때 사용하면 좋다. 가져오는 데이터양이 클때 Find를 쓸 경우 뷰단이 멈춰버릴 수 있다. 이럴때 비동기인 FindAsync로 처리해야한다. FindAsync모든 DB를 한 번에 조회하지 않는다. return값이 cursor라서 DB cursor에서 문서를 하나씩 검색할 수 있는 interface를 제공한다.따라서 데이터양이 클 때 사용하면 좋다. 여기서 DB cursor란?쿼리문에 의해서 반환되는 결과값들을 저장하는 메모리공간을 말한다. 참고 https://docs.microsoft.com/en-us/dotnet/api/system.data.entity.dbset.findasync?view=entity-framework-6.2.0 https://stackoverflow.com/questions/30650722/difference-between-find-and-findasync","link":"/2022/06/11/220611findAsyncvsfind/"},{"title":"[요약&#x2F;후기]The End Of Localhost","text":"구독중인 GeekNews에서 아주 흥미로운 글을 봤다. 제목부터가 Localhost시대의 종말이다.GeekNews에서는 친절하게 한글번역 요약을 해주지만 원문이 궁금해서 원문을 읽고 나름 요약해봤다. 원문 바로가기글쓴이는 어떻게 Localhost가 종말한다는 걸까? 클라우드 덕분에! 미래에는 모든 환경은 클라우드가 될 것이고, 모든 노트북은 클라이언트가 될 것 2030년대 개발자가 위시리스트를 보면 로컬호스트가 아닌 클라우드 환경이 요구됨 dev환경과 prod환경간에 낭비되는 시간을 단축시킬 수 있음 The “Future is Just Not Evenly Distributed” Argument 이미 빅테크 기업들은 전적으로 클라우드 환경에서 일하고 있음. Google Cider : 구글의 웹 IDE. 거대한 Piper 파일 시스템을 탑재하고 코드리뷰/빌드/테스팅을 통합. 로컬머신에 코드를 내려받을 필요 없음FB On-Demand : 로컬보다 더 충실하게 실시간 기능 프리뷰가 가능하게 “On-Demand”로 환경을 프로비저닝. FB에선 “로컬 개발” 자체가 없음Etsy : 모든 개발이 Cloud VM에서 진행 “VSCode가 VM으로 SSH해서 동작하기 때문에, VM 외부로 코드를 체크아웃 해본 적이 없음”Tesla : 자동차 OS 개발을 로컬에서 클라우드로 전환 (그 전엔 개발자에게 빌드용 비싼 데스크탑을 제공했었다고)Palantir : Coder(리모트 개발환경 SaaS)와 EKS를 사용하는 Remote Ephemeral Workspace로 옮겨감Shopify : 대부분의 개발자가 Spin 이라 불리는 클라우드 개발환경으로 이전 (xhyve 위에서 실행되는 경량 VM)GitHub : 깃헙의 개발의 대부분을 Codespaces로 이관출처: https://news.hada.io/topic?id=6799&amp;utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=202226 “sure, but does it work for my small team?” 위 예시 기업들은 이미 큰 회사들이니까 가능한거고 작은 기업에는 그게 가능할까? 맞는 말임. 클라우드로 환경변화는 상당한 규모의 내부 투자가 이루어진 후에야 그 이득을 취할 수 있음. 하지만 기술이 상용화되면 점점 클라우드환경으로의 이동은 점점 더 확산될 것임 Jobs to Be Done of Localhost 이미 많은 프로그램에서 로컬을 실행하지 않고 원격으로 코드를 수정하고 실행하고 있음. The Inevitability Argument 클라우드로의 이동을 피할 수 없는 일임. 언젠가는 일어날 일임. The Potential of Edge Compute CRDT 및 에지 컴퓨팅과 같은 기술의 부상은 우리가 실제로 “로컬”이라고 생각하는 것의 경계를 흐리게 할 가능성이 더 높음. Pushback: It’s Still Not Good Enough 김칫국은 ㄴㄴ 아직 충분하지 않음. 개발자들이 습관처럼 Preview가 빠른 로컬호스트를 사용함 내생각개발환경으로 더이상 로컬호스트를 사용하지 않을 수 있다는 사실이 흥미로웠다.작은 업체에서 여전히 가능할까 의문이지만 그래도 클라우드환경으로의 변화는 막을 수 없을 것으로 보인다.그쪽으로 공부를 열심히 해봐야지 재밌는 표현 going the way of the Dodo: 인간에 의해 멸종된 도도새처럼 멸종된다는 의미이다.","link":"/2022/06/26/220627Article-TheEndOfLocalhost/"},{"title":"[Vue]computed를 찾다가 명령형프로그래밍과 선언형 프로그래밍 차이점까지 알게된 썰","text":"VueJS로 화면을 구성하다가 computed와 watch를 사용하는 데 있어 차이점이 궁금했다.둘이 역할이 비슷한 거 같은데 어떤 차이가 있을까? Vue.js 한글 공식문서에도 이와 관련해서 자세히 설명되어있다. computed 속성원래 computed 속성은 계산이 필요한 속성이 반복 호출될때 사용하는 속성이다.아래 코드와 같이 표현식으로 간단한 계산을 할 수 있지만 저 코드가 반복되서 사용되어야한다면? 여러 코드에 반복사용될수록 소스 코드가 지저분해질것이다. 1234// 간단한 계산&lt;p&gt;책을 가지고 있다:&lt;/p&gt;&lt;span&gt;{{ author.books.length &gt; 0 ? 'Yes' : 'No' }}&lt;/span&gt; 이때 computed 속성을 사용할 수 있다.Vue코드에서 아래처럼 호출한 뒤 123456789101112131415161718192021export default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } }, computed: { // 계산된 값을 반환하는 속성 publishedBooksMessage() { // `this`는 컴포넌트 인스턴스를 가리킵니다. return this.author.books.length &gt; 0 ? 'Yes' : 'No' } }} 화면에서는 아래처럼 간단하게 쓸 수 있어 가독성이 좋아진다. 12&lt;p&gt;책을 가지고 있다:&lt;/p&gt;&lt;span&gt;{{ publishedBooksMessage }}&lt;/span&gt; watchwatch속성은 직관적인 이름에서 알 수 있듯 특정데이터의 변화를 감지하고 지정한 함수를 실행하는 속성이다. 아래 예제는 firstName이나 LastName이 바뀌면 이를 각각 감지하고 fullName에 바뀐 부분을 반영해준다. 1&lt;div id=\"demo\"&gt;{{ fullName }}&lt;/div&gt; 12345678910111213141516var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' }, watch: { firstName: function (val) { this.fullName = val + ' ' + this.lastName }, lastName: function (val) { this.fullName = this.firstName + ' ' + val } }}) 여기엔 어떤 문제점이 있을까? firstName과 lastName안의 코드는 동일하게 바뀐 함수를 조합해 fullname을 리턴하는 데 불필요하게 코드를 반복한다. 명령형 프로그래밍이다. watch속성대신 computed속성을 사용하면 위 두 문제를 해결할 수 있다. 123456789101112var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } }}) 깔끔하긴 한데 왜 명령형 프로그래밍과 선언형 프로그래밍이 무엇이고 왜 선언형 프로그래밍이 더 좋다고 하는걸까? 명령형 프로그래밍 vs 선언형 프로그래밍일반적으로 선언형 프로그래밍이 명령형 프로그래밍보다 코드 반복이 적어서 좋다고 한다.명령평 프로그래밍과 선언형 프로그래밍을 검색하면 아래와 같은 정의를 마주하게 된다. 명령형 프로그래밍: How you do something 어떻게 할 것인지에 초점 선언형 프로그래밍: What you do 무엇을 할지에 초점. 머리로는 알겠는데(?) 언뜻 잘 와닿지 않는다!예시를 들으면 쉽게 와닿는다. 식당에 들어갔다고 생각해보자. 선언형 프로그래밍: 두사람이요~라고 말한다. 명령형 프로그래밍: 식당 내부 전체를 둘러본다 -&gt; 오른쪽 두번째 창가자리가 비어있음을 확인한다 -&gt; 거기까지 걸어간다 -&gt; 자리에 앉는다. 이렇듯 선언형 프로그래밍은 How를 알 필요가 없다. 결과만 잘 받으면 된다. 결과에만 신경쓰려면 뭐가 준비되어있어야할까?바로 잘 훈련된 종업원 즉, 명령형으로 이미 추상화가 되어있어야한다!선언형 프로그래밍은 추상화 된 코드는 독립적으로 사용할 수 있기때문에 재사용성이 높고 코드반복이 적다! 선언형 프로그래밍 언어 예시: SQL, HTML 명령형 프로그래밍 언어 예시: C, C++, JAVA 선언형과 명령형이 섞인 프로그래밍 언어 예시: JavaScript, C#, Python 참고 https://ui.dev/imperative-vs-declarative-programming https://v3-docs.vuejs-korea.org/guide/essentials/computed.html#basic-example","link":"/2022/06/27/220628Vuejs-computed/"},{"title":"스프링부트에 ModelMapper 적용하기(ft.더블콜론::)","text":"책 React.js, 스프링 부트, AWS로 배우는 웹 개발 101을 가지고 5주 스터디를 진행중이다. 책 내용이 정말 좋다! 강력추천서버API 실습과정에서 DTO를 Entity로 변경하기 위해 Builder패턴을 사용했지만 나는 ModelMapper를 사용해보았다. ModelMapper 추가하기책의 코드에서는 builder를 사용했는데 나는 ModelMapper를 사용하고 싶어서 바꿨다.TodoDTO의 toEntity메서드는 없애주고 Gadle에 ModelMapper를 임포트했다. build.gradle1234dependencies { //중략 implementation group: 'org.modelmapper', name: 'modelmapper', version: '2.4.2'} 그 다음 config 패키지를 추가하고 ModelMapperConfig.java파일을 생성했다. ModelMapperConfig.java123456789101112131415import org.modelmapper.ModelMapper;import org.modelmapper.convention.MatchingStrategies;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ModelMapperConfig { @Bean public ModelMapper modelMapper() { ModelMapper modelMapper = new ModelMapper(); modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); return modelMapper; }} 기존 코드책의 코드는 도서 공식 리포지토리에서 확인할 수 있다. TodoDTO.java 123456789101112131415161718192021@NoArgsConstructor@AllArgsConstructor@Datapublic class TodoDTO { private String id; private String title; private boolean done; public TodoDTO(final TodoEntity entity) { this.id = entity.getId(); this.title = entity.getTitle(); this.done = entity.isDone(); } public static TodoEntity toEntity(final TodoDTO dto) { return TodoEntity.builder() .id(dto.getId()) .title(dto.getTitle()) .done(dto.isDone()) .build(); }} TodoController.java 12345678910111213141516171819202122232425262728293031@RestController@RequestMapping(\"todo\")public class TodoController { @Autowired private TodoService service; @PostMapping public ResponseEntity&lt;?&gt; createTodo(@RequestBody TodoDTO dto) { try { String temporaryUserId = \"temporary-user\"; // temporary user id. // (1) TodoEntity로 변환한다. TodoEntity entity = TodoDTO.toEntity(dto); // (2) id를 null로 초기화 한다. 생성 당시에는 id가 없어야 하기 때문이다. entity.setId(null); // (3) 임시 유저 아이디를 설정 해 준다. 이 부분은 4장 인증과 인가에서 수정 할 예정이다. 지금은 인증과 인가 기능이 없으므로 한 유저(temporary-user)만 로그인 없이 사용 가능한 어플리케이션인 셈이다 entity.setUserId(temporaryUserId); // (4) 서비스를 이용해 Todo엔티티를 생성한다. List&lt;TodoEntity&gt; entities = service.create(entity); // (5) 자바 스트림을 이용해 리턴된 엔티티 리스트를 TodoDTO리스트로 변환한다. List&lt;TodoDTO&gt; dtos = entities.stream().map(TodoDTO::new).collect(Collectors.toList()); // (6) 변환된 TodoDTO리스트를 이용해ResponseDTO를 초기화한다. ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().data(dtos).build(); // (7) ResponseDTO를 리턴한다. return ResponseEntity.ok().body(response); } catch (Exception e) { // (8) 혹시 예외가 나는 경우 dto대신 error에 메시지를 넣어 리턴한다. String error = e.getMessage(); ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().error(error).build(); return ResponseEntity.badRequest().body(response); } }} 컨트롤러의 create메서드를 확인하다가 생소한 더블콜론(::)을 만났다.더블콜론(::)이 뭐지? 더블콜론(::)이 뭐지? 물고기 대신 물고기 잡는 법모르는 걸 만났을때 어떻게 검색해야할까?구글링해도 사용법만 나올뿐 더블콜론이 뭐하는 애다~라는 정의가 없었다.답답해하다가 팀장님께 살포시 질문을 들으니 물고기가 아닌 물고기 잡는 법을 알려주셨다.감사합니다 팀장님👍 언어를 사용하다 모르는 걸 만나면 언어 + 언어버전 + Language Specification의 조합으로 검색해보세요. 원하는 정보를 기본부터 얻을 수 있을 거예요From 팀장님 Language Specification을 검색할 생각은 전혀 못하고 있었는데 팀장님이 알려주신 덕에 얼른 java 1.8 language specification ::을 검색해서 찾아냈다! 내가 궁금했던 근본적인 정보가 다 들어있었다!이렇게 찾는 거구나! 또 하나 배웠다! 재밌어!😻 그래서 더블콜론이 뭔데?더블콜론은 Method Reference Expressions(메소드 참조 표현식)의 하나로 실제로 호출을 수행하지 않고 특정 형식의 메서드를 참조하는 역할을 한다. 1234567MethodReference: ExpressionName :: [TypeArguments] Identifier ReferenceType :: [TypeArguments] Identifier Primary :: [TypeArguments] Identifier super :: [TypeArguments] Identifier TypeName . super :: [TypeArguments] Identifier ClassType :: [TypeArguments] 간단한 예시(예시 더 공부하기)로 println을 보자. 12345// Get the streamStream&lt;String&gt; stream = Stream.of(\"치킨\", \"이랑\", \"여행\", \"가\", \"고싶다\");// Print the streamstream.forEach(s -&gt; System.out.println(s)); 위의 결과값은 아래와 같다. 123456//결과값치킨이랑여행가고싶다 이를 더블콜론으로 간단하게 표현할수도 있다. 1stream.forEach( System.out::println); 결과값은? 당연히 위와 동일하다! 완성된 내 코드짠! 서버도 잘 동작한다!공부해서 하나하나 알아가는 게 즐겁다! TodoDTO.java 12345678@NoArgsConstructor@AllArgsConstructor@Datapublic class TodoDTO { private String id; private String title; private boolean done;} TodoController.java 123456789101112131415161718192021222324252627282930313233@RestController@RequestMapping(\"todo\")public class TodoController { @Autowired private ModelMapper modelMapper; @Autowired private TodoService service; @PostMapping public ResponseEntity&lt;?&gt; createTodo(@RequestBody TodoDTO dto) { try { String temporaryUserId = \"temporary-user\"; // temporary user id. // (1) TodoEntity로 변환한다. TodoEntity entity = modelMapper.map(dto, TodoEntity.class); // (2) id를 null로 초기화 한다. 생성 당시에는 id가 없어야 하기 때문이다. entity.setId(null); // (3) 임시 유저 아이디를 설정 해 준다. 이 부분은 4장 인증과 인가에서 수정 할 예정이다. 지금은 인증과 인가 기능이 없으므로 한 유저(temporary-user)만 로그인 없이 사용 가능한 어플리케이션인 셈이다 entity.setUserId(temporaryUserId); // (4) 서비스를 이용해 Todo엔티티를 생성한다. List&lt;TodoEntity&gt; entities = service.create(entity); // (5) 자바 스트림을 이용해 리턴된 엔티티 리스트를 TodoDTO리스트로 변환한다. List&lt;TodoDTO&gt; dtos = entities.stream().map(e -&gt; modelMapper.map(e, TodoDTO.class)).collect(Collectors.toList()); // (6) 변환된 TodoDTO리스트를 이용해ResponseDTO를 초기화한다. ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().data(dtos).build(); // (7) ResponseDTO를 리턴한다. return ResponseEntity.ok().body(response); } catch (Exception e) { // (8) 혹시 예외가 나는 경우 dto대신 error에 메시지를 넣어 리턴한다. String error = e.getMessage(); ResponseDTO&lt;TodoDTO&gt; response = ResponseDTO.&lt;TodoDTO&gt;builder().error(error).build(); return ResponseEntity.badRequest().body(response); } }} 재밌다!","link":"/2022/07/07/220708DouleColonOperator/"},{"title":"[JPA] 리턴타입이 옵셔널(Optional)인 이유는?","text":"JPA를 사용 중 아래 코드를 만났고 의문이 생겼다. 1final Optional&lt;TodoEntity&gt; original = repository.findById(entity.getId()); 왜 꼭 Optional로 리턴타입을 감싸줘야하는걸까?그냥 리턴타입만 쓰면 안될까? 1final TodoEntity original = repository.findById(entity.getId()); 이런식으로 말이다.위처럼 옵셔널(Optional)을 빼버리니 바로 IDE가 에러를 알려주었다. 1Type mismatch: cannot convert from Optional&lt;TodoEntity&gt; to TodoEntity 왜 이런 에러가 발생하는 걸까?원인은 바로 CrudRepository 인터페이스였다. 갑자기 CrudRepository라고?Repository 인터페이스를 만들때 JPA를 쓰기 위해서 JpaRepository를 상속받는다.JpaRepository인터페이스에서 find와 관련된 메서드를 알기위해서는 CrudRepository를 확인하라고 적혀있다. JpaRepository 인터페이스 123456789101112131415161718192021222324252627282930313233343536/** * JPA specific extension of {@link org.springframework.data.repository.Repository}. * * @author Oliver Gierke * @author Christoph Strobl * @author Mark Paluch * @author Sander Krabbenborg * @author Jesse Wouters * @author Greg Turnquist */@NoRepositoryBeanpublic interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; { /* * (non-Javadoc) * @see org.springframework.data.repository.CrudRepository#findAll() */ @Override List&lt;T&gt; findAll(); /* * (non-Javadoc) * @see org.springframework.data.repository.PagingAndSortingRepository#findAll(org.springframework.data.domain.Sort) */ @Override List&lt;T&gt; findAll(Sort sort); /* * (non-Javadoc) * @see org.springframework.data.repository.CrudRepository#findAll(java.lang.Iterable) */ @Override List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids); // (중략)} CrudRepository 인터페이스CrudRepository 인터페이스에서 findById 메서드를 확인해보면 리턴값이 Optional 타입으로 고정되어있다.그래서 바로 IDE가 에러를 알려주었다. 그렇다면 Optional를 쓰면 좋은 점이 뭘까? 123456789101112131415161718192021/** * Interface for generic CRUD operations on a repository for a specific type. * * @author Oliver Gierke * @author Eberhard Wolff * @author Jens Schauder */@NoRepositoryBeanpublic interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; { /** * Retrieves an entity by its id. * * @param id must not be {@literal null}. * @return the entity with the given id or {@literal Optional#empty()} if none found. * @throws IllegalArgumentException if {@literal id} is {@literal null}. */ Optional&lt;T&gt; findById(ID id); // (생략)} Optional 쓰면 좋은 점?Optional은 Java 8에 추가되었다. 이전 자바버전에서는 사용 불가능하다.Optional은 고통스러운 null 처리를 도와주는 Wrapper 클래스이다. 코드 예시를 보자. 12345678910class Person { String name; String getName(){ if(name != null) { return name; } return \"name is null\"; }} 또는 try catch문을 이용해서 null을 처리할 수 있도 있고 다양한 NPE 처리 방법이 있다. 참고: 특별한 거 추가 없이 기본 메서드로 NPE처리하는 방법 그런데 만약 필드가 많다면? 모든 필드를 NULL처리를 해줘야한다. 이때 Optional 클래스와 해당 클래스가 제공하는 orElse 메서드 또는 orElseGet 메서드를 이용하면 쉽게 NPE 처리가 가능하다. 메서드명 특징 orElseThrow(NullPointerException::new) null이라면 함수형 파라미터로 생성한 예외(NullPointerException)를 발생시킨다. orElse(person) null이면 파라미터(person)를 반환한다. 이때 파라미터(person)은 해당 값이 null이든지 말든지 항상 미리 생성된다. orElseGet null이면 파라미터(person)를 반환한다. 이때 파라미터(person)은 해당 값이 null 일때만 생성된다. 즉 미리 생성되지 않는다. 참고 https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html?is-external=true","link":"/2022/07/10/220711JPA-optional/"},{"title":"[리액트]SPA 동작 순서","text":"SPA는 Single Page Application의 약자로 한 번 웹 페이지를 로딩하면 사용자가 새로고침하지 않는 이상 페이지를 새로 로딩하지 않는 애플리케이션을 의미한다.이게 무슨 의미일까? React 동작순서 index.html 렌더링 HTML이 body태그를 렌더링하다가 마지막에 bundle.js 스크립트를 로딩하게 되고 거기에 index.js가 포함되어있음. index.js 실행 ReactDOM.render() 함수가 실행됨 -&gt; 매개변수가 &lt;APP /&gt;이라서 해당 element를 렌더링하게 됨. root element 하위에 React.js가 생성한 HTML element 추가됨 ReactDOM이 내부 컴포넌트들을 root 엘리먼트에 렌더링함. root element 하위 element 렌더링 SPA에서 페이지를 변경하고 싶다면?root의 하위 엘리먼트를 다른 HTMl로 수정해야한다.HOW?fetch나 ajax등의 함수로 서버에 데이터를 요청한 뒤 응답 데이터를 받음 -&gt; js내에서 HTML 재구성된다. 이렇게 서버에게 새 HTML 페이지를 요청하지 않고 데이터를 받은 다음에 js가 동적으로 HTML 재구성해서 만드는 클라이언트 애플리케이션을 SPA라고 한다.이 렌더링 과정을 Client-side Rendering이라고 함. 참고: SSR과 CSR 중 뭐를 우선순위로 두는 게 좋을까?","link":"/2022/07/11/220712React-spa/"},{"title":"DTO vs Model vs Entity","text":"스프링프레임워크를 공부하면서 DTO와 Entity의 역할 차이는 확실한데 Model의 개념과 셋의 차이점이 궁금해 추가로 공부해봤다.닷넷프레임워크를 사용할땐 대부분의 클래스를 Model라고 칭했기 때문에 더 혼란스러웠다.언어별로 부르는 명칭이 다른 듯하다. 사실 명칭보다 더 중요한 것은 각 클래스가 어떤 역할을 하는지 정확히 아는 것이다. 명칭 역할 DTO 클라이언트의 데이터를 받는 역할. 클라이언트에서 사용하는 것이므로 노출되도 상관없다. Model 비즈니스 데이터를 담는 역할 Entity 데이터베이스의 테이블과 스키마를 표현하는 역할. DB컬럼과 연결되기때문에 필드명이 노출되서는 안된다. 참고: Entity VS DTO 차이점, 컨트롤러에서는 뭘 받아야할까? 예시공부하면서 내가 생각해 본 예시이다.결제프로그램을 예로 들어 DTO, Model, Entity를 비교한다면 아래와 같을 것이다. 명칭 예시 DTO 클라이언트가 입력한 카드정보, 쿠폰정보, 결정정보 파라미터로 전달한 걸 컨트롤러에서 받음 Model 유저별 결제 혜택, 포인트 차감, 통신사할인등 중간에 연산이나 외부시스템연동할때 쓸 필드들을 model에 담아서 처리함 Entity 연산되고 DB에 기록되어야 할 데이터(유저ID, 연산 후 포인트등)를 담아서 update시킴 참고 Entity, domain model and DTO – why so many?","link":"/2022/07/14/220714dtovsmodelvsentity/"},{"title":"제네릭(Generic) 타입파라미터(T) vs 와일드카드(?) 차이","text":"제네릭(Generic)의 사전적 의미는 일반화이다.제네릭의 장점은 컴파일시 데이터타입을 체크해줘서 타입이 안정적이고 타입체크와 형변환을 생략할 수 있어 코드가 간결해진다. 와일드카드(&lt;?&gt;) 하나의 참조 변수로 대입된 타입이 다른 객체를 참조 가능하다. 분류 설명 &lt;? extneds T&gt; 와일드 카드의 상한 제한. T와 그 자손들만 가능.실무에서 가장 많이 사용함 &lt;? super T&gt; 와일드 카드의 하한 제한. T와 그 조상들만 가능 &lt;?&gt; 제한 없으므르 모든 타입 가능. &lt;? extneds Object&gt;와 동일 1234ArrayList&lt;? extneds Fruit&gt; list = new ArrayList&lt;apple&gt;(); // OKArrayList&lt;? extneds Fruit&gt; list = new ArrayList&lt;orange&gt;(); // OKArrayList&lt;apple&gt; list = new ArrayList&lt;orange&gt;(); // 에러발생 메서드의 매개변수에 와일드 카드를 사용할 수 있다. 12345class Payment { static Payment buyFruit(FruitBox&lt;? extends Fruit&gt; box){ // 매개변수에 와일드카드를 사용했다. }} 타입 매개변수(&lt;T&gt;)타입 매개변수는 총 3곳에서 사용할 수 있다. 명 사용 위치 제네릭 인터페이스 인터페이스에 타입 매개변수를 사용 제네릭 클래스 클래스에 타입 매개변수를 사용 제네릭 메서드 메서드에 타입 매개변수를 사용 이 중에서 오늘 다룰 내용은 제네릭 클래스이다.제네릭 클래스의 인스턴스를 생성할 때 타입 매개변수로 전달받은 타입으로 데이터타입이 정해진다. 123456789// 제니릭 클래스 선언class 클래스명&lt;타입 매개변수&gt;{}// 제네릭 클래스 생성new 클래스명&lt;타입 인자&gt;(new 타입매개변수());// 제네릭 클래스 생성 - JDK7이후부터는 타입인자 생략 가능new 클래스명&lt;타입 인자&gt;(); 과일로 예시를 들어보자. 123456789101112class FruitBox&lt;T&gt;{ T fruit; public FruitBox}// 제네릭 클래스 생성new FruitBox&lt;Grape&gt;(new Grape());new FruitBox&lt;Pear&gt;(new Pear());// 제네릭 클래스 생성 - JDK7이후부터는 타입인자 생략 가능new FruitBox&lt;&gt;(new Grape());new FruitBox&lt;&gt;(new Pear()); 와일카드 vs 정규타입 매개변수 T차이 The difference is that if you have a type parameter U, you can use that type inside the method;if you use a wildcard, you don’t have access to the actual type inside the method (you only know that it is some unknown type that extends Number).If you need to know the actual type for whatever reason inside the method, then you cannot use the wildcard version.출처: coderanch 블로그 와일드카드는 Object를 받기때문에 get메서드를 사용할 수 있지만 set, put메서드는 사용할 수 없다. 타입 매개변수는 get, set, put메서드는 사용가능하다. 참고 기본클래스 이외에 자바 구성요소3 : annotation, generic 추천영상: 자바의 정석 기초편 와일드카드, 지네릭 메서드 by 남궁성의 정석코딩 유튜브채널","link":"/2022/07/14/220715wildcard-vs-typeparameter/"},{"title":"CORS는 왜 날 헷갈리게 하는걸까?(ft. CSRF, XSS)","text":"CORS는 크로스-오리진 리소스 셰어링(Cross-Origin Resource Sharing)의 약자이고 직역하면 교차 출처 리소스 공유이다.처음 리소스를 제공한 도메인(Origin)이 요청 도메인과 다르더라도 요청을 허락해 주는 웹 보안 방침이다. CORS 웹 보안 방침이 왜 필요한 걸까?웹 사이트는 원래 사용자의 공격에 취약하므로 보안에 유의해야한다.서로 다른 출처의 웹 사이트가 통신하는데 제약이 없으면 악의적인 사용자가 웹 사이트 정보를 탈튀할 수도 있다.따라서 같은 출처인지 다른 출처인지 구분이 필요하고 다른 출처인 경우 경고를 하는 것이다. CORS 취약점 CSRF (참고: 전자정부프레임워크3.8에 CSRF 설정하기): 사이트 간 요청 위조 약자로 공격대상이 Server XSS (참고: XSS 방지): 사이트 간 스크립팅의 약자로 공격대상이 Client 개발자도구(F12)의 네트워크 탭다른 출처의 웹사이트로 요청을 보내면 브라우저는 2개의 요청을 보낸다. Options 메서드를 사용하는 요청 사용자가 보낸 요청 Options 메서드는 보통 리소스에 대해 어떤 HTTP 메서드를 사용할 수 있는지 확인하고 싶을 때 보내고 Options 요청이 반환되고 CORS여부 및 GET 요청 사용가능 여부를 확인하면 두번째 요청을 보내게 된다. Access-Control-Allow-Origin: 프론트엔드 애플리케이션 서버 주소 Access-Control-Allow-Methods: 허용되는 메서드 ex) GET,POST,PUT,PATCH,DELETE,OPTIONS CORS가 가능하려면?CORS가 가능하려면 백엔드에서 CORS 방침을 설정해줘야한다.자바의 경우 WebMvcConfig 클래스로 설정할 수 있다. 1234567891011121314151617@Configuration // 스프링 빈으로 등록public class WebMvcConfig implements WebMvcConfigurer { private final long MAX_AGE_SECS = 3600; @Override public void addCorsMappings(CorsRegistry registry) { // 모든 경로에 대해 registry.addMapping(\"/**\") // Origin이 http:localhost:3000에 대해 .allowedOrigins(\"http://localhost:3000\") // GET, POST, PUT, PATCH, DELETE, OPTIONS 메서드를 허용한다. .allowedMethods(\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", \"OPTIONS\") .allowedHeaders(\"*\") .allowCredentials(true) .maxAge(MAX_AGE_SECS); }} 예시코드 출처 참고 React.js, 스프링 부트, AWS로 배우는 웹 개발 101","link":"/2022/07/17/220718CORS/"},{"title":"[도서]인증과 인가","text":"책 React.js, 스프링 부트, AWS로 배우는 웹 개발 101 를 읽고 공부한 내용을 정리한 글입니다. 도서 공식 링크 도서 정오표 공식 레포지토리 링크 인증과 인가 인증: 내 집에 들어올 수 있는 사용자 인가: 인증받고 들어온 사용자가 내 집에서 할 수 있는 것들 화장실 사용, 주방사용, 거실사용 등등 인증에는 여러 방법이 있다.책에서는 3가지 방법에 대해 이야기한다. 인증종류 3가지 설명 장점 단점 Basic 인증 클라이언트는 매 요청시 아이디와 비번을 전달하여 자신이 인증된 사용자임을 증명한다 인코딩헤도 아이디와 비번 노출됨.사용자를 로그아웃시킬수없음.인증서버에 요청이 많아져 단일 장애점이 되버림. 토근기반인증(Bearer 인증) 토큰은 최초 로그인시 서버가 만들어 줌. 서버가 자기만 아는 시크릿코드로 토큰을 만들어 반환하면 클라이언트는 이후 요청에 아이디와 비번 대신 토큰을 넘겨 자신이 인증된 사용자임을 증명한다. 아디랑 비번이 노출되지 않으므로 보안측면에서 Basic인증방식보다 안전함.서버가 토큰을 생성하므로 유효시간, 인가관리가능. 토큰 이름만 바꾸면 새로운 사용자가 되버리므로 스케일문제 해결못함 JSON 웹 토큰(JWT) JWT는 JSON Web Token의 약자. 전자서명된 토큰을 이용항 스케일 문제를 해결함. 인증서버에 토큰유효성을 물어보지않으므로 단일 장애점문제해결 인코딩을 했는데 왜 문제가 될까?Basic Auth에서는 아이디와 비밀번호를 인코딩한다. 이 솔루션은 아이디와 비밀번호를 노출한다.인코딩을 했는데 왜 문제가 될까? 인코딩은 보안을 목적으로 하는 것이 아니기때문!인간이 아이디와 비밀번호를 바로 알아내기 어렵지만 디코더만 있으면 누구나 원래의 아이디와 비번을 알아낼수 있다.이렇게 가로채는 것을 MITM(Man in the middle attack)라고한다. JWT 설명 및 각 필드 뜻JWT는 JSON 형태로 된 토큰이면서 토큰 기반 인증방식이다.JSON 웹 토큰방식과 토큰 기반 인증방식의 차이점은 무엇일까?JWT는 서버가 헤더와 페이로드를 생성한 후 전자 서명을 한다는 점이 기존 토큰 기반 인증방식과 다르다.JWT에게 전자사명이란 {헤더}.{페이로드}와 시크릿키를 이용해 해시 함수에 돌린 암호화한 결과값이다. HEADER typ: Type의 약자. 토큰타입을 의미. alg: Algorithm의 약자. 토큰 서명을 발행하는 데 사용된 해시 알고리즘의 종류를 의미 Payload sub: Subject의 약자. 토큰의 주인을 의미 ex)사용자이메일, 사용자아이디 iss: Issuer의 약자. 토큰을 발행한 주체를 의미 ex) 내가만든애플리케이션이름, facebook iat: issued at의 약자. 토큰이 발행된 날짜와 시간을 의미. exp: expiration의 약자. 토큰 만료 시간을 의미. Signature 토큰을 발행한 주체 Issuer가 발행한 서명으로 토큰의 유효성 검사에 사용된다. JWT 인증 방식 최초 로그인: 서버는 사용자 아디와 비번을 서버에 저장딘 아디와 비번에 비교해 인증 일치하면 사용자의 정보를 이용해 {헤더}.{페이로드} 작성한 뒤 자신의 시크릿키로 {헤더}.{페이로드}부분을 전자서명함. 전자 서명의 결과로 나온 값을 {헤더}.{페이로드}.{서명}으로 이어붙이고 Base64로 인코딩한 후 반환. 만약 누군가가 이 토큰으로 리소스 접근을 요청한다면? 서버:토큰을 Base64로 디코딩 디코딩한 JSON을 {헤더}.{페이로드}과 {서명}으로 나눈다. 서버는 위에서 나눴던 {헤더}.{페이로드}와 자신이 갖고있는 시크릿키로 전자서명을 만든 후 잘라놨던 {서명}부분과 일치하는 비교 이렇게 처리하면 좋은 점은 인증서버에 토큰 유효성에 대해 물어볼 필요가 없기에 단일 장애점 문제가 발생하지 않는다. 만약 누군가가 토큰을 훔쳐간다면?당연히 해당 계정 리소스에 접근이 가능하다.따라서 반드시 HTTPS로 통신해야만 한다. 그래서 Postman 인증 테스트시 HTTP로 하면 안되었던 거구나. 유레카! 스프링 시큐리티가 필요한 이유?API 실행시마다 사용자 인증을 해주는 부분을 스프링 시큐리티가 대신해줄수있다. 스프링 시큐리티란? 서블릿 필터의 집합 서블릿 필터이란? 서블릿 실행 전 에 실행되는 클래스들로 디스패처 서블릿 실행되기 전에 항상 실행됨. 스프링 시큐리티에서 서블릿 펄터를 사용하려면 2가지를 해야함 서블릿 필터 구현하는 작업 서블릿 컨테이너에 구현한 필터를 사용하도록 설정해주는 작업 여기서 개발자가 할 일은?서블릿 필터를 구현하고 서블릿 필터를 서블릿 컨테이너가 실행하도록 설정해주기! 서블릿필터는 꼭 한 개여야할까?서블릿 필터가 1개일 필요는 없다. 하나의 클래스에 모든 필터를 다 담으면 크기가 어마어마해질 것이다. 따라서 기능에 따라 서블릿 필터 여러 개를 작성하는 것이 좋다.생성한 서블릿 필터들을 FilterChain을 통해 연쇄적으로 순서대로 실행시킬수 있음. HttpSecurity란? WebSecurityConfig.java 파일을 생성해서 스프링시큐리티 설정해야 함 시큐리티 설정을 위한 오브젝트임. 이 오브젝트를 통해 web.xml 대신 HttpSecurity를 이용해 시큐리티 관련 설정함. 스프링시큐리티에 JwtAuthenticationFilter를 사용하라고 알려줘야함 코드 출처 및 원본 바로가기 12345678910111213141516171819202122232425262728293031323334@EnableWebSecurity@Slf4jpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private JwtAuthenticationFilter jwtAuthenticationFilter; @Override protected void configure(HttpSecurity http) throws Exception { // http 시큐리티 빌더 http.cors() // WebMvcConfig에서 이미 설정했으므로 기본 cors 설정. .and() .csrf()// csrf는 현재 사용하지 않으므로 disable .disable() .httpBasic()// token을 사용하므로 basic 인증 disable .disable() .sessionManagement() // session 기반이 아님을 선언 .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // /와 /auth/** 경로는 인증 안해도 됨. .antMatchers(\"/\", \"/auth/**\").permitAll() .anyRequest() // /와 /auth/**이외의 모든 경로는 인증 해야됨. .authenticated(); // filter 등록. // 매 리퀘스트마다 // CorsFilter 실행한 후에 // jwtAuthenticationFilter 실행한다. http.addFilterAfter( jwtAuthenticationFilter, CorsFilter.class ); }} addFilterAfter()메서드는 JwtAuthenticationFilter를 CorsFilter 이후에 실행하라고 설정하는 것임. 즉, 실행순서는 CorsFilter -&gt; JwtAuthenticationFilter 이 된다. 반드시 이 순서로 실행해야하는 것은 아니다. 저자가 보기에 적당해보여서 그렇게 설정한 것이다.","link":"/2022/07/22/220722authenticationVSauthorization/"},{"title":"[JPA] 쿼리 어노테이션(Query Annotation) 에러(expression or DISTINCT expected, got)해결","text":"인텔리제이를 사용하면 Spring 프레임워크를 사용하는데 많은 도움을 받을 수 있다.친구가 인텔리제이로 공부하던 중에 JPA 쿼리어노테이션 에러가 떠서 나한테 물어봤는데 나도 정확히 잘 몰라서 이참에 함께 공부해봤다. 에러친구는 Todo테이블에서 userId에 일치되는 행을 가져오는 쿼리를 짜고 싶었다고 한다. 1@Query(\"SELECT * FROM Todo WHERE t.userId = ?1\") 위 쿼리에서 오류가 있어 인텔리제이가 인텔리저이의 아래 error 메시지를 보여줬다. 1&lt;expression&gt; or DISTINCT expected, got '*' 에러를 해석해보면, 표현식 또는 구별자가 있어야한다라고 한다.어떤 오류일까? 오류 해결where절에서 t.userId를 불러오는데 쿼리상에 t가 정의되지 않았다.즉 Todo 테이블의 별칭을 t로 정의해줘야한다. 1@Query(\"SELECT * FROM Todo t WHERE t.userId = ?1\") 오류가 해결되었다!사실 아주 간단한 문제였다.하지만 JPA Query Annotation을 잘 알지못하니 5초만에 턱 해결할 수가 없었다.JPA Query Annotation은 뭘까?간단하게라도 공부해봤다. JPA Query Annotation 간단 설명1@Query(\"SELECT * FROM Todo t WHERE t.userId = ?1\") 여기서 물음표의 의미는 파라미터갯수이다.물음표 뒤의 숫자 1의 의미는 무엇일까?물음표에 들어올 파라미터의 위치이다. 즉 첫번째 파라미터는 ?1여기에 위치하게된다.만약 파라미터가 두개라면? 1@Query(\"SELECT * FROM Todo t WHERE t.userId = ?1 AND t.userName = ?2\") 간단하다!더 깊은 설명은 아래 글을 참고하면 된다. Spring Data JPA Custom Queries using @Query Annotation","link":"/2022/08/08/220808SpringJPA-queryannotation/"},{"title":"[MySQL] 서브쿼리(Subquery)보다 조인(Join)을 써야하는 이유(코드비교)","text":"회차별로 예약할 수 있는 영화 프로그램을 만들어야 한다고 생각해보자.여기서 회차는 요일별로 동일하다. 즉, 이번주 월요일에 총 3회차 영화상영이, 화요일에는 2회차 영화상영이 있었다면 다음주 월요일도 총 3회차, 화요일에는 2회차 영화상영이 예정되어 있는 것이다.사용자가 선택한 날짜의 회차별로 이미 예약된 내역정보뿐만 아니라 예약 가능한 좌석수를 가져오는 쿼리를 만들어야한다. 쿼리를 이해하기 위한 정보는 아래와 같다. 구분 명칭 설명 테이블 TB_TIME 회차 테이블 테이블 TB_RESERVE 예약 내역테이블 파라미터 dt 조회 날짜 파라미터 id 회차 ID 컬럼 ALL_SEAT 해당 회차의 전체 좌석수 컬럼 RESERVE_DT 상영일 별칭 openSeat 예약가능한 좌석수 내쿼리select구문에 subquery를 넣어서 해당 날짜에서 선택된 회차의 잔여 예약좌석수를 구했다. 123456SELECT TPOT.ID , -- 여러 정보 컬럼 (중략) , IFNULL(TPOT.ALL_SEAT,0) - IFNULL((SELECT sum(IFNULL(TPR.RESERVED_SEAT, 0)) FROM TB_RESERVE TPR WHERE TPR.ID = #{id} AND TPR.RESERVE_DT = DATE(#{dt}) GROUP BY TPR.ID),0) as openSeatFROM TB_TIME TPOT WHERE TPOT.ID = #{id} 팀장님이 이 쿼리를 보시곤 join을 써보는게 어떻냐며 알려주셨다. subquery를 제거한 쿼리12345678910111213141516171819202122SELECT TPOT.ID , -- 여러 정보 컬럼 (중략) , IFNULL(TPOT.ALL_SEAT, 0) - IFNULL(a.totalReservedSeat, 0) as openSeatFROM TB_TIME TPOT LEFT JOIN ( SELECT RESERVE_DT , DATE_FORMAT(RESERVE_DT, '%a') as WEEK_CODE , TIME_ID , SUM(RESERVED_SEAT) totalReservedSeat FROM TB_RESERVE WHERE DATE(RESERVE_DT) = DATE(#{dt}) GROUP BY RESERVE_DT , DATE_FORMAT(RESERVE_DT, '%a') , TIME_ID ) a ON TPOT.WEEK_CODE = a.WEEK_CODE AND TPOT.TIME_ID = a.TIME_IDWHERE TPOT.ID = #{id}AND DATE_FORMAT(#{dt}, '%a') = TPOT.WEEK_CODE 팀장님이 도와주셔서 다시 작성한 쿼리이다.이 쿼리를 보면 요일 구분이 확실히 들어가있어 요구사항이 제대로 반영되어있다는 걸 알 수 있다.자칫 길어보이는 쿼리인데 왜 subquery보다 join을 쓰면 좋을까? subquery보다 join을 써야하는 이유MySQL버전마다 성능이 다르지만 MySQL5.5에서 MySQL5.6으로 버전업되면서 서브쿼리 성능이 개선되었다고 한다.MySQL5.5에서는 서브퀴리 최적화에 많은 문제가 있어왔다. 의도한대로 서브쿼리가 제대로 실행되지 않거나 속도가 느리다.jojoldu님이 블로그 글 MySQL where in (서브쿼리) vs 조인 조회 성능 비교 (5.5 vs 5.6)을 참고하면 얼마나 속도차이가 나는지까지 확인 할 수 있다.버전과 조건 관계없이 좋은 성능을 내려면 최대한 join을 이용하는 것이 좋다.만약 서브 쿼리를 사용해 필터링을 하면 이는 크게 성능이 저하된다. 이럴땐 LEFT [OUTER] JOIN을 써서 옵티마이저(Optimizer)가 최적화 하기 쉽도록 하여 성능을 개선할 수 있다. 오늘도 또 하나 배웠다! 뿌듯~","link":"/2022/08/09/220809SQL-refact-subquery-to-join/"},{"title":"gson을 이용하여 JSON을 HashMap으로 변환하기(영화관 좌석 예매 예시)","text":"클라이언트에서 json형태로 넘긴 데이터를 컨트롤러에서 String으로 받아 Json으로 변환한 뒤 Map으로 변환하여 사용하고싶었다. 코드영화관 좌석을 체크하면 원하는 정보가 Object형태로 생성한 뒤 리스트에 담아서 form태그로 서버에 전송하고싶었다. jsp파일 html태그에는 체크박스 클릭시 클릭이벤트를 달아준다. 1&lt;input type=\"checkbox\" name=\"chkSeat\" value=\"'+idx+'\" data-movieId=\"17\" data-row=\"F\" data-seatNo=\"7\" onclick/&gt; 편의상 제이쿼리로 클릭이벤트를 달았다. 123456789101112131415161718192021222324252627// 각 행 체크박스 클릭시 이벤트let chkMovieSeatList = []; // 전역변수로 설정function tickSeatCheckbox(event){ let currentEl = event.currentTarget; // 체크박스 체크시 if(this.checked) { let tickSeat = new Object(); tickSeat.idx = $(this).val(); tickSeat.movieId = $(this).data('movieId'); tickSeat.row = $(this).data('row'); tickSeat.seatNo = $(this).data('seatNo'); chkMovieSeatList.push(tickSeat) // 체크박스 체크해제시 } else { chkMovieSeatList = chkMovieSeatList.filter((element)=&gt;element.idx != $(currentEl).val()); } // 리스트에 담기 $(\"input[name=chkMovieSeatList]\").val(JSON.stringify(chkMovieSeatJson));}$(document).ready(function(){ // 체크박스 변화시 체크박스 클릭이벤트 실행 $(\"input[name=chkSeat]\").change(function(){ tickSeatCheckbox(); });}); 전송은 form태그로 했다. 1$(\"form[name=saveFrm]\").submit(); DTO파일 12345public class Seat { private int id; // 중략 private String chkMovieSeatList; } 혹시 DTO vs Model vs Entity 이 세가지의 차이가 궁금하다면 여기를 클릭하면 된다. controller파일 1234567891011121314151617181920@PostMapping(\"/save\")public String save(Seat param, RedirectAttributes redirectAttributes) { String redirect = \"redirect:주소\"; BooleanAndMessageResult result = new BooleanAndMessageResult(); try { result = seatService.save(param); if (result.isResult()) { redirectAttributes.addFlashAttribute(\"message\", \"success\"); } else { redirectAttributes.addFlashAttribute(\"message\", \"fail\"); } } catch (Exception e) { result.setResult(false); result.setMessage(\"등록에 실패 하였습니다.\"); redirectAttributes.addFlashAttribute(\"message\", \"fail\"); } redirectAttributes.addFlashAttribute(\"result\", result); return redirect;} gson을 이용하여 JSON을 HashMap으로 변환String 형태로 받은 chkMovieSeatList을 Map형태로 변환한 뒤 체크된 갯수만큼 반복문을 돌려 db에 insert를 했다.자바 JSON 라이브러리인 goolge.gson를 이용해서 변환했다.chkMovieSeatList에서는 쌍따옴표가 &quot;로 들어가 있기때문에 replaceAll()을 이용해서 변경해줬다. SeatServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435363738import com.fasterxml.jackson.databind.JsonMappingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.gson.JsonArray;import com.google.gson.JsonElement;import com.google.gson.JsonObject;import com.google.gson.JsonParseException;import com.google.gson.JsonParser;// 중략@Override@Transactionalpublic BooleanAndMessageResult save(Seat param){ BooleanAndMessageResult result = new BooleanAndMessageResult(); // 중략 JsonParser jsonParser = new JsonParser(); JsonArray jsonArray = (JsonArray) jsonParser.parse(req.getChkMovieSeatList을().replaceAll(\"&amp;quot;\",\"\\\"\")); for(JsonElement seatEl : jsonArray){ JsonObject seatObj = (JsonObject) seatEl; HashMap&lt;String, Object&gt; seatMap; try { seatMap = new ObjectMapper().readValue(seatObj.toString(), HashMap.class); seatDAO.insertSeat(seatMap); } catch (JsonParseException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (JsonMappingException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }","link":"/2022/08/10/220811Json-convert-map/"},{"title":"[SQL]변수 @사용법, 사용자 정의 변수 직접 사용해보기","text":"SQL에서도 변수를 사용할 수 있다! 알고는 있었지만 잘 사용한 적이 없는데 이번에 select로 가져온 값을 서브쿼리에서 사용하고 싶어서 찾아보다가 변수를 사용하게 되었다.이밖에도 row갯수를 셀때에도 단독으로 많이 사용한다. 사용자 정의 변수변수란? 특정 값을 담아두는 곳이다.사용자 정의변수란? 명칭 그대로 사용자가 임의로 사용하려고 만든 변수이다. 1. 선언 및 초기화사용자 정의 변수를 선언 및 초기화하는 방법은 간단하다. 123SET @변수명 = 대입값;SET @변수명 := 대입값;SELECT @변수명 := 대입값; SET 명령문에서는 =과 :=를 둘 다 사용할 수 있지만 SET 이외의 명령문에서는 =가 비교연산자이기때문에 변수를 선언할땐 :=만 쓸 수 있다.기본값은 NULL이다. 2. 사용변수를 사용하는 방법은 더 간단하다.원하는 곳에 123SET @변수명 = 대입값;SET @변수명 := 대입값;SELECT @변수명 := 대입값; 예시코드내가 하고 싶었던 것: select에서 가져온 TPOT.WEEK_CODE의 값을 별칭 roundRowNo를 가져올 서브쿼리에 사용하기.그래서 아래와 같은 코드를 짰다. 12345678910111213141516171819202122232425&lt;select id=\"getDetail\" parameterType=\"int\" resultType=\"Movie\"&gt; /* query id: getDetail */ SELECT DATE_FORMAT(TPR.RESERVE_DT, '%Y-%m-%d') as reserveDt , @weekcode := TPOT.WEEK_CODE , (SELECT roundRowNo FROM ( SELECT OPEN_TIME_ID , (@row_number := @row_number + 1) AS roundRowNo FROM tb_open_time JOIN (SELECT @row_number := 0) r WHERE IS_USE = 1 AND WEEK_CODE = @weekcode ) totalRowCnt WHERE totalRowCnt.OPEN_TIME_ID = TPR.OPEN_TIME_ID ) AS roundRowNo , -- 중략 FROM TB_RESERVE TPR JOIN TB_USER TU ON TPR.RESERVE_USER_NO = TU.USER_NO JOIN TB_OPEN_TIME TPOT ON TPR.OPEN_TIME_ID = TPOT.OPEN_TIME_ID WHERE TPR.RESERVE_ID = #{reserveId}&lt;/select&gt; 1. @weekcode := TPOT.WEEK_CODE의 의미SELECT문에서 weekcode라는 변수를 선언 한 뒤(= @weekcode) TPOT.WEEK_CODE 값으로 초기화 했다.이때 SET 명령문이 아닌 SELECT문이기에 :=를 사용했다. 2. row_number실무에서 사용자 정의 변수를 가장 많이 사용할 때는 바로 row 개수를 구할때이다. @row_number := 0 : 변수 @row_number를 0으로 선언 및 초기화를 한다. @row_number := @row_number + 1 : 출력되는 행의 갯수만큼 +1 더해주면 되므로 누적합을 한다. 이를 행마다 출력해주면 row 개수를 구하는 쿼리 끝!","link":"/2022/08/11/220812SQL-variable/"},{"title":"[JSP] jsp파일을 수정하면 서버를 재시작해야할까?","text":"개발을 하다보면 알겠지만 jsp 파일을 수정한 뒤 서버를 재시작하지않아도 반영이 된다. 어떨땐 즉시 반영되는데 또 어떨땐 반영이 느릴때도 있다.jsp에는 java코드도 있는데 어떻게 컴파일없이 바로 반영이 될까? 그리고 즉시반영이 안 될때 혹 반영이 느릴때는 어떻게 해야할까? JSP 특징 동적 웹어플리케이션 컴포넌트 응답형식 html 페이지 실행 순서 최초 호출: jsp -&gt; 서블릿 java 변환 -&gt; .class로 컴파일(컴파일 일시를 기록) -&gt; 클래스파일을 메모리에 로딩 -&gt; html 전송 -&gt; 브라우저에서 html이 보여짐 jsp 파일 수정없이 호출한 경우: 단순히 publishing jsp 파일 수정후 호출한 경우: 컴파일일시가 변경되었다면, 서블릿 java로 변환 -&gt; .class컴파일 후 재로딩 jsp 수정사항 즉시 반영이 안될때? 서버세팅에서 자동 컴파일 되는 지 체크 톰캣 context.xml 파일에서 &lt;Context reloadable=&quot;true&quot;&gt; 리로더블이 true인지 확인할 것 이클립스에서 publish to the server 버튼을 클릭(단축키 : Ctrl + Alt + P) 참고글: Eclipse HTML 수정 즉시 반영 만약 서버 재시작해도 반영이 안된다면? 기본위치: C:\\workspace.metadata.plugins\\org.eclipse.wst.server.core\\tmp1\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp\\WEB_002dINF\\views 위 위치에서 파일명_jsp.java과 파일명_jsp.class을 찾아 삭제하면 된다.주의할 점은 jsp파일을 삭제하는 것이 아니라 컴파일된 파일명_jsp.java과 파일명_jsp.class을 삭제하는 것이다!삭제한 뒤 브라우저에서 해당 페이지 다시 호출하면 컴파일 파일이 자동 생성된다.이때 새로 생성된 파일명_jsp.java과 파일명_jsp.class의 수정된 날짜가 현재 날짜로 되어있다면 반영이 잘 된 것이다. 만약 그래도 반영이 안된다면?Deployment Assembly 설정이 제대로 되어 있는지 확인해야한다. 프로젝트 우클릭 &gt; Deployment Assembly 에서 Source에 target/m2e-wtp/web-resources가 제대로 설정되어있는지 확인하기.","link":"/2022/08/15/220816Jsp-restart/"},{"title":"[JSTL] 날짜 차이 계산하기","text":"현재날짜와 db에서 가져오는 날짜 차이를 계산하고 싶었다. 코드구글링끝에 드디어 성공~!!now는 오늘날짜이고 list.dbDt는 db에서 가져온 날짜값이다.여기서 중요한 점은 parseNumber할때 .time을 해줘야지 제대로 계산된다는 점이다. 12345&lt;jsp:useBean id=\"now\" class=\"java.util.Date\" /&gt;&lt;fmt:parseNumber value=\"${now.time / (1000*60*60*24)}\" integerOnly=\"true\" var=\"nowfmtTime\" scope=\"request\"/&gt;&lt;fmt:parseNumber value=\"${list.dbDt.time / (1000*60*60*24)}\" integerOnly=\"true\" var=\"dbDtParse\" scope=\"request\"/&gt;${dbDtParse - nowfmtTime } 예를 들어 now가 2022-08-18이고 list.dbDt가 2022-08-19이면 ${dbDtParse - nowfmtTime }값은 0이다.테스트해보면 아래와 같이 값을 계산할 수 있다. now list.dbDt ${dbDtParse - nowfmtTime } 2022-08-18 2022-08-18 -1 2022-08-18 2022-08-18 0 2022-08-18 2022-08-20 1 2022-08-18 2022-08-23 4 관련 java.util.Date 현재날짜의 시간을 0으로 설정하기","link":"/2022/08/18/220818JSTL-date/"},{"title":"포인트 플랫폼 프로젝트를 끝내며 내가 배운 것","text":"이번 프로젝트는 기능 구현상 어려운 점은 크게 없었으나 서비스 도메인이 처음 접하는 도메인이라 비즈니스를 이해하는데 꽤 시간이 걸렸다.이번 프로젝트를 통해 그 어떤 새로운 서비스 도메인을 접해도 어디서부터 어떻게 흐름을 잡고 분석하면 될지 배울 수 있었다. 역시 노력하면 못할 게 없다. 물론 옆에 든든한 대리님과 팀장님이 있어서 모르는 부분을 중복해서 물어봐도 이해가 쏙쏙 되도록 잘 알려주셨다. 이 자리를 빌어 감사드립니다.비즈니스로직에 의문을 품는 습관도 중요하다는 걸 알게되었다. 모두가 다 테스트 끝났다고 했지만 흐름을 이해하면서 하다보니 누락된 오류들을 여러 건 잡을 수 있었다.문제가 발생되기 전에 미리 예방해서 참 뿌듯했다. Keep현재 만족하고 있는 부분과 계속해서 이어갔으면 하는 부분 서비스 도메인을 빠른 시일내에 이해하려고 노력한 부분: 어려운 도메인은 서비스 이해에서부터 시작된다. 처음하는 채굴과 코인, 포인트, 추천인등의 세계에서 나는 갈피를 못잡고 허우적대다 대리님의 주신 동아줄을 가까스로 잡을 수 있었다. 비즈니스 로직에 의심을 품은 부분: 단순히 숫자가 잘 나오는 지 테스트하는 게 아니라 유저입장과 관리자입장에서 각각 비즈니스 로직을 생각하고 현재 있는 로직에 오류는 없는 지 두번 체크한 부분은 참 잘했다. 덕분에 누락된 오류들과 애매모호한 로직들을 미리 잡고 정책을 만들 수 있었다. 뿌듯! 서버에 war배포를 직접 하겠다고 하고 해낸 부분: PuTTY와 FileZilla를 자주 접하려고 노력한 점은 참 잘했다. Problem개선이 필요하다고 생각되는 부분 쉘스크립트 개념이 어려워서 다음에 이해해야지하고 넘어간 부분: 다음이란 없다. 다른 시니어 개발자와 소통할 수 있도록 지금부터 공부해야한다. 자바 스케줄러를 제대로 이해하려고 노력하지 않은 부분: 마찬가지로 다음이란 없다. 지금부터 익히 들어두며 스스로 공부해야한다. 트리구조 쿼리를 여전히 제대로 만들지 못하는 부분: recursive등 고급 SQL을 더 깊게 공부해야한다. 언제까지고 팀장님이 도와주실순 없다. 스스로 노력하자. 톰캣 배포 에러나는 부분은 전혀 갈피를 못잡고 팀장님께 도움을 요청한 부분: Server 배포를 추가로 공부하자. TryProblem의 해결책이 될 수 있는 부분 욕심내자. 생각으로 욕심내는 게아니라 행동으로 욕심내자. 실력은 스스로 키우는 것이다.","link":"/2022/08/20/220715projectreivew6/"},{"title":"소장도서목록","text":"소장도서목록입니다. 📚 소장도서 프로그래머의 뇌 좋은 코드, 나쁜 코드 훌륭한 프로그래머가 알아야 할 인지과학의 모든 것 프로그래머의 코드 개선법 자바 ORM 표준 JPA 프로그래밍 React.js, 스프링 부트, AWS로 배우는 웹 개발 101 스프링 데이터 예제 프로젝트로 배우는 전자정부 표준 데이터베이스 프레임 SPA, REST API 기반 웹 애플리케이션 개발 자바 개발자를 위한 97가지 제안 그림으로 공부하는 TCP/IP 구조 73인의 전문가에게 듣는 자바 컬렉션 인터넷, TCP/IP, 애플리케이션부터 보안, 네트워크 기기, 부하분산까지 네트워크의 기본 지식 모두를 위한 클라우드 컴퓨팅 HTC 개념부터 가상화, 컨테이너, CI/CD, AWS 프로그래밍까지","link":"/2022/08/22/bookList/"},{"title":"예약 프로그램 프로젝트를 끝내며 내가 배운 것","text":"이번 프로젝트에서는 예약프로그램을 도맡아 개발했다. 요구사항에 맞게 기능을 제한하는 부분에 가장 많은 공을 들였다.시간이 많이 촉박했던 프로젝트라 야근을 많이 했는데 테스트할때 생각보다 큰 버그가 없어서 뿌듯했다. Keep현재 만족하고 있는 부분과 계속해서 이어갔으면 하는 부분 성능을 고려하면서 SQL을 제대로 짜기위해 노력했다. js와 jqeury로 달력그리기 마스터가 되었다. 데이터를 가져올때 async 와 await 도 사용하고 이해도가 훨씬 향상되었다. 다음에는 템플릿을 이용해서 그리고 싶다. Problem개선이 필요하다고 생각되는 부분 고객사의 요구사항이 명확하지 않을때 해결하는 과정에서 많은 어려움이 있었다. 고객사 담당자도 구체적인 정책이 없는 상황에서 프로젝트 시간은 여전히 촉박하고 기다림의 시간이 반복되었다. 최대한 확장성이 있는 기능을 구현하는 게 해답이라는 걸 깨달았다. TryProblem의 해결책이 될 수 있는 부분 앞으로도 요구사항이 명확하지 않은 프로젝트를 할 수 있는데 어떤 설계를 해야 확장성을 갖추면서 효율적으로 개발할 수 있을까? 디자인패턴을 공부해야겠다. 관련 포스팅 서브쿼리(Subquery)보다 조인(Join)을 써야하는 이유(코드비교) gson을 이용하여 JSON을 HashMap으로 변환하기(영화관 좌석 예매 예시) 변수 @사용법, 사용자 정의 변수 직접 사용해보기 jsp파일을 수정하면 서버를 재시작해야할까? JSTL 날짜 차이 계산하기 동적 달력(캘린더)만들기","link":"/2022/08/23/220824projectreview7/"},{"title":"[Moment.js]동적 달력(캘린더)만들기","text":"JS로 달에 맞게 생성되는 동적 달력을 그려보자. html 태그로만 달력그리기html코드로만 달력을 그린다면 아래와 같은 것이다.하지만 이렇게 그린다면 달마다 바뀌는 달력이 아닌 정적달력이 되버린다.매달 달라지는 달력은 어떻게 만들까? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255&lt;div&gt; &lt;div&gt; &lt;a&gt;&lt;i class=\"fa fa-arrow-left\" aria-hidden=\"true\"&gt;&lt;/i&gt;이전달&lt;/a&gt; &lt;p id=\"title-date\"&gt;----년 -월&lt;/p&gt; &lt;a&gt;&lt;i class=\"fa fa-arrow-right\" aria-hidden=\"true\"&gt;&lt;/i&gt;다음달&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;table id=\"month-table\" class=\"table_cal\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;일&lt;/th&gt; &lt;th&gt;월&lt;/th&gt; &lt;th&gt;화&lt;/th&gt; &lt;th&gt;수&lt;/th&gt; &lt;th&gt;목&lt;/th&gt; &lt;th&gt;금&lt;/th&gt; &lt;th&gt;토&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;1&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;2&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;p&gt;3&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;4&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;5&lt;/p&gt; &lt;span&gt; &lt;a href=\"javascript:void(0);\"&gt;&lt;/a&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;6&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;7&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td &gt; &lt;p&gt;8&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;9&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;p&gt;10&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;11&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;12&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;13&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;14&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td class=\"possible\"&gt; &lt;p&gt;15&lt;/p&gt; &lt;span&gt; &lt;a href=\"javascript:void(0);\"&gt;&lt;/a&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;16&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;p&gt;17&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;18&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;19&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;20&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;21&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td class=\"possible\"&gt; &lt;p&gt;22&lt;/p&gt; &lt;span&gt; &lt;a href=\"javascript:void(0);\"&gt;&lt;/a&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;23&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;p&gt;24&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;25&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;26&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;27&lt;/p&gt; &lt;span&gt; &lt;a href=\"javascript:void(0);\"&gt;&lt;/a&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;28&lt;/p&gt; &lt;span&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;29&lt;/p&gt; &lt;span&gt; &lt;a href=\"javascript:void(0);\"&gt;&lt;/a&gt; &lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;30&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;p&gt;31&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt; 동적 달력위 html코드에서 thead와 tbody부분을 제거했다.restDaysWeekNumber를 통해서 주말과 평일을 나눠서 달력에 특별한 표시를 할수도 있다.해당 코드를 사용하기 위해서는 moment.js가 있어야한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js\" integrity=\"sha512-CryKbMe7sjSCDPl18jtJI5DR5jtkUWxPXWaLCst6QjH8wxDexfRJic2WRmRXmstr2Y8SxDDWuBO6CQC6IE4KTA==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;&lt;script&gt;const createMonthTable = async (date) =&gt; { let firstDate = new Date(date.getFullYear(), date.getMonth(), 1); let lastDate = new moment(firstDate).add(1, 'months').subtract(1, 'days'); let currentDate = firstDate; $('#title-date').text(moment(firstDate).format(\"YYYY년 MM월\")); $('#title-date').data(\"firstdate\", firstDate); let table = $(\"#month-table\"); let calenderTable = $(\"&lt;table id='month-table'&gt;&lt;/table&gt;\"); calenderTable.empty(); const today = moment(); let tempCurrentDate; let daysNumber = 0; let theadTr = $(\"&lt;thead&gt;&lt;/thead&gt;\"); theadTr.appendTo(calenderTable); let headTr = $(\"&lt;tr&gt;&lt;/tr&gt;\"); for (let i = 0; i &lt; 7; i++) { let th = $(\"&lt;th&gt;\" + moment().day(i).format(\"ddd\") + \"&lt;/th&gt;\"); headTr.append(th); } headTr.appendTo(theadTr); let restDaysWeekNumber = \"60\"; /* 정기휴일(일:0,월:1,화:2, ... ,금:5,토:6) */ while (currentDate &lt;= lastDate) { tempCurrentDate = new moment(currentDate); let daysTr = $(\"&lt;tr&gt;&lt;/tr&gt;\"); for (let i = 0; i &lt; 7; i++) { // 여기서 i는 요일 let td = $(\"&lt;td&gt;&lt;/td&gt;\"); if (restDaysWeekNumber.includes(i)) { td.addClass(\"blocked\"); // 주말표시가 된 class를 추가할 수 있음 } if (tempCurrentDate.day() == i &amp;&amp; firstDate &lt;= tempCurrentDate &amp;&amp; tempCurrentDate &lt;= lastDate) { let p = $(\"&lt;p&gt;\"+tempCurrentDate.date()+\"&lt;/p&gt;\"); p.appendTo(td); let span = $(\"&lt;span&gt;&lt;/span&gt;\"); span.appendTo(td); tempCurrentDate.add(1, 'days'); } td.appendTo(daysTr); } daysTr.appendTo(calenderTable); currentDate = new moment(tempCurrentDate); } let parent = table.parent(); table.remove(); calenderTable.appendTo(parent);};// 달력 이전달 이동const makePreCalender = () =&gt; { preDateString = moment($('#title-date').data('firstdate')).add('-1','M').format(\"YYYY-MM-DD\"); createMonthTable(new Date(preDateString));}// 달력 다음달 이동const makeNextCalender = () =&gt; { nextDateString = moment($('#title-date').data('firstdate')).add('1','M').format(\"YYYY-MM-DD\"); createMonthTable(new Date(nextDateString));}$(document).ready( () =&gt; { var data = createMonthTable(new Date()); });&lt;/script&gt;&lt;div&gt; &lt;div&gt; &lt;a href=\"javascript:makePreCalender();\"&gt;&lt;i class=\"fa fa-arrow-left\" aria-hidden=\"true\"&gt;&lt;/i&gt;이전달&lt;/a&gt; &lt;p id=\"title-date\"&gt;----년 -월&lt;/p&gt; &lt;a href=\"javascript:makeNextCalender();\"&gt;&lt;i class=\"fa fa-arrow-right\" aria-hidden=\"true\"&gt;&lt;/i&gt;다음달&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;table id=\"month-table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;일&lt;/th&gt; &lt;th&gt;월&lt;/th&gt; &lt;th&gt;화&lt;/th&gt; &lt;th&gt;수&lt;/th&gt; &lt;th&gt;목&lt;/th&gt; &lt;th&gt;금&lt;/th&gt; &lt;th&gt;토&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt; 완성!","link":"/2022/08/30/220831js-calendar/"},{"title":"DB서버를 분리하는 이유가 뭘까","text":"프로젝트를 진행하다보면 다양한 서버 구죽 환경을 만난다.단일서버도 있고 DB서버를 분리하여 서버를 구축하기도 한다.실무에선 주로 DB서버를 분리하는 데 단일서버와의 차이점이 궁금했다.어떨때 DB서버를 분리하고 어떨 때는 분리하지 않는걸까? 그로 인한 장단점에는 뭐가 있을까? DB서버와 WAS를 나누는 이유프로젝트 관리정책이나 클라이언트의 요구에 따라 단일 서버를 쓰기도 하고 DB서버를 분리하기도 한다.DB서버를 분리하는 이유는 크게 두 가지를 들 수 있다. 보안 서버를 분리할수록 보안에 유리하다. 성능 DB 서버는 메모리를 빡빡하게 쓴다. 리소스를 많이 잡아먹으므로 서버분리를 통해 성능을 높일 수 있다. 실무에선 WAS에서 처리하는게 많은 경우,DB서버와 분리한다. DB서버 분리 단점보안과 성능이라는 두가지 장점이 있다면 단점도 분명 있을 것이다.단점도 크게 두가지로 볼 수 잇다. 서버 비용 증가 방화벽설정 문제가 발생할 수 있음 단점이라기보단 예상할 수 있는 문제에 가깝지만, 실무에서 DB서버를 분리함으로서 방화벽설정에 문제가 있을 수 있다. 예를 들어 관리포인트가 많을 경우 한 쪽서버만 접속되는 문제가 발생할 수 있다. 소스코드가 있는 프로그램을 부르는 명칭이 따로 있을까?나는 늘 그랬듯 용어가 궁금했다. 소통을 잘하고싶은 마음때문에 항상 용어를 신경쓴다.소스코드가 있는 그 프로그램을 뭐라고 부르는지 무척 궁금했는데 과장님이 프로그램을 소스코드 경로 최상단인 webroot 라고도 부른다고 알려주셨다.감사합니다 과장님! 과장님과 얘기나누던 중에 내가 아파치와 톰캣을 명확히 구분하지 못한다는 사실을 발견했다.이와 관련되서는 따로 포스팅했다. 참고 아파치 vs 톰캣 같은 거 아냐? 차이점 여담으로, 회사 선임분들이 너무 좋다. 팀장님도 좋고 과장님도 좋다. 내가 난해하게 물어볼때도 최대한 알기쉽게 알려주신다. 항상 감사하다. 덕분에 많이 배웁니다. 출처 과장님 경험 단일 서버와 데이터베이스 서버의 분리가 왜 필요할까","link":"/2022/09/04/220905Server-separation/"},{"title":"[Server]아파치 vs 톰캣 같은 거 아냐? 차이점","text":"성과장님과 서버구축 관련 이야기를 나누다 아파치와 톰캣이 차이가 있다는 걸 알게되었다.띠용? 톰캣이 아파치 소프트웨어 재단에서 개발된 것이므로 아파치서버나 톰캣서버나 동일하다고 생각하고 있었다.구글링결과 아파치서버와 톰캣서버는 아주 큰 차이점이 있었고 이를 공부해봤다. 아피치 톰캣 다 같은 거 아냐?NOPE!아파치(Apach)란 아파치 소프트웨어 재단 이름이다. 실무에서 아파치서버라고 부른다면 아파치 재단의 오픈소스로 만든 Web Server를 칭한다.우리가 헷갈리는 이유 WAS가 웹서버의 기능을 다 수행할 수 있기때문이다.하지만 서버과부하, 보안강화 등의 목적으로 WAS와 Web Server를 분리하는 프로젝트들도 있다. Web Server WAS(Web Application Server) 정의 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠(.html .jpeg .css 등)를 제공하는 컴퓨터 프로그램 DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server 데이터 클라이언트측 정적 데이터 서버측 동적 데이터 DB데이터 사용 불가능 가능 예시 Apache Server, Nginx, IIS(Windows 전용 Web 서버)등 Tomcat, JBoss, Jeus, Web Sphere 등 잠시만 IIS도 동적페이지 생성이 가능한데 Web Server라고?맞다. IIS는 Web Server와 WAS가 함께 있는 서버이다.ms진영에서는 IIS를 웹서버라고 부르며, 웹서버와 WAS를 딱히 구별하지 않는 듯 하다.IIS는 ms용, WAS는 범용이라 생각하면 되고 서로 바라보는 범위가 약간 다른 셈! 참고 웹서버(WEB SERVER) VS 웹어플리케이션서버(WAS, Web Application Server)","link":"/2022/09/05/220906Tomcat-vs-Apatch/"},{"title":"[리액트] useEffect에서 props사용하기","text":"부모 컴포넌트에서 위도와 경도를 props로 전달하여 자식컴포넌트에서 카카오맵API를 통해 특정 장소를 호출하고 싶었으나 오류가 발생했다. 목표useEffect안에서 로직상 상태가 변하지않는 props를 쓰고 싶음 상황부모컴포넌트인 Detail.js에서 자녀 컴포넌트인 Map.js로 좌표, 위도와 경도를 넘겨주었다.이를 Map.js에서 props로 위도와 경도를 받아서 카카오맵API로 카카오맵을 호출하고자했다.여기서 로직상 props로 받은 위도와 경도는 상태가 변하지 않는다.componentDidUpdate용도로 useEffect를 사용했다. Detail.js 코드 12// detail.addrLat는 위도이고 detail.addrLng는 경도이다.&lt;Map latitude={detail.addrLat} longitude={detail.addrLng} /&gt; ❗문제발생위도와 경도는 업데이트가 되지않는 데이터이기때문에 Hooks버전에서 componentDidMount만 사용하고 무한루프를 예방하기 위해 빈배열로 나뒀다. Map.js 코드 1234567891011121314151617181920212223242526272829303132import React, { useEffect, useState } from 'react'export default function Map(props) { console.log(`콘솔1번 props.latitude: ${props.latitude}`) const { kakao } = window const lat = props.latitude const long = props.longitude useEffect(() =&gt; { console.log(`콘솔2번 props.latitude: ${props.latitude}`) const container = document.getElementById('map') const options = { center: new kakao.maps.LatLng(lat, long), level: 3, } const map = new kakao.maps.Map(container, options) // 지도에 마커를 생성하고 표시한다 var marker = new kakao.maps.Marker({ position: new kakao.maps.LatLng(lat, long), // 마커의 좌표 map: map, // 마커를 표시할 지도 객체 }) }, []) return ( &lt;&gt; &lt;div id=\"map\" style={{ width: '750px', height: '350px' }}&gt;&lt;/div&gt; &lt;/&gt; )} 그랬더니 콘솔결과는 아래와 같았다. 1234567콘솔1번 props.latitude: undefined Map.js:4 콘솔1번 props.latitude: undefined Map.js:4콘솔2번 props.latitude: undefined Map.js:10 콘솔2번 props.latitude: undefined Map.js:10 콘솔1번 props.latitude: 35.101425 Map.js:4 콘솔1번 props.latitude: 35.101425 Map.js:4 콘솔2번은 useEffect안에서 호출한 건데 props로 받아온 모든 값이 undefined로 되어있어서 카카오맵 API가 제대로 호출되지않았다. 💡해결구글링해본 결과 props를 사용하려면 두번째 인수인 빈 배열에다가 props를 넣으면된다고 한다.물론 두번째 파라미터를 사용하는 경우 useEffect는 componentDidMount + componentDidUpdate역할을 동시에 하게 된다. Map.js 코드 1234567891011121314151617181920212223242526272829303132import React, { useEffect, useState } from 'react'export default function Map(props) { console.log(`콘솔1번 props.latitude: ${props.latitude}`) const { kakao } = window const lat = props.latitude const long = props.longitude useEffect(() =&gt; { console.log(`콘솔2번 props.latitude: ${props.latitude}`) const container = document.getElementById('map') const options = { center: new kakao.maps.LatLng(lat, long), level: 3, } const map = new kakao.maps.Map(container, options) // 지도에 마커를 생성하고 표시한다 var marker = new kakao.maps.Marker({ position: new kakao.maps.LatLng(lat, long), // 마커의 좌표 map: map, // 마커를 표시할 지도 객체 }) }, [props]) return ( &lt;&gt; &lt;div id=\"map\" style={{ width: '750px', height: '350px' }}&gt;&lt;/div&gt; &lt;/&gt; )} 그랬더니 콘솔결과는 아래와 같았다. 12345678콘솔1번 props.latitude: undefined Map.js:4 콘솔1번 props.latitude: undefined Map.js:4콘솔2번 props.latitude: undefined Map.js:10 콘솔2번 props.latitude: undefined Map.js:10 콘솔1번 props.latitude: 35.101425 Map.js:4 콘솔1번 props.latitude: 35.101425 Map.js:4콘솔2번 props.latitude: 35.101425 Map.js:10 콘솔2번에 제대로 된 값이 들어오면서 카카오맵이 내가 원하는 지도를 호출해줬다!해결~! 이 과정을 해결하면서 2가지 궁금증이 생겼다.첫번째는 왜 undefined일까? 였고 두번째는 동일한 콘솔로그가 왜 두번씩 호출될까?였다. 💬근데 왜 undefined일까?리액트의 실행순서때문이다. Map.js(이하 자식컴포넌트) 호출 Detail.js(이하 부모컴포넌트) 호출 자식컴포넌트의 useEffect 실행 부모컴포넌트의 useEffect 실행 -&gt; axios 완료 부모컴포넌트 호출 자식컴포넌트 호출 처음 자식컴포넌트를 호출되므로 부모한테서 props를 받을 수 없기에 아예 없는 값이다.그리곤 부모컴포넌트에서 useEffect로 axios가 실행되어야지 setState()를 통해서 props를 자식컴포넌트에 전달할 수 있다.근데 axios다녀오기도 전에 자식컴포넌트의 useEffect를 실행해버리니 props값이 undefined일수밖에 없다! 이 상황을 말씀드리니 팀장님이 한 가지 더 미션을 주셨다. 팀장님 나 팀장님, 아까 리액트 질문에서요~ 실행순서 때문에 undefined가 났었고 useEffect 두번째 인자에 props를 주니 해결되었습니다. props 받아서 고치는게 맞을것 같네요. 대신에 undefined에 대한 대책이 필요한 것 같아요. 오호 대책이요? props가 값이 없을 때는 카카오 생성하고 하면 그만큼 비효율적일 것 같아서요 오 역시 팀장님께 말씀드리길 잘했다. 생각도 못한 부분인데 어떻게 하면 해결할수 있을지 고심해봤다. 💬undefined에 대한 대책props가 없을땐 자식컴포넌트를 실행시키지 않으면 되니까~ 내 머리속에 떠오른 방법은 크게 두 가지였다. 자식컴포넌트에서 props가 없을 땐 실행하지않기. 부모컴포넌트에서 axios다녀온 뒤에, 즉 데이터가 있을때 자식컴포넌트 실행하기 자식컴포넌트에서 useEffect 조건을 걸어볼까?아래와 같은 소스코드에서 props가 없을땐 카카오의 maps객체르 호출하지 않아야겠다고 생각하고 if조건문을 걸어주려고 했다. 자식컴포넌트 (Map.js) 소스코드123456789101112131415161718192021222324252627282930export default function Map(props) { const { kakao } = window const lat = props.latitude const long = props.longitude console.log('Map 컴포넌트 실행.') useEffect(() =&gt; { //if (props) { debugger const container = document.getElementById('map') const options = { center: new kakao.maps.LatLng(lat, long), level: 3, } const map = new kakao.maps.Map(container, options) // 지도에 마커를 생성하고 표시한다 var marker = new kakao.maps.Marker({ position: new kakao.maps.LatLng(lat, long), // 마커의 좌표 map: map, // 마커를 표시할 지도 객체 }) // } }, []) return ( &lt;&gt; &lt;div id=\"map\" style={{ width: '750px', height: '350px' }}&gt;&lt;/div&gt; &lt;/&gt; )} 하지만!디버깅해보니 디버킹타이밍에선 props가 아예 없는 객체였다! 두둥-1번 방법은 실패! 부모컴포넌트에서 props로 줄 데이터가 있을때 자식컴포넌트 호출하기props로 넘겨줄 detail.addr1 라는 데이터가 있을때만 자식컴포넌트인 Map을 호출했다. 123456{detail.addr1 &amp;&amp; ( &lt;Map latitude={detail.addrLat} longitude={detail.addrLng} /&gt;)} 이렇게 undefined일때는 아예 자식컴포넌트를 호출하지 않는 방법으로 문제 해결!! 💬또 다른 궁금증, 왜 두번씩 호출될까?useEffect안에서 props를 사용하는 과정에서 동일한 콘솔로그가 두 번씩 호출되는 게 궁금해져서 친구 중에 리액트 천재에게 물어봤다.친구가 혹시 index.js에 React.StrictMode 사용했어? 라고 물어봤고 확인해보니 진짜였다!어떻게 안거지? 😱마치 내 코드를 본 것만 같은 정확도였다. 리액트공식문서: Strict 모드에 따르면 Strict 모드는 개발 모드에서만 활성화되기 때문에, 프로덕션 빌드에는 영향을 끼치지 않고 애플리케이션의 잠재적인 문제를 알아내기 위해 사용한다고 한다. 잠재적인 문제란? 안전하지 않은 생명주기를 사용하는 컴포넌트 발견 레거시 문자열 ref 사용에 대한 경고 권장되지 않는 findDOMNode 사용에 대한 경고 예상치 못한 부작용 검사 레거시 context API 검사 Ensuring reusable state 참고 컴포넌트 생명주기","link":"/2022/09/12/220913React-useEffect-props/"},{"title":"[ASP.NET] 웹폼(WebForm) VS MVC","text":"이번 프로젝트에서는 웹폼(WebForm)기반으로 개발하게 되었다. MVC 패턴에만 익숙한 내게 웹폼(WebForm)은 생소했다.그래서 웹폼과 MVC이 어떤 차이가 있는지 비교해봤다. WebFrom VS MVC 가장 큰 차이점은 웹폼(WebForm)은 전통적인 이벤트 중심 개발모델이고 MVC는 Model, View, Controller 기반의 개발모델이다. 웹폼 프로세스(로그인예시) 사용자가 로그인폼에 로그인정보 입력 후 로그인버튼 클릭 form데이터들이 POST방식으로 서버에 전송 ASP.NET 실행 엔진을 통해 파싱(데이터 구문 분석과정) -&gt; 클라이언트에서 로그인버튼이 클릭되었음을 확인 로그인버튼에 연결된 이벤트 핸들러 메서드를 찾아 호출 실행결과를 HTML코드로 클라이언트에게 전달 로그인 완료 또는 실패. 웹폼 장점 데이터 Control이 내장되어 있어 강력한 데이터 엑세스로 신속한 개발 가능. 단일 파일 페이지 모델: 코드와 태그를 한 파일에서 확인할 수 있으며 파일일간의 종속성이 없다. 웹폼 단점 개발자 설계 능력에 따라 웹폼 프로젝트 유지보수 강도가 정해진다. 이벤트 중심으로 전체 흐름을 파악하기 어렵다. 테스트 자동화가 어렵다. SEO에 친화적이지 않다. 참고 What is the Difference Between Webform and MVC Difference Between ASP.NET MVC and Web form ASP.NET WebForm, MVC asp.net 웹폼에 대하여..","link":"/2022/09/20/220921ASPNET-WEBFORM-VS-MVC/"},{"title":"[IT용어] AS-IS VS TO-BE","text":"프로젝트문서를 읽던 중 AS-IS 시스템 설명과 TO-BE 시스템 설명을 읽게되었다.영어로 적혀있어 감은 오지만 정확히 어떤 의미로 IT업계에서 사용하는지 궁금해서 찾아보았다. AS-IS영어 의미로는 지금 현재 또는 있는 그대로로 쓰이는데 IT업게예서도 이와 비슷하다.AS-IS 뒤에 다양한 단어들을 붙여서 기존 서비스, 레거시 프로젝트, 기존 시스템등을 의미한다.AS-IS 분석을 잘해놓으면 추후 구현하고자하는 신규 서비스의 TO-BE분석이 수월하다. 예시 AS-IS 시스템: 현재의(기존) 시스템을 의미 AS-IS 분석: 현재의 업무 프로세스를 분석한다는 의미 TO-BE영어 의미로는 미래의 로 쓰이는데 IT업게예서도 이와 비슷하다.미래에 개선될 업무나 프로젝트, 프로세스, 신규 시스템등을 의미한다. 예시 TO-BE 시스템: 신규 시스템을 의미로 프로젝트에 투입될 시스템 TO-BE 분석: 신규 업무 프로세스를 분석한다는 의미로 보통 각 모듈별로 TO-BE 프로세스 작성함","link":"/2022/09/26/220927as-is-to-be/"},{"title":"[JS] 자바스크립트 파일 문서화해주는 유용한 라이브러리 JSDoc","text":"REST API 문서화할때 자주 사용되는 Swagger 라이브러리처럼 자바스크립트 파일을 문서화해주는 라이브러리가 있다. 개발뿐만아니라 프로젝트 산출물시에도 활용할 수 있어 유용한 라이브러이이다. JSDocJavaScript용 API 문서 생성기이다. 공식사이트에 정말 자세히 잘 나와있다! 공식 사이트 공식 깃헙 리포지토리 설치1npm install -g jsdoc 사용 예시애노테이션(@)을 가지고 정말 쉽게 사용할 수 있다.문서확인은 http://localhost/docs/ 로 가면 확인할 수 있다! 123456789/** * 이 메서드는 유저서비스에 사용합니다 * * @module UserHelper * @author sowon-dev * @example * // require에 모듈을 등록하고 사용합니다. * require([..., 'UserHelper'], function (..., UserHelper) */","link":"/2022/09/27/220928JS-JSDoc/"},{"title":"[Spring&#x2F;MySQL] 현재 서버에서 접속한 DB 이름 로그에 나타내기","text":"DB를 여러 가지 쓰는 경우 현재 어느 DB에 접속되어있는지 서버 런할때 로그로 알 수 있으면 좋겠다고 생각했는데 팀장님이 그 방법을 알려주셨다.바로 local.properties에 message.query를 이용하면 된다. local.properties에 message.query 속성 사용하기local.properties파일에서 message.query 속성을 이용하면 된다.아래처럼 입력해주면 끝! 1message.query=SELECT 'ko' as LOCALE, '0000001' as CODE, concat(database(), ' ver.', version() , ' hostname - ', @@hostname) as MSG FROM DUAL","link":"/2022/10/10/221011DBMessageQuery/"},{"title":"[JS] 배열Array와 객체Object 내 포함 여부","text":"자바스크립트에서 배열[] 안의 객체{}가 있는 경우가 많은데 여기서 내가 원하는 값이 포함되어있는지 확인할 수 있는 좋은 메서드가 있는데 바로 some()이다.some()메서드를 알아볼땐 함께 알아봐야할 메서드가 있다. 짝궁인 every()메서드이다. 또한 개인적으로 includes()와 비슷해서 함께 알아보았다. 📌 Some특정 조건을 만족하는지 배열 내부를 차례대로 검사한다.조건에 내부 원소 한 개라도 만족하면 true, 아니면 false를 리턴한다.차례대로 검사하던 중 조건을 만족하는 내부 값이 발견되면 즉시 검사가 중단되고 return값이 나온다. -&gt; 성능에 GOODes5이상 사용가능하다. 배열 내 객체 예시예약프로그램을 예시로 들어보자. 아래처럼 휴일 객체가 있다. 12345const holiday = [ {RESTDE_DATE: '2022-10-03', RESTDE_NM: '개천절'} , {RESTDE_DATE: '2022-10-28', RESTDE_NM: '정기휴관'} , {RESTDE_DATE: '2022-10-30', RESTDE_NM: '임시휴관'}]; holiday 객체안에 2022-10-28 있는지 확인해보자. 1234holiday.some(date =&gt; date.RESTDE_DATE == '2022-10-28')// 결과값true moment.js를 이용해서 오늘이 휴일객체 안에 있는지 확인해볼 수도 있다. 1234holiday.some(date =&gt; date.RESTDE_DATE == moment().format('YYYY-MM-DD'))// 결과값true or false 📌 Everysome과 비교되는 메서드로 every가 있다.특정 조건을 만족하는지 배열 내부를 차례대로 검사한다.조건에 내부 원소 모두 만족하면 true, 아니면 false를 리턴한다.차례대로 검사하던 중 조건을 만족하지 않는 내부 값이 발견되면 즉시 검사가 중단되고 return값이 나온다. -&gt; 성능에 GOODes5이상 사용가능하다. 배열 내 객체 예시예약프로그램을 예시로 들어보자. 아래처럼 휴일 객체가 있다. 12345const holiday = [ {RESTDE_DATE: '2022-10-03', RESTDE_NM: '개천절'} , {RESTDE_DATE: '2022-10-28', RESTDE_NM: '정기휴관'} , {RESTDE_DATE: '2022-10-30', RESTDE_NM: '임시휴관'}]; holiday 객체가 모두 2022-10-31 이전 일자인지 확인해보자. 1234holiday.some(date =&gt; date.RESTDE_DATE &lt; '2022-10-31')// 결과값true moment.js를 이용해서 오늘보다 이전날짜만 있는지도 확인가능하다. 1234holiday.some(date =&gt; date.RESTDE_DATE &lt; moment().format('YYYY-MM-DD'))// 결과값true or false 📌 includes배열이 특정 요소를 포함하고 있는 지 검사한다.있으면 true, 없으면 false를 리턴한다.대소문자를 구별하고 배열[] 에서만 사용할 수 있다. 배열 예시예약프로그램을 예시로 들어보자. 아래처럼 휴일 객체가 있다. 1const holiday = ['2022-10-03', '2022-10-28', '2022-10-30']; holiday배열에 2022-10-28이 있는지 확인해보자. 1234holiday.includes('2022-10-28'))// 결과값true 📌 참고 -스택오버플로우 질문글 when use JS .includes() vs .some()","link":"/2022/10/25/221026JS-some/"},{"title":"[jQuery] attr과 prop차이","text":"제이쿼리를 사용하면서 attr와 prop는 아주 유사한 기능인데 어떠한 차이점이 있고 어떤 상황일때 어떤 걸 쓰는 게 더 좋은지 궁금해서 찾아봤다. 역시 제일 좋은 건 jQuery 공식문서이다.jQuery 1.6.0 버전에서부터 jQuery.attr()과 jQuery.prop()가 나눠졌다. jQuery.attr() jQuery.prop() 정의 changes attributes for that HTML tag. changes properties for that HTML tag as per the DOM tree 취급 HTML 속성 (Attribute) 취급 javascript 프로퍼티 (Property) 취급 반환값 returns the default value (Original state) returns the current value (Current state) 많은 상황에서 둘은 같은 값을 반환하지만 attr()는 원래 값을 prop()는 현재 값을 반환한다.예를 들어보자. 12&lt;input type=\"checkbox\" id=\"test1\" checked=\"checked\"&gt; 테스트1&lt;input type=\"checkbox\" id=\"test2\"&gt; 테스트2 위 두가지 체크박스의 차이는 checked가 기본값인지 아닌지이다.이를 콘솔에 찍어보면 차이를 발견할 수 있다. 123456$(&quot;#test1&quot;).attr(&quot;checked&quot;)$(&quot;#test2&quot;).attr(&quot;checked&quot;)//결과값checkedundefined 123456$(&quot;#test1&quot;).prop(&quot;checked&quot;)$(&quot;#test2&quot;).prop(&quot;checked&quot;)//결과값truefalse attr()은 최초 element 랜더링시 defalut value를 반환하지만 prop()는 현재상태를 반환한다. 결론 .attr() : element가 가지는 속성 조회 권장 style, src, rowspan .prop(): element가 가지는 실제적인 상태 제어 사용 권장 form요소의 disabled, selected, checked 속성값 확인 혹은 변경 참고 https://api.jquery.com/attr/ https://api.jquery.com/prop/ http://net-informations.com/jq/iq/prop.htm","link":"/2022/10/27/221028jQuery-attr-vs-prop/"},{"title":"[SQLD] 테이블 분할","text":"SQL을 더 잘 다루고싶어서 공부하다가 하는 김에 결과가 남는 자격증을 도전하게되었다.테이블 반정규화 과정에는 3가지가 있다. 🏷️ 테이블 반정규화 테이블 병합: 1:1관계, 1:M관계, 슈퍼/서브타입 테이블 분할: 수직분할, 수평분할 테이블 추가: 중복, 통계, 이력 이 중 테이블 분할에 대해 궁금해져 자세히 알아보았다.테이블은 합치는 것보다 나누는 것이 더 어렵다. 사실 기존 테이블을 바꾼다는 것 자체가 큰 위험이 따른다. 이렇게 위험한 테이블 반정규화를 왜 하는걸까?반정규화는 시스템 성능향상과 개바로가 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 기법이다. 즉, 장기적으로 봤을 때 기존 시스템보다 개선효과가 클때 반정규화를 한다. 테이블 컬럼 수 많을수록 -&gt; I/O(Input/Output) 부하 생김 테이블 Row 수 많을수록 -&gt; Index 부하 생김 따라서, 컬럼 또는 로우 기준으로 수직 또는 수평으로 테이블 분리를 통한 성능 개선을 검토한다.그럼 이제 수직분할과 수평분할을 알아보자. 🏷️ 수직분할 정의: 컬럼 기준으로 테이블 분리 분리이유 만약 한 테이블에 너무 많은 컬럼이 존재한다면 디스크의 여러 블록에 데이터가 저장되어 디스크I/O성능 저하가 일어난다. 왜 디스크의 여러 블록에 데이터가 저장될까? 로우체이닝과 로우 마이그레이션이 많아지기때문! 로우체이닝과 로우마이그레이션이 많아지면 디스크I/O 성능저하가 나타난다. Row Chaining: 길이가 너무 길어 하나의 블록에 저장되지 못하고 다수의 블록에 나눠 저장 Row Migration: 수정된 데이터를 해당 데이터 블록에 저장하지 못하고 다른 블록 빈 공간에 저장 분리기준 조회 조건에 맞게 이용되는 컬럼들을 그룹화하여 분리 🏷️ 수평분할 정의: Row 기준으로 테이블 분리 분리이유 대량의 데이터가 하나의 테이블에 있으면 인덱스 정보 생성시 부하가 터진다. 집중 발생되는 트랙잰션 해소를 통한 성능 향상 왜 인덱시 정보 생성시 부하가 커질까? 인덱스 깊이(Depth)가 깊어지면 찾아가는데 해당 depth까지 시간이 오래 걸림 인덱스 크기가 커질수록 더 많은 성능 저하 분리기준 논리적으로 같은 테이블이지만 물리적으로 나누는 파티션 방법 이용 수평분할시 분리기준으로 파티션 방법이 있다. 파티션 방법이 구체적으로 뭘까? 파티셔닝 종류 파티셔닝명 분리기준 예시 List 사용자가 지정한 값으로 분리(불연속적, 보통 핵심적인 코드값) 판매데이터를 지역별로 Range 주로 날짜 또는 숫자값 기준으로 분리 판매데이터를 분기별로 Hash 파티션 키 값에 해시 함수를 적용하여 지정된 Hash조건에 따라 분리 고객번호, 주문일련번호 등 Composite Range나 List 파티션 내 다른 서브파티션 Range + List 또는 List + Hash 참고 데이타온에어 전문가칼럼 - 테이블의 수직분할과 수평분할에 대한 이해 엄범 기술블로그 - 분산 DB, 파티셔닝 (partitioning ), 샤딩 (sharding)","link":"/2022/10/29/221029SQLD-tablepartition/"},{"title":"[SQLD] 슈퍼타입과 서브타입","text":"슈퍼/서브타입 데이터 모델은 Extended ER모델이라고도 불린다. 슈퍼타입: 공통의 부분 서브타입: 공통으로부터 상속받아 서 if 10만건도 되지 않는 데이터 or 시스템을 운영하는 도중에도 데이터가 증가하지 않는다, 트랜잭션의 성격을 고려하지않고 전체를 하나의 테이블로 묶는 것도 괜찮은 방법이다.하지만 데이터 양이 이미 많고 지속적으로 증가한다면 슈퍼/서브타입 물리적 데이터 모델로 변환하는 세 가지 유형을 고려해야한다. 성능을 고려한 슈퍼/서브타입 데이터 모델 변환 논리모델 One to One Type(1:1 타입) Plus Type(슈퍼+서브 타입) Single Type(All in One 타입) 정의 if 슈퍼타입과 서브타입 각각 트랜잭션이 발생, 개별 테이블로 구성(1:1 관계) if 슈퍼타입과 서브타입 함께 트랜잭션이 발생, 슈퍼타입의 PK와 각 서브타입의 속성을 묶어 N개의 테이블을 구성 if 슈퍼타입과 서브타입 정확히 지정x상황, 하나의 테이블로 통합 예시 고객엔티티 하위에 개인고객, 법인고객으로 구분 개인고객엔티티, 법인고객엔티티 고객엔티티 물리모델 결정기준 개별로 발생되는 경우가 많은 서비스는 Identity로 슈퍼타입+서브타입에 대해 발생되는 서비스는 RollDown 으로! 전체를 하나로 묶어 트랜잭션이 발생할 때는 RollUp 으로! 출처 마띠의블로그 - 데이터베이스 구조와 성능 데이터온에어 - ‘6개의 열쇠’로 데이터 모델링의 고수가 되자 공부하는 개발자 핑구 - 슈퍼-서브타입 모델의 물리모델 결정기준","link":"/2022/10/31/221101SQLD-super-sub/"},{"title":"[JSTL] java.util.Date 현재날짜의 시간을 0으로 설정하기","text":"JSTL로 현재날짜와 DB에서 가져오는 날짜 차이를 계산했었다.잘 되는 줄 알았던 코드가 특정 시간을 기점으로 버그가 발생한다는 것을 알게되었다. 기존코드와 문제점구글링하면 가장 많이 사용하는 방법으로 포스팅 - 날짜 차이 계산하기을 작성했다.날짜차이 계산은 모든 날짜를 시간으로 바꾼 뒤 뺄셈을 통해 날짜가 얼마나 남았는지 계산할 수 있다. 12345&lt;jsp:useBean id=\"now\" class=\"java.util.Date\" /&gt;&lt;fmt:parseNumber var=\"nowfmtTime\" value=\"${now.time / (1000*60*60*24)}\" integerOnly=\"true\" scope=\"request\"/&gt;&lt;fmt:parseNumber var=\"dbDtParse\" value=\"${list.dbDt.time / (1000*60*60*24)}\" integerOnly=\"true\" scope=\"request\"/&gt;${nowfmtTime } 코드상의 문제는 전혀없으나 요구사항이 하루전에는 예약할 수 없는 예약프로그램을 구현하는 것이라서 수정이 필요했다.현재시간을 time로 변경하는데 HH:mm:ss가 00:00:00이 아니라서 위 방식으로 시간계산시 미세하게 차이가 발생했다.이를 해결하기 위해 현재날짜의 시간을 0으로 설정해야했다. 해결코드123456&lt;jsp:useBean id=\"now\" class=\"java.util.Date\" /&gt;&lt;fmt:formatDate var=\"today\" value=\"${now}\" pattern=\"yyyyMMdd000000\" /&gt;&lt;fmt:parseDate var=\"nowfmt\" value=\"${today}\" pattern=\"yyyyMMddHHmmss\"/&gt;&lt;fmt:parseNumber var=\"nowfmtTime\" value=\"${nowfmt.time / (1000*60*60*24)}\" integerOnly=\"true\" scope=\"request\"/&gt;${nowfmtTime } fmt:formatDate의 pattern속성으로 시간을 0으로 설정한다.그리고 fmt:parseDate로 Date 타입으로 파싱해준 뒤 바로 날짜를 이용할 수 있고 나처럼 날짜계산을 위해 다시 fmt:parseNumber 숫자타입으로 변경해서 이용할수도 있다. 참고 JSTL과 EL : fmt 라이브러리(formatDate, formatNumber)","link":"/2022/11/02/221103JSP-utilDatefmt/"},{"title":"[jQuery] checkbox와 select 다루기","text":"jQuery로 checkbox와 select 다루는 법을 전체적으로 정리해보자. ✍Checkbox 1. 체크하기12345// ID로 지정하는 방법$('#체크박스아이디').prop('checked',true);// input 속성으로 지정하는 방법$('input:checkbox[name=\"체크박스네임\"]').prop('checked',true); 2. 체크여부 확인123$('#체크박스아이디').is(':checked');// 반환값: true, false 참고로 $('#체크박스아이디').val()을 하면 반환값이 on이나 undifined가 뜬다. 3. 한번에 전체 체크하기123456$('#allCheck').click(function(){ var isChecked = $('#allCheck').is(':checked'); if(isChecked) $('input:checkbox').prop('checked',true); }); ✍ Select 1. 값 읽기(가져오기)12345// ID로 접근하는 방법$(\"#셀렉트박스아이디 option:selected\").val();// input 속성으로 접근하는 방법$(\"select[name=셀렉트박스네임]\").val(); 2. 옵션 추가하기12345// 옵션추가$(\"#셀렉트박스아이디\").append(\"&lt;option value='1번'&gt;1번 테스트&lt;/option&gt;\");// 옵션을 맨 앞에 추가$(\"#셀렉트박스ID\").prepend(\"&lt;option value='맨앞'&gt;맨앞&lt;/option&gt;\"); 3. 옵션 삭제하기123456789101112131415// 옵션 전체 삭제$(\"#셀렉트박스아이디 option\").remove();$(\"select[name=셀렉트박스네임] option\").remove();// 특정 옵션 벨류 값으로 삭제$(\"#셀렉트박스아이디 option[value='맨앞']\").remove();// 특정 옵션 인덱스 값으로 삭제$(\"#셀렉트박스아이디 option:eq(0)\").remove();// 첫번째 옵션 삭제$(\"#셀렉트박스아이디 option:first\").remove();// 마지막 옵션 삭제$(\"#셀렉트박스아이디 option:last\").remove(); 4. 선택하기12// 옵션 전체 삭제$(\"#셀렉트ID option:eq(1)\").attr(\"selected\", \"selected\");","link":"/2022/11/08/221109jQuery-input-type/"},{"title":"asp.net 웹폼(Web Form)프로젝트를 끝내며 내가 배운 것","text":"이번 프로젝트는 나에게 효율이 나질않는 프로젝트였다.MVC패턴이 아닌 웹폼프레임워크를 처음 사용하면서 효율이 제대로 나오지않아 많이 답답했다. 이번 프로젝트에서는 Code-Behind Page Model을 사용했는데 *.aspx.cs로부터 클래스를 상속받는 *.aspx파일에 html과 js로 화면작업을 했다.화면작업 위주로 했기에 백단을 많이 다루지 못해 개인적으로 아쉬운 프로젝트였다. keep현재 만족하고 있는 부분과 계속해서 이어갔으면 하는 부분 레거시 코드를 분석하고 페이지테스트없이 코드를 이해하는 능력: 레거시 프로젝트를 고도화하는 작업이었기 때문에 레거시 코드를 정확히 읽어 기능을 이해하는 것이 작업의 핵심이였다. 프로젝트 특성상 기능을 테스트해볼수있는 페이지없이 오로지 코드만 보고 기능을 이해해야했기에 처음에는 버벅거렸으나 프로젝트 후반에는 술술 읽혀서 나조차 신기했다. 스스로 가장 많이 성장했다고 생각하는 부분이다. 프로시저 바로 이해하기: 이번 프로젝트는 전체가 프로시저로 구현되어있어 프로시저를 읽고 해석하는 부분이 많았고 덕분에 프로시저와 엄청나게 친숙해졌다. Problem개선이 필요하다고 생각되는 부분 엑셀파일을 업로드하면 엑셀파일을 읽어서 DB에 등록하는 부분 코드 뜯어보기: 호출만 하고 넘어간 부분인데 스스로 구현할 수 있을정도로 깊게 봤으면 더 성장했겠다는 생각이 들었다. TryProblem의 해결책이 될 수 있는 부분 이번에는 백엔드를 거의 건들이지 않았는데 욕심내서 뜯어볼 수도 있었는데 호출만해서 사용한 점이 아쉽다.","link":"/2022/11/10/221111projectreview8/"},{"title":"Cron표현식이 뭐길래","text":"신규로 맡은 프로젝트의 코드분석 중 크론표현식을 만났다.크론표현식을 한 번 공부한 적이 있어서 당연히 술술 읽힐 줄 알았는데 웬걸… 기억이 나질않았다.역시 안다고 생각하는 것과 아는 것은 다르다. 이참에 포스팅을 통해 확실히 내 것으로 만들어야겠다. 개념Cron 표현식은 스케줄러 시간을 세팅할 때 주로 사용되는 표현식으로 7개의 필드를 띄어쓰기로 구분한다.연도는 생략가능하다! 형태시간을 나타내는 표현식인만큼 필드를 외우기는 참 쉽다! 1&lt;초&gt; &lt;분&gt; &lt;시&gt; &lt;일&gt; &lt;월&gt; &lt;요일&gt; &lt;년&gt; 각 필드마다 허용되는 값과 허용되는 특수문자가 다르다. 각 특수문자의 의미도 알아둬야한다! 필드 필수여부 허용되는 값 허용되는 특수문자 초 Y 0-59 , - * / 분 Y 0-59 , - * / 시간 Y 0-23 , - * / 일 Y 1-31 , - * ? / L W C 월 Y 0-11 or JAN-DEC , - * / 요일 Y 1-7 or SUN-SAT or sun-sat , - * ? / L C # 년 N empty or 1970-2099 , - * / 특수문자의 의미 특수문자 의미 * 모든 값 ? 특정한 값이 없음 - 범위 지정 , 여러 값을 지정 / 증가하는 값을 지정(초기값/증가값) L 마지막 값 지 W 가장 가까운 평일 # 몇 번째 무슨 요일인지 지정 예시123456780 30 13 * * ?// 매일 오후 1시 30분마다0 30 10 ? * MON-FRI//평일 오전 10시 30분마다0 15 15 L * ?// 매월 말일 3시 15분마다 사실 가장 쉬운 방법은 cronmaker사이트를 이용하면된다. 참고 https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm https://dev-bri.tistory.com/4","link":"/2022/11/16/221116cron/"},{"title":"[JS]Web Storage vs 쿠키(Cookie) vs 세션(Session) vs 캐시(Cache)","text":"레거시프로젝트의 소스코드를 분석하다가 Web Storage를 만났다.localStorage와 sessionStorage를 둘 다 사용하고 있었기에 둘 차이가 궁금해졌다. 구글링할수도록 쿠키, 세션, 캐시까지 다양한 개념이 나오길래 이참에 다 정리해봤다. Web Storage 클라이언트에 저장 Key-Value 형태 쿠키와 달리 서버에 전송안함 CSRF로부터 안전 why? Origin단위로 접근이 제한되기때문에. 쿠키(4GB)보다 큰 저장용량(5GB)지원 문자형(String) 데이터 타입만 지원 종류 localStorage: 사용자가 데이터를 지우지 않는 이상, 브라우저나 OS를 종료해도 계속 브라우저에 남아있음 (영구성) 단, 동일한 브라우저를 사용할 때만 해당 sessionStorage: 브라우저 탭에도 종속되기 때문에, 윈도우나 브라우저 탭을 닫을 경우 제거 Origin 오리진이란?오리진 = 프로토콜 + 도메인 + 포트 비교 localStorage sessionStorage Cookie Session 저장위치 클라이언트 클라이언트 클라이언트 서버 저장형식 String String String Obejct 전송 서버전송x -&gt; 서버 부담없음 서버전송x -&gt; 서버 부담없음 매번 서버에 자동 전송 -&gt; 크기가 크면 서버에 부담 서버에서 클라이언트를 구분하기 위해 세션 ID를 부여 -&gt; 사용자가 많아질수록 서버 메모리를 많이 차지 유효기간 설정 불가능 불가능 가능 가능(기본 30분) 데이터영구성 브라우저 종료해도 유지 명시적 삭제 필요 윈도우나 브라우저 탭을 닫을 경우 삭제됨 쿠키 저장시 설정(설정 없을 시에는 브라우저 종료시 만료) 브라우저 종료 시 만료기간에 상관없이 삭제됨 생성단위 Origin별로 생성다른 오리진의 로컬 스토리지에는 접근 불가서로 다른 브라우저 탭이라도 동일한 오리진이라면 동일한 로컬 스토리지를 사용함 Origin별마다 탭/윈도우 단위로 생성-&gt;탭/윈도우를 닫을 시 데이터가 삭제됨 브라우저에 여러개 생성가능 브라우저당 하나의 세션SessionID이 생성 주 사용처 지속적으로 필요한 정보를 저장할때e.g.자동 로그인 등 잠시 동안 필요한 정보를 저장할 때e.g.입력 폼 저장, 일회성 로그인 등 로그인유지, 자동완성, 일주일간 다시 보지 않기, 최근 검색한 상품들을 광고에서 추천, 쇼핑몰 장바구니 기능 로그인유지 캐시(Cache)는 또 뭘까?쿠키와 세션을 이야기하다보면 자연스럽게 캐시가 나온다.어떤 차이가 있을까? 캐시: 웹 페이지 요소(e.g.img,css,js등 리소스파일)를 저장하기 위한 임시 저장소 for 빠른 웹페이지 랜더링 쿠키,세션: 정보 저장소 for 사용자인증 참고 https://developer.mozilla.org/ko/docs/Web/API/Window/sessionStorage IT엘도라도 - 쿠키, 웹 스토리지(로컬 스토리지, 세션 스토리지) 푸고배님 - 쿠키 vs 세션 vs 웹 스토리지(로컬 스토리지, 세션 스토리지) https://sowon-dev.github.io/2020/06/30/200701jspi/","link":"/2022/11/21/221121JS-webstorage/"},{"title":"레디스(Redis)가 뭐길래","text":"종종 들었던 Redis, 이번 레거시프로젝트 소스코드분석중 RedisTemplate을 만나면서 그 개념을 함께 정리해보고자한다. In Memory DB란? 인메모리 데이터베이스(In-memory Database)는 데이터 스토리지의 메인 메모리에 설치되어 운영되는 방식의 데이터베이스 관리 시스템이다.인메모리 데이터베이스는 디스크에 최적화된 데이터베이스보다 더 빠른데 그 까닭은 디스크 접근이 메모리 접근보다 느리기 때문이며, 이 데이터베이스는 내부 최적화 알고리즘이 더 단순하며 더 적은 CPU 명령을 실행한다. 메모리의 데이터에 접근하면 데이터를 조회할 때 검색 시간이 줄어들며 디스크보다 더 빠르고 더 예측 가능성 성능을 제공한다.인메모리 데이터 스토리지의 잠재적인 기술적 문제는 RAM의 휘발성이다. 구체적으로 말해 전원이 소실될 경우나 고의적인 상황 등에서 휘발성 RAM 안에 저장된 데이터는 손실된다.비휘발성 RAM 기술의 도입으로 인메모리 데이터베이스는 전력 손실에도 완전한 속도로 데이터를 유지할 수 있게 되었다.출처: 위키백과 인메모리DB 특징인메모리디비의 가장 큰 특징은 2가지이다. 인메모리 데이터구조: 디스크 아닌 메모리 기반. Redis의 가장 큰 특징. 캐시를 사용하여 속도가 빠름 인메모리DB 사용처크게 3가지 용도로 사용한다. 데이터베이스 캐시 메세지 브로커 결국 빠른 속도를 위해서 메모리에 올려서 사용하는 데이터 저장소이다.인메모리DB의 종류에는 Redis, Memcached, Amazon ElastiCache 등이 있고 그 중 Redis의 인기가 압도적으로 높다. Redis란?Redis는 REmote DIctionary Server의 약어로 Key와 Value를 가진 오픈소스 NoSQL 데이터베이스이다.여기서 NoSQL이란 스키마없이 데이터를 표현한 데이터베이스로 NoSQL이 뭐길래포스팅을 참고하면된다. Redis 특징 다양한 데이터 구조: String, Set, Sorted Set, Hash, List 등 다양한 타입을 지원 스냅샷: 장애시 복구 가능 Master-Slave 구조로 여러 개의 복제본 만들기 용이 트랜잭션 지원 Pub(발행) / Sub(구독) 방식의 메시징을 지원 DB가 있는데 인메모리DB를 왜 쓸까?근원적인 궁금증을 해결해준 글을 발견해서 발췌해왔다. 데이터 베이스가 있는데도 Redis라는 인메모리 데이터 구조 저장소를 사용하는 이유는 무엇일까요?데이터 베이스는 데이터를 물리 디스크에 직접 쓰기 때문에 서버에 문제가 발생하여 다운되더라도 데이터가 손실되지 않습니다. 하지만 매번 디스크에 접근해야 하기 때문에 사용자가 많아질수록 부하가 많아져서 느려질 수 있는데요.일반적으로 서비스 운영 초반이거나 규모가 작은, 사용자가 많지 않은 서비스의 경우에는 WEB - WAS - DB 의 구조로도 데이터 베이스에 무리가 가지 않습니다.하지만 사용자가 늘어난다면 데이터 베이스가 과부하 될 수 있기 때문에 이때 캐시 서버를 도입하여 사용합니다.그리고 이 캐시 서버로 이용할 수 있는 것이 바로 Redis 입니다.캐시는 한번 읽어온 데이터를 임의의 공간에 저장하여 다음에 읽을 때는 빠르게 결괏값을 받을 수 있도록 도와주는 공간입니다.같은 요청이 여러 번 들어오는 경우 매번 데이터 베이스를 거치는 것이 아니라 캐시 서버에서 첫 번째 요청 이후 저장된 결괏값을 바로 내려주기 때문에 DB의 부하를 줄이고 서비스의 속도도 느려지지 않는 장점이 있습니다.출처: Jan92님 블로그 - Redis란? 레디스의 기본적인 개념 MSSQL이나 MYSQL도 인메모리테이블을 지원하는데 왜 굳이 레디스(Redis)를 사용할까?레디스에 대해 이야기를 나누다가 팀장님이 RDB에서도 인메모리를 지원하는데 왜 굳이 레디스를 사용하는 지 알아보는게 어떠냐고 제안해주셨다.RDB에서도 메모리DB를 쓸수있다니! 전혀 몰랐던 사실이어서 공부해봤다. DB명 인메모리DB 사용 적용법 Oracle In Memory Option Oracle Database In-Memory Option –I (설명과 설정방법) MySQL 메모리테이블 DB 튜닝 - MySQL Memory 테이블 사용 MSSQL 메모리테이블 MSSQL 테이블을 인메모리(in-memory)로 사용하는 방법 왜 굳이 레디스를 사용할까?먼저, 레디스는 사용자가 많아 자료가 많다. 커뮤니티가 큰 오픈소스를 사용해야 적용 및 대응이 쉽다.두번째로 인메모리데이블은 제약사항이 많은 반면에 레디스는 다양한 데이터구조 사용가능, 스냅샷으로 복구시 활용가능한 점등이 확장성을 고려해봤을때도 여전히 좋다. 참고 https://aws.amazon.com/ko/elasticache/what-is-redis/ https://wildeveloperetrain.tistory.com/m/21 위키백과 - 인메모리데이터베이스 http://www.koreaoug.org/c12/935 https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=oralol&amp;logNo=222198862146 https://mozi.tistory.com/566 https://kdhyo98.tistory.com/89","link":"/2022/11/21/221122Redis/"},{"title":"[MySQL&#x2F;MariaDB] 함수(function) vs 프로시저(Procedure) 차이","text":"이번에 진행중인 프로젝트는 프로시저보다 함수가 더 많이 사용되었다. 지난번 담당했던 프로젝트는 오직 프로시저만 썼었다. 둘의 차이가 뭘까? 언뜻 생각해봤을땐 return유무정도인데 깊이있게 알고싶어졌다. 함수 정의: 항상 리턴값을 가짐 특징 리턴값은 필수이고 오직 하나 try catch 사용 불가 단점 클라이언트실행으로 프로시저보다 속도가 느리다. 선언 123456789CREATE FUNCTION function_name( param1, param2,…)RETURNS datatype[NOT] DETERMINISTICBEGIN -- statementsEND 선언예시 12345create function MultiplyNumbers(@int1 as int,@int2 as int)AsBEGINReturn (@int1 * @int2)end 호출 12MultiplyNumbers(2,2) // RETURN: 4 프로시저 정의: 특정 작업을 수행. 여러 SQL문을 한 번에 실행 가능 특징 개발업무와 DB처리를 구분하여 개발할 수 있음 보수성 뛰어남 서버 실행이라 속도가 함수보다 상대적으로 빠름 리턴값 없거나 여러개도 가능 -&gt; 유연성 try catch 사용가능 -&gt; 에러처리가능 단점 재사용성이 좋지 않음 선언 1234Create Procedure [Procedure Name] ([Parameter 1], [Parameter 2], [Parameter 3] )Begin-- SQL Queries..End 선언 예시 1234CREATE PROCEDURE GetAllProducts()BEGINSELECT * FROM products;END 호출 1CALL GetAllProducts() 차이 함수(Function) 프로시저(Procedure) 처리주체 클라이언트에서 처리 서버로 보내서 처리 리턴값 유무 필수 선택 리턴값 갯수 하나만 반환가능 여러개 반환가능 호출방법 select문장안에서 함수호출 call 프로시저명() 주사용처 로직 처리 도와주는 용도 로직 처리를 직접하는 용도 why? DML문 사용가능해서 참고 https://www.geeksforgeeks.org/difference-between-function-and-procedure/ https://www.mysqltutorial.org/getting-started-with-mysql-stored-procedures.aspx https://velog.io/@devjooj/Mysql-Function%EA%B3%BC-Procedure-%EC%B0%A8%EC%9D%B4 https://spiderwebcoding.tistory.com/7","link":"/2022/11/28/221129MySQL-function-Procedure/"},{"title":"[jQuery] Ajax 글로벌 이벤트(Global Event)가 뭐길래","text":"레거시 소스코드를 분석하면서 jQuery.ajaxSetup()에 대해 알아볼 기회가 생겼다. jQuery Ajax는 지역 이벤트(Local Event)와 전역 이벤트(Global Event)로 나뉜다. 둘이 가지고 있는 이벤트가 매우 비슷하다. 지역 이벤트(Local Event) vs 전역 이벤트(Global Event) 로컬 이벤트 글로벌 이벤트 셋팅 global속성을 false(default)설정 global속성을 true설정 시행시기 ajax수행의 특정시점에 함수가 호출되는 callback형태로 이벤트 발생 개별 혹은 전체 ajax전송에 이벤트 발생 전송시 beforeSend ajaxSend() 성공시(응답코드 200 일때) success ajaxSuccess() 에러발생시(응답코드 오류일때) error ajaxError() 완료시 complete ajaxComplete() 시작시 정의 ajaxStart() 정지시 ajaxStop() 특징 지역과 전역에 둘다 존재하는 send, success, error, complete와 관련된 이벤트들은 지역이벤트 callback이 실행 후 전역이벤트가 실행된다. 참고 https://api.jquery.com/jquery.ajaxsetup/ https://www.nextree.co.kr/p10308/","link":"/2022/11/29/221130jQuery-global/"},{"title":"[MySQL&#x2F;MariaDB] xml파일에 PASSWORD()가 뭐길래","text":"xml파일에 선언하지 않았던 AES_DECRYPT(), UNHEX(), PASSWORD() 함수들이 보였다. 쿼리를 읽었을때 암호화와 복호화인건 알았으나 구체적인 사용방법을 알고 싶어 구글링해보니 MARIADB가 제공하는 내장함수였다. 예시코드 12345select USER_NO , AES_DECRYPT(UNHEX(USER_NUM), #{encrypt_key}) AS USER_NUM , PASSWORD(#{user_login_pin}) AS USER_LOGIN_PIN -- 중략from USER 마리아DB 공식문서에 너무 잘 나와있어서 이해하기 훨씬 편했다. 마리아DB 공식 문서-영어 마리아DB 공식 문서-한국어 한글버전이 있지만 번역되지 않은 페이지가 더 많으므로 영어로 보는 것을 추천한다.그리고 공식문서를 보기위해선 현재 프로젝트가 어떤 버전을 사용하고 있는지 알아야한다. 사용하고 있는 마리아DB버전에 따라 지원되지 않는 함수가 있을 수 있기때문이다.db를 열어 아래 쿼리를 입력해주면 된다. MariaDB 버전확인 하는 방법1234select version();// 쿼리 결과 예시10.3.32-MariaDB-log PASSWORD() Calculates and returns a hashed password string from the plaintext password str. Returns an empty string (&gt;= MariaDB 10.0.4) if the argument was NULL.The return value is a nonbinary string in the connection character set and collation, determined by the values of the character_set_connection and collation_connection system variables.This is the function that is used for hashing MariaDB passwords for storage in the Password column of the user table (see privileges), usually used with the SET PASSWORD statement. It is not intended for use in other applications출처: https://mariadb.com/kb/en/password 순수 문자열을 입력하면 해시처리된 문자열로 바꿔주는 함수이다. 만약 순수 문자열이 NULL인 경우에는 빈 문자열이 반환된다.왜 PASSWORD() 함수를 사용해야할까? 사용자가 입력한 비밀번호를 개발자도 모르는 암호화된 값으로 바꿔서 DB에 저장하기때문이다.어떤 방식으로 암호화될까? 마리아DB 버전4.1까지는 기존의 SHA-1 알고리즘을 사용했으나 보안의 취약성으로 인해 마리아DB 5.2부터는 ed25519 인증플러그인을 사용한다. 구문1PASSWORD(str) 예시123456SELECT PASSWORD('notagoodpwd');+-------------------------------------------+| PASSWORD('notagoodpwd') |+-------------------------------------------+| *3A70EE9FC6594F88CE9E959CD51C5A1C002DC937 |+-------------------------------------------+ HEX()와 UNHEX() HEX(): 기존 텍스트를 16진수 값의 문자로 변환하여 반환한다. UNHEX(): HEX의 역산으로 16진수를 숫자로 해석을 하고 그 숫자에 대응하는 문자로 변환한다. 그 결과, 문자들은 바이너리 스트링으로 리턴된다. 그리고 UTF8로 CONVERT 작업을 해주면 기존 텍스트로 변환이 가능하다. 예시12345678910111213SELECT HEX('MariaDB');+----------------+| HEX('MariaDB') |+----------------+| 4D617269614442 |+----------------+SELECT UNHEX('4D617269614442');+-------------------------+| UNHEX('4D617269614442') |+-------------------------+| MariaDB |+-------------------------+ 참고 https://mariadb.com/kb/en/password/ https://victorydntmd.tistory.com/144 https://shxrecord.tistory.com/238","link":"/2022/12/05/221206mariadb-passwordhashing/"},{"title":"[Java] web.xml이 뭐길래","text":"자바로 웹어플리케이션을 만드면 필수로 만나게 되는 파일 중 web.xml이 있다. web.xml이란단어로는 Deployment Descriptor로 배포설명자이다.자바 웹 애플리케이션은 배포 설명자 파일을 사용하여 URL이 서블릿에 매핑되는 방법, 인증이 필요한 URL 등의 정보를 확인한다.자바 웹 애플리케이션이면 반드시 하나씩 존재해야하는 파일이며 프로그램에 필요한 전반적인 설정을 지정할 수 있다.프로젝트 실행시 가장 먼저 실행되는 파일로서 메모리에 로딩된다.위치는 WEBCONTENT하위의 WEB-INF폴더 하위에 있으며 가장 많이 사용되는 곳은 에러코드별 페이지처리이다. In a java web application a file named web.xml is known as deployment descriptor. It is a xml file and is the root element for it. When a request comes web server uses web.xml file to map the URL of the request to the specific code that handle the request.출처: w3schools 무엇을 설정할수있을까? ServletContext의 초기 파라미터 Session의 유효시간 설정 Servlet/JSP에 대한 정의 Servlet/JSP 매핑: URL 패턴 및 URL이 해당 패턴과 일치하는 요청에 사용할 선언된 서블릿의 이름을 지정. 123456789&lt;servlet-mapping&gt; &lt;servlet-name&gt;redteam&lt;/servlet-name&gt; &lt;url-pattern&gt;/red/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;blueteam&lt;/servlet-name&gt; &lt;url-pattern&gt;/blue/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Mime Type 매핑 Welcome File list Error Pages 처리 12345&lt;!-- 존재하지 않는 페이지, 404에러시 처리 페이지를 error.jsp로 설정함 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; 리스너: 어떠한 이벤트가 발생하면 호출되어 처리하는 객체 123&lt;listener&gt; &lt;listener-class&gt;TestListener&lt;/listener-class&gt;&lt;/listener&gt; 필터: Spring-Filter 포스팅참조 보안: 패턴과 일치하는 URL에 대한 보안 제약조건을 정의할 수 있다. 제약조건에서 사용자 역할을 admin으로 지정하면 등록된 애플리케이션 개발자만 URL에 액세스하도록 만들수있다. 123456789&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;admin&lt;/web-resource-name&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;admin&lt;/role-name&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; 참고 https://www.w3schools.blog/deployment-descriptor-web-xml-file http://wiki.gurubee.net/pages/viewpage.action?pageId=26740333&amp; https://cloud.google.com/appengine/docs/standard/java/config/webxml?hl=ko","link":"/2022/12/06/221207sring-webxml/"},{"title":"[Spring]RestTemplate과 HttpEntity가 뭐길래(제네릭과 ParameterizedTypeReference)","text":"프로젝트를 하다보면 화면이 아닌 서비스단에서 외부 API와 호출해야할 일들이 생긴다.이때 주로 사용되는 것이 RestTemplate이다. 이번 프로젝트에서 백엔드 업무를 도맡았다. 첫 작업으로 맡게 된 건 외부 프로그램과 API로 연동하는 작업이었다.Http통신을 화면에서 수도없이 날렸지만 서비스단에서 하는 건 업무로썬 처음이었다. 결론 너무 재밌다!역시 난 프론트보단 백이 더 재밌어. ✍ RestTemplate 이란?스프링 3.0에서부터 지원하는 객체로 REST방식으로 API를 호출할 수 있는 내장 클래스이다.스프링어플리케이션에서 HTTP요청할때 사용하며 주로 외부API와 연동할때 RestTemplate와 함께 MultiValueMap, HttpEntity도 사용한다.다만, 스프링프레임워크5부터는 WebClient사용을 권장하고 있기에 조만간 RestTemplate은 deprecated 될지도 모른다. 특징 RESTful 원칙을 지킴 멀티쓰레드 방식 사용 Blocking(동기) 방식 사용 함수 가장 많이 사용하는 메서드는 당연 exchage()이다. exchage() : 모든 HTTP 요청 메소드를 지원하며 원하는 서버에 요청시켜주는 메소드1ResponseEntity&lt;원하는클래스타입&gt; resultMap = restTemplate.exchange(uri.toString(), HttpMethod.원하는통신, entity, 원하는클래스타입.class); ✍ 사용방법 1 의존성 설정스프링부트를 사용하면 이미 포함되어있으므로 의존성 설정을 따로 해줄 필요가 없다. 1implementation 'org.springframework.boot:spring-boot-starter-web' 2 RestTemplate의 생성 Header 생성: HTTP요청을 보낼때 Body를 설명해주는 Header도 같이 보내야한다. Body 생성: key-value 형식인 MultiValueMap 타입을 사용해서 만든다. HttpEntity생성: HTTP통신을 하려면 Header와 Body가 하나여야하는데 HttpEntity클래스가 Header와 Body를 합쳐준다. 123456789101112131415161718192021222324252627282930public class RestTemplateClientService {public String test() { // 1. Header생성 HttpHeaders headers = new HttpHeaders(); headers.add(\"content-type\", \"application/json\"); // 2. Body생성 MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;(); params.add(\"name\", \"sowon-dev\"); // 3. HttpEntity생성 HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; entity = new HttpEntity&lt;&gt;(params, headers); // 4. HTTP 통신 RestTemplate rt = new RestTemplate(); ResponseEntity&lt;Map&gt; response = rt.exchange( \"http://localhost:3000/\", //요청할 서버주소 HttpMethod.POST, //요청방식 entity, //요청데이터 String.class //반환되는 데이터타입 ); // 5. Map데이터타입을 메서드리턴타입인 String형태로 파싱 ObjectMapper mapper = new ObjectMapper(); jsonInString = mapper.writeValueAsString(response.getBody()); return jsonInString; }} ✍ 만약 exchange 메서드에서 Generic 클래스를 사용하고싶다면?위의 4번에서 exchange()할때 반환되는 데이터타입이 제네릭클래스라면 어떻게 처리할까?하루종일 구글링한 방법을 정리하고자한다. 1 현재 상황아래처럼 ResponseVO&lt;T&gt;클래스와 TestVO 클래스가 선언되어있다. 1234567891011// ResponseVO&lt;T&gt; 클래스public class ResponseVO&lt;T&gt; { private int code; private T payload;}// testVO 클래스public class TestVO { private int id; private String message;} exchange()를 실행하고자한다. 123456ResponseEntity&lt;ResponseVO&lt;TestVO&gt;&gt; response = rt.exchange( \"http://localhost:3000/\", HttpMethod.POST, testJson, ResponseVO&lt;TestVO&gt;.class //반환되는 데이터타입 ); 당연히 잘 될꺼라고 생각했던 코드에 빨간 밑줄이 생기면서 에러가 발생했다. 123// 에러메시지ResponseVO cannot be resolved to a variableTestVO cannot be resolved to a variable 제네릭클래스인 경우 인스턴스를 어떻게 생성해야할까? 2 ParameterizedTypeReference로 해결 정의: ParameterizedTypeReference는 제네릭형식을 123456ResponseEntity&lt;ResponseVO&lt;TestVO&gt;&gt; response = rt.exchange( \"http://localhost:3000/\", HttpMethod.POST, testJson, new ParameterizedtypeReference&lt;ResponseVO&lt;TestVO&gt;&gt;(){} //반환되는 데이터타입); 잘해결되었지만 어떤 문제가 있었던걸까? 원인을 알아봤다. 3 문제 원인 제네릭은 데이터타입을 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자가 지정한다. 자바는 컴파일시에 제네릭 타입 정보들을 제거 한다.런타임시에는 실제로 타입정보는 존재 하지 않고 강제 캐스팅 된다. 이런 제네릭 정보가 지워지는 문제 때문에 Super type token 기법이 생겨났다.Super type token은 수퍼(상위)타입을 토큰으로 사용하겠다는 의미이다. 무슨말인가?제네릭 정보가 컴파일시 런타임시 다 지워지지만 제네릭 정보를 런타임시 가져올 방법이 존재한다. 제네릭 클래스를 정의한 후에 그 제네릭 클래스를 상속받으면 런타임시에는 제네릭 정보를 가져올 수 있다.Class의 메소드의 public Type getGenericSuperclass() 메소드를 통해 구할수 있다. getGenericSuperclass() 이용하여 바로 위의 슈퍼 클래스의 타입을 반환한다. 상위타입은 제네릭의 타입토큰 정보가 존재한다.슈퍼(상위)타입의 제네릭 파라미터정보인 Type을 통해 제네릭 파라미터 클래스 정보를 가져온다.출처: https://ka0oll.tistory.com/m/6 제네릭 정보가 지워지는 문제때문에 제네릭타입은 인스턴스를 생성할 수 없는게 흥미로웠다. 구글링할수록 자바를 깊이있게 알 수 있어서 재밌었고 좋은 글 써주신 분들 덕분에 한결 쉽게 이해할 수 있었다. 참고 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html https://sowon-dev.github.io/2021/08/11/210812Spring-resttemplate/ https://jung-story.tistory.com/132 https://www.baeldung.com/rest-template https://tecoble.techcourse.co.kr/post/2021-07-25-resttemplate-webclient/ https://vmpo.tistory.com/27 https://www.skyer9.pe.kr/wordpress/?p=1476 https://countryxide.tistory.com/148 https://ka0oll.tistory.com/m/6","link":"/2022/12/09/221210spring-resttemplate/"},{"title":"[Java] TimeUnit의 sleep() 사용하기","text":"js에서는 setTimeout()이나 setInterval()을 자주 사용했는데 자바에서는 어떻게 사용할까?바로 TimeUnit의 static메서드인 sleep()이 있다. TimeUnitTimeUnit는 자바가 제공하는 Enum타입클래스이다.시간에 관한 열거형 클래스로 두날짜의 차이를 구하기, sleep()걸기 등에 유용하게 쓰인다. DAYS HOURS MICROSECONDS MILLISECONDS MINUTES NANOSECONDS SECONDS sleep()TimeUnit.class에 sleep()이 선언되어있다.파라미터에 따라 Thread.sleep()을 쉽게 걸어준다.열거형이기때문에 직관적이고 static 메서드라 바로 사용할 수 있다는 것이 장점이다. 1234567891011121314151617 /** * Performs a {@link Thread#sleep(long, int) Thread.sleep} using * this time unit. * This is a convenience method that converts time arguments into the * form required by the {@code Thread.sleep} method. * * @param timeout the minimum time to sleep. If less than * or equal to zero, do not sleep at all. * @throws InterruptedException if interrupted while sleeping */public void sleep(long timeout) throws InterruptedException { if (timeout &gt; 0) { long ms = toMillis(timeout); int ns = excessNanos(timeout, ms); Thread.sleep(ms, ns); }} 예시다양하게 사용할 수 있다. 12345// 5분 지연시키기TimeUnit.MINUTES.Sleep(5);// 10초 지연시키기TimeUnit.SECONDS.sleep(10); 참고 https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html","link":"/2022/12/12/221213java-timeunit/"},{"title":"[네트워크]페이로드(payload)가 뭐길래? 개념,정의","text":"외부API와 통신을 하면서 payload를 많이 만나게 되었다. 어렴풋이 알고 있는 이 단어, 생긴 건 JSON과 비슷한데 왜 PAYLOAD라고 부를까?궁금한 건 해결해야지! 내가 알고있었던 payload성공이나 실패등이 일어났을때 내가 챙겨 보고 싶은 message. 정확한 개념위키백과에 예시까지 설명이 잘되어있어서 정리해보았다. 개념: 전송되는 데이터 페이로드는 크게 2가지 의미 전송의 근본적인 목적이 되는 데이터의 일부분으로 그 데이터와 함께 전송되는 헤더와 메타데이터와 같은 데이터는 제외한다. 컴퓨터 보안에서 페이로드는 멀웨어의 일부를 뜻한다. 웜, 바이러스, 트로이목마 같은 해로운 소프트웨어를 분석할 때 페이로드는 그 소프트웨어가 주는 피해를 뜻한다. 예를 들어 페이로드에는 데이터 훼손, 스팸메일, 개인정보를 알아내기 위해 다수에게 보내는 이메일 등이 있다. 즉 페이로드는 전송 행위의 본래 의도를 뜻한다. 특징 페이로드라는 용어는 큰 데이터 덩어리 중에 ‘흥미 있는’ 데이터를 구별하는 데 사용된다. 프로그래밍에서 주로 메시지 프로토콜(message protocols) 중에 프로토콜 오버헤드(protocol overhead)와 원하는 데이터를 구별할 때 사용된다. 웹 서비스 응답(web service response)이 아래의 JSON이라 해보자 예시 123456{ \"status\":\"OK\", \"data\": { \"message\":\"Hello, world!\" }} 여기서 “Hello, world!”가 클라이언트가 관심을 가지는 페이로드이다. 나머지 부분은, 중요하긴 하지만, 프로토콜 오버헤드이다. 참고 https://ko.wikipedia.org/wiki/페이로드","link":"/2022/12/15/221216payload/"},{"title":"[Spring]ResponseEntity 코드리뷰","text":"RestTemplate을 통해서 외부 API와 통신하는 메서드를 구현하고 있었다.팀장님이 내 코드를 보시더니 코드리뷰를 해주셨다. (바쁘신 와중에도 코드봐주셔서 감사합니다🙂) 내코드1234567891011// ResponseVO&lt;T&gt; 클래스public class ResponseVO&lt;T&gt; { private int code; private T payload;}// testVO 클래스public class TestVO { private int id; private String message;} 아래처럼 exchange()를 실행하는 코드였다. RestTemplate과 HttpEntity가 궁금한 사람은 RestTemplate과 HttpEntity가 뭐길래글을 참고하면 된다. 123456ResponseEntity&lt;ResponseVO&lt;TestVO&gt;&gt; response = rt.exchange( \"http://localhost:3000/\", HttpMethod.POST, testJson, new ParameterizedtypeReference&lt;ResponseVO&lt;TestVO&gt;&gt;(){} //반환되는 데이터타입); 여기서 좀 더 나은 코드가 있다고 말씀해주셨다. 코드리뷰OOP(객체지향프로그램)를 설명해주시면서 java lang reflect으로 데이터타입을 유연하게 가져갈 수 있다고 말씀해주셨다. 12345678910ResponseEntity&lt;String&gt; responseEntity = rt.exchange( \"http://localhost:3000/\", HttpMethod.POST, httpEntity, string.class);String bodyofResponseEntity = responseEntity.getBody();Gson gson= new Gson();Type gType = TypeToken.getparameterized(ResponseVO.class, TestVO.class).getType():ResponseVO&lt;TestVO&gt; responsevo = gson.fromJson(responseentity.getBody(), gType); 기존 코드와 가장 큰 차이점은 ResponseEntity반환데이터 타입을 String으로 설정했다는 점이다.그 이유는 무엇일까?만약 특정한 데이터타입을 지정해놓으면 exchange()한 뒤 반환데이터타입 형식이 안 맞는 경우 exchage()를 성공적으로 수행했음에도 타입변환에러가 발생한다.이를 예방하기 위해 String으로 반환데이터를 받으면된다! 반환데이터타입을 왜 굳이 String을 쓸까?반환타입을 String으로 쓰면 좋은 점은 크게 3가지가 있다. exchage()하는 도중에 에러가 발생한건지, 캐스팅중에 에러가 발생한건지 명확하게 파악가능 String변수bodyofResponseEntity에 값을 대입함으로서 데이터 유실을 예방가능 String데이터를 원하는 데이터로 캐스팅하려면?구글에서 만든 Gson을 이용하면 된다.String데이터를 Gson으로 원하는 ResponseVO&lt;TestVO&gt;로 변환하면 해결! 123Gson gson= new Gson();Type gType = TypeToken.getparameterized(ResponseVO.class, TestVO.class).getType():ResponseVO&lt;TestVO&gt; responsevo = gson.fromJson(responseentity.getBody(), gType);","link":"/2022/12/20/221221java-responseentity-refactoring/"},{"title":"[Server]Mock Server(목서버)는 어때요?","text":"오늘 회의에서 신규서비스 테스트를 위해 Mock서버, jUnit단위테스트 등의 이야기가 나왔다.외부 API를 테스트를 하려면 어떻게 해야할까? jUnit에 관해서는 이전에 작성한 Junit 포스팅을 참고하면 된다.그럼 목서버는 무엇일까? 먼저 MOCK(목)이 뭘까? 실제 사용되어야하는 객체의 대체객체로 실제 객체를 만들어서 하기엔 시간이 부족하고 비용이 높은 경우, 구현이 까다로울 경우에 가짜 객체를 만들어서 사용하는데 그중 하나가 Mock객체이다.Mock객체: 행위를 검증하기 위해 사용되는 객체직접 만들거나 스프링프레임워크를 통해서 간단하게 만들수 있음출처: Junit - Mock 객체 Mock 서버란? For any system you integrate with via HTTP or HTTPS MockServer can be used as:a mock configured to return specific responses for different requestsa proxy recording and optionally modifying requests and responsesboth a proxy for some requests and a mock for other requests at the same timeWhen MockServer receives a request it matches the request against active expectations that have been configured.Then, if no matches are found, it proxies the request if appropriate; otherwise a 404 is returned.For each request received the following steps happen:find matching expectation and perform actionif no matching expectation proxy requestif not a proxy request return 404An expectation defines the action that is taken, for example, a response could be returned.출처: https://www.mock-server.com/ 간단하게 말하자면, 실제 서버처럼 HTTP나 HTTPS 요청과 응답을 주고 받을 수 있는 가짜 서버이다. 다양한 요청에 특정한 반응을 반환하도록 구성할 수 있음 프록시를 기록하고 선택적으로 요청과 응답을 수정할 수 있음 목서버가 예상되는 요청을 받았을땐 이미 작성된 특정 반응을 반환하고 예상되지 않는 요청인 경우 404를 리턴한다. 왜 목서버를 사용할까?크게 3가지 이유가 있다. testing via HTTP or HTTPS, such as a REST or RPC service. 만약 스펙만 존재하고 실제 동작하지 않는 API를 염두하고 해당 API의 데이터를 받는 부분을 개발해야 한다면 어떻게 해야할까? 이럴 때 필요한 것이 가상의 서버, 바로 Mock Server이다. de-coupling development isolate single service 목서버를 만드는 방법구글링했을때 가장 많이 나오는 방법은 PostMan을 활용하는 것이다. 하지만 무료요금제인 경우 한달에 1000건 요청제한이 있다.Postman 으로 Mock Server 구축하기글을 참고! 출처 https://opennote46.tistory.com/208 https://www.mock-server.com/ Junit - Mock 객체 https://devvkkid.tistory.com/219 우아한마켓 - 외부 API를 어떻게 테스트 할 것인가?","link":"/2022/12/21/221222server-mockserver/"},{"title":"[Spring]@Transactional 속성 총정리","text":"레거시 코드를 분석하면서 다양한 @Transactional 속성을 만났다.평소에 디폴트로만 썼었기에 이참에 정리해보았다. @Transactional 이란?먼저 Transaction을 살펴보자. 트랜젝션은 데이터베이스의 상태를 변화시키기 위한 작업 수행의 논리적 단위를 의미한다.테스트를 위해 서비스에서 SQL쿼리를 호출한 후 롤백을 해야하는 경우라든지 전체 실행 중 특정 수행이 오류가 나면 이전에 완료했던 SQL쿼리들을 다 롤백해야할 경우에 @Transactional을 사용한다. 자세한 내용은 포스팅 @Transactional 쓰는 이유를 참고하면 된다. @Transactional 에 우선순위가 있다?@Transactional은 우선순위를 가지고 있다. 클래스 메서드 클래스 인터페이스 메서드 인터페이스 클래스 메서드에 선언된 트랜잭션의 우선순위가 가장 높다.가장 구체적으로 구현된 것부터 트랜잭션순위가 높다고 생각하면 된다. 속성 속성명 특징 옵션 isolation 일관성없는 데이터 허용 수준을 설정 DEFAULT, READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE noRollbackFor, rollbackFor 특정 예외발생시 rollback하지않음 or rollback함으로 설정 noRollbackForClassName, rollbackForClassName 특정 클래스이름인 경우 rollback하지않음 or rollback함으로 설정 (e.g)rollbackForClassName=”Exception” propagation(전파속성) 트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 설정 REQUIRED(Defualt), REQUIRES_NEW, SUPPORT, NOT_SUPPORT, MANDATORY, NEVER, NESTED readOnly 트랜잭션을 읽기 전용으로 설정. true면 insert, update, delete 실행 시 예외 발생 true, false(Defualt) timeout, timeoutString 지정한 시간내에 메서드수행이 완료되지 않으면 rollback함으로설정(단위 : 초,seconds) transactionManager 특정 Transaction의 qualifier value를 설정 value transactionManager의 alias(별칭)을 설정한다. https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation https://n1tjrgns.tistory.com/266 isolation 레벨 DEFAULT : 기본 격리 수준 READ_UNCOMMITED (level 0): 트랜잭션의 동시 액세스 허용, 커밋되지 않는 데이터에 대한 읽기를 허용 READ_COMMITED (level 1) : 커밋된 데이터에 대해 읽기 허용, Dirty read 방지 REPEATEABLE_READ (level 2) : 동시 액세스를 허용하지 않음, 동일 필드에 대해 다중 접근 시 모두 동일한 결과를 보장, Dirty read, Nonrepeatable read 방지 SERIALIZABLE (level 3) : 가장 높은 격리, 성능 저하의 우려가 있음, 모든 부작용을 방지 isolation 문제점feco님 블로그 글 - 트랜잭션, 트랜잭션 격리수준(Isolation Level)에 예시까지 잘 설명되어있다! 꼭 읽어보길!아래는 feco님 블로그글의 격리성 문제점부분만 발췌했다. Dirty Read: 한 트랜잭션(T1)이 데이타에 접근하여 값을 ‘A’에서 ‘B’로 변경했고 아직 커밋을 하지 않았을때, 다른 트랜잭션(T2)이 해당 데이타를 Read 하면? T2가 읽은 데이타는 B가 될 것이다. 하지만 T1이 최종 커밋을 하지 않고 종료된다면, T2가 가진 데이타는 꼬이게 된다. Non-Repeatable Read: 한 트랜잭션(T1)이 데이타를 Read 하고 있다. 이때 다른 트랜잭션(T2)가 데이타에 접근하여 값을 변경 또는, 데이타를 삭제하고 커밋을 때려버리면? 그 후 T1이 다시 해당 데이타를 Read하고자 하면 변경된 데이타 혹은 사라진 데이타를 찾게 된다. Phantom Read: 트랜잭션(T1) 중에 특정 조건으로 데이타를 검색하여 결과를 얻었다. 이때 다른 트랜잭션(T2)가 접근해 해당 조건의 데이타 일부를 삭제 또는 추가 했을때, 아직 끝나지 않은 T1이 다시 한번 해당 조건으로 데이타를 조회 하면 T2에서 추가/삭제된 데이타가 함께 조회/누락 된다. 그리고 T2가 롤백을 하면? 데이타가 꼬인다 propagation(전파속성) 레벨트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 전파속성을 선택할 수 있다. 총 7가지 속성이 있다. REQUIRED(Defualt): 이미 진행중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 진행중이 아니라면 새로운 트랜잭션을 생성한다. REQUIRES_NEW: 항상 새로운 트랜잭션을 생성한다. 이미 진행중인 트랜잭션이 있다면 잠깐 보류하고 해당 트랜잭션 작업을 먼저 진행한다. SUPPORT: 이미 진행 중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 없다면 트랜잭션을 설정하지 않는다. NOT_SUPPORT: 이미 진행중인 트랜잭션이 있다면 보류하고, 트랜잭션 없이 작업을 수행한다. MANDATORY: 이미 진행중인 트랜잭션이 있어야만, 작업을 수행한다. 없다면 Exception을 발생시킨다. NEVER: 트랜잭션이 진행중이지 않을 때 작업을 수행한다. 트랜잭션이 있다면 Exception을 발생시킨다. NESTED: 진행중인 트랜잭션이 있다면 중첩된 트랜잭션이 실행되며, 존재하지 않으면 REQUIRED와 동일하게 실행된다. 참고 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation https://velog.io/@kdhyo/JavaTransactional-Annotation-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-26her30h","link":"/2022/12/22/221223spring-transactional-annotation/"},{"title":"AP(Access Point)란? 개념,정의","text":"회의때 무수히 들었던 AP. 도대체 AP가 뭘까?일단 Access Point의 약어이다. 네트워크와 관련된 느낌 물씬! AP란AP는 유선랜의 유선신호를 무선으로 변경해주는 것이다. → 회사 내부망이 유선랜인데 다양한 기기에서 사용하려면 무선랜으로 바꿔주면 편리하다.AP는 DHCP 서버에서 IP를 할당해줘야한다. 무선랜을 구성하는 장치중 하나로, 유선랜과 무선랜을 연결시켜주는 장치이다.AP는 Access Point의 약어이나, Wireless Access Point라고 하여 WAP 라고도 한다.AP는 대체로 독립형 장치로, 이더넷 허브(Ehternet Hub)나 서버(Server)에 꽂아 사용할 수 있다.AP는 휴대폰(Cellular Phone)처럼 사용자의 위치에 따라 하나의 AP에서 다른 AP로 핸드오프(Hand-off : 넘겨주기) 되므로, 사용자가 이동하면서 이동형 무선장치를 사용할 수 있다.출처: Just Blue - AP(Access Point) AP와 일반 무선공유기 차이점 일반 무선공유기 AP 한 개의 IP로 여러 명의 네트워크를 사용할 수 있음 건물의 각 층과 사무실별로 설치할 경우 사무실 내에서 자유롭게 네트워크를 사용할 수 있다는 장점이 있고 안테나의 개수에 따라 사용할 수 있는 범위가 정해지며 넓은 곳일수록 안테나가 많이 달린 제품을 활용하면 좋음 SSID 3개까지 가능 SSID 512개까지도 가능 네트워크선 따로, 전원선 따로 특정 모델에 따라 네트워크선 하나로 전원까지 공급가능 일반공유기보다 많은 라우팅 기능을 지원 SSID란?Service Set IDentifier의 약자로 무선네트워크 이름이다. 참고 https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=futuremain&amp;logNo=221618229181","link":"/2022/12/29/221230accesspoint/"},{"title":"[안드로이드] 키스토어란? 개념,정의","text":"오늘 회의에서 키스토어에 대해서 이야기가 나왔다. 앱개발은 전혀 모르므로 이참에 공부해봤다. Keystore란?안드로이드 앱을 구글 플레이스토어에 올리려면 배포할때 개발자가 서명을 해야한다. 이 서명을 코드서명인증서 즉, 키스토어(Keystore)라고 한다.키스토어(Keystore)는 앱 개발자에 대한 정보를 서명한 암호화된 파일이다. 왜 Keystore를 사용할까?추후에 버그픽스등으로 해당 앱 업데이트시 서명이 동일한 지 확인한다. 만약 이 서명을 잃어버리면 아무리 내가 만든 앱이라고해도 이 앱을 업데이트 할 수 없다.즉, 키스토어를 통해서 다른 개발자가 내 앱을 변조 못하게 막는 역할을 한다.","link":"/2023/01/03/230103Android-keystore/"},{"title":"[Java] 포스트맨(Postman)사용시 동시 요청이 되는 이유?","text":"서버 API 작업 중 A요청 후 디버깅을 하는 와중에 B요청을 했더니 B요청에 대한 응답을 바로 받을 수 있었다. A요청에 대한 응답을 받기 전인데 B응답과 요청을 어떻게 처리될 수 있었을까? 멀티쓰레드가 답이다.내가 만든 서버API는 스프링프레임워크로 스프링프레이워크는 멀티스레드를 지원한다. 그래서 특별한 설정을 하지않아도 한 요청에 대한 응답을 받기도 전에 다른 요청을 보내고 응답도 받을 수 있었던 것!간단하게 멀티쓰레드의 장점은 작업 분리로 효율성 증대이고 단점은 제어의 어려움이 있다. 블로그 글 멀티스레드프로그래밍1 : 개념, 용어정리, 스래드 상태와 제어을 보면 더 자세히 알수있다. 멀티스레드말고 싱글스레드를 쓰기도 하는가?싱글스레드하면 떠오르는 건 node.js이다. 사실 node.js는 싱글스레드도 지원하면서 멀티스레드도 지원한다. 이에 대해서는 블로그글 vodkamitlime님의 NodeJS 는 Single Thread 일까? Multi Thread 일까?을 보면 자세히 알수있다. 언뜻보기에는 멀티스레드가 좋은데 왜 싱글스레드를 지원할까?자바스크립트가 싱글스레드를 지원하기 때문이다. 싱글스레드를 사용하는 이유는 싱글스레드만의 장점이 있기때문이다. 싱글스레드 장단점 장점 자원 접근에 대한 동기화를 신경쓰지 않아도 된다 작업전환(context switch) 작업을 요구하지 않는다. 단점 여러개의 CPU를 활용하지 못한다.","link":"/2023/01/04/230105postman-multithread/"},{"title":"[Spring] 새로운 컨트롤러(Controller)를 생성했는데 호출이 안될때","text":"레거시 프로젝트에 신규 패키지를 만들고 그 패키지안에 신규 컨트롤러를 생성했다. 컨트롤러에 서비스 메서드를 만들고 포스트맨으로 호출했는데 웬걸?! 서버가 전혀 반응을 안한다. 왜일까? 기본적으로 해봐야하는 것은 build 탭 &gt; clean &gt; 서버 재시작이다. 빌드가 제대로 안되어있으면 컨트롤러가 새로 생성된지도 모르기때문이다. 하지만 나는 여전히 반응하지않았다. 수석연구원님께 물어 알게된 것은 컴포넌트 스캔문제였다. 문제점servlet-context.xml파일에서 아래처럼 컴포넌트 스캔 코드가 있는데 나는 테스트용 새로운 패키지인 com.test.preview를 만들고 그곳에다 신규 컨트롤러를 생성했다. 따라서 컴포넌트가 스캔이 되지않았던 것이다. 기존코드 1&lt;context:component-scan base-package=\"com.test.controller\" /&gt; 해결콤마를 이용해서 베이스패키지를 추가해주면 해결!감사합니다 김수석연구원님! 1&lt;context:component-scan base-package=\"com.test.controller,com.test.preview\" /&gt;","link":"/2023/01/04/230105spring-servletcontext/"},{"title":"[Gson]한글이 ?로 깨져보일때","text":"구글에서 만든 Gson을 사용해서 객체를 json으로 혹은 그 반대로 변환하는데 사용하고 있다. 이때 한글이 ?로 깨지는 현상이 나타났다. 한글깨질때 produces=&quot;text/plain;charset=UTF-8&quot; 추가하기컨트롤러 RequestMapping 에 추가하면 된다. 1@RequestMapping(value=\"/test\", method=RequestMethod.GET, produces=\"text/plain;charset=UTF-8\") 그래도 안될때produces를 설정하고 나니까 http통신이 안된다. 그래서 produces = &quot;application/json;charset=utf-8&quot;로 바꿔주니 통신이 되었다. 1@RequestMapping(value=\"/test\", method=RequestMethod.GET, produces=\"application/json;charset=UTF-8\") 그래도 또 안될때하지만 여전히 한글이 깨졌다. 그래서 다시 구글링해서 찾은 내용인 produces = &quot;MediaType.APPLICATION_JSON_UTF8_VALUE&quot;로 바꿔적용했다. 1@RequestMapping(value=\"/test\", method=RequestMethod.GET, produces=\"MediaType.APPLICATION_JSON_UTF8_VALUE\") 해결!","link":"/2023/01/05/230106gson-korean-encoding/"},{"title":"[Spring] 컨트롤러에서 json을 리턴하고 싶을때","text":"컨트롤러에서 json형식으로 반환해주는 방법은 크게 두가지이다. String으로 반환: Controller return type을 String으로 리턴한 뒤 클라이언트에서 파싱하기. MappingJackson2JsonView 사용: ModelAndView를 json 형식으로 반환해 준다. 스프링프레임워크에서는 주로 MappingJackson2JsonView을 bean으로 등록해서 이용한다. MappingJackson2JsonViewservlet-context.xml에서 아래 코드를 추가한다. 12345678&lt;bean id=\"jsonView\" class=\"org.springframework.web.servlet.view.json.MappingJacksonJsonView\"&gt; &lt;property name=\"contentType\" value=\"application/json;charset=UTF-8\"&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- BeanNameViewResolver 우선순위 지정 --&gt;&lt;bean id=\"beanNameResolver\" class=\"org.springframework.web.servlet.view.BeanNameViewResolver\"&gt; &lt;property name=\"order\" value=\"0\"/&gt;&lt;/bean&gt; BeanNameViewResolver우선순위 지정: beanNameResolver는 우선순위를 0으로 해서 ViewPage를 찾을 때 우선 탐색한다. 만약 BeanNameViewResolver에서 없으면 viewResolver에서 탐색한다.출처: Classic!님의 블로그 글 BeanNameViewResolver","link":"/2023/01/08/230109spring-returnjsonview/"},{"title":"[Java]익숙한 for each말고 Stream도 써봐야지","text":"코드리뷰를 통해 익숙한 for each대신 Stream을 써보게되었다. 너무 재밌는 배움이라 기록하기로 마음먹었다. 정책상의 이유로 동일한 데이터를 서로 다른 User DB와 Wallet DB에 각각 저장하고 있다. 이 두 DB의 값들이 싱크가 맞는지 확인하는 메서드가 필요했다. 상황 User.java 123456@Datapublic class User{ private int id; private String name; private int balance;} Wallet.java 1234567@Datapublic class Wallet{ private int walletId; private int userId; private int balance; private Boolean isAvailalbe;} 내 코드DiffVO를 담을 객체를 구현하고 User 디비를 호출해서 userDBValue에 셋팅하고 Wallet를 호출해서 walletDBValue에 셋팅한 뒤 if조건문으로 두 값을 비교해서 같으면 isTheSame = true로 바꿔주도록 구현했다.주의점은 User 디비 호출메서드 리턴데이터타입(User)과 Wallet 디비 호출메서드 리턴데이터타입(List)이 다르게 고정되어 있다는 점이다. DiffVO.java 123456@Datapublic class DiffVO{ private int userDBValue; private int walletDBValue; private Boolean isTheSame = false; // 디폴트 false로} service 1234567891011121314151617181920212223242526public testService{ private DiffVO checkTheSameValue(int id){ DiffVO diffInfo = new DiffVO(); // 1. A디비 값 가져오기 User userInfo = dao.selectUserInfo(id); diffInfo.setUserDBValue(userInfo.getBalance()); // 2. B디비 값 가져오기 List&lt;Wallet&gt; walletInfo = balanceAllWallet(); // 기 구현된 서비스 balanceAllWallet()이용 필수 for(Wallet w : walletInfo){ if(w.getUserId() == id){ diffInfo.setWalletDBValue(w.getBalance()); } } // 3. 비교하기 if(diffInfo.getUserDBValue() == diffInfo.getWalletDBValue()){ diffInfo.setIsTheSame(true); } return diffInfo; }} 3단계로 비교했다. 팀장님이 내 코드를 보시곤 Stream을 사용하는 건 어떻겠냐고 말씀해주셨다. 팀장님 코드 내 코드는 for each문이고 팀장님은 stream을 사용하셨다. stream에 대한 자세한 설명은 블로그 글 - 스트림 API 개념에 엄청 친절하게 적어놓았다. stream을 써보고싶었는데 익숙한 for 문만 쓰다 이렇게 코드리뷰하다가 쓰게되니 무척 재밌었다. 너무 재밌어! service123456789101112131415// (중략)// 2. B디비 값 가져오기 -&gt; 코드리뷰List&lt;Wallet&gt; walletInfo = balanceAllWallet(); // 기 구현된 서비스 balanceAllWallet()이용 필수Stream&lt;Wallet&gt; walletStream = walletInfo.stream().filter(d -&gt; id.equals(d.getUserId()));Wallet wallet = walletInfo.findFirst().orElse(null);diffInfo.setWalletDBValue(wallet.getBalance());// 3. 비교하기if(diffInfo.getUserDBValue() == diffInfo.getWalletDBValue()){diffInfo.setIsTheSame(true);}return diffInfo; Stream을 쓰니 가독성도 좋아졌다.여담이지만 팀장님은 정말 천재같다. 스트림과 for반복문 어느 것이 더 좋을까?이렇게 스트림을 쓰고나니 for문과 비교해서 뭐가 더 좋은지가 궁금했다. 여러 구글링 끝에 흥미로운 미디엄 글 Sigrid Jin님의 Java Stream API는 왜 for-loop보다 느릴까?를 찾았다. 오늘의 결론이다. 스트림 사용이 for-loop보다 의미가 있으려면 Collection이 되는 스트림 소스의 크기가 충분히 크거나, 컴퓨팅 연산이 CPU-intensive할 정도로 비용이 매우 비싸야 한다. 병렬 스트림을 사용하려면, 스트림 소스인 Collection은 split하기 쉬운 자료 구조이어야 하며, 웬만해서는 연산이 stateful하지 않아야 한다. 성능차이는 개발자의 로컬환경에 따라 다를 수 있다.","link":"/2023/01/10/230111codereview/"},{"title":"[Spring]RestTemplate response 한글깨짐 UTF-8적용하기","text":"최근에 Gson 한글 깨지는 현상을 해결한 블로그 글 Gson 한글이 ?로 깨져보일때을 포스팅했었다.성공메시지는 한글이라 몰랐는데 에러메시지가 엉망진창으로 인코딩되서 출력되었다.나는 한글을 정말 사랑하는데… 한글 인코딩이 나를 힘들게 한다. 한글아 그만 깨져😠 문제 현상이번에는 어디서 한글이 깨졌는지부터 찾아야했다. log를 뒤진 결과 RestTemplateLoggingInterceptor의 로그까지는 한글이 깨지지않고 출력하나 그 뒤 RestTemplate response를 받는 부분에서 한글이 깨지는 것을 확인했다.RestTemplate 선언하는 방법은 블로그 글 RestTemplate과 HttpEntity가 뭐길래(제네릭과 ParameterizedTypeReference)를 참조하면 된다. 수정한 코드StringHttpMessageConverter의 default Charset이 ISO-8859-1이라고 한다. 이를 UTF-8로 변경하면 한글이 깨짐없이 잘 출력된다! 123RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(new HttpComponentsClientHttpRequestFactory()));restTemplate.getMessageConverters().add(0, new StringHttpMessageConverter(StandardCharsets.UTF_8)); // 추가한 부분restTemplate.exchange(apiUrl, HttpMethod.POST, entity, String.class); StringHttpMessageConverter가 어떤 역할을 하는 지 좀 더 깊게 궁금했는데 잘 정리된 글이 이미 있었다. 자세한 내용은 깡냉쓰님의 RestTemplate 한글 깨짐관련(StringHttpMessageConverter)을 참고하면 된다. 해결!😎","link":"/2023/01/12/230113spring-resttemplateutf8/"},{"title":"나스(NAS)란? 개념,정의","text":"클라우드 네이티브관련해서 교육을 듣던 중 강사님이 NAS에 관해 아래처럼 말씀하셨다. 서버 1x.x.x.xx는 NAS로 사용합니다. 예전에 대리님이 아기 사진이 너무 많아 NAS서버를 만들까한다는 말도 떠오르면서 NAS가 정확히 뭔지 궁금해졌다.문맥상 데이터 저장소같은데 DB와는 또 어떻게 다를까? 외부에서 접근하면 클라우드저장소같은데 그와는 또 어떻게 다를까? NAS(Network Attached Storage) Network Attached Storage: 네트워크 결합 스토리지 LAN으로 연결하는 외장 하드디스크 반대 개념은 컴퓨터에 직접 연결해서 쓰는 DAS(직접 결합 저장장치, Direct Attached Storage) e.g. 내장형 하드디스크 컴퓨터를 직접 연결하지 않고 근거리 통신 네트워크(LAN)를 통해 데이터를 주고 받는다. 클라우드 스토리지 서비스와 유사한 느낌인데 어떤 차이가 있을까? 클라우드 스토리지 서비스와 차이점 NAS 클라우드스토리지 정의 LAN으로 연결하는 외장 하드디스크 보안성 우수 개인정보보안취약 안정성 하드디스크에 몇개에 의존해서 취약 우수 속도 상대적 빠름 상대적 느림 비용 초기비용많지만 유지비 상대적 저렴 주로 월정액방식으로 초기비용도 낮고 유지비도 비싸지않다 NAS 목적사람에 따라 사용방식이 다양하지만 구글링해본 결과 대용량, 개인자료는 NAS에 보관하고 업무용 또는 백업용 자료는 클라우드저장소(구글클라우드)를 많이 사용하는 것으로 보인다. RAIDNAS에 대해 궁금한 점을 팀장님께 물으니 팀장님이 RAID에 관해서도 함께 설명해주셨다. 안 물어보면 어쩔뻔했어! 이렇게 지식이 확장되는 거 정말 좋다! 재밌어! RAID정의: 저장장치 여러 개를 묶어 고용량, 고성능인 저장 장치 한 개와 같은 효과를 얻기 위해 개발된 기법 사용목적 무정지 구현 고성능 구현 그렇다면 왜 묶어서 사용할까? 나무위키에 그에 관한 설명이 잘 나와있다. 저장장치는 소모품이다. 5년에서 10년정도 수없이 읽고 쓰기를 반복하면 물리적으로 움직이는 부품이 있는 HDD는 물론이요 전자적으로만 작동하는 SSD도 NAND 소자가 닳아 읽고 쓰는 속도가 느려지고, 결국에는 읽고 쓸 수 없는 부분인 불량섹터가 발생하게 된다. 이런 경우에는 불량섹터에 기록되어 있던 정보가 손상되는 것도 문제지만, 이후에 저장장치에 기록되는 데이터의 무결성을 보장할 수 없기 때문에 보통 장치째로 (기존에 기록되어 있던 데이터와 함께) 폐기 처분하게 된다. 여러개의 디스크를 특정 방법으로 연결해주는 시스템인 RAID는 바로 이렇게 저장장치가 갑자기 고장나는 경우를 대비해서 활용할 수 있는 유용한 기법이다. 방대한 양의 데이터를 읽고 쓰며 1년 365일 내내 가용성이 보장되어야 하는 구글이나 페이스북의 서버들을 상상해보자.출처: 나무위키 참고 https://namu.wiki/w/NAS(%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98) https://namu.wiki/w/RAID quarker님 - NAS와 Cloud Storage 서비스 비교","link":"/2023/01/15/230116nas/"},{"title":"클라우드 네이티브(Cloud Native)란? 개념,정의","text":"클라우드 네이티브(Cloud Native)란 무엇일까? 이번에 교육을 받으면서 도커, 쿠버네티스, MSA등의 용어가 쏟아졌다. 이들이 어떤 Cloud Native와 관계가 있는지 궁금해서 정확히 알아보았다. 클라우드 네이티브 클라우드 네이티브라는 용어는 클라우드 제공 모델에서 제공하는 분산 컴퓨팅을 활용하기 위해 애플리케이션을 구축 및 실행하는 개념을 의미합니다. 클라우드 네이티브 앱은 클라우드가 제공하는 확장성, 탄력성, 복원성, 유연성을 활용하도록 설계 및 구축되었습니다.(중략) 클라우드 네이티브 서비스는 Kubernetes, Docker, 서버리스 함수, API 및 Kafka와 같은 기술을 사용하여 최신 애플리케이션 개발을 지원합니다. 업계 최고의 클라우드 제공업체를 통해 클라우드 툴과 서비스를 구현하므로 개발자가 운영 작업을 줄이고 애플리케이션을 더 빠르게 구축할 수 있습니다. 클라우드 네이티브 서비스는 개발자에게 마이크로서비스, 서버리스 함수와 같은 클라우드 네이티브 애플리케이션을 구축, 배포, 관리할 수 있는 종합적인 표준 기반 플랫폼을 제공합니다.출처: 오라클 공식홈페이지 클라우드 네이티브란 클라우드의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식이다.그렇다면 클라우드의 장점이 무엇일까? 클라우드의 장점 확장가능성(Scaling) : 사용량에 따라 편리하게 인스턴스를 증가, 감소할 수 있음 CI/CD: 구축, 테스트 및 배포를 자동화하여 소프트웨어가 개발 시스템에서 운영 시스템으로 빠르고 안정적인 프로그램 구축가능 장애대응: 정 서비스에 오류가 발생해도 다른 서비스에 영향을 주지 않음 클라우드 네이티브 핵심 구성요소 4가지사진출처: https://www.influxdata.com/blog/introduction-cloud-native/ DevOps 개발 조직과 운영 조직의 통합을 의미: 이전에는 개발과 운영이 분리되어 개발자가 구동할 프로그램 준비를 끝나면, 이후 배포와 운영 작업은 다른 조직이 했다. 만약 우리가 단 몇줄의 코드를 바꿔야 할지라도 바꾼 후에 운영 조직과 다시 소통하여 배포해야 하므로 매우 번거로운 일이 아닐 수 없다. 이를 극복하기 위해 나온 개념으로 서비스의 문제가 생기면 바로 수정해서 즉시 배포하는 과정을 반복하는 것을 목적으로 한다. CI/CD 지속적인 통합 (CI : Continuous Integration) 소스 관리(형상관리), 빌드, 테스트를 모두 포함한다. e.g. 젠킨스, Team CI, Travic CI등 지속적인 배포 (CD : Continuous Delivery &amp; Deployment) Continuous Delivery인 경우 빌드는 자동이지만 배포는 수동 반영 Continuous Deployment인 경우 빌드와 배포까지 모두 자동 반영 Container 가상화 기술 기존에는 서로 다른 OS환경을 위해 가상머신을 사용해야해서 비용, 운영측면에서 부담이 많았지만 도커라는 컨테이너 가상화 기술을 도입하여 각각의 서비스와 앱을 관리할 수 있게 되었음 MSA(Micro Service Architecture) 내가 이해한 MSA(MicroService Architecture) 참고 참고 IT World - 클라우드 네이티브의 진정한 의미 jimkwon님 - Cloud Native Architecture - (1)","link":"/2023/01/17/230118cloudnative/"},{"title":"Jackson ObjectMapper VS Gson 차이","text":"Object Mapper만 사용하다가 Gson을 알게되면서 둘의 차이점이 궁금해졌다. 개념Jackson ObjectMapper와 Gson은 뭐하는 애들일까? 자바에서 JSON data-binding 지원해주는 라이브러리이다. 사용법HashMap을 Json으로 변환한뒤 콘솔에 출력하는 예시이다. 12345678910111213HashMap&lt;String, Obejct&gt; map = new HashMap&lt;&gt;();map.put(\"name\", \"나혜석\");map.put(\"age\", 77);// 1. ObjectMapper 사용 + throws Exception 필수String serializedMap1 = new ObjectMapper().writeValueAsString(map);system.out.println(serializedMap1);// output: {\"name\":\"나혜석\",\"age\":77}// 2. Gson 사용String serializedMap2 = new GsonBuilder().create().toJson(map)system.out.println(serializedMap2);// output: {\"name\":\"나혜석\",\"age\":77} 사용하다보면 큰 차이점 하나를 발견할 수 있는데 ObjectMapper는 Exceptionc처리가 필수이다. 각 장점 Jackson Gson 스프링프레임워크에 이미 속해있어 따로 설치안해도 됨 가장 간단한 toJson/fromJson방식 다양한 어노테이션 활용가능 역직렬화시 자바 엔티티에 접근할 필요가 없음 Jackson: Built into all JAX-RS (Jersey, Apache CXF, RESTEasy, Restlet), and Spring framework Extensive annotation support Gson: Simplicity of toJson/fromJson in the simple cases For deserialization, do not need access to the Java entities 출처: baeldung의 jackson-vs-gson 글","link":"/2023/01/18/230119objectmappervsgson/"},{"title":"[디자인패턴] 옵저버 패턴(observer pattern)이란? 개념,정의","text":"오늘 김팀장님 코드를 보다가 옵저버 패턴을 만났다. 디자인패턴을 잘 모르기때문에 이참에 공부해보았다. 여담으로, 공부해봤지만 디자인 패턴은 여전히 어렵다. 옵저버 패턴(Observer pattern)이란?영단어 observer 뜻 그대로 관찰자와 관련된 패턴이다. 객체의 상태 변화를 관찰하는 관찰자들(옵저버)을 목록에 등록해놓고 상태 변화가 있을때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지(notify)하는 디자인 패턴이다. 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. 발행/구독 모델로 알려져 있기도 하다. 코틀린에서는 Observer(옵저버)대신 Listener(리스너) 용어를 사용한다. 자바에서는 옵저버패턴을 위한 클래스와 인터페이스를 제공한다. docs.oracle - Interface Observer docs.oracle - Class Observable 쉽게 이해할 수 있는 예시는 유튜브 채널(Subject)과 구독자들(Observer)간의 관계이다.유튜브 채널 관리자가 영상을 업로드하면 구독자들에게만 알람이가 가고 구독자가 아닌 사람들에게는 아무런 영향을 끼치지않는다.즉, 객체(Subject)의 상태가 변화하면 Observer 목록에 있는 각 Observer에게 통지(notify)한다. 리액트도 옵저버?옵저버패턴을 알수록 리액트가 자꾸 떠올랐다.Seungho Lee - 리덕스(Redux)와 Observer 패턴에서 왜 자꾸 리액트가 떠올랐는지 확인할 수 있었다. 리액트 사용시 데이터 관리를 손쉽게 하기 위해 리덕스(redux)를 사용하며, 이는 옵저버 패턴을 기반으로 제작되었습니다. 리덕스 스토어(store)는 애플리케이션의 상태트리(state tree)를 관리하고 있습니다. 스토어 내부에서 상태값이 변하면 그것에 대한 액션을 보내줘야합니다.출처: Seungho Lee - 리덕스(Redux)와 Observer 패턴 리액트의 리덕스는 옵저버패턴으로 디자인된 것이었다!지식이 연결되는 느낌! 재밌다! 참고 위키백과 - 옵서버 패턴 haero_kim - 옵저버 패턴 개념 떠먹여드립니다 hanna2100 - 디자인패턴 2.옵저버 패턴 개념과 예제","link":"/2023/01/24/230125ObserverPattern/"},{"title":"[Spring]RestTemplate(레스트템플릿)과 Websocket(웹소켓)차이점","text":"RestTemplate은 간편하게 Rest 방식 API를 호출할 수 있는 라이브러리이고 Spring 3.0부터 지원한다.따라서 RestTemplate과 Websocket 차이점은 결국 REST API와 Websocket API 차이점이라고 볼 수 있다. 가장 잘 알고 있는 차이점은 REST API는 클라이언트의 요청이 없으면 서버는 먼저 말을 걸 수 없지만 웹소켓은 서버가 클라이언트에게 먼저 말(메세지)을 걸수있다.즉, REST API는 클라이언트의 요청이 있어야 서버 응답이 있는 반면에 Websocket API는 클라이언트 요청없이도 서버가 클라이언트에 응답할 수 있다.실무자입자에서는 어떠한 차이가 있을까? REST API와 Websocket API 차이점 REST API: 동기, 비동기 둘다 지원. 프레임워크가 에러보드까지 구현을 다 해놓아서 커넥션이 안정적이라고 하는편 Websocket API: 동기, 비동기 둘다 지원. 빠른 응답이 장점. 서버리소스가 많이 든다. 커넥션 안정성(커넥션 끊을때까지 커넥션이 안 끊김) 웹소켓을 쓰면 커멘드패턴에 따라서 규칙을 다 맞춰줘야함. 사람이 직접 해야하는 게 많아서 난이도가 있고 서버 리소스가 많이 들지만 커넥션이 매우 안정적임 참고 부장님 지식","link":"/2023/01/26/230127resttemplate-vs-websocket/"},{"title":"유저테이블의 PK에 휴대전화번호를 쓰면 안되는 이유","text":"가장 메인이 되는 User테이블을 만들때 PK로 휴대전화번호를 써도 될까? 실무에서 user테이블의 pk는 뭐로 쓸까?가장 메인이 되는 user테이블의 pk가 개인정보(전화번호 등)이 되어서는 안된다.개인정보보호법에 따라 DB에 저장할때 비밀번호처럼 항상 암호화해서 저장해야한다.따라서 UUID, 일련번호, 이메일을 PK로 주로 사용한다.","link":"/2023/01/29/230130userpk/"},{"title":"IaaS, PaaS, SaaS 차이","text":"프로젝트에서 사용중인 클라우드네이티브 서비스가 있는데 PaaS서비스이다. 예전에 이와 관련해서 공부한 적이 있는데 기록하지 않으니 벌써 기억이 가물가물하다. 이참에 다시 정리해보았다. 참고로 클라우드네이티브가 무엇인지 궁금하다면 블로그 글 클라우드 네이티브(Cloud Native)란? 개념,정의을 참조하면 된다. 한눈에 비교하기 IaaS(Infrastructure as a Service) 정보시스템의 모든 인프라를 인터넷상에서 제공한다. 언뜻 호스팅 서비스같아오이지만 IaaS의 경우,서버를 이용할 때에 필요한 하드웨어의 스펙이나 OS등을 사용자가 자유롭게 선정할 수 있다. 장점: 환경 구축 자유도가 높다, 시스템관리자의 부하가 적다. 단점: 환경 구축에 전문성 필요, 유지보수 범위가 넓다. PaaS(Platform as a Service) 정의: 개발 환경이 플랫폼화되어있는 서비스 플랫폼화란? 클라우드 환경의 서버, OS, 미들웨어, 데이터베이스 등 애플리케이션 개발에 필요한 환경이 플랫폼으로 갖추어져 있음. 장점: 개발환경의 플랫폼화로 인해 서비스·어플리케이션의 개발에 전념 가능, 초기 비용 및 시간 비용 절감 가능 단점: 개발환경의 커스텀마이징이 낮다. SaaS(Software as a Service) 정의: 패키지 제품으로 아예 서비스를 제공 예시: Office365, Gmail 등등 장점: 필요한 서비스를 월별요금제 등으로 결제해서 즉시 사용 가능 단점: 커스터마이징 불가, 데이터마이그레이션 어려움. 참고 https://www.redhat.com/ko/topics/cloud-computing/what-is-paas https://tagilog.tistory.com/1138","link":"/2023/01/30/230131iaas-paas-saas/"},{"title":"카디널리티(Cardinality) 개념, 정의","text":"오늘 팀장님에게 sql 작성할때 where에 PK컬럼뿐만 아니라 다른 컬럼을 추가로 조건을 걸면 조회성능에 더 좋은지 문의드렸다.PK컬럼은 항상 우선순위로 검색이 되기에 이외 컬럼을 추가한다고해서 조회성능이 좋아지지않는다고 알려주셨다. 그리고 카디널리티 개념을 알려주셨다. 카디널리티 개념이 흥미로워서 정리해보았다. 정의카디널리티(Cardinality)는 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표이다. 중복도가 낮으면 카디널리티가 높다 e.g. 휴대전화번호, 주민등록번호 중복도가 높으면 카디널리티가 낮다 e.g. 이름(동명이인) 여기서 중요한 개념은 카디널리티는 상대적이라는 것이다. 카디널리티는 데이터에 따라 상대적이기때문에 개발DB에서는 카디널리티가 낮아도 운영DB에서는 카디널리티가 높을 수 있다. 활용DB에서 인덱스를 걸 때 최대한 많은 데이터가 걸러져야 성능이 좋다.인덱스로 선택된 데이터가 많을수록 full scan이 되므로 성능이 좋지않다.즉, 여러 컬럼을 동시에 인덱싱할때는 카디널리티가 높은 컬럼을(중복이 적은 컬럼을) 우선순위로 두는 것이 인덱싱 전략에 유리하다.다만, 인덱스 키를 많이 사용하게 되면 공간 효울이 낮아지게 된다. 공간효율이 무엇일까?여기서 인덱스(index)란 DB테이블의 검색속도를 향상시키기위한 자료구조로 책 뒤편의 단어와 쪽수를 기재한 색인과 비슷하다.색인이 책에서 어느정도 비중을 차지할 수 있듯 인덱스를 관리하기 위해선 DB의 약 10%에 해당하는 저장공간이 필요하다.따라서, 인덱스키를 많이 걸수록 공간효율이 좋지않다. 참고 팀장님 지식 https://soft.plusblog.co.kr/87#:~:text=%EC%B9%B4%EB%94%94%EB%84%90%EB%A6%AC%ED%8B%B0(Cardinality)%EB%8A%94%20%ED%8A%B9%EC%A0%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0,%EA%B2%BD%EC%9A%B0%20%EC%B9%B4%EB%94%94%EB%84%90%EB%A6%AC%ED%8B%B0%EB%8A%94%202%EB%8B%A4. https://itholic.github.io/database-cardinality/","link":"/2023/02/01/230202db-cardinality/"},{"title":"[자료구조DataStructure]B-Tree(비트리)란, 개념,정의(최대한 쉽게)","text":"DB 카디널리티 관련해서 구글링하다보니 B-Tree구조를 반복해서 보게되었다. 듣기만 들었지 정확히 어떤 것인지 궁금해서 정리해보았다. 카디널리티가 궁금하다면 블로그 글 - 카디널리티 개념,정의을 참고하면 된다. B-Tree(B트리)가 뭐길래 전산학에서 B-트리(B-tree)는 데이터베이스와 파일 시스템에서 널리 사용되는 트리 자료구조의 일종으로, 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.방대한 양의 저장된 자료를 검색해야 하는 경우 검색어와 자료를 일일이 비교하는 방식은 비효율적이다. B-트리는 자료를 정렬된 상태로 보관하고, 삽입 및 삭제를 대수 시간으로 할 수 있다. 대부분의 이진 트리는 항목이 삽입될 때 하향식으로 구성되는 데 반해, B-트리는 일반적으로 상향식으로 구성된다.출처: 위키백과 뭐? 한글인데 너무 어렵다. 차근차근 살펴보자.위키백과에 따르면 B-Tree(이하 B트리)는 트리 자료구조 중 이진트리를 확장한 구조이다. 자료구조란?먼저 자료구조란 무엇일까? 자료구조(data structure) : 데이터를 효율적으로 사용하기 틀이다. 이러한 효율성은 시간 복잡도(time complexity)와 공간 복잡도(space complexity) 기준으로 평가된다. 추가로 블로그 글 - 자료구조와 알고리즘 차이를 참고하면 좋다. 트리자료구조란?B트리는 이름에서도 알수있듯 트리 자료구조이다. 자료구조는 알았는데 트리자료구조는 또 뭘까? 트리 구조란 그래프의 일종으로, 한 노드에서 시작해서 다른 정점들을 순회하여 자기 자신에게 돌아오는 순환이 없는 연결 그래프이다.트리에서 최상위 노드를 루트 노드(root node 뿌리 노드[*])라고 한다.또한 노드 A가 노드 B를 가리킬 때 A를 B의 부모 노드(parent node), B를 A의 자식 노드(child node)라고 한다.자식 노드가 없는 노드를 잎 노드(leaf node 리프 노드[*]) 또는 말단 노드 (terminal node)라고 한다. 잎 노드가 아닌 노드를 내부 노드(internal node)라고 한다.출처: 위키백과 트리구조의 특징 트리는 하나의 루트 노드를 갖는다. 루트 노드는 0개 이상의 자식 노드를 갖는다. 자식 노드 또한 0개 이상의 자식 노드를 갖는다. 노드(Node)들과 노드들을 연결하는 간선(Edge)들로 구성되어 있다. 트리구조 중 유명한 트리구조로는 자가 균형 이진 탐색 트리 최소 비용 신장 트리 B-트리, 2-3 트리, B+ 트리, B*-트리 이진트리자료구조란? 컴퓨터 과학에서 이진 트리(二進-, 영어: binary tree)는 각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조로, 자식 노드를 각각 왼쪽 자식 노드와 오른쪽 자식 노드라고 한다.출처: 위키백과 즉, 이진트리는 각 노드가 최대 두 개의 자식을 갖는 트리를 뜻한다. 따라서 각 노드는 자식이 없거나 한 개 이거나 두 개만을 가질 수 있다. 이진트리종류 정이진트리(full binary tree) 완전이진트리(complete binary tree) 균형이진트리(balanced binary tree) 등 B트리자료구조란?보통 B트리라고 하면 B-트리를 의미한다. B-트리는 이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 벨런스를 맞추는 트리이다. B트리구조특징 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 크다. 내부 노드는 M/2 ~ M개의 자식을 가질 수 있다. 최대 M개의 자식을 가질 수 있는 B 트리를 M차 B트리라고 한다. 정렬된 순서 보장 멀티레벨 인덱싱을 통한 빠른 검색 가능 실제 MySQLDB,MariaDB에서는 B트리에서 발전한 B+트리를 실제로 사용한다. B+트리 왜 B+트리가 나왔을까? B-트리의 단점때문이다. B-트리는 삽입, 수정, 삭제에 따라 트리의 균형을 맞추는 작업이 필요해 성능에 문제가 발생할 수 있다.이를 해결하고자 B+트리는 Leaf node끼리는 linked list을 사용해 최적화했다. 아래 사이트를 통해 B+트리구조를 직접 만들어볼 수 있다. 재밌다! https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 참고 https://ratsgo.github.io/data%20structure&amp;algorithm/2017/10/21/tree/ https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Tree https://code-lab1.tistory.com/217 https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Plus-Tree","link":"/2023/02/02/230203Btree/"},{"title":"String.valueOf() vs toString() 차이 알고쓰자","text":"비슷한 역할을 하지만 결과는 다른 두 메서드 String.valueOf()와 Object.toString()의 차이에 대해 알아보자. 차이점: Null처리가장 큰 차이점은 null처리이다. null처리때문에 보통 Object.toString()을 많이 쓴다. 클라이언트는 null을 볼 필요가 없기때문이다. 1234567Object testObj = null; System.out.println(String.valueOf(testObj)); // 결과: nullSystem.out.println(testObj.toString()); // 결과: NullPointerException 오류 발생 String.valueOf(): null인 경우 문자열null을 만들어서 출력 null체크: “null”.equals(string) 확인 필수 Object.toString(): null인 경우 NPE 발생 Onject의 값이 String타입이 아니어도 출력한다. 결론NPE를 방지하고 싶다면 String.valueOf()를 사용하고 널체크를 꼭 해줘야한다.","link":"/2023/02/06/230207stringvalueof-vs-tostring/"},{"title":"ClassCastException발생 Java.lang.Integer cannot be case to Java.lang.String 해결방법(ft. ChatGPT)","text":"String을 int로 변환하는 과정에서 cast 에러가 발생했다. 문제상황내가 원했던 건 DB에서 가져온 balance정보를 int로 바꿔주고싶었다. 쿼리가 아주 길지만 간략하게 요약해보면 아래와 같다. 컬럼 정의 balance int(11) 잔액 123&lt;select id=\"getBalance\" resultType=\"HashMap\"&gt; select balance from User&lt;/select&gt; 123456HashMap&lt;String, String&gt; map = dao.getBalance();int curBalance = Integer.parseInt(map.get(\"balance\"));// 결과// ClassCastException발생 Java.lang.Integer cannot be case to Java.lang.String 컴파일 에러는 안나지만 ClassCastException이 발생했다.이상했다.HashMap 데이터타입을 String으로 정의했는데 왜 Integer to String으로 캐스팅을 하는걸까? 해결일단 해결부터! 아래로 캐스팅하니 바로 해결되었다. 1int curBalance = Integer.valueOf(String.valueOf(map.get(\"balance\"))); 해결 방법은 금방 찾았으나 원인이 너무 궁금했다.다시 질문으로 돌아가보자. HashMap 데이터타입을 String으로 정의했는데 왜 Integer to String으로 캐스팅을 하는걸까? 원인찾기데이터타입이 무엇인지 정확히 알기위해 getClass()를 하니 Integer가 나왔다. 12map.get(\"balance\").getClass();// 결과 Java.lang.Integer 이게 말이 되는 건가?HashMap의 데이터타입을 String으로 정의했는데 어떻게 Integer가 들어간걸까?구글링해도 도저히 찾지 못하겠어서 팀장님께 질문드리니 팀장님이 아래와 같은 예제 코드를 주셨다. 123456HashMap test = new HashMap&lt;&gt;();test.put(\"test\", 123);HashMap&lt;String, String&gt; test2 = test;System.out.println(test2.get(\"test\").getClass());// 결과값 jva.lang.Integer 컴파일 에러없이 서버런해도 정상 작동해버리는 코드! 뭐야?팀장님께서는 자바8 제네릭에 대해 찾아보라는 조언을 주셨다. 역시 팀장님은 천재야…! 제네릭 타입소거 (ft.ChatGPT)요즘 유행인 ChatGPT에게 물어봤다. This code will result in a compilation error because test is declared as a HashMap with a key of type String and a value of type Integer, while test2 is declared as a HashMap with a key and value of type String. Therefore, you cannot assign test to test2 as the two types are not compatible.Assuming that test2 is declared correctly with the same key and value types as test, and test.put(“test”, 123) has been fixed to use a String value, the output of System.out.println(test2.get(“test”).getClass()) would be java.lang.Integer, since the value associated with the key “test” is an Integer. The getClass() method returns the runtime class of an object, which in this case is Integer since that’s the type of the value associated with the “test” key in the HashMap. 하지만 이 케이스는 컴파일에러가 발생하지 않기에 다시 물어봤다. Me: But there is no compilation error in java 8. how can you explain this?ChatGPT: You are correct that in Java 8, the code you provided will compile without error.In Java 8 and earlier versions, the generic types of a variable were not enforced by the compiler in all situations. This is known as type erasure, where the generic type information is removed during compilation and is not available at runtime. As a result, it was possible to assign a variable of type HashMap to a variable of type HashMap&lt;String, String&gt; or vice versa, even if the generic types were not the same.However, this type of assignment is not recommended as it can result in runtime errors if the wrong types of data are inserted or retrieved from the map. Starting from Java 9, the compiler will issue a warning for this kind of unchecked conversion, and it is recommended to use generics correctly to avoid any potential issues.So, while the code you provided will compile in Java 8, it is not considered good programming practice and may result in unexpected behavior if the wrong data types are used with the map. 요약해보자면, Java 8에서 제네릭타입은 컴파일 중 타입 소거(Type Erasure)되어 HashMap 타입의 변수를 HashMap&lt;String, String&gt; 타입의 변수에 할당하거나 그 반대의 경우에도 할당할 수 있게 된 것 이다.너무 신기하잖아😲ChatGPT에게 자바8 타입 소거(Type Erasure)에 대해 지금 예시로 알려달라고 요청했다. Me: Can you explain more about Type Erasure in this case?ChatGPT: Sure, I’d be happy to explain type erasure in this case.In Java, generic types were introduced in order to provide stronger type checking and to avoid class cast exceptions. A generic type is a type that can be parameterized with other types. For example, List&lt;T&gt; is a generic type that can be parameterized with another type, such as List&lt;String&gt;.However, at runtime, Java’s virtual machine (JVM) doesn’t have access to the generic type information. This is where type erasure comes in. Type erasure is the process by which the JVM replaces the generic type parameters with their upper bounds or with Object, depending on the type’s use.For example, in the code you provided, the HashMap is declared with a generic type of HashMap&lt;String, Integer&gt;. However, at runtime, the JVM replaces the type parameters with their upper bounds, which means that the HashMap object will be treated as if it were of type HashMap&lt;Object, Object&gt;. This is why, in Java 8 and earlier versions, it is possible to assign a variable of type HashMap to a variable of type HashMap&lt;String, String&gt; or vice versa, as the generic type information is not used to enforce the type compatibility between the two variables.In summary, type erasure is a process by which the JVM removes the generic type information from a class or method, and replaces it with its upper bounds or with Object. This can lead to unchecked type conversions and potential runtime errors, which is why it is recommended to use generics correctly and to avoid unchecked conversions. 요약해보자면 아래와 같다. 타입 소거(Type Erasure)란?Type Erasure(타입 소거)란 제네릭 타입에 사용된 타입 정보를 컴파일 타임에만 사용하고 런타임에는 소거하는 것을 말한다.자바 컴파일러는 모든 타입 파라미터를 Object 타입으로 교체한다. 제네릭 타입을 제거한 후 타입이 일치하지 않으면 타입 캐스팅을 추가한다. 왜 Object 타입으로 바꿀까?런타임시 Java 가상 머신(JVM)은 제네릭 타입 정보에 접근할 수 없다. 그래서 타입 소거(Type Erasure)가 필요하다.즉, 타입 소거는 JVM이 제네릭 타입 매개변수를 상한값으로 또는 Object로 대체하는 과정이다.런타임에서 JVM은 상한값으로 타입 매개변수를 대체하므로 HashMap 객체는 HashMap&lt;Object, Object&gt; 타입인 것처럼 처리된다. 그래서 Java 8 이전 버전에서 HashMap 타입의 변수를 HashMap&lt;String, String&gt; 타입의 변수에 할당할 수 있게 된 것이다.즉, 제네릭 타입 정보가 두 변수 간의 타입 호환성을 강제하기 위해 사용되지 않기 때문입니다. 결론타입 소거는 JVM이 클래스 또는 메서드에서 제네릭 타입 정보를 제거하고 상한값으로 또는 Object로 대체하는 과정이다. 이는 검사되지 않은 타입 변환 및 잠재적인 런타임 오류를 발생시킬 수 있기 때문에 올바른 제네릭 사용을 권장하고 검사되지 않은 변환을 피해야 한다. ChatGPT 진짜 천재다.😲 참고 김팀장님 지식 ChatGPT https://wisdom-and-record.tistory.com/134","link":"/2023/02/13/230214integervalueof/"},{"title":"MVC패턴과 MVP패턴 차이","text":"박부장님과 김팀장님 셋이서 함께 치맥을 하던 중 부장님이 요즘은 무슨 공부를 하느냐고 물으셨다.그때그때 궁금한 것들을 공부하고 있지만 디자인 패턴이 흥미롭다고 말씀드렸더니 MVP패턴에 대해 알려주셨다. 흘려들을 순 없지! 바로 공부를 해보았다.아무리 봐도 MVC와 차이가 느껴지지 않아 한참을 찾아보았다. MVP이란Model - View - Presenter로 이뤄진 디자인 패턴이다.MVC에서 Controller가 하는 역할을 Presenter가 한다고 보면 되는데 여기서 궁금증이 생긴다.그러면 MVC 쓰면 되지 왜 MVP를 쓸까? MVC Pattern과의 차이 MVC패턴에서는 Model과 View가 서로 연결되어 있어 의존관계를 가지고 있다. MVP패턴은 Model과 View는 서로 연결되지 않고 Presenter를 통해서 변화를 알 수 있게 된다.이렇게 화면과 비즈니스로직이 완전히 분리되면서 테스트가 용이해진다. 장점: View와 Model을 분리시켜 MVC나 Apple의 MVC에서 하기 힘들었던 테스트가 용이 단점: View와 Presenter의 의존관계가 강해지고 Controller 대신 Presenter가 복잡해짐 MVP패턴에서 뷰가 업데이트 되는 과정 사용자가 View에서 액션을 한다. View는 Presenter에 액션이 들어왔다고 전달한다. Presenter는 View 액션대로 Model이나 Service를 구성한다. Update된 Presenter의 데이터를 View에 업데이트 한다. 참고 팀장님 지식 https://ykss.netlify.app/web/design_pattern/ https://medium.com/android-news/mvp-depp-dive-c6bb1903ace1 https://fomaios.tistory.com/entry/Design-Pattern-MVP-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80","link":"/2023/02/16/230217MVPpattern/"},{"title":"[요약]이제야 NFT가 궁금해진 너에게 - 박근모","text":"현재 진행중인 프로젝트에서 블록체인과 NFT 개념이 자주 나온다. 정확히 이해하고 싶어서 글을 찾아보다 토스에서 발행한 좋은 글이 있길래 요약해봤다. 이 글은 원문이제야 NFT가 궁금해진 너에게 - 박근모의 요약을 바탕으로 필자의 생각을 추가한 것이다. 원문을 읽을 것을 강력 추천한다!NFT를 이야기하면 항상 블록체인이 나온다. 왜 둘은 같이 나올까? 블록체인먼저 블록체인이라는 기술을 이해하고, 거기에 암호화폐와 NFT를 연결해서 이해하면 쉽다.블록체인은 블록과 체인이 결합된 단어이다. 여기서 블록은 데이터(정보)를 뜻한다. 즉, 블록체인은 데이터를 연결하는 기술을 의미한다. 데이터를 연결하는 기술이 왜 필요할까?블록체인 기술은 데이터를 연결하는 시스템을 만들어서 모든 사람이 확인할 수 있게 하고, 그래서 조작할 수 없게 만드는 것이다.블록체인을 이용하면 정부나 은행 등 권력을 가진 기관 없이 중요한 거래가 가능해진다. 이를 탈중앙화라고 한다.탈중앙화를 통해, 금융 기관의 안정성과 투명성을 믿을 수 없게 된 사람들이 어디에도 특권을 주지 않고(탈중앙화) 금융 거래를 가능케한다. 그래서 NFT는 뭘까?NFT는 Non-Fungible Token의 약어로 추가 설명은 원문이 너무 좋아 그대로 가지고왔다. 암호화폐가 블록체인을 이용해서 만든 돈이라면 NFT는 블록체인을 이용해 만든 증명서입니다.본격적으로 NFT를 알아보기에 앞서 딱 3가지만 기억하세요.❶ NFT는 유일하다(대체 불가능하다).❷ 그걸 증명할 수 있다.❸ 디지털 세상에는 그게 필요했다. 암호화폐=가상화폐=코인=크립토 커런시(crypto currency)=크립토는 모두 암호화폐를 지칭하는 단어예요.출처: 원문이제야 NFT가 궁금해진 너에게 - 박근모 NFT는 어떻게 증명서가 될 수 있을까? 이를 알려면 토큰 개념을 알아야한다. 토큰토큰(token)은 현금 대신 쓸 수 있는 교환권이라는 뜻으로 블록체인에서 토큰은 블록체인에 등록된(진짜라는 것이 증명된) 자산이다.NFT는 이름 그대로 대체불가능한 토큰(Non-Fungible Token)으로 블록체인이 부여한 고유한 번호를 가진, 대체 불가능한 자산이다. 왜 대체 불가능할까? 조작할 수 있지 않을까? NFT를 적용하면 생성 이력과 데이터가 기록되고 이를 수만~수십만 개로 분산 저장하기 때문에 함부로 조작할 수 없다.블록체인에 기록된 정보는 누구나 열람할 수 있고, 전체 참여자의 51% 이상이 허락하지 않는 한 변경할 수 없다.출처: 원문이제야 NFT가 궁금해진 너에게 - 박근모 NFT 구성요소 3가지 NFT 미디어 데이터(NFT media data): 원본데이터 NFT 메타데이터(NFT metadata): 원본데이터 설명, 생성자정보, 원본데이터가 저장되어있는 주소 NFT 스마트 계약(NFT smart contract): NFT의 소유권자, 거래 내역, 조건, 가격 등이 기록 스마트계약이 복잡하기 때문에 NFT를 조작하기는 어렵다. NFT 구매방법NFT전용 온라인 플랫폼에서 암호화폐로 구매할 수 있다. NFT전용 온라인 플랫폼 국내: 카카오-클립 드롭스, 두나무-업비트 NFT 등 해외: 세계 최대 NFT 거래소-오픈시나 슈퍼레어(SuperRare), 라리블(Rarible) 등 암호화폐를 사용하려면 암호화폐 전용지갑이 필요하고, 이 지갑에 구매한 NFT를 보관한다. 공짜 NFT를 구매해도 돈을 낸다고?NFT가 무료여도 가스비(수수료)가 발생한다. 오픈시에서 직접 무료인 NFT를 구매해 봤어요. NFT 가격은 무료지만, 약 43달러(약 5만 2000원)의 가스비를 냈습니다. 가스비는 이더리움, 클레이튼, 솔라나 등 NFT가 만들어진 플랫폼마다 다르고, 거래 시점에 따라서도 약간씩 달라져요.출처: 원문이제야 NFT가 궁금해진 너에게 - 박근모","link":"/2023/03/01/230302whatisnft/"},{"title":"[Gson]MalformedJsonException 에러해결","text":"백단 테스트 중 json을 받을 일이 있어서 그냥 작성했더니 아래와 같은 오류가 발생했다. 문제 jsp코드 123456789101112let param = {};param.userid = 'testuser';param.json = '{\\\"title\\\":\\\"테스트제목\\\", \\\"detail\\\":\\\"테스트1의 설명입니다.\\\"}';$.ajax({ url: \"/test/json\", method: \"POST\", data: param, callback: function(data){ alert(JSON.stringify(data)); }}) testVO코드 12345@Datapublic class TestVO { private String title; private String detail;} 컨트롤러코드 12345678@RequestMapping(value=\"/test/json\", method= RequestMethod.POST)@ResponseBodypublic TestVO testControl(@ResquestParam HashMap&lt;String, String&gt; param) throws Exception{ TestVO test = new TestVO(); test = new Gson().fromJson(param.get(\"json\"), TestVO.class); return test;} 에러메시지 1com.google.gson.stream.MalformedJsonException: Expected ':' at line 1 column 8 path $.&amp;quot 언제나 에러메시지 안에 답이 있다. 해결1: 공백, 특수문자 제거com.google.gson.stream.MalformedJsonException - juno.log을 참고하면 특수문자를 제거하는 방법이 있다.내 상황에선 json형태가 깨지기에 사용할 수 없었다. 해결2: setter 사용jsp코드와 컨트롤러 코드를 수정했다. jsp코드12345678910111213let param = {};param.userid = \"testuser\";param.title = \"테스트제목\";param.detail = \"테스트1의 설명입니다\";$.ajax({ url: \"/test/json\", method: \"POST\", data: param, callback: function(data){ alert(JSON.stringify(data)); }}) 컨트롤러코드 123456789@RequestMapping(value=\"/test/json\", method= RequestMethod.POST)@ResponseBodypublic TestVO testControl(@ResquestParam HashMap&lt;String, String&gt; param) throws Exception{ TestVO test = new TestVO(); test.setTitle(param.get(\"title\")); test.setDetail(param.get(\"detail\")); return test;} 그냥 받았다… 더 좋은 방법이 있다면 댓글로 알려주시면 감사하겠습니다.","link":"/2023/03/02/230303malformedjsonexception/"},{"title":"[@Autowired에러]no qualifying bean of type available: expected at least 1 bean which qualifies as autowire candidate 오류해결","text":"스트레스를 주는(?) 생성자주입에러! 나는 분명 모든 스프링빈등록을 어노테이션으로 제대로 걸었다고 생각했는데 자꾸 빈등록할 것이 없단다. 1. @Controller, @Service, @Repository 누락 어노테이션 찾기구글링해보니 @Controller, @Service, @Repository 어노테이션을 누락된 부분을 찾으라는 글이 많았다.하지만 아무리 찾아도 보이지않았다.프로세스 흐름대로 흘러가도 보이지 않는 누락 어노테이션. 2. component-scan에 패키지가 누락되었는지 확인하기root-context.xml 과 servlet-context.xml에서 해당 패키지가 누락되진않았는지 체크해보자.나의 경우 패키지 com.test.api가 누락되서 발생된 에러였다.추가해주니 정상적으로 빈생성이 되고 server run이 성공했다. 123456&lt;bean&gt; &lt;context:component-scan base-package=\"com.test.dao\" /&gt; &lt;context:component-scan base-package=\"com.test.service\" /&gt; &lt;context:component-scan base-package=\"com.test.util\" /&gt; &lt;context:component-scan base-package=\"com.test.api\" /&gt; &lt;!-- 추가 --&gt;&lt;/bean&gt;","link":"/2023/03/12/230313autowirederror/"},{"title":"[GITHUB]깃허브액션(github action)","text":"어제 부장님이 젠키스와 깃헙액션을 이용해서 CI/CD에 관한 걸 말씀해주셨다. 젠킨스랑 깃헙액션이 같은 역할을 한다고 생각했는데 아닌거 같아 깃헙액션을 공부하게 되었다.깃헙액션을 가장 잘 소개한 영상이 있다면 바로 드림코딩 엘리님이다.정말 쉽게 잘 설명해주시니까 깃헙액션을 알고싶은 사람이라면 필수 시청해야하는 영상이다! 이번 글은 위 영상을 요약하면서 추가적으로 구글링한 내용을 덧붙였음을 밝혀둔다.😍엘리님 매번 좋은 영상 감사합니다😍 깃과 깃헙, 깃헙액션의 관계버전관리시스템에서 가장 많이 사용하는 GIT과 그걸 배포할 수 있는 GITHUB가 있다.여기서 자동화(CI/CD)를 이용하려면 GITHUB의 레포지토리에다가 jenkins, buildkite, circleci 중 하나를 연결해야 가능했다.하지만 2018년에 깃헙액션이 등장하면서 별도의 외부툴없이 자동화프로세스를 만들 수 있다. 여기서 잠깐 CI/CD란? CI: 지속적인 통합 CD: 지속적인 배포 깃헙 메인 리포지토리에 새롭게 추가되는 기능들을 CI서버에서 자동으로 빌드하고 테스트하고 지속적으로 배포하는 것을 말한다.CI와 CD의 차이점과 데브옵스까지 궁금하다면 블로그 글 - DevOps와 CI/CD차이에 쉽게 작성해두었으니 참고하면 좋다. 깃헙액션 개념깃헙액션에는 중요한 5가지 개념이 있다. 1 Events어떤 일이 발생했는지를 지정하는 곳아래 예시처럼 특정한 이벤트가 일어났을때 그 후로 뭘 해야할지 wrokflows로 지정해줄 수 있다.e.g 1) main브랜치로 머지했을때 2) 커밋을 푸쉬했을때 3) 이슈를 누군가 만든다면 2 Workflows특정한 이벤트가 발생하면 어떤 걸 해야하는지 순서를 명시하는 곳.Workflows안에는 하나 또는 다수의 job이 있다. 3 Job무언가를 실행하는 걸 명시하는 곳job안에는 쉘스크립트로 step을 만들어줄수있다. 4 Action깃헙액션에서 제일 유용한 부분이다.우리가 자주 사용하는 공개적으로 오픈된 Action들이 미리 정해져 제공된다.npm에서 라이브러리 가져다쓰는 것처럼 깃헙액션도 동일한 것이라고 생각하면 된다. 5 RunnerJob을 실행하는 것이 바로 Runner이다.JOB의 갯수만큼 RUNNER가 존재하며 이들은 독립적으로 실행된다.러너는 VM 혹 도커컨테이너라고도 생각할 수 있다. 깃헙액션 흐름","link":"/2023/03/16/230317githubaction/"},{"title":"CDN이 뭐길래(개념, 정의)","text":"CDN이란 뭘까? 서버리스개념을 공부하면서 CDN이 궁금해졌다. CDN(Content Delivery Network) 거리상의 문제로 발생하는 페이지로딩속도 향상을 위해서 CDN사용 웹페이지, 이미지, 폰트 등 정적 콘텐츠를 캐싱할 수 있는 서버 장점: 페이지로딩속도 향상할 수 있음 단점: 동적은 CDN에서 처리 불가 CDN에서 동적코드 가능하도록 몇몇 함수를 구현할 수 있다. 즉, 특정 국가나 지역만을 타깃으로 하는 웹 서비스를 운영한다면 CDN 서비스를 활용할 필요가 없다. 참고 https://aws.amazon.com/ko/what-is/cdn/","link":"/2023/03/27/230328cdn/"},{"title":"[Java]List에서 중복값을 제외하는 방법2가지","text":"커스텀한 객체를 가지는 List에서 중복된 객체를 제거하고 싶었다. 차장님께 물어보니 2가지 방법을 알려주셨다. 기존코드123456789101112131415161718192021222324252627// 커스텀한 User 객체@Dataclass User { String name; int age; @Override public String toString() { return name + \":\" + age; } }// List 선언하기List&lt;User&gt; userList = new ArrayList&lt;&gt;();userList.add(new User(\"조지\", 7));userList.add(new User(\"휘슬\", 8));userList.add(new User(\"브라이언\", 9));userList.add(new User(\"브라이언\", 9));userList.forEach(System.out::println);// 결과값조지:7휘슬:8브라이언:9브라이언:9 위 userList에서 중복을 제거하는 방법은 2가지이다.생성자를 활용하거나 stream().distinct()를 사용하는 방법이다. 1 생성자 활용기본 타입이 아닌 참조 타입인 경우 클래스에서 hashCode() 메서드와 equals() 메서드를 재정의 먼저 해줘야한다. 123456789101112131415161718192021222324252627282930313233343536// hashCode(), equals() 메서드 추가@Dataclass User { String name; int age; @Override public String toString() { return name + \":\" + age; } @Override public int hashCode(){ return Objects.hash(name, age); } @Override public boolean equals(Object obj){ if(this == obj) return true; if(obj == null) return false; if(getClass() != obj.getClass()){ retyrn false; } User other = (User) obj; return name == other.name &amp;&amp; Objects.equals(age, other.age); } }// 생성자활용List&lt;User&gt; distinctUserList = new ArrayList&lt;User&gt;(new HashSet&lt;User&gt;(userList));distinctUserList.forEach(System.out::println);// 결과값조지:7휘슬:8브라이언:9 2 stream 활용기본 타입이 아닌 참조 타입인 경우 클래스에서 hashCode() 메서드와 equals() 메서드를 재정의 먼저 해줘야한다. 123456789101112131415161718192021222324252627282930313233343536373839// hashCode(), equals() 메서드 추가@Dataclass User { String name; int age; @Override public String toString() { return name + \":\" + age; } @Override public int hashCode(){ return Objects.hash(name, age); } @Override public boolean equals(Object obj){ if(this == obj) return true; if(obj == null) return false; if(getClass() != obj.getClass()){ retyrn false; } User other = (User) obj; return name == other.name &amp;&amp; Objects.equals(age, other.age); } }// stream().distinct() 활용List&lt;User&gt; distinctUserList = userList.stream() .distinct() .collect(Collectors.toList());distinctUserList.forEach(System.out::println);// 결과값조지:7휘슬:8브라이언:9 출처 차장님 지식","link":"/2023/04/06/230407removeduplicatevalueinlist/"},{"title":"Kafka(카프카)가 뭐길래(개념, 정의)","text":"저번주 회의에서 팀장님과 차장님이 kafka에 대해 짧게 이야기를 나누셨는데 나는 메시지 다루는 시스템인 줄만 알았는데 비동기등 다양한 이야기를 해주셨다. 놓칠수없기에 따로 공부를 해보았다. Kafka 카프카chatGPT에 문의하니 아래와 같이 답변을 얻었다. Kafka is an open-source platform used for handling large amounts of data in real-time. It was originally developed by LinkedIn, but is now maintained by the Apache Software Foundation.Think of Kafka as a messaging system that can receive, store, and distribute data streams. It allows you to publish data to a stream or subscribe to a stream to receive data. This makes it useful for applications where data needs to be processed and analyzed as it’s generated, such as in a real-time analytics system.Here’s a super easy example to help illustrate Kafka’s functionality:Let’s say you have a website where users can upload images. Whenever a new image is uploaded, you want to process it in some way (maybe resizing it or running some filters on it) and then store it on your servers. You also want to display a thumbnail of the image on the website so users can see it right away.With Kafka, you could set up a “topic” (a stream of data) called “image-uploads”. Whenever a user uploads an image, your website would send a message to the “image-uploads” topic with the details of the image (e.g. the file name, user ID, etc.). You could have a separate “consumer” application (i.e. a program that subscribes to the “image-uploads” topic) that listens for new messages and processes them accordingly.For example, the consumer application might download the image, resize it, and store it on your servers. It could also generate a thumbnail and send a message to a separate “thumbnails” topic with the details of the thumbnail. Another consumer application could listen for messages on the “thumbnails” topic and display the thumbnail on the website.This is just one simple example, but hopefully it gives you an idea of how Kafka can be used to handle real-time data processing and distribution.출처: chatGPT 카프카 정의 및 특징 실시간으로 대용량 데이터를 처리하는 오픈소스 링크드인에서 처음 개발 데이터 스트림을 수신, 저장 및 배포하는 메시징 시스템 특징: 데이터를 스트림에 게시하거나 스트림을 구독하여 데이터를 수신할 수 있도록 함 활용: 실시간 분석 시스템과 같이 데이터가 생성됨과 동시에 처리 및 분석해야 하는 애플리케이션에 유용 가장 쉬운 예시와 함께 설명해달라고 했더니 chatGPT가 준 사용자 이미지 업로드 웹사이트 예시를 알려줬다.사용자 이미지 업로드와 동시에 썸네일만들어서 올리기, 이미지사이즈 조정하기등 특별한 절차가 존재한다면, Kafka를 통해 사용자이미지업로드라는 토픽을 만든 뒤 토픽을 구독하고 있는 모든 애플리케이션에 실시간으로 상세데이터와 함께 토픽을 전달한다. 참고 chatGPT","link":"/2023/04/09/230410kafka/"},{"title":"[모바일] deeplink가 뭐길래(개념, 정의)","text":"오늘 회의를 하다가 부장님이 deeplink를 사용하면된다고 하셨다.deeplink가 뭐지? 처음 듣는 용어라 공부해봤다. Deeplink 링크를 클릭하면 특정 앱으로 이동하거나, 앱이 없다면 설치를 유도하거나, 앱이 있다면 앱 내 특정페이지로 이동시킬 수 있다. 활용: 모바일 마케팅광고에 흔히 사용하는 방식으로 클릭시 앱이 없다면 앱설치 유도하는 페이지로, 앱이 있다면 앱 내 특정페이지로 이동시킨다. Deeplink 3가지 방식 URI 스킴 방식 : 앱에 URI 스킴(scheme) 값을 등록하여 딥링크 사용 앱링크(App Link) : Android 제공 - 도메인 주소를 이용한 딥링크 사용 유니버셜 링크 (Universal Link) : iOS 제공 - 도메인 주소를 이용한 딥링크 사용 1 URI scheme 가장 일반적으로 딥링크를 사용하는 방식은 URI Scheme 방식이다.이 방식의 한계는 점차 앱이 다양해지면서 앱 스킴값이 중복되는 경우가 존재한다는 것이다. 이런 경우 개발자가 원하는 대로 작동하지 않을 수 있다. 2 유니버셜 링크와 앱 링크유니버설 링크(Universal Links)와 앱 링크(App Links)는 각각 iOS와 Android에서 사용되는 딥 링킹 프로토콜이다.도메인은 딱 1개밖에 없기때문에 이들은 URI 스키마의 한계를 극복하기 위해 앱의 도메인 이름을 운영 체제(OS)에 등록하여 소유권을 증명하는 방식을 사용한다.여기서 도메인이름이란? https://sowon-dev.github.io/categories/Android/ 에서 domain name은 sowon-dev.github.io이다. 이 방식에도 한계가 존재한다.유니버셜링크는 구글에서만, 앱링크는 사파리에서만 정상 작동되고 다른 앱이나 브라우저에서 작동이 안될 수 있다. 결론적으로 현재까진 3가지 방식(URI 스킴 방식, 유니버셜링크, 앱링크)을 모두 사용해야한다. 참고 https://www.airbridge.io/blog/deeplink-101-for-marketers-and-developers https://help.dfinery.io/hc/ko/articles/360039757433-딥링크-Deeplink-URI스킴-유니버셜-링크-앱링크-구분과-이해","link":"/2023/04/10/230411deeplink/"},{"title":"팝업(모달)창에서 datepicker 적용 안되는 오류 해결법","text":"화면작업을 하는데 리스트화면에서도 부트스트랩 datepicker를 사용하고 리스트화면의 상세보기 버튼을 눌러 팝업창을 띄우는데 거기서도 datepicker를 써야했다.근데 문제는 리스트화면의 datepicker는 잘 작동하는데 팝업창의 datepicker는 전혀 작동하지않았다.달력아이콘을 클릭해도 달력이 안나오고 input을 클릭해도 포커싱은 되는데 달력이 안나오니 환장할 노릇. 오전 내내 이 문제를 가지고 구글링해서 여러 방법을 시도했다. 원인찾기디버깅해보니 캘린더 클릭시 아래 div태그가 disploy:none에서 display:block으로 바뀌지않는 문제였다. 123&lt;div id=\"ui-datepicker-div\" style=\"display=none;\"&gt; //중략&lt;/div&gt; 시도1 : 팝업화면 show 이벤트 적용리스트화면에 팝업show 이벤트 적용하기 실패했다. 123$('#modal').on('show', function () { $.fn.modal.Constructor.prototype.enforceFocus = function () { };}); 혹시몰라서 팝업창 스크립트에서도 아래 코드 적용해봤지만 실패했다. 1$.fn.modal.Constructor.prototype.enforceFocus = function () { }; 시도2 : 팝업화면 shown 이벤트 적용리스트화면에 팝업 shown 이벤트 적용도 실패했다. 123$('#modal').on('shown', function () { $.fn.modal.Constructor.prototype.enforceFocus = function () { };}); 시도3 : z-index주기혹시나하고 z-index를 줘봤지만 역시나 실패했다. 1style=\"z-index:10000; 시도4 : 강제로 div태그 display:block주기팝업창 내에서 달력아이콘에 온클릭이벤트를 걸어 toggle을 줘봤지만 실패했다. 123$('#달력아이콘').on('click', function () { $(\"#ui-datepicker-div\").toggle()}); 해결비흡연자지만 담타를 가시는 차장님을 쫄래쫄래 따라가서 여쭤봤다.이런 에러가 있고 이런 것까지 오전내내했는데 안되는데 뭐가 문제일까요 하고 여쭤봤더니 5분만에 해결해주셨다. 나의 경우 스크립트와 link를 중복 선언한게 문제였다.그래서 리스트화면의 스크립트태그, link태그는 그대로 두고 팝업창에 선언한 스크립트태그와 link태그를 삭제했더니 잘 작동했다! 12345&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/resources/css/bootstrap.css\" /&gt; //삭제&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/resources/css/base.css\" /&gt; //삭제&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/resources/css/jquery_ui.css\" /&gt; //삭제&lt;script src=\"/resources/js/jquery_min.js\"&gt;&lt;/script&gt; //삭제&lt;script src=\"/resources/js/jquery-ui.min.js\"&gt;&lt;/script&gt; //삭제 유레카!감사합니다 차장님!","link":"/2023/04/25/230426datepicker-error-in-modal/"},{"title":"Double&#x2F;Float 변환시 ClassCastException오류 NaN 해결","text":"화면에서 컨트롤러로 파라미터 HashMap&lt;String, String&gt; map를 받아 double값을 형변환하려고 하는데 ClassCastException이 발생했다.Java.lang.Integer cannot be case to Java.lang.String 이었고 원인을 찾아보니 NaN가 문제였다. 기존코드와 원인분석1Double fee = Double.valueOf(map.get(\"fee\")); 원인은 바로바로 NaN이다!화면에서 map.get(“fee”)의 값이 없어서 NaN으로 파라미터가 컨트롤러로 넘어왔다.내 의도는 화면에서 주는 값이 없으면 서비스단에서 null을 넣는 거였는데 NaN이라 이를 Double로 형변환하려니까 ClassCastException이 발생한 것이었다. 해결Double에서는 isNaN을 제공해준다. 이를 이용하면 된다. 123456//해결코드if(Double.isNaN(Double.valueOf(map.get(\"fee\")))){ fee = null;} else{ fee = Double.Double.valueOf(map.get(\"fee\"));} 오늘도 해결! 참고 https://www.javatpoint.com/java-double-isnan-method","link":"/2023/05/09/230509double-NaN/"},{"title":"count(**)와 count(1) 그리고 count(컬럼명) 차이","text":"SQL에서 count를 셀때 3가지 방법으로 나타낼 수 있다. count(*) count(1) count(컬럼명) count(*) vs count(1)사실 둘 사이에는 아무런 차이도 없다.동일하게 동작하는 걸 알 수 있다.다만 가독성을 위해 count(*) 사용하는 것을 좋다고 한다. count(*) vs count(컬럼명) COUNT(*)는 레코드 갯수 전체를 카운트 COUNT(column_name) 컬럼이 null이 아닌 경우 레코드 갯수를 카운트","link":"/2023/05/10/230511-count/"},{"title":"[JS&#x2F;jQuery]정규표현식 숫자 소수둘째자리까지 적용하기","text":"input태그에 소수점 둘째자리까지만 받고 싶었다. input number 타입을 쓰고 step=”0.01”을 쓰는 방법도 있지만 input타입을 text로 써야하는 상황이라 그냥 정규식을 사용했다. 숫자 소수점 둘째짜리만 입력허용하는 경우1&lt;input type=\"text\" id=\"price\" val=\"0\" /&gt; 123456$(\"#price\").keyup(function(){ let price = $(this).val(); const regex = /(^/d+$)|(^d{1,}.\\d{0,2}$)/g; let resultPrice = price.replace(regex, \"\"); $(this).val(resultPrice);}); 숫자입력만 허용하는 경우1&lt;input type=\"text\" id=\"price\" val=\"0\" /&gt; 123456$(\"#price\").keyup(function(){ let price = $(this).val(); const regex = /[^0-9]/g; let resultPrice = price.replace(regex, \"\"); $(this).val(resultPrice);}); 이렇게 처리한다면 input태그에 숫자가 아닌 문자는 입력이 아예 안된다!","link":"/2023/05/11/230512regex-seconddigit-decimalpoint/"},{"title":"[JAVA] float, double 소수점 오류(부동소수점) 해결하기","text":"사용자가 기입한 확률을 DB에 넣고 싶었다.자세히 말하자면 사용자가 2라고 입력하면 백분율로 환산하여 DB에는 0.02로 넣고싶었다.그런데 입력된 DB 값을 보니 0.02가 아닌 0.019999999999999999…로 되어있었다.난 정확히 0.02를 넣고싶었는데 무엇이 잘못된걸까? 상황마리아DB를 사용하고 있고 Data Type은 float이다.VO는 Double형을 선언했다. 기존코드1234@Dataclass Testvo{ Double rate;} 문제 원인컴퓨터의 메모리는 한정적이라 실수의 소숫점 표현에 제한이 있을 수 밖에 없고 이로인해 소수점이하 계산 오차가 발생한다.이를 해결하기 위해서는 2가지 방법이 있다. int, long 정수형타입 치환 BigDecimal 클래스 사용 계속 소수점을 이용해야했기에 2번방법을 사용했다. BigDecimal 클래스 사용한 사칙연산 간단 예시1234567891011121314BigDecimal a = new BigDecimal(\"7\");BigDecimal a = new BigDecimal(\"3\");a.add(b);= 10a.subtract(b)= 4a.multiply(b);= 21a.divide(b);= 2.3333... 다른 사칙연산과 달리 나눗셈을 하기 위해서는 setScale()을 사용해야 정확한 소수점 연산이 가능하다. 123BigDecimal setScale(int newScale);BigDecimal setScale(int newScale, int roundingMode);BigDecimal setScale(int newScale, RoundingMode mode); 첫번째 파라미터는 표시하고자하는 소수점의 자릿수이고두번째 파라미터는 라운딩모드이고 라운딩모드 상수값은 아래와 같다. RoudingMode의 상수 설명 CELING 올림 FLOOR 내림 UP 양수일 때는 올림, 음수일 때는 내림 DOWN 양수일 때는 내림, 음수일 때는 올림 HALF_UP 5기준으로 반올림(5이상 올림, 5미만 버림) HALF_EVEN 반올림 자리의 값이 짝수면 HALF_DOWN, 홀수면 HALF_UP HALF_DOWN 6기준으로 반올림(6이상 올림, 6미만 버림) UNNECESSARY 나눗셈의 결과가 딱 떨어지는 수가 아니면, ArithmeticException발생 해결코드 Service 코드 12BigDecimal feeRate = new BigDecimal(vo.getRate());r.setSacle(6, RoudingMode.HALE_UP); 해결! 참고 Inpa Dev - 소수 정확히 계산하는 방법 작은거인 - 부동소수점의 문제점과 해결책 (BigDecimal의 필요성)","link":"/2023/05/21/230522bigdecimal/"},{"title":"블록체인구축프로젝트를 끝내며 내가 배운 것","text":"처음 해보는 대규모 파견 프로젝트! 파견도 처음이었고 블록체인, 앱, 웹, 운영등 다양한 분야의 개발자들과 협업하는 것도 처음이었다. 7개월간 모든 것이 신기하고 재미있었다.이번 프로젝트에서는 꼭 웹 백엔드를 맡고싶었는데 팀장님이 믿고 맡겨주셨다! 감사합니다 팀장님! 외부 API와 연동API를 개발하면서 다른 개발자가 써놓은 API명세서 읽고 이해하고 수정사항 요청하는 것도 재밌는 경험이었다.외부 API팀에서 RestAPI로 설계하셨다고했는데 몇몇 delete메서드에 body param을 넣으셔서 “Restful하지않은데 그냥 해주신 그대로 저도 연계API만들면 될까요?”하고 말씀드렸더니 고려해보시곤 path variable만 받는 걸로 수정해주셨다.뭔가 뿌듯~! 제대로 RestAPI를 이해하고 있구나 나자신 칭찬해! 대부분 나보다 연차가 많으신 시니어개발자분들과 협업하면서 많은 것을 배울 수 있었다. good example이 많았지만 bad example도 있다. 파견이 처음인 나에겐 여러모로 모든 해결과정들이 큰 도움이 되었다. 특히 업무를 대하는 태도와 갑사를 대하는 자세에 대해 많이 배웠다. 찐 어른들… 유연하게 대처하는 자세가 멋있었다. keep현재 만족하고 있는 부분과 계속해서 이어갔으면 하는 부분 레거시 코드를 분석하고 리팩토링하는 능력 레거시 프로젝트를 고도화하면서 블록체인시스템을 추가하는 프로젝트였기에 레거시 코드를 정확히 읽고 추가 및 수정해서 기존 기능은 문제 없이 사용할 수 있어야하는 것이 이번 작업의 핵심이었다. 처음 해보는 금융관련 도메인이었는데 평소 은행, 증권사 앱을 많이 사용해서 그런지 친숙하게 느껴졌다. 다양한 분야에 관심을 가지고 있어야겠다는 생각이 들었다. 다른 분야 개발자와 협업하는 능력 처음에는 용어 정리도 안되고 동일한 내용을 다른 명칭을 사용해서 소통에 혼선이 있었는데 시간을 내어 타 팀 개발자분들과 용어를 맞추고 공통코드 및 공통 용어 적립한 뒤에는 의사소통이 원활하게 이루어졌다. 프로젝트 전체를 보는 눈 요구사항 기능을 내 서비스에서만 생각하지않고 타팀 프로세스까지 고려할 수 있게 되었다. 예를 들어, 구매하기기능을 구현할때 내가 담당한 서비스 로직에서만 국한된게 아니라 타팀 서비스에선 해당 기능이 어떻게 구현되는 지까지 고려하여 내 서비스를 설계하다보니 처음에는 너무 헷갈렸는데 나중에는 자연스럽게 프로젝트 전체 흐름을 이해할 수 있게 되었고 아직 정의되지 않은 부분은 확장성있게 짤 수 있게 되었다. 확장성있는 공통함수 설계 능력 외부연계API를 만들면서 중복코드를 최대한 없애면서도 언제 생길지 모르는 갑사의 추가 요구사항에 대비해 확장성있게 공통함수로 정의하는데 각고의 노력을 기울였다. 노력이 빛을 봤는지 대부분의 추가, 수정사항에서도 공통함수를 건들이는 일 없이 잘 처리할 수 있었다.팀장님이 잠깐 해당 코드 리뷰도 해주셨는데 은근 튼튼하게 잘 짰다고 칭찬해주셨다. 전부 팀장님한테 배운건데도 칭찬해주셔서 뿌듯했다. 팀장님의 칭찬은 날 춤추게 해~💃 잘잘못따지기 전에 버그부터 해결하는 마인드 이번 프로젝트에서는 개발시간이 턱없이 부족했기에 시간단축이 생명이었는데 많은 개발자들이 한 리포에 커밋을 하다보니 잘못된 커밋이나 머지, 엘리야스실수등으로 인해 런타임오류가 발생해 원인을 찾느라 시간을 많이 쓰게 되었다. 이때 잘잘못을 따지고 싶은 마음을 굴뚝같았지만 잘잘못을 따지기보단 일단 빨리 해결부터 하자 마인드가 확고해졌다. 누가 잘못 커밋했는 지 파헤치기전에 일단 버그부터 잡았다. 이는 차장님의 영향이 컸다. 누군지 잡아낸다고 하시면서도 “지금 알아서 뭐하겠어~ 귀찮다~” 하며 버그부터 잡는 모습이 크게 와닿았기때문이다. 앞으로도 해결부터하는 개발자가 되어야지! json 다루는 능력 objectMapper와 Gson 통해서 자유자재로 json과 객체를 만들 수 있게 되었다. double과 float 변환시 부동소수점 오류 해당 문제가 있는지도 몰랐는데 이번에 금융프로젝트를 하면서 돈에 민감하다보니 자연스레 주의깊게 구분해서 쓰게 되었다. 관련 포스팅: float, double 소수점 오류(부동소수점) 해결하기 RestTemplate을 통한 외부API통신 자신감 외부API 통신을 위해 RestTemplate 자유자재로 사용하였고 제네릭 클래스 오류를 해결했다. 관련 포스팅1: 제네릭과 ParameterizedTypeReference 관련 포스팅2: ResponseEntity 코드리뷰 Problem개선이 필요하다고 생각되는 부분 다중 팝업 jsp화면 구현시 속도 개선 필요 백엔드 작업하다가 화면에 도움이 필요하여 jsp화면 몇개를 만들었다. 다중 팝업에 데이터를 제이쿼리로만 이동 시켜야해서 굉장히 재미없었다. 흥미를 못 느끼다보니 속도가 늦어졌고 결국 맡았던 3개 화면 중 1개를 다 끝내지 못해서 결국 차장님이 도와주셨고 나는 기능테스트에 투입되어 버그를 잡았다. 아무리 흥미가 없더라도 맡은 업무는 빠르게 쳐내야하는데 이 부분이 개선되어야한다. 파일서비스를 욕심내지 못한 것 기능테스트에 치여서 파일서비스 개발에 욕심을 내지 못했다. 잘 만들려면 한도끝도없이 잘 만들어 낼 수 있는 부분인다. File 클래스를 다뤄본 적이 거의 없어서 한 번은 꼭 필요한 부분이다. 객체는 어디까지 확장되어야할까? VO객체를 어디까지 확장해야하는 지가 제일 어려웠다. 기획이 수시로 변경되고 DB테이블에 컬럼들이 추가,수정,삭제되면서 서비스별로 나눠놨던 VO의 경계가 흐려졌다. 언제나 그렇듯 완벽하게 설계된 채 시작하는 프로젝트는 없으니까 유연하게 한 개의 VO에 다 담아야하는 지, 중간에 새로운 기준으로 다시 VO를 나눠야하는 지 아니면 속편하게 HashMap을 쓸 지 고민스러웠다. 한 번 바뀌면 화면 파라미터명부터 controller, xml까지 다 변경해야하니 여간 번거로운게 아니였다. 팀장님께 질문드리니 프로젝트에 맞게 설계하면 된다고 하셨는데 아직 많은 프로젝트를 만나보지 않아서 그런지 감이 잡히질 않는다. CUD 쿼리 전 set으로 코드 가독성 하락 CUD 쿼리 전 dto를 set하는 코드가 너무 길어져서 가독성이 떨어졌다. set하면서도 항상 바꾸고 싶었는데 어떻게 해야할 지 알 수가 없었다. TryProblem의 해결책이 될 수 있는 부분 다중팝업 jsp화면을 다루는 연습할 것: 테이블이 각 화면마다 있는 다중 팝업데이터 다루는 연습이 필요하다. 파일서비스 따로 만들어볼 것: 깃헙 리포생성해서 File객체로 오픈소스도움없이 파일 업로드/다운로드 서비스를 따로 만들어봐야겠다. 멀티파트써서 이미지랑 텍스트 다 되게끔 만들어봐야겠다. 설계에 관한 글과 책을 찾아 읽어볼 것 BeanUtils를 적극 활용할 것: 차장님 코드를 살펴보는데 Class BeanUtils을 이용하여 간편하게 set을 한 줄로 끝낸 코드를 보고 감탄했다. 사막에서 오아시스를 발견한 기분이었다. 내가 찾던 게 바로 이거! 역시 간절히 원하니까 보였다. 관련 포스팅: BeanUtils 관련 포스팅 제네릭과 ParameterizedTypeReference ResponseEntity 코드리뷰 List에서 중복값을 제외하는 방법2가지 String.valueOf() vs toString() 차이 알고쓰자 ClassCastException발생 Java.lang.Integer cannot be case to Java.lang.String 해결방법(ft. ChatGPT) MVC패턴과 MVP패턴 차이 MalformedJsonException 에러해결 no qualifying bean of type available: expected at least 1 bean which qualifies as autowire candidate 오류해결 Kafka(카프카)가 뭐길래(개념, 정의) deeplink가 뭐길래(개념, 정의) 팝업(모달)창에서 datepicker 적용 안되는 오류 해결법 Double/Float 변환시 ClassCastException오류 NaN 해결 float, double 소수점 오류(부동소수점) 해결하기","link":"/2023/06/06/230607prjtreview9/"},{"title":"[OS&#x2F;WINDOW]포트가 이미 사용중이라고 서버런이 안될때 포트 확인하는 방법","text":"오랜만에 프로젝트 셋팅하는데 다른 곳에서는 서버 사용하고 있지 않은데도 포트 80이 이미 사용중이라고 서버 런에 계속 실패했다.구글링하다가도 잘 모르겠어서 결국 쏭과장님에게 도움을 요청했고 1분만에 찾아주셨다.세상에 천재는 참 많다. 1-1 현재 사용중인 포트 확인하기Win(윈도우키) + R 후 열기 인풋란에 cmd입력해서 윈도우 명령프롬프트 창을 연다.아래 명령어를 입력하면 현재 사용중인 포트 전부를 확인할 수 있다. 1netstat -ano 1-2 현재 사용중인 포트 중 특정 포트만 확인하기아래 명령어를 입력하고 찾고싶은 포트번호를 입력하면 된다.예를 들어 8080이 들어간 모든 포트를 리스트업해보고싶다면 netstat -ano | findstr &quot;8080&quot;를 입력한다. 1234netstat -ano | findstr &quot;포트번호&quot;// 포트 8080 예시netstat -ano | findstr &quot;8080&quot; 검색결과가 없으면 사용중인 포트가 아니다. 포트상태 의미 LISTENING 열린 포트 CLOSED 연결이 닫힌 포트 ESTABLISHED 연결 중인 포트 포트상태가 LISTENING 이면 사용중인 포트이다. 사용중이라면 PID를 기억해놓는다. 2 작업관리자를 통해서 해당 포트를 사용중인 서비스 종료Ctrl + Shift + ESC를 통해 작업관리자를 연다.세부정보탭을 클릭하면 PID를 확인할 수 있다.동일한 PID 서비스를 찾은 뒤 우클릭해서 작업끝내기를 클릭하면 해결! 3 근본원인 찾기 -&gt; IIS일시적인 해결책말고 좀 더 근본적인 원인을 찾아봤다.문제의 원인은 IIS서비스가 자동실행이 되어 80포트를 사용하고 있었기에 톰캣이 80포트로 실행이 안됐었다.따라서 IIS를 종료해주었다. 4 IIS 종료하기Win(윈도우키) + R 후 열기 인풋란에 iis입력해서 IIS 관리자 창을 연다.왼쪽 연결 패널에서 내 컴퓨터를 더블클릭하면 애플리케이션 풀과 사이트가 하위목록으로 나온다.이 중 사이트를 클릭한 뒤 바인딩 열에 80포트가 있는 지 확인하고 해당 행을 클릭한 뒤 우클릭 혹은 오른쪽 작업패널에서 웹사이트관리 - 중지해주면 된다.해결~! 참고 송과장님 지식 구글링","link":"/2023/06/12/230613netstat/"},{"title":"[HEXO]링크 미리보기 이미지 변경하기(ft.Open Graph)","text":"내 블로그글의 링크를 복사하여 카카오톡에 공유하는데 미리보기 이미지가 hexo-theme-icarus 이었다.이 부분을 커스텀하고 싶어서 head 소스에서 찾아보니 Open Graph가 담당하고 있었다. 메타태그란?메타태그는 HEAD사이에 작성하는 웹사이트의 안내자이다.대부분의 포털사이트는 웹 사이트의 제목, 태그의 내용, 본문의 첫 100여 단어등을 검색한 후 사용자의 검색어와 비교해서 검색 결과를 나열해준다. 참고: meta태그, 내부링크, id와 name속성의 차이 개념글로 강추: 링크의 미리보기 제목, 설명, 이미지를 결정하는 open graph 태그 메타태그를 편하게 사용할 수 있도록 정의해놓은 프로토콜이 바로 Open Graph이다. Open GraphOpen Graph는 HTML 파일의 메타정보를 쉽게 표시하기 위해서 메타정보에 해당하는 제목, 종류, 이미지, url 등 다양한 요소들을 통일해서 사용할 수 있도록 정의해놓은 프로토콜이다. 오픈그래프 기본 태그 설명 og:title 사이트의 제목 og:type 사이트의 종류(참고링크: type에 들어갈 수 있는 값) og:image 사이트 링크 미리보기 이미지 og:url 사이트의 대표 url 헥소블로그에 적용하기미리보기 이미지를 하나로 고정하고 싶다면 아래와 같은 config.yml 파일에서 open_graph: 하위 image:를 찾은 뒤 그 옆에 /img/고정이미지이름.png를 입력하면 된다. config.yml123456789101112131415161718192021222324head: # URL or path to the website's icon favicon: /img/star.svg # Open Graph metadata # https://hexo.io/docs/helpers.html#open-graph open_graph: # Page title (og:title) (optional) # You should leave this blank for most of the time title: # Page type (og:type) (optional) # You should leave this blank for most of the time type: article # Page URL (og:url) (optional) # You should leave this blank for most of the time url: # Page cover (og:image) (optional) # You should leave this blank for most of the time image: /img/고정이미지이름.png # Site name (og:site_name) (optional) # You should leave this blank for most of the time site_name: # Page author (article:author) (optional) # You should leave this blank for most of the time author: sowon-dev 해결하지만 나는 썸네일이 있는 게시글은 썸네일이 미리보기 이미지로 보이고 썸네일이 없다면 내가 지정한 기본 이미지로 보이고 싶었다.따라서 config.yml 파일의 open_graph: 하위 image: 를 다시 공백으로 한 뒤 123456789101112131415161718192021222324head: # URL or path to the website's icon favicon: /img/star.svg # Open Graph metadata # https://hexo.io/docs/helpers.html#open-graph open_graph: # Page title (og:title) (optional) # You should leave this blank for most of the time title: # Page type (og:type) (optional) # You should leave this blank for most of the time type: article # Page URL (og:url) (optional) # You should leave this blank for most of the time url: # Page cover (og:image) (optional) # You should leave this blank for most of the time image: # Site name (og:site_name) (optional) # You should leave this blank for most of the time site_name: # Page author (article:author) (optional) # You should leave this blank for most of the time author: sowon-dev 아래 경로의 og_image.png 찾은 뒤 내가 원하는 이미지로 바꿔치기 해주면 해결! 경로: public/img/og_image.png 카카오톡 미리보기에는 여전히 반영이 안된다면?카카오톡에서 만든 공유 디버거에 해당 글 주소를 입력하면 OG(Open Graph) 프로토콜을 통해 파싱하고 스크랩 결과도 친절하게 알려준다.여기서 캐시 초기화를 누르면 카카오톡 미리보기가 반영된다! 공유 디버거 카카오 천재들….덕분에 넘 편하다 참고 hexo 공식문서 open-graph The Open Graph protocol 공식문서","link":"/2023/06/13/230614opengrap-img/"},{"title":"[HEXO]링크공유하기 버튼을 헥소블로그에 커스텀하게 적용하기(ft.AddToAny)","text":"Hexo를 이용해서 간편하게 개발블로그를 운영하고 있다.블로그의 좋은 글을 편하게 공유해갈 수 있는 링크 공유하기 버튼을 만들고 싶었다. Hexo에선 이미 다양한 플러그인을 제공한다.내가 이용중인 Icarus 테마에서는 아래와 같이 총 5가지 공유 플러그인을 제공한다. 다른 플러그인을 원하면 설치해서 사용하면 된다, AddThis AddToAny Baidu Share Share.js ShareThis 이 5가지 중 나는 AddToAny의 디자인이 마음에 들었기에 이걸 선택했다.나머지 4가지 공유 플러그인에 대한 자세한 내용은 Icarus User Guide - Share Buttons에서 확인할 수 있다. 적용하기아래 경로의 config파일에서 share를 검색한 뒤 AddToAny를 기입해준다. 경로: ../themes/hexo-theme-icarus/_config.yml 123456# Share plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share/share: type: addtoany #원하는 공유플러그인 기입 # URL to the ShareThis share plugin script install_url: '' 이렇게 설정만 하더라도 바로 공유버튼이 생기는 걸 알 수 있다.디폴트대로 이용해도 되지만 블로그의 재미는 커스텀 아니겠는 가.커스텀하는 방법도 AddToAny의 공식문서를 따라하면 금방이다. addtoany.jsx 생성하기커스텀하기위해서는 아래 share폴더 하위에 addtoany.jsx 파일을 생성해야한다. 경로: ../themes/hexo-theme-icarus/layout/share/addtoany.jsx 그리고 생성한 파일에 커스텀한 코드를 입력해준다.커스텀 코드는 AddToAny의 공식문서를 참고하면 된다. 이건 참고용 내 커스텀 코드! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * AddToAny share buttons JSX component. * @module view/share/addtoany */const { Component, Fragment } = require('inferno');const { cacheComponent } = require('hexo-component-inferno/lib/util/cache');/** * AddToAny share buttons JSX component. * * @see https://www.addtoany.com/buttons/ * @example * &lt;AddToAny /&gt; */class AddToAny extends Component { render() { return &lt;Fragment&gt; &lt;div class=\"a2a_kit a2a_kit_size_32 a2a_default_style\" style=\"display:flex; justify-content:center;\" data-a2a-icon-color=\"lightseagreen\"&gt; &lt;a class=\"a2a_dd\" href=\"https://www.addtoany.com/share\"&gt;&lt;/a&gt; &lt;a class=\"a2a_button_copy_link\"&gt;&lt;/a&gt; &lt;a class=\"a2a_button_facebook\"&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var a2a_config = a2a_config || {}; a2a_config.locale = \"ko\"; a2a_config.num_services = 2; &lt;/script&gt; &lt;script async src=\"https://static.addtoany.com/menu/page.js\"&gt;&lt;/script&gt; &lt;/Fragment&gt;; }}/** * Cacheable AddToAny share buttons JSX component. * &lt;p&gt; * This class is supposed to be used in combination with the &lt;code&gt;locals&lt;/code&gt; hexo filter * ({@link module:hexo/filter/locals}). * * @see module:util/cache.cacheComponent * @example * &lt;AddToAny.Cacheable /&gt; */AddToAny.Cacheable = cacheComponent(AddToAny, 'share.addtoany', props =&gt; { return {};});module.exports = AddToAny; 적용 끝!","link":"/2023/06/19/230620addtoany/"},{"title":"아파치와 톰캣 분리한다고요?(ft. Web Service Architecture 차이)","text":"오늘 커피챗에서 이번 프로젝트 서버 설계에 대한 이야기가 나왔다. 아파치와 톰캣을 분리한다고 하셨다. 가볍게 스쳐 지나간 주제지만 아파치 vs 톰캣 포스팅이 떠오르면서 분리하면 어떻게 서버가 도는 건지 궁금해졌다. Web Service Architecture 종류 Client -&gt; WAS -&gt; DB Client -&gt; Web Server -&gt; DB Client -&gt; Web Server -&gt; WAS -&gt; DB 가장 많이 사용하는건 1번 WAS이다. 왜냐하면 WAS가 Web Server의 기능을 대부분 수행할 수 있기때문이다.그럼에도 불구하고 이번 프로젝트에서 3번을 사용한다고 한다. 왜 Web Server와 WAS를 분리하는 걸까? 보안강화: WAS는 DB와 바로 연결되기때문에 WEB SERVER와 WAS를 분리하여 WEB SERVER를 외부서버에 두고 WAS와 DB서버를 내부 서버에 두면 보안을 강화할 수 있다. 서버부하방지: WAS는 DB조회나 서비스로직을 처리하느라 항상 바쁘기에 단순한 정적페이지는 WEB SERVER를 이용하면 빠르게 사용자에게 보여주고 WAS 부하를 방지할 수 있다. 로드밸런싱을 위한 여러 대 WAS 연결 가능 여러 웹 어플리케이션 서비스 가능: 예를들어 PHP APPLICATION과 JAVA APPLICATION 함께 사용 가능하다. 이번 프로젝트는 사이트가 많은 편인데 정적 페이지도 많으므로 서버 부하가 예상되기에 WEB SERVER를 WAS앞에 두고 DB나 서비스로직이 필요할때마다 WAS를 호출하는 형태로 사용하기 위해 분리한다고 하셨다.아하~ 유레카😎 웹서버(WEB SERVER) VS 웹어플리케이션서버(WAS, Web Application Server)기본적인 차이점이다. 웹서버 : DB사용 불가능 클라이언트측 정적데이터 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠(.html .jpeg .css 등)를 제공하는 컴퓨터 프로그램 Web Server의 예 : Apache Server, Nginx, IIS(Windows 전용 Web 서버) 등 WAS : DB사용 가능 서버측 동적데이터 사용 DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server WAS의 예 : Ex) Tomcat, JBoss, Jeus, Web Sphere 등 참고 송과장님 지식 웹서버(WEB SERVER) VS 웹어플리케이션서버(WAS, Web Application Server) 아파치 vs 톰캣 같은 거 아냐? 차이점 HeeJeong Kwon - Web Server와 WAS의 차이와 웹 서비스 구조","link":"/2023/06/25/230626webserver-vs-was/"},{"title":"[jQuery] jsTree 검색추가하기","text":"jsTree는 제이쿼리 플러그인으로 손쉽게 트리구조를 만들 수 있는 라이브러리이다. jsTree 사용법은 매우 간단한 편이라 jstree 공식 docs를 참고하면 된다. 검색기능 추가plugins부분에 search를 추가하고 검색창에 keyup이벤트로 search()를 호출하면 된다.show_only_matches 속성은 디폴트가 false인데 나는 true로 하고싶어서 true로 주었다. 해당 속성은 이름에도 알 수 있듯 검색시 매치되는 노드만 보여준다. 1234567891011121314151617181920var $testTree = $('#testTree');$testTree.jstree({ 'core' : { 'data' : data, \"themes\":{ \"icons\":false } }, \"search\": { \"show_only_matches\": true, \"show_only_matches_children\": true }, \"plugins\" : [\"search\"]});$('#search_input').keyup(debounce(function () { var v = $('#search_input').val().trim(); $testTree.jstree(true).search(v);}, 50)); EasyPeasyLemon Squeezy🍋","link":"/2023/06/26/230627jstree/"},{"title":"[JAVA&#x2F;Spring]BeanUtils","text":"이렇게 좋은 유틸이 있었다니 왜 몰랐지?!클래스들을 서로 복사하는 작업을 해야하는데 그때마다 엄청난 set때문에 가독성도 떨어지고 코드도 길어지고 참 마음에 안들었다.차장님이 쓴 코드를 읽을 기회가 있었는데 BeanUtil를 이용해서 한 줄로 간결하게 짜여진 코드를 보고 감동했다! 유레카! 내가 찾던 것이 바로 이거야!그래서 BeanUtils에 대해 공부해봤다. Class BeanUtils스프링에서 기본으로 제공해주는 메소드로서 객체를 쉽고 간결하게 복사할 수 있다. 너무너무 편하다! 패키지: org.springframework.beans 기본형123copyProperties(Object source, Object target)source - 원본 객체target - 복사 객체 source에는 setter메소드 필수 target에는 getter메소드 필수 동일한 필드명만 복사가 된다. 예시이제 예시를 살펴보자아래처럼 2개의 객체가 있다. 교수객체 중 특정 객체는 면접관객체로 복사해야한다고 가정해보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@SpringBootApplicationpublic class SimpleTestApplication { @Data @AllArgsConstructor static class Professor { private String name; private String major; private String hp; private int professorId; } @Data static class Interviewer { private String name; private String major; private String hp; private int interviewerId; } public static void main(String[] args) { SpringApplication.run(SimpleTestApplication.class, args); Professor p1 = new Professor(\"김노동\", \"건축학\", \"010-1234-1234\", 111); System.out.println(p1.toString()); //결과: Professor(name=김노동, major=건축학, hp=010-1234-1234, professorId=111) // 1. Setter 사용하기 Interviewer a = new Interviewer(); a.setName(p1.getName()); a.setMajor(p1.getMajor()); a.setHp(p1.getHp()); System.out.println(a.toString()); //결과: Interviewer(name=김노동, major=건축학, hp=010-1234-1234, interviewerId=0) // 2. BeanUtils.copyProperties()사용: 동일한 필드 전체 복사 Interviewer b = new Interviewer(); BeanUtils.copyProperties(p1, b); System.out.println(b.toString()); //결과: Interviewer(name=김노동, major=건축학, hp=010-1234-1234, interviewerId=0) // 3. BeanUtils.copyProperties()사용: p1의 name필드를 제외한 채 c로 복사 Interviewer c = new Interviewer(); BeanUtils.copyProperties(p1, c, \"name\"); //name속성은 무시 System.out.println(c.toString()); //결과: Interviewer(name=null, major=건축학, hp=010-1234-1234, interviewerId=0) }} 1번 Setter를 이용하는 방법은 직관적이나 코드가 길어져서 필드가 많을 경우 가독성이 매우 떨어진다.이땐 2번처럼 BeanUtils.copyProperties()을 사용하면 동일한 필드명은 복사가 된다!만약 특정 필드를 빼고 싶다면 3번처럼 ignoreProperties 를 사용하면 된다. 참고 docs.spring.io/spring-framework","link":"/2023/06/20/230621beanutils/"},{"title":"[구글애드센스]수익손실위험 ads.txt파일 문제를 해결해야합니다.(ft.Hexo헥소블로그)","text":"오랜만에 들어간 애드센스에서 수익 손실 위험 - 수익에 심각한 영향을 미치지 않도록 사이트에서 발견된 ads.txt 파일 문제를 해결해야 합니다. 경고메시지를 확인했다.지금 해결하기를 클릭해봐도 아무런 반응이 없었다. 자세히 알아보기를 클릭했더니 안내 페이지가 나왔다.안내페이지 그대로 이행했다. 완벽히 해결 된 후 글을 쓰고 싶어서 며칠을 기다렸다가 드디어 오늘에서야 포스팅을 할 수 있게 되었다! 타임라인 230630 문제 발견 및 ads.txt파일 추가 후 배포 주말이라 체크하는 거 깜박함… 230703 문제 해결 완료 구글측 설명으로는 72시간이면 반영이 된다고 한다.72시간이 걸리는 이유는 구글봇이 돌아다니면서 찾아야한다고! 문제발견 노란 동그라미에서 알 수 있듯 Ads.txt상태가 찾을 수 없음 이기에 경고메시지가 보였던 것이었다. 문제해결지금 해결하기를 클릭해봐도 아무런 반응이 없었기에 자세히 알아보기를 클릭했다. 귀찮지않을까 했는데 생각보다 간단하고 참 쉬웠다. 해결방법 root경로에 ads.txt파일 신규생성 신규 파일에 아래 코드 입력 1google.com, pub-본인게시자코드, DIRECT, f08c47fec0942fa0 잘 되었는지 블로그뒤에 /ads.txt로 2번에서 작성한 코드가 리턴되는 지 확인하기 끝! 해결타임라인에서 말한 그대로 230630에 최상위 경로에 ads.txt 파일명으로 신규 파일을 생성했고 게시자코드를 확인하여 기입한 후 배포를 진행했다.그리고 블로그 https://sowon-dev.github.io/ads.txt 를 브라우저 주소창에 입력하여 정상적으로 호출되는 지 확인했다. 그리고 230703 오늘에서야 구글애드센스에 들어가봤는데 아래처럼 Ads.txt상태가 승인됨으로 변경되었고 더이상 경고메시지도 안나온다!해결!","link":"/2023/07/02/230703ads/"},{"title":"[바닐라JS&#x2F;Pure JS]iframe 내 태그에 접근하고 싶을때(선택자)","text":"자주 보는 사이트 중 table의 첫번째 tr을 숨기고 싶어서 스크립트 코드를 만들었다. 해당 사이트 HTML 구성이 어떻게 되어있는지 몰라서 차근차근 뜯어보았는데iframe 하위에 iframe을 또 부르고 그 하위에 table이 있고 그 하위에 내가 숨기고싶은 tr이 있는 구조였다. 코드12345678910111213141516&lt;body&gt; &lt;iframe id=\"sub2\"&gt; &lt;iframe id=\"ifrm\"&gt; &lt;table id=\"tableList\"&gt; &lt;thead&gt; // 중략 &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;첫번째 - 숨김처리 하고싶다&lt;/tr&gt; &lt;tr&gt;두번째&lt;/tr&gt; &lt;tr&gt;세번째&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/iframe&gt; &lt;/iframe&gt;&lt;/body&gt; HTML구조를 최대한 간략하게 작성해보았고 스크립트는 아래와 같이 만들어봤다. 12// 첫번째 tr 숨기기document.getElementById(\"sub2\").contentWindow.document.getElementById(\"ifrm\").contentWindow.document.getElementById(\"tableList\").querySelector(\"tbody &gt; tr\").style.display = \"none\"; 개선 필요점크롬 브라우저에서 테스트하면 가끔 TypeError: Cannot read properties of null (reading 'contentWindow') 에러가 발생한다. 어떻게 해결해야하는지 모르겠다. 이 부분 개선필요하다. 팀장님 꿀팁🍯크롬브라우저에선 개발자도구를 통해 1초만에 js선택자코드를 복사할수있다.F12에서 요소탭의 HTML코드에서 원하는 HTML태그를 우클릭한 후 복사 &gt; JS경로 복사를 선택하면 자동으로 js선택자코드가 클립보드에 복사된다! 그래서 복붙만 해주면 간편하게 이용하면 끝! 12// JS경로 복사를 활용한 간단 버전 document.querySelector(\"#tableList &gt; tbody &gt; tr:nth-child(1)\").style.display = \"none\"; 잘 적용은 되나 가끔 TypeError: Cannot read properties of null (reading 'contentWindow') 에러가 여전히 발생한다. 어떻게 해결할수있을까…","link":"/2023/07/08/230709iframe-contentwindow/"},{"title":"[톰캣Tomcat]SSL이 뭐길래(ft.HTTPS와 비교, 차이점)","text":"톰캣에서 SSL을 적용했는데 개발 중에는 적용된 HTTPS를 없애고 HTTP로만 통신하고싶어서 server.xml에서 포트를 변경했다. 코드SSL을 미적용하기 위해서 redirectPort포트를 443에서 8443으로 변경했다. server.xml12345// SSL적용&lt;Connector connectionTimeout=\"20000\" port=\"80\" protocol=\"HTTP/1.1\" redirectPort=\"443\" /&gt;// SSL미적용&lt;Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" /&gt; 해결은 간단하게 되었지만 SSL이 단순히 인증서라고 생각하고있었는데 정확히 무엇인지 알고싶어졌다. 기본부터 하자! HTTP VS HTTPSHTTP는 Hypertext Transfer Protocol의 약자이며 하이퍼텍스트란 링크와 링크로 이루어진 텍스트를 의미하며 그 중 대표적인 것이 HTML이다.즉, Hypertext 인 HTML을 전송하기 위한 통신규약을 의미한다.HTTPS에서 마지막의 S는 Over Secure Socket Layer의 약자로 보안이 강화된 HTTP이다. HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고 받는 메시지를 빼앗기가 쉽다.예를들어 로그인을 위해서 서버로 비밀번호를 전송하거나, 또는 중요한 기밀 문서를 열람하는 과정에서 악의적인 감청이나 데이터의 변조등이 일어날 수 있다. 이를 보안한 것이 HTTPS다.이 블로그도 보안(Secure)된 HTML인 https://sowon-dev.github.io/이다. HTTPS VS SSLSSL는 Secure Socket Layer의 약어로 암호화 소켓층이다.SSL이라는 통신 방법 위에서 동작하는 서비스 중에 하나가 HTTP이다. 그리고 HTTP가 SSL을 이용하면 HTTPS가 된다. SSL VS TLS같은 말!TLS 1.0은 SSL 3.0을 따른다. 참고 https://www.geeksforgeeks.org/difference-between-http-and-https/ 생활코딩 - HTTPS와 SSL 인증서","link":"/2023/07/12/230713-server-redirectport443/"},{"title":"[JavaScript&#x2F;jQuery]제이쿼리 선택자(Selector) 비교","text":"VanillaJS와 jQuery는 최대 10배 속도차이가 발생난다고 한다. 그래서 이번에 손에 익힐겸 jQuery보다 VanillaJS를 사용하려고 노력해봤다. 제일 헷갈리는 부분은 선택자부분이었다. 선택자(Selector) JavaScript jQuery document.getElementById(아이디명) $(#아이디명) document.getElementsByClassName(클래스명) $(.클래스명) document.getElementsByTagName(태그명) $(태그명) querySelector: 매칭된 첫번째 element 반환, 조회값 없을땐 null 반환 querySelectorAll: 매칭된 모든 element를 NodeList로 반환, 조회값 없을땐 [] 반환 코드12345678910111213141516171819202122// 모든 요소$(\"*\")document.querySelectorAll(\"*\")// ID명이 password인 요소 선택 $(\"#password\")document.querySelector(\"#password\")document.getElementById('password')window['password']// Class 명이 'btn'인 요소 선택$(\".btn\")document.querySelectorAll(\".btn\")document.getElementsByClassName('btn')// attribute요소 선택$('a[target=_blank]')document.querySelectorAll('a[target=_blank]')// input의 value값이 'address'인 요소 선택$(\"input[value='address']\")document.querySelector(\"input[value='address']\") 참고 You-Dont-Need-jQuery 깃헙 리포","link":"/2023/07/16/230717js-jquery/"},{"title":"[MySQL&#x2F;MariaDB] ON DUPLICATE KEY UPDATE","text":"SQL 쿼리 작성시 PK키가 중복되는 경우 지정한 데이터만 INSERT가 아닌 UPDATE 시킬 수는 없을까?ON DUPLICATE KEY UPDATE를 사용하면 된다. ON DUPLICATE KEY UPDATEINSERT시 PK나 UNIQUE KEY가 중복인 경우 원하는 컬럼만 UPDATE하고 중복되지 않은 경우에는 INSERT된다. 예시코드123456789101112-- 테이블생성 CREATE TABLE tb_user ( user_id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY , name VARCHAR(20) NOT NULL , mobile VARCHAR(20) NOT NULL , address VARCHAR(50) DEFAULT NULL , reg_dt DATE() , update_dt DATE() ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 제약조건 ALTER TABLE tb_user ADD UNIQUE (name, mobile); 테이블 tb_user에서 pk는 user_id이고 AUTO_INCREMENT이고 mobile이 UNIQUE KEY인 경우를 예시로 해보자.이름과 휴대전화번호가 쌍으로 없는 경우 INSERT하고, 존재하는 경우 주소만 UPDATE하는 쿼리는 아래와 같다. 1234567891011121314INSERT INTO tb_user( name, mobile, address, reg_dt) VALUES ( '김테스트', '010-1234-1234, '서울 강남구', now()) ON DUPLICATE KEY UPDATE address = #{address}, update_dt = now()","link":"/2023/08/01/230802mysql-on-duplicate-key-update/"},{"title":"org.springframework.beans.factory.BeanCreationException: Error creating bean with name 해결 의외의 방법","text":"잘 되던 maven프로젝트가 refresh만 하면 BeanCreationException을 내며 서버런에 실패했다. 임시방편임시방편으로 BeanCreationException이 나는 경우 Project &gt; Clean 후 서버 재시작하곤 했는데 여간 귀찮고 시간이 많이 드는 일이 아닐 수 없다. 의외의 해결방법성과장님이 JRE 부분을 확인해주셨다.Window &gt; Preferences &gt; Java &gt; Installed JREs에서 경로를 jdk로 잡았었는데 그걸 jdk 하위 jre폴더로 잡아보라고 해주셨다.그리고 놀랍게도 해결!원인은 정확히는 모르겠으나… 일주일 내내 구글링해도해도 절대 해결되지않던 이놈의 BeanCreationException 오류를 해결했다! JRE VS JDKJDK가 JRE를 포함하고 있다. JDK(Java Development Kit)란? JDK는 자바 개발키트(Java Development Kit)의 약자 JDK안에는 개발 시 필요한 라이브러리들과 javac, javadoc 등의 개발 도구들을 포함되어 있다. 개발을 하려면 당연히 실행도 시켜줘야 하기 때문에 JRE (Java Runtime Environment)도 함께 포함되어 있습니다. JRE(Java Runtime Environment)란? JRE는 자바 실행 환경(Java Runtime Environment)의 약자 자바로 만들어진 프로그램을 실행시키는데 필요한 라이브러리들과 각종 API, 그리고 자바 가상 머신 (JVM)이 포함 개발(쓰기)은 안되고 실행(읽기)만 된다 # 참고 - 성과장님 지식 - [자바 JDK, JRE의 차이점(JDK란? JRE란?)](https://coding-factory.tistory.com/826)","link":"/2023/08/10/230811jre-jdk/"},{"title":"[MySQL&#x2F;MariaDB] 트리메뉴 WITH RECURSIVE로 정렬하기","text":"트리구조의 메뉴를 select하는 과정에서 1뎁스가 10개가 넘어가니 문제가 발생했다. 문제 기존코드123456789101112131415161718192021222324252627282930SELECT SITEMENUID, PARENTID, SEQ, FULLSEQFROM ( SELECT '1' AS DEPTH , '00_00_00' AS FULLSEQ , A1.PARENTID , A1.SITEMENUID , A1.SEQ FROM tb_site_menu A1 UNION ALL SELECT '2' AS DEPTH , CONCAT(A2.SEQ,'_',A1.SEQ) AS FULLSEQ , A2.PARENTID , A2.SITEMENUID , A2.SEQ FROM tb_site_menu A1 INNER JOIN tb_site_menu A2 ON A1.SITEMENUID = A2.PARENTID UNION ALL SELECT '3' AS DEPTH , CONCAT(A2.SEQ,'_',A1.SEQ,'_',A3.SEQ) AS FULLSEQ , A3.PARENTID , A3.SITEMENUID , A3.SEQ FROM tb_site_menu A1 INNER JOIN tb_site_menu A2 ON A1.SITEMENUID = A2.PARENTID INNER JOIN tb_site_menu A3 ON A2.SITEMENUID = A3.PARENTID ) TBLORDER BY FULLSEQ; 1번 다음에 2번이 와야하는데 VARCHAR라서 1다음에 10이 와버렸다. 콘솔1234567891011&lt;1뎁스-2뎁스-3뎁스&gt;00_00_001_011_02_011_02_021_0310_0110_022_01_012_01_022_02 LPAD로 해결팀장님이 자리수를 맞추면 해결되는 문제라고 알려주셨다. LPAD추가된 코드 1234567891011121314151617181920212223242526272829303132SELECT SITEMENUID, PARENTID, SEQ, FULLSEQFROM ( SELECT '1' AS DEPTH , '00_00_00' AS FULLSEQ , A1.PARENTID , A1.SITEMENUID , A1.SEQ FROM tb_site_menu A1 UNION ALL SELECT '2' AS DEPTH -- , CONCAT(A2.SEQ,'_',A1.SEQ) AS FULLSEQ , CONCAT(LPAD(A2.SEQ, 2 , '0'),'_',LPAD(A1.SEQ, 2 , '0')) AS FULLSEQ , A2.PARENTID , A2.SITEMENUID , A2.SEQ FROM tb_site_menu A1 INNER JOIN tb_site_menu A2 ON A1.SITEMENUID = A2.PARENTID UNION ALL SELECT '3' AS DEPTH -- , CONCAT(A2.SEQ,'_',A1.SEQ,'_',A3.SEQ) AS FULLSEQ , CONCAT(LPAD(A2.SEQ, 2 , '0'),'_',LPAD(A1.SEQ, 2 , '0'),'_',LPAD(A3.SEQ, 2 , '0')) AS FULLSEQ , A3.PARENTID , A3.SITEMENUID , A3.SEQ FROM tb_site_menu A1 INNER JOIN tb_site_menu A2 ON A1.SITEMENUID = A2.PARENTID INNER JOIN tb_site_menu A3 ON A2.SITEMENUID = A3.PARENTID ) TBLORDER BY FULLSEQ; 콘솔 1234567891011&lt;1뎁스-2뎁스-3뎁스&gt;00_00_0001_0101_02_0101_02_0201_0302_01_0102_01_0202_0210_0110_02 원하는대로 잘 출력!!! 더나은 방법: with recursive팀장님께서 LPAD 대신 with recursive를 써서 쿼리를 더 간단하게 만들수있다고 알려주셨다. 123456789101112131415161718with recursive menuTree as ( SELECT 1 AS DEPTH , cast('00' as VARCHAR(256)) AS FULLSEQ , A1.PARENTID , A1.SITEMENUID , A1.SEQ FROM tb_site_menu A1 UNION ALL SELECT parent.DEPTH + 1 AS DEPTH , CONCAT(parent.SEQ, '-', LPAD(child.SEQ, 2, '0')) AS FULLSEQ , child.PARENTID , child.SITEMENUID , child.SEQ FROM menuTree parent JOIN tb_site_menu child ON parent.SITEMENUID = child.PARENTID)SELECT * FROM menuTree ORDER BY FULLSEQ; 와 역시 팀장님 최고다… 참고 팀장님 지식 WITH RECURSIVE 초간단 설명","link":"/2023/08/21/230822withrecursive-treemenu/"},{"title":"[ajax]분명 success인데 왜 계속 error로 가는걸까?","text":"DB저장도 잘되고 controller를 디버그에서 확인해보니 result값도 정상적으로 잘 작동되었는데 화면에서만 오면 ajax에서 success를 타지않고 error로 빠져버렸다.왜일까? 문제와 원인 controller 코드 123456789101112131415161718192021@PostMapping(value = \"/admin/new\")public BooleanAndMessageResult save(HttpServletRequest request, RedirectAttributes redirectAttributes, @RequestBody List&lt;Admin&gt; list) { BooleanAndMessageResult result = new BooleanAndMessageResult(); Site site = (Site) request.getAttribute(\"site\"); for (Admin a : list) { a.setSiteid(site.getSiteid()); } result.setResult(true); result.setMessage(\"정상적으로 등록 되었습니다.\"); try { adminService.insertAdminList(list); } catch (Exception e) { result.setResult(false); result.setMessage(\"등록에 실패 하였습니다.\"); LOGGER.error(\"error : \", e); } return result;} js코드 123456789101112131415161718192021222324252627282930$.confirm({ theme: 'supervan', title: '운영정보관리 저장', content: '저장하시겠습니까?', confirmButton: '예', cancelButton: '아니오', confirm: function(){ $.ajax({ type: \"POST\" , url: \"/admin/new\" , contentType : \"application/json; charset:utf-8\" , data: JSON.stringify(jList) , dataType: 'json' , success: function(data){ if(data.result == true){ alert(\"저장에 성공했습니다.\"); setTimeout(function() {location.reload(true);}, 2000); } else if(data.result == false){ alert(data.message); return false; } } , error: function(request,status,error){ alert(\"에러가 발생했습니다. 새로고침합니다.\"); location.href = \"/admin/infosetting\"; } }); }, cancel: function(){}}); 위 코드는 한 가지 잘못된 점이 있다. 원인: @ResponseBody 누락@ResponseBody 어노테이션을 이용하면 자바 객체를 HTTP 응답 분문의 객체로 변환하여 클라이언트에 전송 할 수 있다.body에 리턴값을 담아주지 않았기때문에 ajax의 success가 아닌 error로 빠진것이다. 해결코드 controller코드 12345678910111213141516171819202122@PostMapping(value = \"/admin/new\")@ResponseBody // 까먹자말고 추가public BooleanAndMessageResult save(HttpServletRequest request, RedirectAttributes redirectAttributes, @RequestBody List&lt;Admin&gt; list) { BooleanAndMessageResult result = new BooleanAndMessageResult(); Site site = (Site) request.getAttribute(\"site\"); for (Admin a : list) { a.setSiteid(site.getSiteid()); } result.setResult(true); result.setMessage(\"정상적으로 등록 되었습니다.\"); try { adminService.insertAdminList(list); } catch (Exception e) { result.setResult(false); result.setMessage(\"등록에 실패 하였습니다.\"); LOGGER.error(\"error : \", e); } return result;} js코드 123456789101112131415161718192021222324252627282930$.confirm({ theme: 'supervan', title: '운영정보관리 저장', content: '저장하시겠습니까?', confirmButton: '예', cancelButton: '아니오', confirm: function(){ $.ajax({ type: \"POST\" , url: \"/admin/new\" , contentType : \"application/json; charset:utf-8\" , data: JSON.stringify(jList) , dataType: 'json' , success: function(data){ if(data.result == true){ alert(\"저장에 성공했습니다.\"); setTimeout(function() {location.reload(true);}, 2000); } else if(data.result == false){ alert(data.message); return false; } } , error: function(request,status,error){ alert(\"에러가 발생했습니다. 새로고침합니다.\"); location.href = \"/admin/infosetting\"; } }); }, cancel: function(){}}); 그래도 해결이 안된다면?ajax에서 잘못된 dataType설정했을 가능성이 높다!jQuery ajax의 setting 중 dataType은 response를 어떤 데이터 형식으로 파싱할 지를 설정하는 것이다.dataType: 'json'으르 설정했기에 리턴타입을 json으로 주어야하는데 단순 String타입으로 준건 아닌지 체크해보자.데이터형식이 맞지않으면 ajax의 success가 아닌 error로 빠진다.","link":"/2023/09/10/230911ajax-sucess-error/"},{"title":"[HTML]IMG태그 기본이미지설정(DEFAULT IMG, ONERROR속성) 에러 해결","text":"이미지태그사용시 src경로에 이미지가 없다면 기본 이미지를 설정하고 싶었다.찾아보니 onerror 속성을 찾아서 손쉽게 처리할 수 있었다. 그런데 여전히 디폴트이미지를 못 불러오는 에러가 발생했다. 기존코드1&lt;img src=\"/resources/custom/images/main_${idx}.png\" onerror=\"/resources/custom/images/main_default.png\" alt=\"${name}이미지\"&gt; 잘했다고 생각했으나 여전히 이미지가 엑박이 떴다.해당 경로에 이미지도 제대로 있는 걸 확인했는데 왜 onerror에서 설정한 경로의 기본이미지가 보이지않을까? 해결코드1&lt;img src=\"/resources/custom/images/main_${idx}.png\" onerror=\"this.src='/resources/custom/images/main_default.png'\" alt=\"${name} 아이콘\"&gt; onerror는 함수가 들어가는 곳으로 src속성과는 다르다. 따라서 그냥 경로를 입력하는 것이 아니라 함수로 입력해야한다.따라서 this.src=를 추가하여 함수로 디폴트png가 있는 src로 연결하도록 바꿔주니 원하는대로 정상작동했다. 해결! 참고 onerror Event","link":"/2023/10/15/231016imgtag-onerrer/"},{"title":"[Moment.js] isSame 오늘날짜와 비교가 안되는 이유","text":"달력을 만들면서 오늘날짜와 일치하는 셀에는 음영을 넣고 싶었다.여기서 잠깐🤚모먼트js로 달력을 만들고싶다면 포스팅:: 동적 달력(캘린더)만들기을 참조하면 된다. 기존코드이번달 1일부터 for문을 돌면서 현재 날짜와 일치하면 class today를 추가해주는 코드를 구현했다. 123456789101112131415const today = moment();const firstDayOfMonth = moment({today.year(), today.month() + 1}).startOf('month');let currentDate = firstDayOfMonth.clone().startOf('week'); //달력의 현재 셀 날짜for (let i = 0; i &lt; 7; i++) { let cell = $(\"&lt;td&gt;&lt;/td&gt;\"); // 오늘일자인 경우 class 추가하기 if(currentDate.isSame(today){ cell.addClass(\"today\"); } tableRow.append(cell); currentDate.add(1, 'days');} 해결코드isSame은 연월일뿐만 아니라 시분초도 같이 확인한 후 같은지 아닌지 판단한다.따라서 포맷도 YYYY-MM-DD로 맞춰주면서 시분초를 00으로 바꿔주는 startOf('day')를 사용하면 해결된다. 1234// 오늘일자인 경우 class 추가하기if(moment(currentDate.startOf('day'), \"YYYY-MM-DD\").isSame(moment(today.startOf('day'), \"YYYY-MM-DD\"))){ cell.addClass(\"today\");}","link":"/2023/10/17/231018momentjs-issame/"},{"title":"[WIP&#x2F;Moment.js] moment String을 Controller에서 LocalDateTime으로 받기","text":"moment으로 startDate를 포맷하여 startDate.format(&quot;YYYY-MM-DDTHH:mm:ss&quot;) ajax를 이용해 컨트롤러로 보냈다.LocalDateTime 데이터타입이 당연히 받을 수 있을 줄 알았는데 typeMismatch.java.time.LocalDateTime 에러가 발생했다. 문제12// request bodycalendarParam(idx=10, startDate=2023-10-01T00:00:00, endDate=2023-10-31T23:59:59) 클라이언트에서 보내는 데이터는 위와 같다 12Field error in object 'calendarParam' on field 'startDate': rejected value [2023-10-01&amp;amp;#39;T&amp;amp;#39;00:00:00.000]; codes [typeMismatch.calendarParam.startDate,typeMismatch.startDate,typeMismatch.java.time.LocalDateTime,typeMismatch]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [calendarParam.startDate,startDate]; arguments []; default message [startDate]]; default message [Failed to convert property value of type 'java.lang.String' to required type 'java.time.LocalDateTime' for property 'startDate'; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [@org.springframework.format.annotation.DateTimeFormat java.time.LocalDateTime] for value '2023-10-01&amp;amp;#39;T&amp;amp;#39;00:00:00.000'; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [2023-10-01&amp;amp;#39;T&amp;amp;#39;00:00:00.000]]Field error in object 'calendarParam' on field 'end': rejected value [2023-10-31&amp;amp;#39;T&amp;amp;#39;23:59:59.999]; typeMismatch 에러가 발생했다.혹시 데이터포맷상 startDate.format(&quot;YYYY-MM-DDTHH:mm:ss&quot;)의 T 때문인가 싶어(그럴리없겠지만) 여러가지를 시도했다. 123startDate.format(\"YYYY-MM-DD'T'HH:mm:ss\") //작은따옴표로 감싸보기startDate.format(\"YYYY-MM-DD[T]HH:mm:ss\") //대괄호로 감싸보기startDate.format(\"YYYY-MM-DD HH:mm:ss\") //T없애보기 결과는 여전히 typeMismatch에러였다. 해결: String LocalDateTime을 쓰고 싶었던 이유는 mybatis에서 시작일과 종료일 날짜연산을 하기위해서였다. LocalDateTime을 String으로 변경하고 나서야 정상 작동했다. String이라도 형식이 맞기때문인지 날짜연산도 잘되었다. 해결!","link":"/2023/10/18/231019momentjs-to-localdatetime/"},{"title":"[JS] URL 파라미터(쿼리파라미터Query Parameter) 가져오기","text":"정말 초간단한 Query Parameter 가져오는 방법은 URL객체를 사용하는 것이다. 네이버 검색을 예로 들어보자.아래와 같은 URL에서 query=가나다만 가져오고 싶다면 어떻게 해야할까? 1https://search.naver.com/search.naver?where=nexearch&amp;sm=top_hty&amp;fbm=0&amp;ie=utf8&amp;query=가나다 URLSearchParamsURLSearchParams 객체를 활용하면 된다! 1234const urlParams = new URLSearchParams(window.location.search);const query = urlParams.get('query'); console.log(query)//output: 가나다 해결! 참고 MDN URLSearchParams 객체","link":"/2023/10/19/231020URLsearchparams/"},{"title":"[mybatis] update시 모두 if test를 써야 할 경우","text":"mybatis에서 update시 모든 컬럼에 if 조건물을 걸어야할때가 있다. 아래와 같이 사용하면 된다. 123456789&lt;update id=\"testUpdate\" parameterType=\"VO\"&gt; UPDATE testTable &lt;trim prefix=\"SET\" suffixOverrides=\",\"&gt; &lt;if test=\"testItem1 != null\"&gt;testItem1 = #{testItem1},&lt;/if&gt; &lt;if test=\"testItem2 != null\"&gt;testItem2 = #{testItem2},&lt;/if&gt; &lt;/trim&gt; WHERE idx = #{idx}&lt;/update&gt;","link":"/2023/11/14/231114mybatis-if-update-all/"},{"title":"[mybatis] 객체 안에 객체 매핑하기","text":"객체를 필드로 사용하는 경우 mybatis에서 &lt;association&gt;을 활용할 수 있다. 객체User객체를 필드로 사용하는 2개의 컬럼이 있는 Board객체가 있다.이를 하나의 쿼리로 select해오려면 resultMap과 &lt;association&gt;을 사용하면 된다. 12345678910@Datapublic class Board { private int idx; private String title; private String content; private int writerIdx; private int editorIdx; private User writer; private User editor;} 123456@Datapublic class User { private int idx; private String name; private String mobile;} 쿼리12345678910111213141516&lt;!-- Board 객체 매핑 --&gt;&lt;resultMap id=\"boardMap\" type=\"Board\"&gt; &lt;id property=\"idx\" column=\"IDX\"/&gt; &lt;result property=\"title\" column=\"TITLE\"/&gt; &lt;result property=\"content\" column=\"CONTENT\"/&gt; &lt;!-- 아래 userMap 실행해서 가져옴 --&gt; &lt;association property=\"writer\" resultMap=\"userMap\" columnPrefix=\"WRITER_\"&gt; &lt;association property=\"editor\" resultMap=\"userMap\" columnPrefix=\"EDITOR_\"/&gt;&lt;/resultMap&gt;&lt;!-- userMap 객체 매핑 --&gt;&lt;resultMap id=\"userMap\" type=\"User\"&gt; &lt;id property=\"idx\" column=\"IDX\"/&gt; &lt;result property=\"name\" column=\"NAME\"/&gt; &lt;result property=\"mobile\" column=\"MOBILE\"/&gt;&lt;/resultMap&gt; 위처럼 resultMap 매핑코드를 작성해주고 아래와같이 select문을 호출하면 된다 123456789101112131415&lt;select id=\"getBoardDetail\" parameterType=\"int\" resultMap=\"reportMap\"&gt; SELECT b.*, writer.NAME AS WRITER_NAME, writer.mobile AS WRITER_MOBILE, editor.NAME AS EDITOR_NAME, editor.mobile AS EDITOR_MOBILEFROM BOARD bJOIN USER writerON b.WRITER_IDX = writer.IDXJOIN USER editorON b.EDITOR_IDX = editor.IDXWHERE 1=1AND b.IDX = #{idx}&lt;/select&gt; 주의점association의 resultMap를 동일한 userMap으로 사용하므로 association의 속성인 columnPrefix로 꼭 구분해줘야한다!이걸 못찾아서 몇시간을 삽질했는지… 절레절레","link":"/2023/11/14/231114mybatis-resultMap-manyassociation/"},{"title":"[HTML] radio&#x2F;checkbox 클릭 안 되는 오류가 label for 때문이라고?","text":"radio와 checkbox가 클릭이 안되는 오류가 발생했다.css문제인 줄 알고 디자인팀에 문의했는데 css문제가 전혀 없었고 id를 추가하니까 되던데요?하는 답변을 받았다.또잉?! 문제코드FORM으로 데이터를 넘길거니까 name과 value만 신경써서 작업했다. 12&lt;input type=\"radio\" name=\"reply_type\" value=\"email\" checked&gt;&lt;label for=\"email\"&gt;E-mail&lt;/label&gt;&lt;input type=\"radio\" name=\"reply_type\" value=\"post\" &gt;&lt;labelfor=\"post\"&gt;우편&lt;/label&gt; 그런데 라디오버튼이 클릭도 안되고 post로 보내도 값이 넘어오지않았다!어디가 문제일까? 해결코드원인은 label for이었다.디자인팀에서 구분을 위해서 추가했는데 내가 미처 확인하지 못했다.label for를 쓴다면 input 속성에 id값과 일치 시켜줘야한다! 12&lt;input type=\"radio\" name=\"reply_type\" value=\"email\" id=\"email\" checked&gt;&lt;label for=\"email\"&gt;E-mail&lt;/label&gt;&lt;input type=\"radio\" name=\"reply_type\" value=\"post\" id=\"post\" &gt;&lt;labelfor=\"post\"&gt;우편&lt;/label&gt; 해결!checkbox도 이와 동일하다.name과 value를 잘 넣었는데도 눌러지지않는다면 lable for값과 id값이 일치하는지 의심해보자그리고 사소한 실수 하지말자! 근데 label은 왜 쓸까?input 태그 타입 중 month, number, password, radio, range같은 경우 placeholder속성이 없기에 어떤 input인지 설명해줄수가 없다.따라서 label을 사용해서 명시적으로 용도를 나타내줄수있다. 참고 TCP SCHOOL - label태그의 for 속성 개발자의 낙원 - label태그 왜 쓸까?","link":"/2023/11/14/231115lable-for/"}],"tags":[{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"HTML&amp;CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"Review","slug":"Review","link":"/tags/Review/"},{"name":"Web Game","slug":"Web-Game","link":"/tags/Web-Game/"},{"name":"GIT","slug":"GIT","link":"/tags/GIT/"},{"name":"Journal","slug":"Journal","link":"/tags/Journal/"},{"name":"생활코딩","slug":"생활코딩","link":"/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"},{"name":"패스트캠퍼스(파이썬웹개발)","slug":"패스트캠퍼스-파이썬웹개발","link":"/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9B%B9%EA%B0%9C%EB%B0%9C/"},{"name":"ITWILL(JAVA)","slug":"ITWILL-JAVA","link":"/tags/ITWILL-JAVA/"},{"name":"Oracle","slug":"Oracle","link":"/tags/Oracle/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"},{"name":"Codeup100","slug":"Codeup100","link":"/tags/Codeup100/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"IntelliJ","slug":"IntelliJ","link":"/tags/IntelliJ/"},{"name":"SQL퀴즈","slug":"SQL퀴즈","link":"/tags/SQL%ED%80%B4%EC%A6%88/"},{"name":"Backjoon","slug":"Backjoon","link":"/tags/Backjoon/"},{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"Eclipse","slug":"Eclipse","link":"/tags/Eclipse/"},{"name":"SVN","slug":"SVN","link":"/tags/SVN/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"Port","slug":"Port","link":"/tags/Port/"},{"name":"오류일지","slug":"오류일지","link":"/tags/%EC%98%A4%EB%A5%98%EC%9D%BC%EC%A7%80/"},{"name":"Web Development","slug":"Web-Development","link":"/tags/Web-Development/"},{"name":"STS","slug":"STS","link":"/tags/STS/"},{"name":"Facebook","slug":"Facebook","link":"/tags/Facebook/"},{"name":"YouTube","slug":"YouTube","link":"/tags/YouTube/"},{"name":"Hackerrank","slug":"Hackerrank","link":"/tags/Hackerrank/"},{"name":"Programmers","slug":"Programmers","link":"/tags/Programmers/"},{"name":"Discord","slug":"Discord","link":"/tags/Discord/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"오늘또못알아듣고말았습니다","slug":"오늘또못알아듣고말았습니다","link":"/tags/%EC%98%A4%EB%8A%98%EB%98%90%EB%AA%BB%EC%95%8C%EC%95%84%EB%93%A3%EA%B3%A0%EB%A7%90%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"xAPI","slug":"xAPI","link":"/tags/xAPI/"},{"name":"패스트캠퍼스(초격차Java&#x2F;Spring)","slug":"패스트캠퍼스-초격차Java-Spring","link":"/tags/%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4-%EC%B4%88%EA%B2%A9%EC%B0%A8Java-Spring/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"MSA","slug":"MSA","link":"/tags/MSA/"},{"name":"MariaDB","slug":"MariaDB","link":"/tags/MariaDB/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"회고록","slug":"회고록","link":"/tags/%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"name":"APK","slug":"APK","link":"/tags/APK/"},{"name":"java.util.Calendar","slug":"java-util-Calendar","link":"/tags/java-util-Calendar/"},{"name":"DBeaver","slug":"DBeaver","link":"/tags/DBeaver/"},{"name":"정규표현식","slug":"정규표현식","link":"/tags/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/"},{"name":"Lombok","slug":"Lombok","link":"/tags/Lombok/"},{"name":"디자인패턴","slug":"디자인패턴","link":"/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"},{"name":"DB설계","slug":"DB설계","link":"/tags/DB%EC%84%A4%EA%B3%84/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"NoSQL","slug":"NoSQL","link":"/tags/NoSQL/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"VueJS","slug":"VueJS","link":"/tags/VueJS/"},{"name":"GeekNews","slug":"GeekNews","link":"/tags/GeekNews/"},{"name":"차이","slug":"차이","link":"/tags/%EC%B0%A8%EC%9D%B4/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"Book","slug":"Book","link":"/tags/Book/"},{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"JSTL","slug":"JSTL","link":"/tags/JSTL/"},{"name":"EL","slug":"EL","link":"/tags/EL/"},{"name":"SQLD","slug":"SQLD","link":"/tags/SQLD/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Gson","slug":"Gson","link":"/tags/Gson/"},{"name":"RESTfulAPI","slug":"RESTfulAPI","link":"/tags/RESTfulAPI/"},{"name":"RestTemplate","slug":"RestTemplate","link":"/tags/RestTemplate/"},{"name":"Websocket","slug":"Websocket","link":"/tags/Websocket/"},{"name":"HttpEntity","slug":"HttpEntity","link":"/tags/HttpEntity/"},{"name":"ChatGPT","slug":"ChatGPT","link":"/tags/ChatGPT/"},{"name":"구글애드센스","slug":"구글애드센스","link":"/tags/%EA%B5%AC%EA%B8%80%EC%95%A0%EB%93%9C%EC%84%BC%EC%8A%A4/"},{"name":"VanillaJS","slug":"VanillaJS","link":"/tags/VanillaJS/"},{"name":"설치","slug":"설치","link":"/tags/%EC%84%A4%EC%B9%98/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"Moment.js","slug":"Moment-js","link":"/tags/Moment-js/"}],"categories":[{"name":"제주코딩베이스캠프 10기","slug":"제주코딩베이스캠프-10기","link":"/categories/%EC%A0%9C%EC%A3%BC%EC%BD%94%EB%94%A9%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%BA%A0%ED%94%84-10%EA%B8%B0/"},{"name":"코드스테이츠 PRE35기","slug":"코드스테이츠-PRE35기","link":"/categories/%EC%BD%94%EB%93%9C%EC%8A%A4%ED%85%8C%EC%9D%B4%EC%B8%A0-PRE35%EA%B8%B0/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Lectures &amp; Seminars","slug":"Lectures-Seminars","link":"/categories/Lectures-Seminars/"},{"name":"HTML&amp;CSS","slug":"HTML-CSS","link":"/categories/HTML-CSS/"},{"name":"Journal","slug":"Journal","link":"/categories/Journal/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"JSP","slug":"JSP","link":"/categories/JSP/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Oracle","slug":"Database/Oracle","link":"/categories/Database/Oracle/"},{"name":"Version control","slug":"Version-control","link":"/categories/Version-control/"},{"name":"Django","slug":"Django","link":"/categories/Django/"},{"name":"MySQL","slug":"Database/MySQL","link":"/categories/Database/MySQL/"},{"name":"오픈소스컨트리뷰톤2020","slug":"오픈소스컨트리뷰톤2020","link":"/categories/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A42020/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Team Project","slug":"Journal/Team-Project","link":"/categories/Journal/Team-Project/"},{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"Network","slug":"Network","link":"/categories/Network/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"회고록","slug":"Journal/회고록","link":"/categories/Journal/%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"name":"JPA","slug":"Spring/JPA","link":"/categories/Spring/JPA/"},{"name":"Operating Systeming","slug":"Operating-Systeming","link":"/categories/Operating-Systeming/"},{"name":".NET","slug":"NET","link":"/categories/NET/"},{"name":"CS","slug":"CS","link":"/categories/CS/"}]}