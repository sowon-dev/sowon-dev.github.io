<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>야망찬 개발자의 블로그</title>
    <link>https://sowon-dev.github.io/</link>
    
    <atom:link href="https://sowon-dev.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>devlog</description>
    <pubDate>Thu, 02 Feb 2023 05:16:20 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>카디널리티(Cardinality) 개념, 정의</title>
      <link>https://sowon-dev.github.io/2023/02/01/230202db-cardinality/</link>
      <guid>https://sowon-dev.github.io/2023/02/01/230202db-cardinality/</guid>
      <pubDate>Wed, 01 Feb 2023 20:04:48 GMT</pubDate>
      
      <description>&lt;p&gt;오늘 팀장님에게 sql 작성할때 where에 pk컬럼말고 다른 컬럼을 추가하면 어디에 좋을지에 대해 문의드렸다.&lt;br&gt;내 &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>오늘 팀장님에게 sql 작성할때 where에 pk컬럼말고 다른 컬럼을 추가하면 어디에 좋을지에 대해 문의드렸다.<br>내 </p><a id="more"></a><h1 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h1><p>카디널리티(Cardinality)는 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표이다.</p><ul><li>중복도가 낮으면 카디널리티가 높다 e.g. 휴대전화번호, 주민등록번호</li><li>중복도가 높으면 카디널리티가 낮다 e.g. 이름(동명이인)</li></ul><p>여기서 중요한 개념은 카디널리티는 상대적이라는 것이다. 카디널리티는 데이터에 따라 상대적이기때문에 개발DB에서는 카디널리티가 낮아도 운영DB에서는 카디널리티가 높을 수 있다. </p><p><br><br><br></p><h1 id="활용"><a href="#활용" class="headerlink" title="활용"></a>활용</h1><p>DB에서 인덱스를 걸 때 최대한 많은 데이터가 걸러져야 성능이 좋다.<br>인덱스로 선택된 데이터가 많을수록 full scan이 되므로 성능이 좋지않다.</p><p>즉, 여러 컬럼을 동시에 인덱싱할때는 카디널리티가 높은 컬럼을(중복이 적은 컬럼을) 우선순위로 두는 것이 인덱싱 전략에 유리하다.<br>다만, 인덱스 키를 많이 사용하게 되면 공간 효울이 낮아지게 된다.</p><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://soft.plusblog.co.kr/87#:~:text=%EC%B9%B4%EB%94%94%EB%84%90%EB%A6%AC%ED%8B%B0(Cardinality)%EB%8A%94%20%ED%8A%B9%EC%A0%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0,%EA%B2%BD%EC%9A%B0%20%EC%B9%B4%EB%94%94%EB%84%90%EB%A6%AC%ED%8B%B0%EB%8A%94%202%EB%8B%A4">https://soft.plusblog.co.kr/87#:~:text=%EC%B9%B4%EB%94%94%EB%84%90%EB%A6%AC%ED%8B%B0(Cardinality)%EB%8A%94%20%ED%8A%B9%EC%A0%95%20%EB%8D%B0%EC%9D%B4%ED%84%B0,%EA%B2%BD%EC%9A%B0%20%EC%B9%B4%EB%94%94%EB%84%90%EB%A6%AC%ED%8B%B0%EB%8A%94%202%EB%8B%A4</a>.</li><li><a href="https://itholic.github.io/database-cardinality/">https://itholic.github.io/database-cardinality/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Database/">Database</category>
      
      
      
      <comments>https://sowon-dev.github.io/2023/02/01/230202db-cardinality/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IaaS, PaaS, SaaS 차이</title>
      <link>https://sowon-dev.github.io/2023/01/30/230131iaas-paas-saas/</link>
      <guid>https://sowon-dev.github.io/2023/01/30/230131iaas-paas-saas/</guid>
      <pubDate>Mon, 30 Jan 2023 22:58:49 GMT</pubDate>
      
      <description>&lt;p&gt;프로젝트에서 사용중인 클라우드네이티브 서비스가 있는데 PaaS서비스이다. 예전에 이와 관련해서 공부한 적이 있는데 기록하지 않으니 벌써 기억이 가물가물하다. 이참에 다시 정리해보았다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>프로젝트에서 사용중인 클라우드네이티브 서비스가 있는데 PaaS서비스이다. 예전에 이와 관련해서 공부한 적이 있는데 기록하지 않으니 벌써 기억이 가물가물하다. 이참에 다시 정리해보았다.</p><a id="more"></a><p>참고로 클라우드네이티브가 무엇인지 궁금하다면 블로그 글 <a href="https://sowon-dev.github.io/2023/01/17/230118cloudnative/">클라우드 네이티브(Cloud Native)란? 개념,정의</a>을 참조하면 된다.</p><h1 id="한눈에-비교하기"><a href="#한눈에-비교하기" class="headerlink" title="한눈에 비교하기"></a>한눈에 비교하기</h1><p><img src="https://www.redhat.com/cms/managed-files/iaas-paas-saas-diagram3-1638x1046.png" alt="출처: redhat"></p><p><br><br><br></p><h1 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS(Infrastructure as a Service)"></a>IaaS(Infrastructure as a Service)</h1><ul><li>정보시스템의 모든 인프라를 인터넷상에서 제공한다. </li><li>언뜻 호스팅 서비스같아오이지만 IaaS의 경우,서버를 이용할 때에 필요한 하드웨어의 스펙이나 OS등을 사용자가 자유롭게 선정할 수 있다.</li><li>장점: 환경 구축 자유도가 높다, 시스템관리자의 부하가 적다.</li><li>단점: 환경 구축에 전문성 필요, 유지보수 범위가 넓다. </li></ul><p><br><br><br></p><h1 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS(Platform as a Service)"></a>PaaS(Platform as a Service)</h1><ul><li>정의: 개발 환경이 플랫폼화되어있는 서비스<ul><li>플랫폼화란? 클라우드 환경의 서버, OS, 미들웨어, 데이터베이스 등 애플리케이션 개발에 필요한 환경이 플랫폼으로 갖추어져 있음.</li></ul></li><li>장점: 개발환경의 플랫폼화로 인해 서비스·어플리케이션의 개발에 전념 가능, 초기 비용 및 시간 비용 절감 가능</li><li>단점: 개발환경의 커스텀마이징이 낮다.</li></ul><p><br><br><br></p><h1 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS(Software as a Service)"></a>SaaS(Software as a Service)</h1><ul><li>정의: 패키지 제품으로 아예 서비스를 제공<ul><li>예시: Office365, Gmail 등등</li></ul></li><li>장점: 필요한 서비스를 월별요금제 등으로 결제해서 즉시 사용 가능</li><li>단점: 커스터마이징 불가, 데이터마이그레이션 어려움.</li></ul><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://www.redhat.com/ko/topics/cloud-computing/what-is-paas">https://www.redhat.com/ko/topics/cloud-computing/what-is-paas</a></li><li><a href="https://tagilog.tistory.com/1138">https://tagilog.tistory.com/1138</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Network/">Network</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%B0%A8%EC%9D%B4/">차이</category>
      
      
      <comments>https://sowon-dev.github.io/2023/01/30/230131iaas-paas-saas/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>유저테이블의 PK에 휴대전화번호를 쓰면 안되는 이유</title>
      <link>https://sowon-dev.github.io/2023/01/29/230130userpk/</link>
      <guid>https://sowon-dev.github.io/2023/01/29/230130userpk/</guid>
      <pubDate>Sun, 29 Jan 2023 20:28:59 GMT</pubDate>
      
      <description>&lt;p&gt;가장 메인이 되는 User테이블을 만들때 PK로 휴대전화번호를 써도 될까?&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>가장 메인이 되는 User테이블을 만들때 PK로 휴대전화번호를 써도 될까?</p><a id="more"></a><h1 id="실무에서-user테이블의-pk는-뭐로-쓸까"><a href="#실무에서-user테이블의-pk는-뭐로-쓸까" class="headerlink" title="실무에서 user테이블의 pk는 뭐로 쓸까?"></a>실무에서 user테이블의 pk는 뭐로 쓸까?</h1><p>가장 메인이 되는 user테이블의 pk가 개인정보(전화번호 등)이 되어서는 안된다.<br>개인정보보호법에 따라 DB에 저장할때 비밀번호처럼 항상 암호화해서 저장해야한다.<br>따라서 UUID, 일련번호, 이메일을 PK로 주로 사용한다.</p>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Database/">Database</category>
      
      
      
      <comments>https://sowon-dev.github.io/2023/01/29/230130userpk/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Spring]RestTemplate(레스트템플릿)과 Websocket(웹소켓)차이점</title>
      <link>https://sowon-dev.github.io/2023/01/26/230127resttemplate-vs-websocket/</link>
      <guid>https://sowon-dev.github.io/2023/01/26/230127resttemplate-vs-websocket/</guid>
      <pubDate>Thu, 26 Jan 2023 19:43:38 GMT</pubDate>
      
      <description>&lt;p&gt;RestTemplate은 간편하게 Rest 방식 API를 호출할 수 있는 라이브러리이고 Spring 3.0부터 지원한다.&lt;br&gt;따라서 RestTemplate과 Websocket 차이점은 결국 REST API와 Websocket API 차이점이라고 볼 수 있다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>RestTemplate은 간편하게 Rest 방식 API를 호출할 수 있는 라이브러리이고 Spring 3.0부터 지원한다.<br>따라서 RestTemplate과 Websocket 차이점은 결국 REST API와 Websocket API 차이점이라고 볼 수 있다.</p><a id="more"></a><p>가장 잘 알고 있는 차이점은 REST API는 클라이언트의 요청이 없으면 서버는 먼저 말을 걸 수 없지만 웹소켓은 서버가 클라이언트에게 먼저 말(메세지)을 걸수있다.<br>즉, REST API는 클라이언트의 요청이 있어야 서버 응답이 있는 반면에 Websocket API는 클라이언트 요청없이도 서버가 클라이언트에 응답할 수 있다.<br>실무자입자에서는 어떠한 차이가 있을까?</p><p><br><br><br></p><h1 id="REST-API와-Websocket-API-차이점"><a href="#REST-API와-Websocket-API-차이점" class="headerlink" title="REST API와 Websocket API 차이점"></a>REST API와 Websocket API 차이점</h1><ul><li>REST API: <ul><li>동기, 비동기 둘다 지원. </li><li>프레임워크가 에러보드까지 구현을 다 해놓아서 커넥션이 안정적이라고 하는편</li></ul></li><li>Websocket API: <ul><li>동기, 비동기 둘다 지원. </li><li>빠른 응답이 장점. </li><li>서버리소스가 많이 든다.</li><li>커넥션 안정성(커넥션 끊을때까지 커넥션이 안 끊김)</li><li>웹소켓을 쓰면 커멘드패턴에 따라서 규칙을 다 맞춰줘야함. 사람이 직접 해야하는 게 많아서 난이도가 있고 서버 리소스가 많이 들지만 커넥션이 매우 안정적임</li></ul></li></ul><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li>부장님 지식</li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%B0%A8%EC%9D%B4/">차이</category>
      
      <category domain="https://sowon-dev.github.io/tags/RestTemplate/">RestTemplate</category>
      
      <category domain="https://sowon-dev.github.io/tags/Websocket/">Websocket</category>
      
      
      <comments>https://sowon-dev.github.io/2023/01/26/230127resttemplate-vs-websocket/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[디자인패턴] 옵저버 패턴(observer pattern)이란? 개념,정의</title>
      <link>https://sowon-dev.github.io/2023/01/24/230125ObserverPattern/</link>
      <guid>https://sowon-dev.github.io/2023/01/24/230125ObserverPattern/</guid>
      <pubDate>Tue, 24 Jan 2023 22:13:16 GMT</pubDate>
      
      <description>&lt;p&gt;오늘 팀장님 코드를 보다가 옵저버 패턴을 만났다. 디자인패턴을 잘 모르기때문에 이참에 공부해보았다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>오늘 팀장님 코드를 보다가 옵저버 패턴을 만났다. 디자인패턴을 잘 모르기때문에 이참에 공부해보았다.</p><a id="more"></a><p>여담으로, 공부해봤지만 디자인 패턴은 여전히 어렵다.</p><h1 id="옵저버-패턴-Observer-pattern-이란"><a href="#옵저버-패턴-Observer-pattern-이란" class="headerlink" title="옵저버 패턴(Observer pattern)이란?"></a>옵저버 패턴(Observer pattern)이란?</h1><p>영단어 observer 뜻 그대로 관찰자와 관련된 패턴이다. 객체의 상태 변화를 관찰하는 관찰자들(옵저버)을 목록에 등록해놓고 상태 변화가 있을때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지(notify)하는 디자인 패턴이다.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8d/Observer.svg" alt="출처 - 나무위키"></p><ul><li>주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. </li><li>발행/구독 모델로 알려져 있기도 하다.</li><li>코틀린에서는 Observer(옵저버)대신 Listener(리스너) 용어를 사용한다.</li></ul><p>자바에서는 옵저버패턴을 위한 클래스와 인터페이스를 제공한다.</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/Observer.html">docs.oracle - Interface Observer</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/Observable.html">docs.oracle - Class Observable</a></li></ul><p>쉽게 이해할 수 있는 예시는 유튜브 채널(Subject)과 구독자들(Observer)간의 관계이다.<br>유튜브 채널 관리자가 영상을 업로드하면 구독자들에게만 알람이가 가고 구독자가 아닌 사람들에게는 아무런 영향을 끼치지않는다.<br>즉, 객체(Subject)의 상태가 변화하면 Observer 목록에 있는 각 Observer에게 통지(notify)한다.</p><p><br><br><br></p><h1 id="리액트도-옵저버"><a href="#리액트도-옵저버" class="headerlink" title="리액트도 옵저버?"></a>리액트도 옵저버?</h1><p>옵저버패턴을 알수록 리액트가 자꾸 떠올랐다.<br><a href="https://medium.com/@shlee1353/리액트-리덕스-redux-와-observer-패턴-a4aae3468a25">Seungho Lee - 리덕스(Redux)와 Observer 패턴</a>에서 왜 자꾸 리액트가 떠올랐는지 확인할 수 있었다.</p><blockquote><p>리액트 사용시 데이터 관리를 손쉽게 하기 위해 리덕스(redux)를 사용하며, 이는 옵저버 패턴을 기반으로 제작되었습니다. 리덕스 스토어(store)는 애플리케이션의 상태트리(state tree)를 관리하고 있습니다. 스토어 내부에서 상태값이 변하면 그것에 대한 액션을 보내줘야합니다.<br>출처: <a href="https://medium.com/@shlee1353/리액트-리덕스-redux-와-observer-패턴-a4aae3468a25">Seungho Lee - 리덕스(Redux)와 Observer 패턴</a></p></blockquote><p>리액트의 리덕스는 옵저버패턴으로 디자인된 것이었다!<br>지식이 연결되는 느낌! 재밌다!</p><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4">위키백과 - 옵서버 패턴</a></li><li><a href="https://velog.io/@haero_kim/옵저버-패턴-개념-떠먹여드립니다">haero_kim - 옵저버 패턴 개념 떠먹여드립니다</a></li><li><a href="https://velog.io/@hanna2100/디자인패턴-2.-옵저버-패턴-개념과-예제-observer-pattern">hanna2100 - 디자인패턴 2.옵저버 패턴 개념과 예제</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Journal/">Journal</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/">디자인패턴</category>
      
      
      <comments>https://sowon-dev.github.io/2023/01/24/230125ObserverPattern/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Jackson ObjectMapper VS Gson 차이</title>
      <link>https://sowon-dev.github.io/2023/01/18/230119objectmappervsgson/</link>
      <guid>https://sowon-dev.github.io/2023/01/18/230119objectmappervsgson/</guid>
      <pubDate>Wed, 18 Jan 2023 15:51:35 GMT</pubDate>
      
      <description>&lt;p&gt;Object Mapper만 사용하다가 Gson을 알게되면서 둘의 차이점이 궁금해졌다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Object Mapper만 사용하다가 Gson을 알게되면서 둘의 차이점이 궁금해졌다.</p><a id="more"></a><h1 id="개념"><a href="#개념" class="headerlink" title="개념"></a>개념</h1><p>Jackson ObjectMapper와 Gson은 뭐하는 애들일까? 자바에서 JSON data-binding 지원해주는 라이브러리이다.</p><p><br><br><br></p><h1 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h1><p>HashMap을 Json으로 변환한뒤 콘솔에 출력하는 예시이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Obejct&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"나혜석"</span>);</span><br><span class="line">map.put(<span class="string">"age"</span>, <span class="number">77</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. ObjectMapper 사용 + throws Exception 필수</span></span><br><span class="line">String serializedMap1 = <span class="keyword">new</span> ObjectMapper().writeValueAsString(map);</span><br><span class="line">system.out.println(serializedMap1);</span><br><span class="line"><span class="comment">// output: &#123;"name":"나혜석","age":77&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Gson 사용</span></span><br><span class="line">String serializedMap2 = <span class="keyword">new</span> GsonBuilder().create().toJson(map)</span><br><span class="line">system.out.println(serializedMap2);</span><br><span class="line"><span class="comment">// output: &#123;"name":"나혜석","age":77&#125;</span></span><br></pre></td></tr></table></figure><p>사용하다보면 큰 차이점 하나를 발견할 수 있는데 ObjectMapper는 Exceptionc처리가 필수이다.</p><p><br><br><br></p><h1 id="각-장점"><a href="#각-장점" class="headerlink" title="각 장점"></a>각 장점</h1><table><thead><tr><th align="left">Jackson</th><th align="left">Gson</th></tr></thead><tbody><tr><td align="left">스프링프레임워크에 이미 속해있어 따로 설치안해도 됨</td><td align="left">가장 간단한 toJson/fromJson방식</td></tr><tr><td align="left">다양한 어노테이션 활용가능</td><td align="left">역직렬화시 자바 엔티티에 접근할 필요가 없음</td></tr></tbody></table><ul><li>Jackson:<ul><li>Built into all JAX-RS (Jersey, Apache CXF, RESTEasy, Restlet), and Spring framework</li><li>Extensive annotation support</li></ul></li><li>Gson:<ul><li>Simplicity of toJson/fromJson in the simple cases</li><li>For deserialization, do not need access to the Java entities</li></ul></li></ul><p>출처: <a href="https://www.baeldung.com/jackson-vs-gson">baeldung의 jackson-vs-gson 글</a></p>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JAVA/">JAVA</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%B0%A8%EC%9D%B4/">차이</category>
      
      <category domain="https://sowon-dev.github.io/tags/Gson/">Gson</category>
      
      
      <comments>https://sowon-dev.github.io/2023/01/18/230119objectmappervsgson/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>클라우드 네이티브(Cloud Native)란? 개념,정의</title>
      <link>https://sowon-dev.github.io/2023/01/17/230118cloudnative/</link>
      <guid>https://sowon-dev.github.io/2023/01/17/230118cloudnative/</guid>
      <pubDate>Tue, 17 Jan 2023 19:24:30 GMT</pubDate>
      
      <description>&lt;p&gt;클라우드 네이티브(Cloud Native)란 무엇일까? 이번에 교육을 받으면서 도커, 쿠버네티스, MSA등의 용어가 쏟아졌다. 이들이 어떤 Cloud Native와 관계가 있는지 궁금해서 정확히 알아보았다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>클라우드 네이티브(Cloud Native)란 무엇일까? 이번에 교육을 받으면서 도커, 쿠버네티스, MSA등의 용어가 쏟아졌다. 이들이 어떤 Cloud Native와 관계가 있는지 궁금해서 정확히 알아보았다.</p><a id="more"></a><h1 id="클라우드-네이티브"><a href="#클라우드-네이티브" class="headerlink" title="클라우드 네이티브"></a>클라우드 네이티브</h1><blockquote><p>클라우드 네이티브라는 용어는 클라우드 제공 모델에서 제공하는 분산 컴퓨팅을 활용하기 위해 애플리케이션을 구축 및 실행하는 개념을 의미합니다. 클라우드 네이티브 앱은 클라우드가 제공하는 확장성, 탄력성, 복원성, 유연성을 활용하도록 설계 및 구축되었습니다.(중략) 클라우드 네이티브 서비스는 Kubernetes, Docker, 서버리스 함수, API 및 Kafka와 같은 기술을 사용하여 최신 애플리케이션 개발을 지원합니다. 업계 최고의 클라우드 제공업체를 통해 클라우드 툴과 서비스를 구현하므로 개발자가 운영 작업을 줄이고 애플리케이션을 더 빠르게 구축할 수 있습니다. 클라우드 네이티브 서비스는 개발자에게 마이크로서비스, 서버리스 함수와 같은 클라우드 네이티브 애플리케이션을 구축, 배포, 관리할 수 있는 종합적인 표준 기반 플랫폼을 제공합니다.<br>출처: <a href="https://www.oracle.com/kr/cloud/cloud-native/what-is-cloud-native/">오라클 공식홈페이지</a></p></blockquote><p>클라우드 네이티브란 클라우드의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식이다.<br>그렇다면 클라우드의 장점이 무엇일까?</p><p><br><br><br></p><h1 id="클라우드의-장점"><a href="#클라우드의-장점" class="headerlink" title="클라우드의 장점"></a>클라우드의 장점</h1><ol><li>확장가능성(Scaling) : 사용량에 따라 편리하게 인스턴스를 증가, 감소할 수 있음</li><li>CI/CD: 구축, 테스트 및 배포를 자동화하여 소프트웨어가 개발 시스템에서 운영 시스템으로 빠르고 안정적인 프로그램 구축가능</li><li>장애대응: 정 서비스에 오류가 발생해도 다른 서비스에 영향을 주지 않음</li></ol><p><br><br><br></p><h1 id="클라우드-네이티브-핵심-구성요소-4가지"><a href="#클라우드-네이티브-핵심-구성요소-4가지" class="headerlink" title="클라우드 네이티브 핵심 구성요소 4가지"></a>클라우드 네이티브 핵심 구성요소 4가지</h1><p><img src="https://images.ctfassets.net/o7xu9whrs0u9/2tVV4YzJRE7JGKzXjj4Xsp/af35d764254ead0c720c5761c74c134e/Cloud-Nateive-technologies-pyramid.jpg" alt=""><br><a href="https://www.influxdata.com/blog/introduction-cloud-native/">사진출처: https://www.influxdata.com/blog/introduction-cloud-native/</a></p><ol><li>DevOps<ul><li>개발 조직과 운영 조직의 통합을 의미: 이전에는 개발과 운영이 분리되어 개발자가 구동할 프로그램 준비를 끝나면, 이후 배포와 운영 작업은 다른 조직이 했다. 만약 우리가 단 몇줄의 코드를 바꿔야 할지라도 바꾼 후에 운영 조직과 다시 소통하여 배포해야 하므로 매우 번거로운 일이 아닐 수 없다. 이를 극복하기 위해 나온 개념으로 서비스의 문제가 생기면 바로 수정해서 즉시 배포하는 과정을 반복하는 것을 목적으로 한다.</li></ul></li><li>CI/CD<ul><li>지속적인 통합 (CI : Continuous Integration)<ul><li>소스 관리(형상관리), 빌드, 테스트를 모두 포함한다. e.g. 젠킨스, Team CI, Travic CI등</li></ul></li><li>지속적인 배포 (CD : Continuous Delivery &amp; Deployment)<ul><li>Continuous Delivery인 경우 빌드는 자동이지만 배포는 수동 반영</li><li>Continuous Deployment인 경우 빌드와 배포까지 모두 자동 반영</li></ul></li></ul></li><li>Container 가상화 기술<ul><li>기존에는 서로 다른 OS환경을 위해 가상머신을 사용해야해서 비용, 운영측면에서 부담이 많았지만 도커라는 컨테이너 가상화 기술을 도입하여 각각의 서비스와 앱을 관리할 수 있게 되었음</li></ul></li><li>MSA(Micro Service Architecture)<ul><li><a href="https://sowon-dev.github.io/2021/04/12/210415MSA/">내가 이해한 MSA(MicroService Architecture)</a> 참고</li></ul></li></ol><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://www.itworld.co.kr/news/248260">IT World - 클라우드 네이티브의 진정한 의미</a></li><li><a href="https://born2bedeveloper.tistory.com/51">jimkwon님 - Cloud Native Architecture - (1)</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Server/">Server</category>
      
      
      
      <comments>https://sowon-dev.github.io/2023/01/17/230118cloudnative/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>나스(NAS)란? 개념,정의</title>
      <link>https://sowon-dev.github.io/2023/01/15/230116nas/</link>
      <guid>https://sowon-dev.github.io/2023/01/15/230116nas/</guid>
      <pubDate>Sun, 15 Jan 2023 16:55:28 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://sowon-dev.github.io/2023/01/17/230118cloudnative/&quot;&gt;클라우드 네이티브&lt;/a&gt;관련해서 교육을 듣던 중 강사님이 NAS에 관해 아래처럼 말씀하셨다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;서버 1x.x.x.xx는 NAS로 사용합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;예전에 대리님이 아기 사진이 너무 많아 NAS서버를 만들까한다는 말도 떠오르면서 NAS가 정확히 뭔지 궁금해졌다.&lt;br&gt;문맥상 데이터 저장소같은데 DB와는 또 어떻게 다를까? 외부에서 접근하면 클라우드저장소같은데 그와는 또 어떻게 다를까?&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://sowon-dev.github.io/2023/01/17/230118cloudnative/">클라우드 네이티브</a>관련해서 교육을 듣던 중 강사님이 NAS에 관해 아래처럼 말씀하셨다.</p><blockquote><p>서버 1x.x.x.xx는 NAS로 사용합니다.</p></blockquote><p>예전에 대리님이 아기 사진이 너무 많아 NAS서버를 만들까한다는 말도 떠오르면서 NAS가 정확히 뭔지 궁금해졌다.<br>문맥상 데이터 저장소같은데 DB와는 또 어떻게 다를까? 외부에서 접근하면 클라우드저장소같은데 그와는 또 어떻게 다를까?</p><a id="more"></a><h1 id="NAS-Network-Attached-Storage"><a href="#NAS-Network-Attached-Storage" class="headerlink" title="NAS(Network Attached Storage)"></a>NAS(Network Attached Storage)</h1><ul><li>Network Attached Storage: 네트워크 결합 스토리지</li><li>LAN으로 연결하는 외장 하드디스크</li><li>반대 개념은 컴퓨터에 직접 연결해서 쓰는 DAS(직접 결합 저장장치, Direct Attached Storage) e.g. 내장형 하드디스크</li></ul><p>컴퓨터를 직접 연결하지 않고 근거리 통신 네트워크(LAN)를 통해 데이터를 주고 받는다. 클라우드 스토리지 서비스와 유사한 느낌인데 어떤 차이가 있을까?</p><p><br><br><br></p><h1 id="클라우드-스토리지-서비스와-차이점"><a href="#클라우드-스토리지-서비스와-차이점" class="headerlink" title="클라우드 스토리지 서비스와 차이점"></a>클라우드 스토리지 서비스와 차이점</h1><table><thead><tr><th align="center"></th><th align="left">NAS</th><th align="left">클라우드스토리지</th></tr></thead><tbody><tr><td align="center">정의</td><td align="left">LAN으로 연결하는 외장 하드디스크</td><td align="left"></td></tr><tr><td align="center">보안성</td><td align="left">우수</td><td align="left">개인정보보안취약</td></tr><tr><td align="center">안정성</td><td align="left">하드디스크에 몇개에 의존해서 취약</td><td align="left">우수</td></tr><tr><td align="center">속도</td><td align="left">상대적 빠름</td><td align="left">상대적 느림</td></tr><tr><td align="center">비용</td><td align="left">초기비용많지만 유지비 상대적 저렴</td><td align="left">주로 월정액방식으로 초기비용도 낮고 유지비도 비싸지않다</td></tr></tbody></table><p><br><br><br></p><h1 id="NAS-목적"><a href="#NAS-목적" class="headerlink" title="NAS 목적"></a>NAS 목적</h1><p>사람에 따라 사용방식이 다양하지만 구글링해본 결과 대용량, 개인자료는 NAS에 보관하고 업무용 또는 백업용 자료는 클라우드저장소(구글클라우드)를 많이 사용하는 것으로 보인다.</p><p><br><br><br></p><h1 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h1><p>NAS에 대해 궁금한 점을 팀장님께 물으니 팀장님이 RAID에 관해서도 함께 설명해주셨다. 안 물어보면 어쩔뻔했어! 이렇게 지식이 확장되는 거 정말 좋다! 재밌어!</p><ul><li>RAID정의: 저장장치 여러 개를 묶어 고용량, 고성능인 저장 장치 한 개와 같은 효과를 얻기 위해 개발된 기법</li><li>사용목적<ol><li>무정지 구현</li><li>고성능 구현</li></ol></li></ul><p>그렇다면 왜 묶어서 사용할까? 나무위키에 그에 관한 설명이 잘 나와있다.</p><blockquote><p>저장장치는 소모품이다. 5년에서 10년정도 수없이 읽고 쓰기를 반복하면 물리적으로 움직이는 부품이 있는 HDD는 물론이요 전자적으로만 작동하는 SSD도 NAND 소자가 닳아 읽고 쓰는 속도가 느려지고, 결국에는 읽고 쓸 수 없는 부분인 불량섹터가 발생하게 된다. 이런 경우에는 불량섹터에 기록되어 있던 정보가 손상되는 것도 문제지만, 이후에 저장장치에 기록되는 데이터의 무결성을 보장할 수 없기 때문에 보통 장치째로 (기존에 기록되어 있던 데이터와 함께) 폐기 처분하게 된다. 여러개의 디스크를 특정 방법으로 연결해주는 시스템인 RAID는 바로 이렇게 저장장치가 갑자기 고장나는 경우를 대비해서 활용할 수 있는 유용한 기법이다. 방대한 양의 데이터를 읽고 쓰며 1년 365일 내내 가용성이 보장되어야 하는 구글이나 페이스북의 서버들을 상상해보자.<br>출처: 나무위키</p></blockquote><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://namu.wiki/w/NAS(%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98)">https://namu.wiki/w/NAS(%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98)</a></li><li><a href="https://namu.wiki/w/RAID">https://namu.wiki/w/RAID</a></li><li><a href="https://quarker.tistory.com/175">quarker님 - NAS와 Cloud Storage 서비스 비교</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Server/">Server</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%98%A4%EB%8A%98%EB%98%90%EB%AA%BB%EC%95%8C%EC%95%84%EB%93%A3%EA%B3%A0%EB%A7%90%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/">오늘또못알아듣고말았습니다</category>
      
      
      <comments>https://sowon-dev.github.io/2023/01/15/230116nas/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Spring]RestTemplate response 한글깨짐 UTF-8적용하기</title>
      <link>https://sowon-dev.github.io/2023/01/12/230113spring-resttemplateutf8/</link>
      <guid>https://sowon-dev.github.io/2023/01/12/230113spring-resttemplateutf8/</guid>
      <pubDate>Thu, 12 Jan 2023 15:46:57 GMT</pubDate>
      
      <description>&lt;p&gt;최근에 Gson 한글 깨지는 현상을 해결한 블로그 글 &lt;a href=&quot;https://sowon-dev.github.io/2023/01/05/230106gson-korean-encoding/&quot;&gt;Gson 한글이 ?로 깨져보일때&lt;/a&gt;을 포스팅했었다.&lt;br&gt;성공메시지는 한글이라 몰랐는데 에러메시지가 엉망진창으로 인코딩되서 출력되었다.&lt;br&gt;나는 한글을 정말 사랑하는데… 한글 인코딩이 나를 힘들게 한다. 한글아 그만 깨져😠&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>최근에 Gson 한글 깨지는 현상을 해결한 블로그 글 <a href="https://sowon-dev.github.io/2023/01/05/230106gson-korean-encoding/">Gson 한글이 ?로 깨져보일때</a>을 포스팅했었다.<br>성공메시지는 한글이라 몰랐는데 에러메시지가 엉망진창으로 인코딩되서 출력되었다.<br>나는 한글을 정말 사랑하는데… 한글 인코딩이 나를 힘들게 한다. 한글아 그만 깨져😠</p><a id="more"></a><h1 id="문제-현상"><a href="#문제-현상" class="headerlink" title="문제 현상"></a>문제 현상</h1><p>이번에는 어디서 한글이 깨졌는지부터 찾아야했다. log를 뒤진 결과 <code>RestTemplateLoggingInterceptor</code>의 로그까지는 한글이 깨지지않고 출력하나 그 뒤 RestTemplate response를 받는 부분에서 한글이 깨지는 것을 확인했다.<br>RestTemplate 선언하는 방법은 블로그 글 <a href="https://sowon-dev.github.io/2022/12/09/221210spring-resttemplate/">RestTemplate과 HttpEntity가 뭐길래(제네릭과 ParameterizedTypeReference)</a>를 참조하면 된다.</p><p><br><br><br></p><h1 id="수정한-코드"><a href="#수정한-코드" class="headerlink" title="수정한 코드"></a>수정한 코드</h1><p>StringHttpMessageConverter의 default Charset이 ISO-8859-1이라고 한다. 이를 UTF-8로 변경하면 한글이 깨짐없이 잘 출력된다! </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(<span class="keyword">new</span> BufferingClientHttpRequestFactory(<span class="keyword">new</span> HttpComponentsClientHttpRequestFactory()));</span><br><span class="line">restTemplate.getMessageConverters().add(<span class="number">0</span>, <span class="keyword">new</span> StringHttpMessageConverter(StandardCharsets.UTF_8)); <span class="comment">// 추가한 부분</span></span><br><span class="line">restTemplate.exchange(apiUrl, HttpMethod.POST, entity, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>StringHttpMessageConverter가 어떤 역할을 하는 지 좀 더 깊게 궁금했는데 잘 정리된 글이 이미 있었다. 자세한 내용은 <a href="https://cornswrold.tistory.com/402">깡냉쓰님의 RestTemplate 한글 깨짐관련(StringHttpMessageConverter)</a>을 참고하면 된다.</p><p>해결!😎</p>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      
      <comments>https://sowon-dev.github.io/2023/01/12/230113spring-resttemplateutf8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Java]익숙한 for each말고 Stream도 써봐야지</title>
      <link>https://sowon-dev.github.io/2023/01/10/230111codereview/</link>
      <guid>https://sowon-dev.github.io/2023/01/10/230111codereview/</guid>
      <pubDate>Tue, 10 Jan 2023 15:56:45 GMT</pubDate>
      
      <description>&lt;p&gt;코드리뷰를 통해 익숙한 for each대신 Stream을 써보게되었다. 너무 재밌는 배움이라 기록하기로 마음먹었다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>코드리뷰를 통해 익숙한 for each대신 Stream을 써보게되었다. 너무 재밌는 배움이라 기록하기로 마음먹었다.</p><a id="more"></a><p>정책상의 이유로 동일한 데이터를 서로 다른 User DB와 Wallet DB에 각각 저장하고 있다. 이 두 DB의 값들이 싱크가 맞는지 확인하는 메서드가 필요했다.</p><p><br><br><br></p><h1 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h1><ul><li><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Wallet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> walletId;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="keyword">private</span> Boolean isAvailalbe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h1 id="내-코드"><a href="#내-코드" class="headerlink" title="내 코드"></a>내 코드</h1><p>DiffVO를 담을 객체를 구현하고 User 디비를 호출해서 userDBValue에 셋팅하고 Wallet를 호출해서 walletDBValue에 셋팅한 뒤 if조건문으로 두 값을 비교해서 같으면 isTheSame = true로 바꿔주도록 구현했다.<br>주의점은 User 디비 호출메서드 리턴데이터타입(User)과 Wallet 디비 호출메서드 리턴데이터타입(List)이 다르게 고정되어 있다는 점이다. </p><ul><li><p>DiffVO.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffVO</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> userDBValue;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> walletDBValue;</span><br><span class="line">  <span class="keyword">private</span> Boolean isTheSame = <span class="keyword">false</span>; <span class="comment">// 디폴트 false로</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> testService&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> DiffVO <span class="title">checkTheSameValue</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    DiffVO diffInfo = <span class="keyword">new</span> DiffVO();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. A디비 값 가져오기</span></span><br><span class="line">User userInfo = dao.selectUserInfo(id);</span><br><span class="line">diffInfo.setUserDBValue(userInfo.getBalance());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. B디비 값 가져오기</span></span><br><span class="line">List&lt;Wallet&gt; walletInfo = balanceAllWallet(); <span class="comment">// 기 구현된 서비스 balanceAllWallet()이용 필수</span></span><br><span class="line"><span class="keyword">for</span>(Wallet w : walletInfo)&#123;</span><br><span class="line">  <span class="keyword">if</span>(w.getUserId() == id)&#123;</span><br><span class="line">      diffInfo.setWalletDBValue(w.getBalance());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 비교하기</span></span><br><span class="line"><span class="keyword">if</span>(diffInfo.getUserDBValue() == diffInfo.getWalletDBValue())&#123;</span><br><span class="line">  diffInfo.setIsTheSame(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> diffInfo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3단계로 비교했다. 팀장님이 내 코드를 보시곤 Stream을 사용하는 건 어떻겠냐고 말씀해주셨다.</p><p><br><br><br></p><h1 id="팀장님-코드"><a href="#팀장님-코드" class="headerlink" title="팀장님 코드"></a>팀장님 코드</h1><p> 내 코드는 for each문이고 팀장님은 stream을 사용하셨다.<br> stream에 대한 자세한 설명은 <a href="https://sowon-dev.github.io/2020/08/26/200827javai2/">블로그 글 - 스트림 API 개념</a>에 엄청 친절하게 적어놓았다.<br> stream을 써보고싶었는데 익숙한 for 문만 쓰다 이렇게 코드리뷰하다가 쓰게되니 무척 재밌었다. 너무 재밌어!</p><ul><li>service<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (중략)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. B디비 값 가져오기 -&gt; 코드리뷰</span></span><br><span class="line">List&lt;Wallet&gt; walletInfo = balanceAllWallet(); <span class="comment">// 기 구현된 서비스 balanceAllWallet()이용 필수</span></span><br><span class="line"></span><br><span class="line">Stream&lt;Wallet&gt; walletStream = walletInfo.stream().filter(d -&gt; id.equals(d.getUserId()));</span><br><span class="line">Wallet wallet = walletInfo.findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">diffInfo.setWalletDBValue(wallet.getBalance());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 비교하기</span></span><br><span class="line"><span class="keyword">if</span>(diffInfo.getUserDBValue() == diffInfo.getWalletDBValue())&#123;</span><br><span class="line">diffInfo.setIsTheSame(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> diffInfo;</span><br></pre></td></tr></table></figure></li></ul><p>Stream을 쓰니 가독성도 좋아졌다.<br>여담이지만 팀장님은 정말 천재같다. </p><p><br><br><br></p><h1 id="스트림과-for반복문-어느-것이-더-좋을까"><a href="#스트림과-for반복문-어느-것이-더-좋을까" class="headerlink" title="스트림과 for반복문 어느 것이 더 좋을까?"></a>스트림과 for반복문 어느 것이 더 좋을까?</h1><p>이렇게 스트림을 쓰고나니 for문과 비교해서 뭐가 더 좋은지가 궁금했다. 여러 구글링 끝에 흥미로운 미디엄 글 <a href="https://jypthemiracle.medium.com/java-stream-api%EB%8A%94-%EC%99%9C-for-loop%EB%B3%B4%EB%8B%A4-%EB%8A%90%EB%A6%B4%EA%B9%8C-50dec4b9974b">Sigrid Jin님의 Java Stream API는 왜 for-loop보다 느릴까?</a>를 찾았다.</p><blockquote><p>오늘의 결론이다. 스트림 사용이 for-loop보다 의미가 있으려면 Collection이 되는 스트림 소스의 크기가 충분히 크거나, 컴퓨팅 연산이 CPU-intensive할 정도로 비용이 매우 비싸야 한다. 병렬 스트림을 사용하려면, 스트림 소스인 Collection은 split하기 쉬운 자료 구조이어야 하며, 웬만해서는 연산이 stateful하지 않아야 한다. 성능차이는 개발자의 로컬환경에 따라 다를 수 있다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%B0%A8%EC%9D%B4/">차이</category>
      
      
      <comments>https://sowon-dev.github.io/2023/01/10/230111codereview/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Spring] 컨트롤러에서 json을 리턴하고 싶을때</title>
      <link>https://sowon-dev.github.io/2023/01/08/230109spring-returnjsonview/</link>
      <guid>https://sowon-dev.github.io/2023/01/08/230109spring-returnjsonview/</guid>
      <pubDate>Sun, 08 Jan 2023 21:44:25 GMT</pubDate>
      
      <description>&lt;p&gt;컨트롤러에서 json형식으로 반환해주는 방법은 크게 두가지이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>컨트롤러에서 json형식으로 반환해주는 방법은 크게 두가지이다.</p><a id="more"></a><ol><li>String으로 반환: Controller return type을 String으로 리턴한 뒤 클라이언트에서 파싱하기.</li><li>MappingJackson2JsonView 사용: ModelAndView를 json 형식으로 반환해 준다.</li></ol><p>스프링프레임워크에서는 주로 MappingJackson2JsonView을 bean으로 등록해서 이용한다.</p><p><br><br><br></p><h1 id="MappingJackson2JsonView"><a href="#MappingJackson2JsonView" class="headerlink" title="MappingJackson2JsonView"></a>MappingJackson2JsonView</h1><p><code>servlet-context.xml</code>에서 아래 코드를 추가한다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jsonView"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.json.MappingJacksonJsonView"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"contentType"</span> <span class="attr">value</span>=<span class="string">"application/json;charset=UTF-8"</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- BeanNameViewResolver 우선순위 지정 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanNameResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.BeanNameViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>BeanNameViewResolver우선순위 지정: beanNameResolver는 우선순위를 0으로 해서 ViewPage를 찾을 때 우선 탐색한다. 만약 BeanNameViewResolver에서 없으면 viewResolver에서 탐색한다.<br>출처: <a href="https://icefree.tistory.com/entry/Spring-BeanNameViewResolver">Classic!님의 블로그 글 BeanNameViewResolver</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      
      <comments>https://sowon-dev.github.io/2023/01/08/230109spring-returnjsonview/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Gson]한글이 ?로 깨져보일때</title>
      <link>https://sowon-dev.github.io/2023/01/05/230106gson-korean-encoding/</link>
      <guid>https://sowon-dev.github.io/2023/01/05/230106gson-korean-encoding/</guid>
      <pubDate>Thu, 05 Jan 2023 21:07:31 GMT</pubDate>
      
      <description>&lt;p&gt;구글에서 만든 &lt;a href=&quot;https://github.com/google/gson&quot;&gt;Gson&lt;/a&gt;을 사용해서 객체를 json으로 혹은 그 반대로 변환하는데 사용하고 있다. 이때 한글이 ?로 깨지는 현상이 나타났다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>구글에서 만든 <a href="https://github.com/google/gson">Gson</a>을 사용해서 객체를 json으로 혹은 그 반대로 변환하는데 사용하고 있다. 이때 한글이 ?로 깨지는 현상이 나타났다.</p><a id="more"></a><h1 id="한글깨질때-produces-quot-text-plain-charset-UTF-8-quot-추가하기"><a href="#한글깨질때-produces-quot-text-plain-charset-UTF-8-quot-추가하기" class="headerlink" title="한글깨질때 produces=&quot;text/plain;charset=UTF-8&quot; 추가하기"></a>한글깨질때 <code>produces=&quot;text/plain;charset=UTF-8&quot;</code> 추가하기</h1><p>컨트롤러 RequestMapping 에 추가하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/test"</span>, method=RequestMethod.GET, produces=<span class="string">"text/plain;charset=UTF-8"</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="그래도-안될때"><a href="#그래도-안될때" class="headerlink" title="그래도 안될때"></a>그래도 안될때</h1><p>produces를 설정하고 나니까 http통신이 안된다. 그래서 <code>produces = &quot;application/json;charset=utf-8&quot;</code>로 바꿔주니 통신이 되었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/test"</span>, method=RequestMethod.GET, produces=<span class="string">"application/json;charset=UTF-8"</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="그래도-또-안될때"><a href="#그래도-또-안될때" class="headerlink" title="그래도 또 안될때"></a>그래도 또 안될때</h1><p>하지만 여전히 한글이 깨졌다. 그래서 다시 구글링해서 찾은 내용인 <code>produces = &quot;MediaType.APPLICATION_JSON_UTF8_VALUE&quot;</code>로 바꿔적용했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/test"</span>, method=RequestMethod.GET, produces=<span class="string">"MediaType.APPLICATION_JSON_UTF8_VALUE"</span>)</span><br></pre></td></tr></table></figure><p>해결!</p>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Journal/">Journal</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/Gson/">Gson</category>
      
      
      <comments>https://sowon-dev.github.io/2023/01/05/230106gson-korean-encoding/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Spring] 새로운 컨트롤러(Controller)를 생성했는데 호출이 안될때</title>
      <link>https://sowon-dev.github.io/2023/01/04/230105spring-servletcontext/</link>
      <guid>https://sowon-dev.github.io/2023/01/04/230105spring-servletcontext/</guid>
      <pubDate>Wed, 04 Jan 2023 20:02:22 GMT</pubDate>
      
      <description>&lt;p&gt;레거시 프로젝트에 신규 패키지를 만들고 그 패키지안에 신규 컨트롤러를 생성했다. 컨트롤러에 서비스 메서드를 만들고 포스트맨으로 호출했는데 웬걸?! 서버가 전혀 반응을 안한다. 왜일까?&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>레거시 프로젝트에 신규 패키지를 만들고 그 패키지안에 신규 컨트롤러를 생성했다. 컨트롤러에 서비스 메서드를 만들고 포스트맨으로 호출했는데 웬걸?! 서버가 전혀 반응을 안한다. 왜일까?</p><a id="more"></a><p>기본적으로 해봐야하는 것은 build 탭 &gt; clean &gt; 서버 재시작이다. 빌드가 제대로 안되어있으면 컨트롤러가 새로 생성된지도 모르기때문이다. 하지만 나는 여전히 반응하지않았다. 수석연구원님께 물어 알게된 것은 컴포넌트 스캔문제였다.</p><h1 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h1><p><code>servlet-context.xml</code>파일에서 아래처럼 컴포넌트 스캔 코드가 있는데 나는 테스트용 새로운 패키지인 <code>com.test.preview</code>를 만들고 그곳에다 신규 컨트롤러를 생성했다. 따라서 컴포넌트가 스캔이 되지않았던 것이다.</p><ul><li>기존코드 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.test.controller"</span> /&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h1><p>콤마를 이용해서 베이스패키지를 추가해주면 해결!<br>감사합니다 김수석연구원님!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.test.controller,com.test.preview"</span> /&gt;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      
      <comments>https://sowon-dev.github.io/2023/01/04/230105spring-servletcontext/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Java] 포스트맨(Postman)사용시 동시 요청이 되는 이유?</title>
      <link>https://sowon-dev.github.io/2023/01/04/230105postman-multithread/</link>
      <guid>https://sowon-dev.github.io/2023/01/04/230105postman-multithread/</guid>
      <pubDate>Wed, 04 Jan 2023 19:20:56 GMT</pubDate>
      
      <description>&lt;p&gt;서버 API 작업 중 A요청 후 디버깅을 하는 와중에 B요청을 했더니 B요청에 대한 응답을 바로 받을 수 있었다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>서버 API 작업 중 A요청 후 디버깅을 하는 와중에 B요청을 했더니 B요청에 대한 응답을 바로 받을 수 있었다.</p><a id="more"></a><p>A요청에 대한 응답을 받기 전인데 B응답과 요청을 어떻게 처리될 수 있었을까?</p><h1 id="멀티쓰레드가-답이다"><a href="#멀티쓰레드가-답이다" class="headerlink" title="멀티쓰레드가 답이다."></a>멀티쓰레드가 답이다.</h1><p>내가 만든 서버API는 스프링프레임워크로 스프링프레이워크는 멀티스레드를 지원한다. 그래서 특별한 설정을 하지않아도 한 요청에 대한 응답을 받기도 전에 다른 요청을 보내고 응답도 받을 수 있었던 것!<br>간단하게 멀티쓰레드의 장점은 작업 분리로 효율성 증대이고 단점은 제어의 어려움이 있다.</p><p>블로그 글 <a href="https://sowon-dev.github.io/2020/08/19/200820javai/">멀티스레드프로그래밍1 : 개념, 용어정리, 스래드 상태와 제어</a>을 보면 더 자세히 알수있다.</p><p><br><br><br></p><h1 id="멀티스레드말고-싱글스레드를-쓰기도-하는가"><a href="#멀티스레드말고-싱글스레드를-쓰기도-하는가" class="headerlink" title="멀티스레드말고 싱글스레드를 쓰기도 하는가?"></a>멀티스레드말고 싱글스레드를 쓰기도 하는가?</h1><p>싱글스레드하면 떠오르는 건 node.js이다. 사실 node.js는 싱글스레드도 지원하면서 멀티스레드도 지원한다. 이에 대해서는 블로그글 <a href="https://haeunyah.tistory.com/81">vodkamitlime님의 NodeJS 는 Single Thread 일까? Multi Thread 일까?</a>을 보면 자세히 알수있다.</p><p>언뜻보기에는 멀티스레드가 좋은데 왜 싱글스레드를 지원할까?<br>자바스크립트가 싱글스레드를 지원하기 때문이다. </p><p>싱글스레드를 사용하는 이유는 싱글스레드만의 장점이 있기때문이다.</p><p><br><br><br></p><h1 id="싱글스레드-장단점"><a href="#싱글스레드-장단점" class="headerlink" title="싱글스레드 장단점"></a>싱글스레드 장단점</h1><ul><li>장점<ul><li>자원 접근에 대한 동기화를 신경쓰지 않아도 된다</li><li>작업전환(context switch) 작업을 요구하지 않는다.</li></ul></li><li>단점<ul><li>여러개의 CPU를 활용하지 못한다.</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JAVA/">JAVA</category>
      
      
      
      <comments>https://sowon-dev.github.io/2023/01/04/230105postman-multithread/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[안드로이드] 키스토어란? 개념,정의</title>
      <link>https://sowon-dev.github.io/2023/01/03/230103Android-keystore/</link>
      <guid>https://sowon-dev.github.io/2023/01/03/230103Android-keystore/</guid>
      <pubDate>Tue, 03 Jan 2023 04:51:33 GMT</pubDate>
      
      <description>&lt;p&gt;오늘 회의에서 키스토어에 대해서 이야기가 나왔다. 앱개발은 전혀 모르므로 이참에 공부해봤다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>오늘 회의에서 키스토어에 대해서 이야기가 나왔다. 앱개발은 전혀 모르므로 이참에 공부해봤다.</p><a id="more"></a><h1 id="Keystore란"><a href="#Keystore란" class="headerlink" title="Keystore란?"></a>Keystore란?</h1><p>안드로이드 앱을 구글 플레이스토어에 올리려면 배포할때 개발자가 서명을 해야한다. 이 서명을 코드서명인증서 즉, 키스토어(Keystore)라고 한다.<br>키스토어(Keystore)는 앱 개발자에 대한 정보를 서명한 암호화된 파일이다.</p><p><br><br><br></p><h1 id="왜-Keystore를-사용할까"><a href="#왜-Keystore를-사용할까" class="headerlink" title="왜 Keystore를 사용할까?"></a>왜 Keystore를 사용할까?</h1><p>추후에 버그픽스등으로 해당 앱 업데이트시 서명이 동일한 지 확인한다. 만약 이 서명을 잃어버리면 아무리 내가 만든 앱이라고해도 이 앱을 업데이트 할 수 없다.<br>즉, 키스토어를 통해서 다른 개발자가 내 앱을 변조 못하게 막는 역할을 한다.</p>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Android/">Android</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%98%A4%EB%8A%98%EB%98%90%EB%AA%BB%EC%95%8C%EC%95%84%EB%93%A3%EA%B3%A0%EB%A7%90%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/">오늘또못알아듣고말았습니다</category>
      
      
      <comments>https://sowon-dev.github.io/2023/01/03/230103Android-keystore/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AP(Access Point)란? 개념,정의</title>
      <link>https://sowon-dev.github.io/2022/12/29/221230accesspoint/</link>
      <guid>https://sowon-dev.github.io/2022/12/29/221230accesspoint/</guid>
      <pubDate>Thu, 29 Dec 2022 16:09:24 GMT</pubDate>
      
      <description>&lt;p&gt;회의때 무수히 들었던 AP. 도대체 AP가 뭘까?&lt;br&gt;일단 Access Point의 약어이다. 네트워크와 관련된 느낌 물씬!&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>회의때 무수히 들었던 AP. 도대체 AP가 뭘까?<br>일단 Access Point의 약어이다. 네트워크와 관련된 느낌 물씬!</p><a id="more"></a><h1 id="AP란"><a href="#AP란" class="headerlink" title="AP란"></a>AP란</h1><p>AP는 유선랜의 유선신호를 무선으로 변경해주는 것이다. → 회사 내부망이 유선랜인데 다양한 기기에서 사용하려면 무선랜으로 바꿔주면 편리하다.<br>AP는 DHCP 서버에서 IP를 할당해줘야한다.</p><blockquote><p>무선랜을 구성하는 장치중 하나로, 유선랜과 무선랜을 연결시켜주는 장치이다.<br>AP는 Access Point의 약어이나, Wireless Access Point라고 하여 WAP 라고도 한다.<br>AP는 대체로 독립형 장치로, 이더넷 허브(Ehternet Hub)나 서버(Server)에 꽂아 사용할 수 있다.<br>AP는 휴대폰(Cellular Phone)처럼 사용자의 위치에 따라 하나의 AP에서 다른 AP로 핸드오프(Hand-off : 넘겨주기) 되므로, 사용자가 이동하면서 이동형 무선장치를 사용할 수 있다.<br>출처: <a href="https://m.blog.naver.com/twers/50118628879">Just Blue - AP(Access Point)</a></p></blockquote><p><br><br><br></p><h1 id="AP와-일반-무선공유기-차이점"><a href="#AP와-일반-무선공유기-차이점" class="headerlink" title="AP와 일반 무선공유기 차이점"></a>AP와 일반 무선공유기 차이점</h1><table><thead><tr><th align="left">일반 무선공유기</th><th align="left">AP</th></tr></thead><tbody><tr><td align="left">한 개의 IP로 여러 명의 네트워크를 사용할 수 있음</td><td align="left">건물의 각 층과 사무실별로 설치할 경우 사무실 내에서 자유롭게 네트워크를 사용할 수 있다는 장점이 있고 안테나의 개수에 따라 사용할 수 있는 범위가 정해지며 넓은 곳일수록 안테나가 많이 달린 제품을 활용하면 좋음</td></tr><tr><td align="left">SSID 3개까지 가능</td><td align="left">SSID 512개까지도 가능</td></tr><tr><td align="left">네트워크선 따로, 전원선 따로</td><td align="left">특정 모델에 따라 네트워크선 하나로 전원까지 공급가능</td></tr><tr><td align="left"></td><td align="left">일반공유기보다 많은 라우팅 기능을 지원</td></tr></tbody></table><ul><li>SSID란?<br>Service Set IDentifier의 약자로 무선네트워크 이름이다.</li></ul><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=futuremain&logNo=221618229181">https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=futuremain&amp;logNo=221618229181</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Network/">Network</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%98%A4%EB%8A%98%EB%98%90%EB%AA%BB%EC%95%8C%EC%95%84%EB%93%A3%EA%B3%A0%EB%A7%90%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/">오늘또못알아듣고말았습니다</category>
      
      
      <comments>https://sowon-dev.github.io/2022/12/29/221230accesspoint/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Spring]@Transactional 속성 총정리</title>
      <link>https://sowon-dev.github.io/2022/12/22/221223spring-transactional-annotation/</link>
      <guid>https://sowon-dev.github.io/2022/12/22/221223spring-transactional-annotation/</guid>
      <pubDate>Thu, 22 Dec 2022 20:35:29 GMT</pubDate>
      
      <description>&lt;p&gt;레거시 코드를 분석하면서 다양한 @Transactional 속성을 만났다.&lt;br&gt;평소에 디폴트로만 썼었기에 이참에 정리해보았다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>레거시 코드를 분석하면서 다양한 @Transactional 속성을 만났다.<br>평소에 디폴트로만 썼었기에 이참에 정리해보았다.</p><a id="more"></a><h1 id="Transactional-이란"><a href="#Transactional-이란" class="headerlink" title="@Transactional 이란?"></a>@Transactional 이란?</h1><p>먼저 Transaction을 살펴보자. 트랜젝션은 데이터베이스의 상태를 변화시키기 위한 작업 수행의 논리적 단위를 의미한다.<br>테스트를 위해 서비스에서 SQL쿼리를 호출한 후 롤백을 해야하는 경우라든지 전체 실행 중 특정 수행이 오류가 나면 이전에 완료했던 SQL쿼리들을 다 롤백해야할 경우에 @Transactional을 사용한다.</p><p>자세한 내용은 포스팅 <a href="https://sowon-dev.github.io/2021/08/04/210805Spring-Transactional/">@Transactional 쓰는 이유</a>를 참고하면 된다.</p><p><br><br><br></p><h1 id="Transactional-에-우선순위가-있다"><a href="#Transactional-에-우선순위가-있다" class="headerlink" title="@Transactional 에 우선순위가 있다?"></a>@Transactional 에 우선순위가 있다?</h1><p>@Transactional은 우선순위를 가지고 있다.</p><ol><li>클래스 메서드</li><li>클래스</li><li>인터페이스 메서드</li><li>인터페이스</li></ol><p>클래스 메서드에 선언된 트랜잭션의 우선순위가 가장 높다.<br>가장 구체적으로 구현된 것부터 트랜잭션순위가 높다고 생각하면 된다.</p><p><br><br><br></p><h1 id="속성"><a href="#속성" class="headerlink" title="속성"></a>속성</h1><table><thead><tr><th align="center">속성명</th><th align="center">특징</th><th align="center">옵션</th></tr></thead><tbody><tr><td align="center">isolation</td><td align="center">일관성없는 데이터 허용 수준을 설정</td><td align="center">DEFAULT, READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE</td></tr><tr><td align="center">noRollbackFor, rollbackFor</td><td align="center">특정 예외발생시 rollback하지않음 or rollback함으로 설정</td><td align="center"></td></tr><tr><td align="center">noRollbackForClassName, rollbackForClassName</td><td align="center">특정 클래스이름인 경우 rollback하지않음 or rollback함으로 설정</td><td align="center">(e.g)rollbackForClassName=”Exception”</td></tr><tr><td align="center">propagation(전파속성)</td><td align="center">트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 설정</td><td align="center">REQUIRED(Defualt), REQUIRES_NEW, SUPPORT, NOT_SUPPORT, MANDATORY, NEVER, NESTED</td></tr><tr><td align="center">readOnly</td><td align="center">트랜잭션을 읽기 전용으로 설정. true면 insert, update, delete 실행 시 예외 발생</td><td align="center">true, false(Defualt)</td></tr><tr><td align="center">timeout, timeoutString</td><td align="center">지정한 시간내에 메서드수행이 완료되지 않으면 rollback함으로설정(단위 : 초,seconds)</td><td align="center"></td></tr><tr><td align="center">transactionManager</td><td align="center">특정 Transaction의 qualifier value를 설정</td><td align="center"></td></tr><tr><td align="center">value</td><td align="center">transactionManager의 alias(별칭)을 설정한다.</td><td align="center"></td></tr></tbody></table><ul><li><a href="https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation">https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation</a></li><li><a href="https://n1tjrgns.tistory.com/266">https://n1tjrgns.tistory.com/266</a></li></ul><p><br><br><br></p><h1 id="isolation-레벨"><a href="#isolation-레벨" class="headerlink" title="isolation 레벨"></a>isolation 레벨</h1><ol><li>DEFAULT : 기본 격리 수준</li><li>READ_UNCOMMITED (level 0): 트랜잭션의 동시 액세스 허용, 커밋되지 않는 데이터에 대한 읽기를 허용</li><li>READ_COMMITED (level 1) : 커밋된 데이터에 대해 읽기 허용, Dirty read 방지</li><li>REPEATEABLE_READ (level 2) : 동시 액세스를 허용하지 않음, 동일 필드에 대해 다중 접근 시 모두 동일한 결과를 보장, Dirty read, Nonrepeatable read 방지</li><li>SERIALIZABLE (level 3) : 가장 높은 격리, 성능 저하의 우려가 있음, 모든 부작용을 방지</li></ol><p><br><br><br></p><h2 id="isolation-문제점"><a href="#isolation-문제점" class="headerlink" title="isolation 문제점"></a>isolation 문제점</h2><p><a href="https://feco.tistory.com/45">feco님 블로그 글 - 트랜잭션, 트랜잭션 격리수준(Isolation Level)</a>에 예시까지 잘 설명되어있다! 꼭 읽어보길!<br>아래는 feco님 블로그글의 격리성 문제점부분만 발췌했다.</p><ol><li>Dirty Read: 한 트랜잭션(T1)이 데이타에 접근하여 값을 ‘A’에서 ‘B’로 변경했고 아직 커밋을 하지 않았을때, 다른 트랜잭션(T2)이 해당 데이타를 Read 하면? T2가 읽은 데이타는 B가 될 것이다. 하지만 T1이 최종 커밋을 하지 않고 종료된다면, T2가 가진 데이타는 꼬이게 된다.</li><li>Non-Repeatable Read: 한 트랜잭션(T1)이 데이타를 Read 하고 있다. 이때 다른 트랜잭션(T2)가 데이타에 접근하여 값을 변경 또는, 데이타를 삭제하고 커밋을 때려버리면? 그 후 T1이 다시 해당 데이타를 Read하고자 하면 변경된 데이타 혹은 사라진 데이타를 찾게 된다.</li><li>Phantom Read: 트랜잭션(T1) 중에 특정 조건으로 데이타를 검색하여 결과를 얻었다. 이때 다른 트랜잭션(T2)가 접근해 해당 조건의 데이타 일부를 삭제 또는 추가 했을때, 아직 끝나지 않은 T1이 다시 한번 해당 조건으로 데이타를 조회 하면 T2에서 추가/삭제된 데이타가 함께 조회/누락 된다. 그리고 T2가 롤백을 하면? 데이타가 꼬인다</li></ol><p><br><br><br></p><h1 id="propagation-전파속성-레벨"><a href="#propagation-전파속성-레벨" class="headerlink" title="propagation(전파속성) 레벨"></a>propagation(전파속성) 레벨</h1><p>트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 전파속성을 선택할 수 있다. 총 7가지 속성이 있다.</p><ol><li>REQUIRED(Defualt): 이미 진행중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 진행중이 아니라면 새로운 트랜잭션을 생성한다.</li><li>REQUIRES_NEW: 항상 새로운 트랜잭션을 생성한다. 이미 진행중인 트랜잭션이 있다면 잠깐 보류하고 해당 트랜잭션 작업을 먼저 진행한다.</li><li>SUPPORT: 이미 진행 중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 없다면 트랜잭션을 설정하지 않는다.</li><li>NOT_SUPPORT: 이미 진행중인 트랜잭션이 있다면 보류하고, 트랜잭션 없이 작업을 수행한다.</li><li>MANDATORY: 이미 진행중인 트랜잭션이 있어야만, 작업을 수행한다. 없다면 Exception을 발생시킨다.</li><li>NEVER: 트랜잭션이 진행중이지 않을 때 작업을 수행한다. 트랜잭션이 있다면 Exception을 발생시킨다.</li><li>NESTED: 진행중인 트랜잭션이 있다면 중첩된 트랜잭션이 실행되며, 존재하지 않으면 REQUIRED와 동일하게 실행된다.</li></ol><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html</a></li><li><a href="https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation">https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation</a></li><li><a href="https://velog.io/@kdhyo/JavaTransactional-Annotation-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-26her30h">https://velog.io/@kdhyo/JavaTransactional-Annotation-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-26her30h</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/12/22/221223spring-transactional-annotation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Server]Mock Server(목서버)는 어때요?</title>
      <link>https://sowon-dev.github.io/2022/12/21/221222server-mockserver/</link>
      <guid>https://sowon-dev.github.io/2022/12/21/221222server-mockserver/</guid>
      <pubDate>Wed, 21 Dec 2022 19:52:19 GMT</pubDate>
      
      <description>&lt;p&gt;오늘 회의에서 신규서비스 테스트를 위해 Mock서버, jUnit단위테스트 등의 이야기가 나왔다.&lt;br&gt;외부 API를 테스트를 하려면 어떻게 해야할까?&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>오늘 회의에서 신규서비스 테스트를 위해 Mock서버, jUnit단위테스트 등의 이야기가 나왔다.<br>외부 API를 테스트를 하려면 어떻게 해야할까?</p><a id="more"></a><p>jUnit에 관해서는 이전에 작성한 <a href="https://sowon-dev.github.io/2021/08/12/210813Spring-junit/#Mock">Junit</a> 포스팅을 참고하면 된다.<br>그럼 목서버는 무엇일까?</p><h1 id="먼저-MOCK-목-이-뭘까"><a href="#먼저-MOCK-목-이-뭘까" class="headerlink" title="먼저 MOCK(목)이 뭘까?"></a>먼저 MOCK(목)이 뭘까?</h1><blockquote><p>실제 사용되어야하는 객체의 대체객체로 실제 객체를 만들어서 하기엔 시간이 부족하고 비용이 높은 경우, 구현이 까다로울 경우에 가짜 객체를 만들어서 사용하는데 그중 하나가 Mock객체이다.<br>Mock객체: 행위를 검증하기 위해 사용되는 객체<br>직접 만들거나 스프링프레임워크를 통해서 간단하게 만들수 있음<br>출처: <a href="https://sowon-dev.github.io/2021/08/12/210813Spring-junit/#Mock">Junit - Mock 객체</a></p></blockquote><p><br><br><br></p><h1 id="Mock-서버란"><a href="#Mock-서버란" class="headerlink" title="Mock 서버란?"></a>Mock 서버란?</h1><blockquote><p>For any system you integrate with via HTTP or HTTPS MockServer can be used as:<br>a mock configured to return specific responses for different requests<br>a proxy recording and optionally modifying requests and responses<br>both a proxy for some requests and a mock for other requests at the same time<br>When MockServer receives a request it matches the request against active expectations that have been configured.<br>Then, if no matches are found, it proxies the request if appropriate; otherwise a 404 is returned.<br>For each request received the following steps happen:<br>find matching expectation and perform action<br>if no matching expectation proxy request<br>if not a proxy request return 404<br>An expectation defines the action that is taken, for example, a response could be returned.<br>출처: <a href="https://www.mock-server.com/">https://www.mock-server.com/</a></p></blockquote><p>간단하게 말하자면, 실제 서버처럼 HTTP나 HTTPS 요청과 응답을 주고 받을 수 있는 가짜 서버이다. </p><ul><li>다양한 요청에 특정한 반응을 반환하도록 구성할 수 있음</li><li>프록시를 기록하고 선택적으로 요청과 응답을 수정할 수 있음</li><li>목서버가 예상되는 요청을 받았을땐 이미 작성된 특정 반응을 반환하고 예상되지 않는 요청인 경우 404를 리턴한다.</li></ul><p><br><br><br></p><h1 id="왜-목서버를-사용할까"><a href="#왜-목서버를-사용할까" class="headerlink" title="왜 목서버를 사용할까?"></a>왜 목서버를 사용할까?</h1><p>크게 3가지 이유가 있다.</p><ul><li>testing via HTTP or HTTPS, such as a REST or RPC service.<ul><li>만약 스펙만 존재하고 실제 동작하지 않는 API를 염두하고 해당 API의 데이터를 받는 부분을 개발해야 한다면 어떻게 해야할까? 이럴 때 필요한 것이 가상의 서버, 바로 Mock Server이다.</li></ul></li><li>de-coupling development</li><li>isolate single service</li></ul><p><br><br><br></p><h1 id="목서버를-만드는-방법"><a href="#목서버를-만드는-방법" class="headerlink" title="목서버를 만드는 방법"></a>목서버를 만드는 방법</h1><p>구글링했을때 가장 많이 나오는 방법은 PostMan을 활용하는 것이다. 하지만 무료요금제인 경우 한달에 1000건 요청제한이 있다.<br><a href="https://way-be-developer.tistory.com/239">Postman 으로 Mock Server 구축하기</a>글을 참고!</p><p><br><br><br></p><h1 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h1><ul><li><a href="https://opennote46.tistory.com/208">https://opennote46.tistory.com/208</a></li><li><a href="https://www.mock-server.com/">https://www.mock-server.com/</a></li><li><a href="https://sowon-dev.github.io/2021/08/12/210813Spring-junit/#Mock">Junit - Mock 객체</a></li><li><a href="https://devvkkid.tistory.com/219">https://devvkkid.tistory.com/219</a></li><li><a href="https://velog.io/@kyle/%EC%99%B8%EB%B6%80-API%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%A0-%EA%B2%83%EC%9D%B8%EA%B0%80">우아한마켓 - 외부 API를 어떻게 테스트 할 것인가?</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Server/">Server</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%98%A4%EB%8A%98%EB%98%90%EB%AA%BB%EC%95%8C%EC%95%84%EB%93%A3%EA%B3%A0%EB%A7%90%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/">오늘또못알아듣고말았습니다</category>
      
      
      <comments>https://sowon-dev.github.io/2022/12/21/221222server-mockserver/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Spring]ResponseEntity 코드리뷰</title>
      <link>https://sowon-dev.github.io/2022/12/20/221221java-responseentity-refactoring/</link>
      <guid>https://sowon-dev.github.io/2022/12/20/221221java-responseentity-refactoring/</guid>
      <pubDate>Tue, 20 Dec 2022 15:31:41 GMT</pubDate>
      
      <description>&lt;p&gt;RestTemplate을 통해서 외부 API와 통신하는 메서드를 구현하고 있었다.&lt;br&gt;팀장님이 내 코드를 보시더니 코드리뷰를 해주셨다. (바쁘신 와중에도 코드봐주셔서 감사합니다🙂)&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>RestTemplate을 통해서 외부 API와 통신하는 메서드를 구현하고 있었다.<br>팀장님이 내 코드를 보시더니 코드리뷰를 해주셨다. (바쁘신 와중에도 코드봐주셔서 감사합니다🙂)</p><a id="more"></a><h1 id="내코드"><a href="#내코드" class="headerlink" title="내코드"></a>내코드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResponseVO&lt;T&gt; 클래스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseVO</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"><span class="keyword">private</span> T payload;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testVO 클래스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVO</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래처럼 exchange()를 실행하는 코드였다. RestTemplate과 HttpEntity가 궁금한 사람은 <a href="https://sowon-dev.github.io/2022/12/09/221210spring-resttemplate/">RestTemplate과 HttpEntity가 뭐길래</a>글을 참고하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;ResponseVO&lt;TestVO&gt;&gt; response = rt.exchange(</span><br><span class="line"><span class="string">"http://localhost:3000/"</span>,</span><br><span class="line">HttpMethod.POST,</span><br><span class="line">testJson,</span><br><span class="line"><span class="keyword">new</span> ParameterizedtypeReference&lt;ResponseVO&lt;TestVO&gt;&gt;()&#123;&#125; <span class="comment">//반환되는 데이터타입</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>여기서 좀 더 나은 코드가 있다고 말씀해주셨다.</p><p><br><br><br></p><h1 id="코드리뷰"><a href="#코드리뷰" class="headerlink" title="코드리뷰"></a>코드리뷰</h1><p>OOP(객체지향프로그램)를 설명해주시면서 java lang reflect으로 데이터타입을 유연하게 가져갈 수 있다고 말씀해주셨다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity = rt.exchange(</span><br><span class="line"><span class="string">"http://localhost:3000/"</span>, </span><br><span class="line">HttpMethod.POST, </span><br><span class="line">httpEntity, </span><br><span class="line">string<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line">String bodyofResponseEntity = responseEntity.getBody();</span><br><span class="line">Gson gson= <span class="keyword">new</span> Gson();</span><br><span class="line">Type gType = TypeToken.getparameterized(ResponseVO.class, TestVO.class).getType():</span><br><span class="line">ResponseVO&lt;TestVO&gt; responsevo = gson.fromJson(responseentity.getBody(), gType);</span><br></pre></td></tr></table></figure><p>기존 코드와 가장 큰 차이점은 ResponseEntity반환데이터 타입을 String으로 설정했다는 점이다.<br>그 이유는 무엇일까?<br>만약 특정한 데이터타입을 지정해놓으면 exchange()한 뒤 반환데이터타입 형식이 안 맞는 경우 exchage()를 성공적으로 수행했음에도 타입변환에러가 발생한다.<br>이를 예방하기 위해 String으로 반환데이터를 받으면된다!</p><p><br><br><br></p><h2 id="반환데이터타입을-왜-굳이-String을-쓸까"><a href="#반환데이터타입을-왜-굳이-String을-쓸까" class="headerlink" title="반환데이터타입을 왜 굳이 String을 쓸까?"></a>반환데이터타입을 왜 굳이 String을 쓸까?</h2><p>반환타입을 String으로 쓰면 좋은 점은 크게 3가지가 있다.</p><ol><li>exchage()하는 도중에 에러가 발생한건지, 캐스팅중에 에러가 발생한건지 명확하게 파악가능</li><li>String변수<code>bodyofResponseEntity</code>에 값을 대입함으로서 데이터 유실을 예방가능</li></ol><p><br><br><br></p><h2 id="String데이터를-원하는-데이터로-캐스팅하려면"><a href="#String데이터를-원하는-데이터로-캐스팅하려면" class="headerlink" title="String데이터를 원하는 데이터로 캐스팅하려면?"></a>String데이터를 원하는 데이터로 캐스팅하려면?</h2><p><a href="https://sites.google.com/site/gson/gson-user-guide#TOC-Using-Gson">구글에서 만든 Gson</a>을 이용하면 된다.<br>String데이터를 Gson으로 원하는 <code>ResponseVO&lt;TestVO&gt;</code>로 변환하면 해결!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Gson gson= <span class="keyword">new</span> Gson();</span><br><span class="line">Type gType = TypeToken.getparameterized(ResponseVO.class, TestVO.class).getType():</span><br><span class="line">ResponseVO&lt;TestVO&gt; responsevo = gson.fromJson(responseentity.getBody(), gType);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%B0%A8%EC%9D%B4/">차이</category>
      
      
      <comments>https://sowon-dev.github.io/2022/12/20/221221java-responseentity-refactoring/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[네트워크]페이로드(payload)가 뭐길래? 개념,정의</title>
      <link>https://sowon-dev.github.io/2022/12/15/221216payload/</link>
      <guid>https://sowon-dev.github.io/2022/12/15/221216payload/</guid>
      <pubDate>Thu, 15 Dec 2022 19:54:50 GMT</pubDate>
      
      <description>&lt;p&gt;외부API와 통신을 하면서 payload를 많이 만나게 되었다. 어렴풋이 알고 있는 이 단어, 생긴 건 JSON과 비슷한데 왜 PAYLOAD라고 부를까?&lt;br&gt;궁금한 건 해결해야지!&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>외부API와 통신을 하면서 payload를 많이 만나게 되었다. 어렴풋이 알고 있는 이 단어, 생긴 건 JSON과 비슷한데 왜 PAYLOAD라고 부를까?<br>궁금한 건 해결해야지!</p><a id="more"></a><h1 id="내가-알고있었던-payload"><a href="#내가-알고있었던-payload" class="headerlink" title="내가 알고있었던 payload"></a>내가 알고있었던 payload</h1><p>성공이나 실패등이 일어났을때 내가 챙겨 보고 싶은 message.</p><p><br><br><br></p><h1 id="정확한-개념"><a href="#정확한-개념" class="headerlink" title="정확한 개념"></a>정확한 개념</h1><p>위키백과에 예시까지 설명이 잘되어있어서 정리해보았다.</p><ul><li>개념: 전송되는 데이터</li><li>페이로드는 크게 2가지 의미<ol><li>전송의 근본적인 목적이 되는 데이터의 일부분으로 그 데이터와 함께 전송되는 헤더와 메타데이터와 같은 데이터는 제외한다.</li><li>컴퓨터 보안에서 페이로드는 멀웨어의 일부를 뜻한다. 웜, 바이러스, 트로이목마 같은 해로운 소프트웨어를 분석할 때 페이로드는 그 소프트웨어가 주는 피해를 뜻한다. 예를 들어 페이로드에는 데이터 훼손, 스팸메일, 개인정보를 알아내기 위해 다수에게 보내는 이메일 등이 있다. 즉 페이로드는 전송 행위의 본래 의도를 뜻한다.</li></ol></li><li>특징<ol><li>페이로드라는 용어는 큰 데이터 덩어리 중에 ‘흥미 있는’ 데이터를 구별하는 데 사용된다.</li><li>프로그래밍에서 주로 메시지 프로토콜(message protocols) 중에 프로토콜 오버헤드(protocol overhead)와 원하는 데이터를 구별할 때 사용된다. </li></ol></li></ul><p> 웹 서비스 응답(web service response)이 아래의 JSON이라 해보자</p><ul><li><h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"status"</span>:<span class="string">"OK"</span>,</span><br><span class="line"><span class="attr">"data"</span>: &#123;</span><br><span class="line"><span class="attr">"message"</span>:<span class="string">"Hello, world!"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>여기서 “Hello, world!”가 클라이언트가 관심을 가지는 페이로드이다. 나머지 부분은, 중요하긴 하지만, 프로토콜 오버헤드이다.</p><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EB%A1%9C%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85)">https://ko.wikipedia.org/wiki/페이로드</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Network/">Network</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/12/15/221216payload/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
