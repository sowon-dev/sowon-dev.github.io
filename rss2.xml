<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>야망찬 개발자의 블로그</title>
    <link>https://sowon-dev.github.io/</link>
    
    <atom:link href="https://sowon-dev.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>devlog</description>
    <pubDate>Wed, 28 Dec 2022 04:54:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Spring]@Transactional 속성 총정리</title>
      <link>https://sowon-dev.github.io/2022/12/22/221223spring-transactional-annotation/</link>
      <guid>https://sowon-dev.github.io/2022/12/22/221223spring-transactional-annotation/</guid>
      <pubDate>Thu, 22 Dec 2022 20:35:29 GMT</pubDate>
      
      <description>&lt;p&gt;레거시 코드를 분석하면서 다양한 @Transactional 속성을 만났다.&lt;br&gt;평소에 디폴트로만 썼었기에 이참에 정리해보았다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>레거시 코드를 분석하면서 다양한 @Transactional 속성을 만났다.<br>평소에 디폴트로만 썼었기에 이참에 정리해보았다.</p><a id="more"></a><h1 id="Transactional-이란"><a href="#Transactional-이란" class="headerlink" title="@Transactional 이란?"></a>@Transactional 이란?</h1><p>먼저 Transaction을 살펴보자. 트랜젝션은 데이터베이스의 상태를 변화시키기 위한 작업 수행의 논리적 단위를 의미한다.<br>테스트를 위해 서비스에서 SQL쿼리를 호출한 후 롤백을 해야하는 경우라든지 전체 실행 중 특정 수행이 오류가 나면 이전에 완료했던 SQL쿼리들을 다 롤백해야할 경우에 @Transactional을 사용한다.</p><p>자세한 내용은 포스팅 <a href="https://sowon-dev.github.io/2021/08/04/210805Spring-Transactional/">@Transactional 쓰는 이유</a>를 참고하면 된다.</p><p><br><br><br></p><h1 id="Transactional-에-우선순위가-있다"><a href="#Transactional-에-우선순위가-있다" class="headerlink" title="@Transactional 에 우선순위가 있다?"></a>@Transactional 에 우선순위가 있다?</h1><p>@Transactional은 우선순위를 가지고 있다.</p><ol><li>클래스 메서드</li><li>클래스</li><li>인터페이스 메서드</li><li>인터페이스</li></ol><p>클래스 메서드에 선언된 트랜잭션의 우선순위가 가장 높다.<br>가장 구체적으로 구현된 것부터 트랜잭션순위가 높다고 생각하면 된다.</p><p><br><br><br></p><h1 id="속성"><a href="#속성" class="headerlink" title="속성"></a>속성</h1><table><thead><tr><th align="center">속성명</th><th align="center">특징</th><th align="center">옵션</th></tr></thead><tbody><tr><td align="center">isolation</td><td align="center">일관성없는 데이터 허용 수준을 설정</td><td align="center">DEFAULT, READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE</td></tr><tr><td align="center">noRollbackFor, rollbackFor</td><td align="center">특정 예외발생시 rollback하지않음 or rollback함으로 설정</td><td align="center"></td></tr><tr><td align="center">noRollbackForClassName, rollbackForClassName</td><td align="center">특정 클래스이름인 경우 rollback하지않음 or rollback함으로 설정</td><td align="center">(e.g)rollbackForClassName=”Exception”</td></tr><tr><td align="center">propagation(전파속성)</td><td align="center">트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 설정</td><td align="center">REQUIRED(Defualt), REQUIRES_NEW, SUPPORT, NOT_SUPPORT, MANDATORY, NEVER, NESTED</td></tr><tr><td align="center">readOnly</td><td align="center">트랜잭션을 읽기 전용으로 설정. true면 insert, update, delete 실행 시 예외 발생</td><td align="center">true, false(Defualt)</td></tr><tr><td align="center">timeout, timeoutString</td><td align="center">지정한 시간내에 메서드수행이 완료되지 않으면 rollback함으로설정(단위 : 초,seconds)</td><td align="center"></td></tr><tr><td align="center">transactionManager</td><td align="center">특정 Transaction의 qualifier value를 설정</td><td align="center"></td></tr><tr><td align="center">value</td><td align="center">transactionManager의 alias(별칭)을 설정한다.</td><td align="center"></td></tr></tbody></table><ul><li><a href="https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation">https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation</a></li><li><a href="https://n1tjrgns.tistory.com/266">https://n1tjrgns.tistory.com/266</a></li></ul><p><br><br><br></p><h1 id="isolation-레벨"><a href="#isolation-레벨" class="headerlink" title="isolation 레벨"></a>isolation 레벨</h1><ol><li>DEFAULT : 기본 격리 수준</li><li>READ_UNCOMMITED (level 0): 트랜잭션의 동시 액세스 허용, 커밋되지 않는 데이터에 대한 읽기를 허용</li><li>READ_COMMITED (level 1) : 커밋된 데이터에 대해 읽기 허용, Dirty read 방지</li><li>REPEATEABLE_READ (level 2) : 동시 액세스를 허용하지 않음, 동일 필드에 대해 다중 접근 시 모두 동일한 결과를 보장, Dirty read, Nonrepeatable read 방지</li><li>SERIALIZABLE (level 3) : 가장 높은 격리, 성능 저하의 우려가 있음, 모든 부작용을 방지</li></ol><p><br><br><br></p><h2 id="isolation-문제점"><a href="#isolation-문제점" class="headerlink" title="isolation 문제점"></a>isolation 문제점</h2><p><a href="https://feco.tistory.com/45">feco님 블로그 글 - 트랜잭션, 트랜잭션 격리수준(Isolation Level)</a>에 예시까지 잘 설명되어있다! 꼭 읽어보길!<br>아래는 feco님 블로그글의 격리성 문제점부분만 발췌했다.</p><ol><li>Dirty Read<br>한 트랜잭션(T1)이 데이타에 접근하여 값을 ‘A’에서 ‘B’로 변경했고 아직 커밋을 하지 않았을때, 다른 트랜잭션(T2)이 해당 데이타를 Read 하면? T2가 읽은 데이타는 B가 될 것이다. 하지만 T1이 최종 커밋을 하지 않고 종료된다면, T2가 가진 데이타는 꼬이게 된다.</li></ol><br>2. Non-Repeatable Read한 트랜잭션(T1)이 데이타를 Read 하고 있다. 이때 다른 트랜잭션(T2)가 데이타에 접근하여 값을 변경 또는, 데이타를 삭제하고 커밋을 때려버리면? 그 후 T1이 다시 해당 데이타를 Read하고자 하면 변경된 데이타 혹은 사라진 데이타를 찾게 된다.<br>3. Phantom Read트랜잭션(T1) 중에 특정 조건으로 데이타를 검색하여 결과를 얻었다. 이때 다른 트랜잭션(T2)가 접근해 해당 조건의 데이타 일부를 삭제 또는 추가 했을때, 아직 끝나지 않은 T1이 다시 한번 해당 조건으로 데이타를 조회 하면 T2에서 추가/삭제된 데이타가 함께 조회/누락 된다. 그리고 T2가 롤백을 하면? 데이타가 꼬인다<p><br><br><br></p><h1 id="propagation-전파속성-레벨"><a href="#propagation-전파속성-레벨" class="headerlink" title="propagation(전파속성) 레벨"></a>propagation(전파속성) 레벨</h1><p>트랜잭션 동작 도중 다른 트랜잭션을 호출할 때, 어떻게 할 것인지 전파속성을 선택할 수 있다. 총 7가지 속성이 있다.</p><ol><li>REQUIRED(Defualt): 이미 진행중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 진행중이 아니라면 새로운 트랜잭션을 생성한다.</li><li>REQUIRES_NEW: 항상 새로운 트랜잭션을 생성한다. 이미 진행중인 트랜잭션이 있다면 잠깐 보류하고 해당 트랜잭션 작업을 먼저 진행한다.</li><li>SUPPORT: 이미 진행 중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 없다면 트랜잭션을 설정하지 않는다.</li><li>NOT_SUPPORT: 이미 진행중인 트랜잭션이 있다면 보류하고, 트랜잭션 없이 작업을 수행한다.</li><li>MANDATORY: 이미 진행중인 트랜잭션이 있어야만, 작업을 수행한다. 없다면 Exception을 발생시킨다.</li><li>NEVER: 트랜잭션이 진행중이지 않을 때 작업을 수행한다. 트랜잭션이 있다면 Exception을 발생시킨다.</li><li>NESTED: 진행중인 트랜잭션이 있다면 중첩된 트랜잭션이 실행되며, 존재하지 않으면 REQUIRED와 동일하게 실행된다.</li></ol><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html</a></li><li><a href="https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation">https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation</a></li><li><a href="https://velog.io/@kdhyo/JavaTransactional-Annotation-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-26her30h">https://velog.io/@kdhyo/JavaTransactional-Annotation-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-26her30h</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/12/22/221223spring-transactional-annotation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Server]Mock Server(목서버)는 어때요?</title>
      <link>https://sowon-dev.github.io/2022/12/21/221222server-mockserver/</link>
      <guid>https://sowon-dev.github.io/2022/12/21/221222server-mockserver/</guid>
      <pubDate>Wed, 21 Dec 2022 19:52:19 GMT</pubDate>
      
      <description>&lt;p&gt;오늘 회의에서 신규서비스 테스트를 위해 Mock서버, jUnit단위테스트 등의 이야기가 나왔다.&lt;br&gt;외부 API를 테스트를 하려면 어떻게 해야할까?&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>오늘 회의에서 신규서비스 테스트를 위해 Mock서버, jUnit단위테스트 등의 이야기가 나왔다.<br>외부 API를 테스트를 하려면 어떻게 해야할까?</p><a id="more"></a><p>jUnit에 관해서는 이전에 작성한 <a href="https://sowon-dev.github.io/2021/08/12/210813Spring-junit/#Mock">Junit</a> 포스팅을 참고하면 된다.<br>그럼 목서버는 무엇일까?</p><h1 id="먼저-MOCK-목-이-뭘까"><a href="#먼저-MOCK-목-이-뭘까" class="headerlink" title="먼저 MOCK(목)이 뭘까?"></a>먼저 MOCK(목)이 뭘까?</h1><blockquote><p>실제 사용되어야하는 객체의 대체객체로 실제 객체를 만들어서 하기엔 시간이 부족하고 비용이 높은 경우, 구현이 까다로울 경우에 가짜 객체를 만들어서 사용하는데 그중 하나가 Mock객체이다.<br>Mock객체: 행위를 검증하기 위해 사용되는 객체<br>직접 만들거나 스프링프레임워크를 통해서 간단하게 만들수 있음<br>출처: <a href="https://sowon-dev.github.io/2021/08/12/210813Spring-junit/#Mock">Junit - Mock 객체</a></p></blockquote><p><br><br><br></p><h1 id="Mock-서버란"><a href="#Mock-서버란" class="headerlink" title="Mock 서버란?"></a>Mock 서버란?</h1><blockquote><p>For any system you integrate with via HTTP or HTTPS MockServer can be used as:<br>a mock configured to return specific responses for different requests<br>a proxy recording and optionally modifying requests and responses<br>both a proxy for some requests and a mock for other requests at the same time<br>When MockServer receives a request it matches the request against active expectations that have been configured.<br>Then, if no matches are found, it proxies the request if appropriate; otherwise a 404 is returned.<br>For each request received the following steps happen:<br>find matching expectation and perform action<br>if no matching expectation proxy request<br>if not a proxy request return 404<br>An expectation defines the action that is taken, for example, a response could be returned.<br>출처: <a href="https://www.mock-server.com/">https://www.mock-server.com/</a></p></blockquote><p>간단하게 말하자면, 실제 서버처럼 HTTP나 HTTPS 요청과 응답을 주고 받을 수 있는 가짜 서버이다. </p><ul><li>다양한 요청에 특정한 반응을 반환하도록 구성할 수 있음</li><li>프록시를 기록하고 선택적으로 요청과 응답을 수정할 수 있음</li><li>목서버가 예상되는 요청을 받았을땐 이미 작성된 특정 반응을 반환하고 예상되지 않는 요청인 경우 404를 리턴한다.</li></ul><p><br><br><br></p><h1 id="왜-목서버를-사용할까"><a href="#왜-목서버를-사용할까" class="headerlink" title="왜 목서버를 사용할까?"></a>왜 목서버를 사용할까?</h1><p>크게 3가지 이유가 있다.</p><ul><li>testing via HTTP or HTTPS, such as a REST or RPC service.<ul><li>만약 스펙만 존재하고 실제 동작하지 않는 API를 염두하고 해당 API의 데이터를 받는 부분을 개발해야 한다면 어떻게 해야할까? 이럴 때 필요한 것이 가상의 서버, 바로 Mock Server이다.</li></ul></li><li>de-coupling development</li><li>isolate single service</li></ul><p><br><br><br></p><h1 id="목서버를-만드는-방법"><a href="#목서버를-만드는-방법" class="headerlink" title="목서버를 만드는 방법"></a>목서버를 만드는 방법</h1><p>구글링했을때 가장 많이 나오는 방법은 PostMan을 활용하는 것이다. 하지만 무료요금제인 경우 한달에 1000건 요청제한이 있다.<br><a href="https://way-be-developer.tistory.com/239">Postman 으로 Mock Server 구축하기</a>글을 참고!</p><p><br><br><br></p><h1 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h1><ul><li><a href="https://opennote46.tistory.com/208">https://opennote46.tistory.com/208</a></li><li><a href="https://www.mock-server.com/">https://www.mock-server.com/</a></li><li><a href="https://sowon-dev.github.io/2021/08/12/210813Spring-junit/#Mock">Junit - Mock 객체</a></li><li><a href="https://devvkkid.tistory.com/219">https://devvkkid.tistory.com/219</a></li><li><a href="https://velog.io/@kyle/%EC%99%B8%EB%B6%80-API%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%A0-%EA%B2%83%EC%9D%B8%EA%B0%80">우아한마켓 - 외부 API를 어떻게 테스트 할 것인가?</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Server/">Server</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%98%A4%EB%8A%98%EB%98%90%EB%AA%BB%EC%95%8C%EC%95%84%EB%93%A3%EA%B3%A0%EB%A7%90%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/">오늘또못알아듣고말았습니다</category>
      
      
      <comments>https://sowon-dev.github.io/2022/12/21/221222server-mockserver/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Spring]ResponseEntity 코드리뷰</title>
      <link>https://sowon-dev.github.io/2022/12/20/221221java-responseentity-refactoring/</link>
      <guid>https://sowon-dev.github.io/2022/12/20/221221java-responseentity-refactoring/</guid>
      <pubDate>Tue, 20 Dec 2022 15:31:41 GMT</pubDate>
      
      <description>&lt;p&gt;RestTemplate을 통해서 외부 API와 통신하는 메서드를 구현하고 있었다.&lt;br&gt;팀장님이 내 코드를 보시더니 코드리뷰를 해주셨다. (바쁘신 와중에도 코드봐주셔서 감사합니다🙂)&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>RestTemplate을 통해서 외부 API와 통신하는 메서드를 구현하고 있었다.<br>팀장님이 내 코드를 보시더니 코드리뷰를 해주셨다. (바쁘신 와중에도 코드봐주셔서 감사합니다🙂)</p><a id="more"></a><h1 id="내코드"><a href="#내코드" class="headerlink" title="내코드"></a>내코드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResponseVO&lt;T&gt; 클래스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseVO</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"><span class="keyword">private</span> T payload;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testVO 클래스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVO</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래처럼 exchange()를 실행하는 코드였다. RestTemplate과 HttpEntity가 궁금한 사람은 <a href="https://sowon-dev.github.io/2022/12/09/221210spring-resttemplate/">RestTemplate과 HttpEntity가 뭐길래</a>글을 참고하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;ResponseVO&lt;TestVO&gt;&gt; response = rt.exchange(</span><br><span class="line"><span class="string">"http://localhost:3000/"</span>,</span><br><span class="line">HttpMethod.POST,</span><br><span class="line">testJson,</span><br><span class="line"><span class="keyword">new</span> ParameterizedtypeReference&lt;ResponseVO&lt;TestVO&gt;&gt;()&#123;&#125; <span class="comment">//반환되는 데이터타입</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>여기서 좀 더 나은 코드가 있다고 말씀해주셨다.</p><p><br><br><br></p><h1 id="코드리뷰"><a href="#코드리뷰" class="headerlink" title="코드리뷰"></a>코드리뷰</h1><p>OOP(객체지향프로그램)를 설명해주시면서 java lang reflect으로 데이터타입을 유연하게 가져갈 수 있다고 말씀해주셨다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity = rt.exchange(</span><br><span class="line"><span class="string">"http://localhost:3000/"</span>, </span><br><span class="line">HttpMethod.POST, </span><br><span class="line">httpEntity, </span><br><span class="line">string<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line">String bodyofResponseEntity = responseEntity.getBody();</span><br><span class="line">Gson gson= <span class="keyword">new</span> Gson();</span><br><span class="line">Type gType = TypeToken.getparameterized(ResponseVO.class, TestVO.class).getType():</span><br><span class="line">ResponseVO&lt;TestVO&gt; responsevo = gson.fromJson(responseentity.getBody(), gType);</span><br></pre></td></tr></table></figure><p>기존 코드와 가장 큰 차이점은 ResponseEntity반환데이터 타입을 String으로 설정했다는 점이다.<br>그 이유는 무엇일까?<br>만약 특정한 데이터타입을 지정해놓으면 exchange()한 뒤 반환데이터타입 형식이 안 맞는 경우 exchage()를 성공적으로 수행했음에도 타입변환에러가 발생한다.<br>이를 예방하기 위해 String으로 반환데이터를 받으면된다!</p><p><br><br><br></p><h2 id="반환데이터타입을-왜-굳이-String을-쓸까"><a href="#반환데이터타입을-왜-굳이-String을-쓸까" class="headerlink" title="반환데이터타입을 왜 굳이 String을 쓸까?"></a>반환데이터타입을 왜 굳이 String을 쓸까?</h2><p>반환타입을 String으로 쓰면 좋은 점은 크게 3가지가 있다.</p><ol><li>exchage()하는 도중에 에러가 발생한건지, 캐스팅중에 에러가 발생한건지 명확하게 파악가능</li><li>String변수<code>bodyofResponseEntity</code>에 값을 대입함으로서 데이터 유실을 예방가능</li></ol><p><br><br><br></p><h2 id="String데이터를-원하는-데이터로-캐스팅하려면"><a href="#String데이터를-원하는-데이터로-캐스팅하려면" class="headerlink" title="String데이터를 원하는 데이터로 캐스팅하려면?"></a>String데이터를 원하는 데이터로 캐스팅하려면?</h2><p><a href="https://sites.google.com/site/gson/gson-user-guide#TOC-Using-Gson">구글에서 만든 Gson</a>을 이용하면 된다.<br>String데이터를 Gson으로 원하는 <code>ResponseVO&lt;TestVO&gt;</code>로 변환하면 해결!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Gson gson= <span class="keyword">new</span> Gson();</span><br><span class="line">Type gType = TypeToken.getparameterized(ResponseVO.class, TestVO.class).getType():</span><br><span class="line">ResponseVO&lt;TestVO&gt; responsevo = gson.fromJson(responseentity.getBody(), gType);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%EC%B0%A8%EC%9D%B4/">차이</category>
      
      
      <comments>https://sowon-dev.github.io/2022/12/20/221221java-responseentity-refactoring/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[네트워크]payload가 뭐길래</title>
      <link>https://sowon-dev.github.io/2022/12/15/221216payload/</link>
      <guid>https://sowon-dev.github.io/2022/12/15/221216payload/</guid>
      <pubDate>Thu, 15 Dec 2022 19:54:50 GMT</pubDate>
      
      <description>&lt;p&gt;외부API와 통신을 하면서 payload를 많이 만나게 되었다. 어렴풋이 알고 있는 이 단어, 생긴 건 JSON과 비슷한데 왜 PAYLOAD라고 부를까?&lt;br&gt;궁금한 건 해결해야지!&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>외부API와 통신을 하면서 payload를 많이 만나게 되었다. 어렴풋이 알고 있는 이 단어, 생긴 건 JSON과 비슷한데 왜 PAYLOAD라고 부를까?<br>궁금한 건 해결해야지!</p><a id="more"></a><h1 id="내가-알고있었던-payload"><a href="#내가-알고있었던-payload" class="headerlink" title="내가 알고있었던 payload"></a>내가 알고있었던 payload</h1><p>성공이나 실패등이 일어났을때 내가 챙겨 보고 싶은 message.</p><p><br><br><br></p><h1 id="정확한-개념"><a href="#정확한-개념" class="headerlink" title="정확한 개념"></a>정확한 개념</h1><p>위키백과에 예시까지 설명이 잘되어있어서 정리해보았다.</p><ul><li>개념: 전송되는 데이터</li><li>페이로드는 크게 2가지 의미<ol><li>전송의 근본적인 목적이 되는 데이터의 일부분으로 그 데이터와 함께 전송되는 헤더와 메타데이터와 같은 데이터는 제외한다.</li><li>컴퓨터 보안에서 페이로드는 멀웨어의 일부를 뜻한다. 웜, 바이러스, 트로이목마 같은 해로운 소프트웨어를 분석할 때 페이로드는 그 소프트웨어가 주는 피해를 뜻한다. 예를 들어 페이로드에는 데이터 훼손, 스팸메일, 개인정보를 알아내기 위해 다수에게 보내는 이메일 등이 있다. 즉 페이로드는 전송 행위의 본래 의도를 뜻한다.</li></ol></li><li>특징<ol><li>페이로드라는 용어는 큰 데이터 덩어리 중에 ‘흥미 있는’ 데이터를 구별하는 데 사용된다.</li><li>프로그래밍에서 주로 메시지 프로토콜(message protocols) 중에 프로토콜 오버헤드(protocol overhead)와 원하는 데이터를 구별할 때 사용된다. </li></ol></li></ul><p> 웹 서비스 응답(web service response)이 아래의 JSON이라 해보자</p><ul><li><h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"status"</span>:<span class="string">"OK"</span>,</span><br><span class="line"><span class="attr">"data"</span>: &#123;</span><br><span class="line"><span class="attr">"message"</span>:<span class="string">"Hello, world!"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>여기서 “Hello, world!”가 클라이언트가 관심을 가지는 페이로드이다. 나머지 부분은, 중요하긴 하지만, 프로토콜 오버헤드이다.</p><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EB%A1%9C%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85)">https://ko.wikipedia.org/wiki/페이로드</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Network/">Network</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/12/15/221216payload/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Java] TimeUnit의 sleep() 사용하기</title>
      <link>https://sowon-dev.github.io/2022/12/12/221213java-timeunit/</link>
      <guid>https://sowon-dev.github.io/2022/12/12/221213java-timeunit/</guid>
      <pubDate>Mon, 12 Dec 2022 15:39:23 GMT</pubDate>
      
      <description>&lt;p&gt;js에서는 &lt;a href=&quot;https://sowon-dev.github.io/2019/09/21/190922/&quot;&gt;setTimeout()이나 setInterval()&lt;/a&gt;을 자주 사용했는데 자바에서는 어떻게 사용할까?&lt;br&gt;바로 TimeUnit의 static메서드인 sleep()이 있다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>js에서는 <a href="https://sowon-dev.github.io/2019/09/21/190922/">setTimeout()이나 setInterval()</a>을 자주 사용했는데 자바에서는 어떻게 사용할까?<br>바로 TimeUnit의 static메서드인 sleep()이 있다.</p><a id="more"></a><h1 id="TimeUnit"><a href="#TimeUnit" class="headerlink" title="TimeUnit"></a>TimeUnit</h1><p>TimeUnit는 자바가 제공하는 Enum타입클래스이다.<br>시간에 관한 열거형 클래스로 두날짜의 차이를 구하기, sleep()걸기 등에 유용하게 쓰인다.</p><ul><li>DAYS </li><li>HOURS </li><li>MICROSECONDS </li><li>MILLISECONDS </li><li>MINUTES </li><li>NANOSECONDS </li><li>SECONDS </li></ul><p><br><br><br></p><h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h1><p>TimeUnit.class에 sleep()이 선언되어있다.<br>파라미터에 따라 Thread.sleep()을 쉽게 걸어준다.<br>열거형이기때문에 직관적이고 static 메서드라 바로 사용할 수 있다는 것이 장점이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs a &#123;<span class="doctag">@link</span> Thread#sleep(long, int) Thread.sleep&#125; using</span></span><br><span class="line"><span class="comment"> * this time unit.</span></span><br><span class="line"><span class="comment"> * This is a convenience method that converts time arguments into the</span></span><br><span class="line"><span class="comment"> * form required by the &#123;<span class="doctag">@code</span> Thread.sleep&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout the minimum time to sleep. If less than</span></span><br><span class="line"><span class="comment"> * or equal to zero, do not sleep at all.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if interrupted while sleeping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> ms = toMillis(timeout);</span><br><span class="line"><span class="keyword">int</span> ns = excessNanos(timeout, ms);</span><br><span class="line">Thread.sleep(ms, ns);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h1><p>다양하게 사용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5분 지연시키기</span></span><br><span class="line">TimeUnit.MINUTES.Sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10초 지연시키기</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html">https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JAVA/">JAVA</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/12/12/221213java-timeunit/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Spring]RestTemplate과 HttpEntity가 뭐길래(제네릭과 ParameterizedTypeReference)</title>
      <link>https://sowon-dev.github.io/2022/12/09/221210spring-resttemplate/</link>
      <guid>https://sowon-dev.github.io/2022/12/09/221210spring-resttemplate/</guid>
      <pubDate>Fri, 09 Dec 2022 19:32:44 GMT</pubDate>
      
      <description>&lt;p&gt;프로젝트를 하다보면 화면이 아닌 서비스단에서 외부 API와 호출해야할 일들이 생긴다.&lt;br&gt;이때 주로 사용되는 것이 RestTemplate이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>프로젝트를 하다보면 화면이 아닌 서비스단에서 외부 API와 호출해야할 일들이 생긴다.<br>이때 주로 사용되는 것이 RestTemplate이다.</p><a id="more"></a><p>이번 프로젝트에서 백엔드 업무를 도맡았다. 첫 작업으로 맡게 된 건 외부 프로그램과 API로 연동하는 작업이었다.<br>Http통신을 화면에서 수도없이 날렸지만 서비스단에서 하는 건 업무로썬 처음이었다. 결론 너무 재밌다!<br>역시 난 프론트보단 백이 더 재밌어.</p><h1 id="✍-RestTemplate-이란"><a href="#✍-RestTemplate-이란" class="headerlink" title="✍ RestTemplate 이란?"></a>✍ RestTemplate 이란?</h1><p>스프링 3.0에서부터 지원하는 객체로 REST방식으로 API를 호출할 수 있는 내장 클래스이다.<br>스프링어플리케이션에서 HTTP요청할때 사용하며 주로 외부API와 연동할때 RestTemplate와 함께 MultiValueMap, HttpEntity도 사용한다.<br>다만, 스프링프레임워크5부터는 <a href="https://www.baeldung.com/spring-5-webclient">WebClient</a>사용을 권장하고 있기에 조만간 RestTemplate은 deprecated 될지도 모른다.</p><ul><li><p>특징</p><ul><li>RESTful 원칙을 지킴</li><li>멀티쓰레드 방식 사용</li><li><a href="https://sowon-dev.github.io/2019/09/23/190924/#2-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-%EA%B0%9C%EB%85%90%EC%84%A4%EB%AA%85-Blocking-VS-non-blocking">Blocking(동기) 방식 사용</a></li></ul></li><li><p>함수</p><ul><li><img src="https://velog.velcdn.com/images%2Fsoosungp33%2Fpost%2Fd02efacc-56e6-4abc-a390-12ecbb565c6b%2Fimage.png" alt="출처: https://velog.io/@soosungp33/%EC%8A%A4%ED%94%84%EB%A7%81-RestTemplate-%EC%A0%95%EB%A6%AC%EC%9A%94%EC%B2%AD-%ED%95%A8"></li><li>가장 많이 사용하는 메서드는 당연 exchage()이다.</li><li>exchage() : 모든 HTTP 요청 메소드를 지원하며 원하는 서버에 요청시켜주는 메소드<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;원하는클래스타입&gt; resultMap &#x3D; restTemplate.exchange(uri.toString(), HttpMethod.원하는통신, entity, 원하는클래스타입.class);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><br><br><br></p><h1 id="✍-사용방법"><a href="#✍-사용방법" class="headerlink" title="✍ 사용방법"></a>✍ 사용방법</h1><p><br><br><br></p><h2 id="1-의존성-설정"><a href="#1-의존성-설정" class="headerlink" title="1 의존성 설정"></a>1 의존성 설정</h2><p>스프링부트를 사용하면 이미 포함되어있으므로 의존성 설정을 따로 해줄 필요가 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="2-RestTemplate의-생성"><a href="#2-RestTemplate의-생성" class="headerlink" title="2 RestTemplate의 생성"></a>2 RestTemplate의 생성</h2><ol><li>Header 생성: HTTP요청을 보낼때 Body를 설명해주는 Header도 같이 보내야한다.</li><li>Body 생성: key-value 형식인 MultiValueMap 타입을 사용해서 만든다.</li><li>HttpEntity생성: HTTP통신을 하려면 Header와 Body가 하나여야하는데 HttpEntity클래스가 Header와 Body를 합쳐준다. </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateClientService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. Header생성</span></span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.add(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Body생성</span></span><br><span class="line">MultiValueMap&lt;String, String&gt; params = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">params.add(<span class="string">"name"</span>, <span class="string">"sowon-dev"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. HttpEntity생성</span></span><br><span class="line">HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; entity = <span class="keyword">new</span> HttpEntity&lt;&gt;(params, headers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. HTTP 통신</span></span><br><span class="line">RestTemplate rt = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">ResponseEntity&lt;Map&gt; response = rt.exchange(</span><br><span class="line">                <span class="string">"http://localhost:3000/"</span>, <span class="comment">//요청할 서버주소</span></span><br><span class="line">                HttpMethod.POST, <span class="comment">//요청방식</span></span><br><span class="line">                entity, <span class="comment">//요청데이터</span></span><br><span class="line">                String<span class="class">.<span class="keyword">class</span> //반환되는 데이터타입</span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Map데이터타입을 메서드리턴타입인 String형태로 파싱</span></span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">jsonInString = mapper.writeValueAsString(response.getBody());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jsonInString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="✍-만약-exchange-메서드에서-Generic-클래스를-사용하고싶다면"><a href="#✍-만약-exchange-메서드에서-Generic-클래스를-사용하고싶다면" class="headerlink" title="✍ 만약 exchange 메서드에서 Generic 클래스를 사용하고싶다면?"></a>✍ 만약 exchange 메서드에서 Generic 클래스를 사용하고싶다면?</h1><p>위의 4번에서 exchange()할때 반환되는 데이터타입이 제네릭클래스라면 어떻게 처리할까?<br>하루종일 구글링한 방법을 정리하고자한다.</p><p><br><br><br></p><h2 id="1-현재-상황"><a href="#1-현재-상황" class="headerlink" title="1 현재 상황"></a>1 현재 상황</h2><p>아래처럼 <code>ResponseVO&lt;T&gt;클래스</code>와 <code>TestVO 클래스</code>가 선언되어있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResponseVO&lt;T&gt; 클래스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseVO</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"><span class="keyword">private</span> T payload;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testVO 클래스</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVO</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exchange()를 실행하고자한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;ResponseVO&lt;TestVO&gt;&gt; response = rt.exchange(</span><br><span class="line">                <span class="string">"http://localhost:3000/"</span>,</span><br><span class="line">                HttpMethod.POST,</span><br><span class="line">                testJson,</span><br><span class="line">                ResponseVO&lt;TestVO&gt;<span class="class">.<span class="keyword">class</span> //반환되는 데이터타입</span></span><br><span class="line"><span class="class">)</span>;</span><br></pre></td></tr></table></figure><p>당연히 잘 될꺼라고 생각했던 코드에 빨간 밑줄이 생기면서 에러가 발생했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 에러메시지</span><br><span class="line">ResponseVO cannot be resolved to a variable</span><br><span class="line">TestVO cannot be resolved to a variable</span><br></pre></td></tr></table></figure><p>제네릭클래스인 경우 인스턴스를 어떻게 생성해야할까?</p><p><br><br><br></p><h2 id="2-ParameterizedTypeReference로-해결"><a href="#2-ParameterizedTypeReference로-해결" class="headerlink" title="2 ParameterizedTypeReference로 해결"></a>2 ParameterizedTypeReference로 해결</h2><ul><li>정의: <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/ParameterizedTypeReference.html">ParameterizedTypeReference</a>는 제네릭형식을 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;ResponseVO&lt;TestVO&gt;&gt; response = rt.exchange(</span><br><span class="line"><span class="string">"http://localhost:3000/"</span>,</span><br><span class="line">HttpMethod.POST,</span><br><span class="line">testJson,</span><br><span class="line"><span class="keyword">new</span> ParameterizedtypeReference&lt;ResponseVO&lt;TestVO&gt;&gt;()&#123;&#125; <span class="comment">//반환되는 데이터타입</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>잘해결되었지만 어떤 문제가 있었던걸까? 원인을 알아봤다.</p><h2 id="3-문제-원인"><a href="#3-문제-원인" class="headerlink" title="3 문제 원인"></a>3 문제 원인</h2><ul><li>제네릭은 데이터타입을 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자가 지정한다. </li><li>자바는 컴파일시에 제네릭 타입 정보들을 제거 한다.런타임시에는 실제로 타입정보는 존재 하지 않고 강제 캐스팅 된다.</li></ul><blockquote><p>이런 제네릭 정보가 지워지는 문제 때문에 Super type token 기법이 생겨났다.<br>Super type token은 수퍼(상위)타입을 토큰으로 사용하겠다는 의미이다. 무슨말인가?<br>제네릭 정보가 컴파일시 런타임시 다 지워지지만 제네릭 정보를 런타임시 가져올 방법이 존재한다. 제네릭 클래스를 정의한 후에 그 제네릭 클래스를 상속받으면 런타임시에는 제네릭 정보를 가져올 수 있다.<br>Class의 메소드의 public Type getGenericSuperclass() 메소드를 통해 구할수 있다. getGenericSuperclass() 이용하여 바로 위의 슈퍼 클래스의 타입을 반환한다. 상위타입은 제네릭의 타입토큰 정보가 존재한다.<br>슈퍼(상위)타입의 제네릭 파라미터정보인 Type을 통해 제네릭 파라미터 클래스 정보를 가져온다.<br>출처: <a href="https://ka0oll.tistory.com/m/6">https://ka0oll.tistory.com/m/6</a></p></blockquote><p>제네릭 정보가 지워지는 문제때문에 제네릭타입은 인스턴스를 생성할 수 없는게 흥미로웠다. 구글링할수록 자바를 깊이있게 알 수 있어서 재밌었고 좋은 글 써주신 분들 덕분에 한결 쉽게 이해할 수 있었다.</p><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html</a></li><li><a href="https://sowon-dev.github.io/2021/08/11/210812Spring-resttemplate/">https://sowon-dev.github.io/2021/08/11/210812Spring-resttemplate/</a></li><li><a href="https://jung-story.tistory.com/132">https://jung-story.tistory.com/132</a></li><li><a href="https://www.baeldung.com/rest-template">https://www.baeldung.com/rest-template</a></li><li><a href="https://tecoble.techcourse.co.kr/post/2021-07-25-resttemplate-webclient/">https://tecoble.techcourse.co.kr/post/2021-07-25-resttemplate-webclient/</a></li><li><a href="https://vmpo.tistory.com/27">https://vmpo.tistory.com/27</a></li><li><a href="https://www.skyer9.pe.kr/wordpress/?p=1476">https://www.skyer9.pe.kr/wordpress/?p=1476</a></li><li><a href="https://countryxide.tistory.com/148">https://countryxide.tistory.com/148</a></li><li><a href="https://ka0oll.tistory.com/m/6">https://ka0oll.tistory.com/m/6</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Spring/">Spring</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/12/09/221210spring-resttemplate/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Java] web.xml이 뭐길래</title>
      <link>https://sowon-dev.github.io/2022/12/06/221207sring-webxml/</link>
      <guid>https://sowon-dev.github.io/2022/12/06/221207sring-webxml/</guid>
      <pubDate>Tue, 06 Dec 2022 19:19:12 GMT</pubDate>
      
      <description>&lt;p&gt;자바로 웹어플리케이션을 만드면 필수로 만나게 되는 파일 중 &lt;code&gt;web.xml&lt;/code&gt;이 있다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>자바로 웹어플리케이션을 만드면 필수로 만나게 되는 파일 중 <code>web.xml</code>이 있다.</p><a id="more"></a><h1 id="web-xml이란"><a href="#web-xml이란" class="headerlink" title="web.xml이란"></a>web.xml이란</h1><p>단어로는 Deployment Descriptor로 배포설명자이다.<br>자바 웹 애플리케이션은 배포 설명자 파일을 사용하여 URL이 서블릿에 매핑되는 방법, 인증이 필요한 URL 등의 정보를 확인한다.<br>자바 웹 애플리케이션이면 반드시 하나씩 존재해야하는 파일이며 프로그램에 필요한 전반적인 설정을 지정할 수 있다.<br>프로젝트 실행시 가장 먼저 실행되는 파일로서 메모리에 로딩된다.<br>위치는 WEBCONTENT하위의 WEB-INF폴더 하위에 있으며 가장 많이 사용되는 곳은 에러코드별 페이지처리이다.</p><blockquote><p>In a java web application a file named web.xml is known as deployment descriptor. It is a xml file and <web-app> is the root element for it. When a request comes web server uses web.xml file to map the URL of the request to the specific code that handle the request.<br>출처: <a href="https://www.w3schools.blog/deployment-descriptor-web-xml-file">w3schools</a></p></blockquote><p><br><br><br></p><h1 id="무엇을-설정할수있을까"><a href="#무엇을-설정할수있을까" class="headerlink" title="무엇을 설정할수있을까?"></a>무엇을 설정할수있을까?</h1><ol><li>ServletContext의 초기 파라미터</li><li>Session의 유효시간 설정</li><li>Servlet/JSP에 대한 정의</li><li>Servlet/JSP 매핑: URL 패턴 및 URL이 해당 패턴과 일치하는 요청에 사용할 선언된 서블릿의 이름을 지정. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>redteam<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/red/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>blueteam<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/blue/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Mime Type 매핑</li><li>Welcome File list</li><li>Error Pages 처리 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 존재하지 않는 페이지, 404에러시 처리 페이지를 error.jsp로 설정함 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>리스너: 어떠한 이벤트가 발생하면 호출되어 처리하는 객체 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>TestListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>필터: <a href="https://sowon-dev.github.io/2021/08/06/210807Spring-filter/">Spring-Filter 포스팅참조</a></li><li>보안: 패턴과 일치하는 URL에 대한 보안 제약조건을 정의할 수 있다. 제약조건에서 사용자 역할을 admin으로 지정하면 등록된 애플리케이션 개발자만 URL에 액세스하도록 만들수있다. <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">web-resource-name</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">web-resource-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">role-name</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">role-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://www.w3schools.blog/deployment-descriptor-web-xml-file">https://www.w3schools.blog/deployment-descriptor-web-xml-file</a></li><li><a href="http://wiki.gurubee.net/pages/viewpage.action?pageId=26740333&amp;">http://wiki.gurubee.net/pages/viewpage.action?pageId=26740333&amp;</a></li><li><a href="https://cloud.google.com/appengine/docs/standard/java/config/webxml?hl=ko">https://cloud.google.com/appengine/docs/standard/java/config/webxml?hl=ko</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JAVA/">JAVA</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/WEB/">WEB</category>
      
      
      <comments>https://sowon-dev.github.io/2022/12/06/221207sring-webxml/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[MySQL/MariaDB] xml파일에 PASSWORD()가 뭐길래</title>
      <link>https://sowon-dev.github.io/2022/12/05/221206mariadb-passwordhashing/</link>
      <guid>https://sowon-dev.github.io/2022/12/05/221206mariadb-passwordhashing/</guid>
      <pubDate>Mon, 05 Dec 2022 20:16:15 GMT</pubDate>
      
      <description>&lt;p&gt;xml파일에 선언하지 않았던 AES_DECRYPT(), UNHEX(), PASSWORD() 함수들이 보였다. 쿼리를 읽었을때 암호화와 복호화인건 알았으나 구체적인 사용방법을 알고 싶어 구글링해보니 MARIADB가 제공하는 내장함수였다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>xml파일에 선언하지 않았던 AES_DECRYPT(), UNHEX(), PASSWORD() 함수들이 보였다. 쿼리를 읽었을때 암호화와 복호화인건 알았으나 구체적인 사용방법을 알고 싶어 구글링해보니 MARIADB가 제공하는 내장함수였다.</p><a id="more"></a><ul><li>예시코드</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> USER_NO</span><br><span class="line">, <span class="keyword">AES_DECRYPT</span>(<span class="keyword">UNHEX</span>(USER_NUM), <span class="comment">#&#123;encrypt_key&#125;) AS USER_NUM</span></span><br><span class="line">, <span class="keyword">PASSWORD</span>(<span class="comment">#&#123;user_login_pin&#125;) AS USER_LOGIN_PIN</span></span><br><span class="line"><span class="comment">-- 중략</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">USER</span></span><br></pre></td></tr></table></figure><p>마리아DB 공식문서에 너무 잘 나와있어서 이해하기 훨씬 편했다.</p><ul><li><a href="https://mariadb.com/kb/en/">마리아DB 공식 문서-영어</a></li><li><a href="https://mariadb.com/kb/ko/">마리아DB 공식 문서-한국어</a></li></ul><p>한글버전이 있지만 번역되지 않은 페이지가 더 많으므로 영어로 보는 것을 추천한다.<br>그리고 공식문서를 보기위해선 현재 프로젝트가 어떤 버전을 사용하고 있는지 알아야한다. 사용하고 있는 마리아DB버전에 따라 지원되지 않는 함수가 있을 수 있기때문이다.<br>db를 열어 아래 쿼리를 입력해주면 된다.</p><p><br><br><br></p><h1 id="MariaDB-버전확인-하는-방법"><a href="#MariaDB-버전확인-하는-방법" class="headerlink" title="MariaDB 버전확인 하는 방법"></a>MariaDB 버전확인 하는 방법</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">version</span>();</span><br><span class="line"></span><br><span class="line">// 쿼리 결과 예시</span><br><span class="line">10.3.32-MariaDB-log</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="PASSWORD"><a href="#PASSWORD" class="headerlink" title="PASSWORD()"></a>PASSWORD()</h1><blockquote><p>Calculates and returns a hashed password string from the plaintext password str. Returns an empty string (&gt;= MariaDB 10.0.4) if the argument was NULL.<br>The return value is a nonbinary string in the connection character set and collation, determined by the values of the character_set_connection and collation_connection system variables.<br>This is the function that is used for hashing MariaDB passwords for storage in the Password column of the user table (see privileges), usually used with the SET PASSWORD statement. It is not intended for use in other applications<br>출처: <a href="https://mariadb.com/kb/en/password/">https://mariadb.com/kb/en/password</a></p></blockquote><p>순수 문자열을 입력하면 해시처리된 문자열로 바꿔주는 함수이다. 만약 순수 문자열이 NULL인 경우에는 빈 문자열이 반환된다.<br>왜 PASSWORD() 함수를 사용해야할까? 사용자가 입력한 비밀번호를 개발자도 모르는 암호화된 값으로 바꿔서 DB에 저장하기때문이다.<br>어떤 방식으로 암호화될까? <a href="https://mariadb.com/kb/en/authentication-plugin-ed25519/">마리아DB 버전4.1까지는 기존의 SHA-1 알고리즘을 사용했으나 보안의 취약성으로 인해 마리아DB 5.2부터는 ed25519 인증플러그인을 사용한다.</a></p><p><br><br><br></p><h2 id="구문"><a href="#구문" class="headerlink" title="구문"></a>구문</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PASSWORD(str)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">PASSWORD</span>(<span class="string">'notagoodpwd'</span>);</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| PASSWORD('notagoodpwd')                   |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| *3A70EE9FC6594F88CE9E959CD51C5A1C002DC937 |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="HEX-와-UNHEX"><a href="#HEX-와-UNHEX" class="headerlink" title="HEX()와 UNHEX()"></a>HEX()와 UNHEX()</h1><ul><li>HEX(): 기존 텍스트를 16진수 값의 문자로 변환하여 반환한다.</li><li>UNHEX(): HEX의 역산으로 16진수를 숫자로 해석을 하고 그 숫자에 대응하는 문자로 변환한다. 그 결과, 문자들은 바이너리 스트링으로 리턴된다. 그리고 UTF8로 CONVERT 작업을 해주면 기존 텍스트로 변환이 가능하다.</li></ul><p><br><br><br></p><h2 id="예시-1"><a href="#예시-1" class="headerlink" title="예시"></a>예시</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">HEX</span>(<span class="string">'MariaDB'</span>);</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| HEX('MariaDB') |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| 4D617269614442 |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNHEX</span>(<span class="string">'4D617269614442'</span>);</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| UNHEX('4D617269614442') |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| MariaDB                 |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://mariadb.com/kb/en/password/">https://mariadb.com/kb/en/password/</a></li><li><a href="https://victorydntmd.tistory.com/144">https://victorydntmd.tistory.com/144</a></li><li><a href="https://shxrecord.tistory.com/238">https://shxrecord.tistory.com/238</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Database/">Database</category>
      
      <category domain="https://sowon-dev.github.io/categories/Database/MySQL/">MySQL</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/MariaDB/">MariaDB</category>
      
      
      <comments>https://sowon-dev.github.io/2022/12/05/221206mariadb-passwordhashing/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[jQuery] Ajax 글로벌 이벤트(Global Event)가 뭐길래</title>
      <link>https://sowon-dev.github.io/2022/11/29/221130jQuery-global/</link>
      <guid>https://sowon-dev.github.io/2022/11/29/221130jQuery-global/</guid>
      <pubDate>Tue, 29 Nov 2022 21:10:59 GMT</pubDate>
      
      <description>&lt;p&gt;레거시 소스코드를 분석하면서 jQuery.ajaxSetup()에 대해 알아볼 기회가 생겼다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>레거시 소스코드를 분석하면서 jQuery.ajaxSetup()에 대해 알아볼 기회가 생겼다.</p><a id="more"></a><p>jQuery Ajax는 지역 이벤트(Local Event)와 전역 이벤트(Global Event)로 나뉜다. 둘이 가지고 있는 이벤트가 매우 비슷하다.</p><h1 id="지역-이벤트-Local-Event-vs-전역-이벤트-Global-Event"><a href="#지역-이벤트-Local-Event-vs-전역-이벤트-Global-Event" class="headerlink" title="지역 이벤트(Local Event) vs 전역 이벤트(Global Event)"></a>지역 이벤트(Local Event) vs 전역 이벤트(Global Event)</h1><table><thead><tr><th align="left"></th><th align="left">로컬 이벤트</th><th align="left">글로벌 이벤트</th></tr></thead><tbody><tr><td align="left">셋팅</td><td align="left">global속성을 false(default)설정</td><td align="left">global속성을 true설정</td></tr><tr><td align="left">시행시기</td><td align="left">ajax수행의 특정시점에 함수가 호출되는 callback형태로 이벤트 발생</td><td align="left">개별 혹은 전체 ajax전송에 이벤트 발생</td></tr><tr><td align="left">전송시</td><td align="left">beforeSend</td><td align="left">ajaxSend()</td></tr><tr><td align="left">성공시(응답코드 200 일때)</td><td align="left">success</td><td align="left">ajaxSuccess()</td></tr><tr><td align="left">에러발생시(응답코드 오류일때)</td><td align="left">error</td><td align="left">ajaxError()</td></tr><tr><td align="left">완료시</td><td align="left">complete</td><td align="left">ajaxComplete()</td></tr><tr><td align="left">시작시 정의</td><td align="left"></td><td align="left">ajaxStart()</td></tr><tr><td align="left">정지시</td><td align="left"></td><td align="left">ajaxStop()</td></tr></tbody></table><ul><li>특징<ul><li>지역과 전역에 둘다 존재하는 send, success, error, complete와 관련된 이벤트들은 지역이벤트 callback이 실행 후 전역이벤트가 실행된다.</li></ul></li></ul><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://api.jquery.com/jquery.ajaxsetup/">https://api.jquery.com/jquery.ajaxsetup/</a></li><li><a href="https://www.nextree.co.kr/p10308/">https://www.nextree.co.kr/p10308/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/jQuery/">jQuery</category>
      
      
      <comments>https://sowon-dev.github.io/2022/11/29/221130jQuery-global/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[MySQL/MariaDB] 함수(function) vs 프로시저(Procedure) 차이</title>
      <link>https://sowon-dev.github.io/2022/11/28/221129MySQL-function-Procedure/</link>
      <guid>https://sowon-dev.github.io/2022/11/28/221129MySQL-function-Procedure/</guid>
      <pubDate>Mon, 28 Nov 2022 21:03:57 GMT</pubDate>
      
      <description>&lt;p&gt;이번에 진행중인 프로젝트는 프로시저보다 함수가 더 많이 사용되었다. 지난번 담당했던 프로젝트는 오직 프로시저만 썼었다. 둘의 차이가 뭘까? 언뜻 생각해봤을땐 return유무정도인데 깊이있게 알고싶어졌다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번에 진행중인 프로젝트는 프로시저보다 함수가 더 많이 사용되었다. 지난번 담당했던 프로젝트는 오직 프로시저만 썼었다. 둘의 차이가 뭘까? 언뜻 생각해봤을땐 return유무정도인데 깊이있게 알고싶어졌다.</p><a id="more"></a><p><br><br><br></p><h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><ol><li>정의: 항상 리턴값을 가짐</li><li>특징<ul><li>리턴값은 필수이고 오직 하나</li><li>try catch 사용 불가</li></ul></li><li>단점<ul><li>클라이언트실행으로 프로시저보다 속도가 느리다.</li></ul></li><li>선언 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name(</span><br><span class="line">param1,</span><br><span class="line">param2,…</span><br><span class="line">)</span><br><span class="line"><span class="keyword">RETURNS</span> datatype</span><br><span class="line">[<span class="keyword">NOT</span>] <span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="comment">-- statements</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></li><li>선언예시 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> MultiplyNumbers(@int1 <span class="keyword">as</span> <span class="built_in">int</span>,@int2 <span class="keyword">as</span> <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">As</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">Return</span> (@int1 * @int2)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>호출 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultiplyNumbers(2,2) </span><br><span class="line">// RETURN: 4</span><br></pre></td></tr></table></figure></li></ol><h1 id="프로시저"><a href="#프로시저" class="headerlink" title="프로시저"></a>프로시저</h1><ol><li>정의: 특정 작업을 수행. 여러 SQL문을 한 번에 실행 가능</li><li>특징<ul><li>개발업무와 DB처리를 구분하여 개발할 수 있음</li><li>보수성 뛰어남</li><li>서버 실행이라 속도가 함수보다 상대적으로 빠름</li><li>리턴값 없거나 여러개도 가능 -&gt; 유연성</li><li>try catch 사용가능 -&gt; 에러처리가능</li></ul></li><li>단점<ul><li>재사용성이 좋지 않음</li></ul></li><li>선언 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">Procedure</span> [<span class="keyword">Procedure</span> <span class="keyword">Name</span>] ([Parameter <span class="number">1</span>], [Parameter <span class="number">2</span>], [Parameter <span class="number">3</span>] )</span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="comment">-- SQL Queries..</span></span><br><span class="line"><span class="keyword">End</span></span><br></pre></td></tr></table></figure></li><li>선언 예시 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> GetAllProducts()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> *  <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></li><li>호출 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> GetAllProducts()</span><br></pre></td></tr></table></figure></li></ol><p><br><br><br></p><h1 id="차이"><a href="#차이" class="headerlink" title="차이"></a>차이</h1><table><thead><tr><th align="center"></th><th align="left">함수(Function)</th><th align="left">프로시저(Procedure)</th></tr></thead><tbody><tr><td align="center">처리주체</td><td align="left">클라이언트에서 처리</td><td align="left">서버로 보내서 처리</td></tr><tr><td align="center">리턴값 유무</td><td align="left">필수</td><td align="left">선택</td></tr><tr><td align="center">리턴값 갯수</td><td align="left">하나만 반환가능</td><td align="left">여러개 반환가능</td></tr><tr><td align="center">호출방법</td><td align="left">select문장안에서 함수호출</td><td align="left">call 프로시저명()</td></tr><tr><td align="center">주사용처</td><td align="left">로직 처리 도와주는 용도</td><td align="left">로직 처리를 직접하는 용도 why? DML문 사용가능해서</td></tr></tbody></table><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://www.geeksforgeeks.org/difference-between-function-and-procedure/">https://www.geeksforgeeks.org/difference-between-function-and-procedure/</a></li><li><a href="https://www.mysqltutorial.org/getting-started-with-mysql-stored-procedures.aspx">https://www.mysqltutorial.org/getting-started-with-mysql-stored-procedures.aspx</a></li><li><a href="https://velog.io/@devjooj/Mysql-Function%EA%B3%BC-Procedure-%EC%B0%A8%EC%9D%B4">https://velog.io/@devjooj/Mysql-Function%EA%B3%BC-Procedure-%EC%B0%A8%EC%9D%B4</a></li><li><a href="https://spiderwebcoding.tistory.com/7">https://spiderwebcoding.tistory.com/7</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Database/">Database</category>
      
      <category domain="https://sowon-dev.github.io/categories/Database/MySQL/">MySQL</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/11/28/221129MySQL-function-Procedure/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>레디스(Redis)가 뭐길래</title>
      <link>https://sowon-dev.github.io/2022/11/21/221122Redis/</link>
      <guid>https://sowon-dev.github.io/2022/11/21/221122Redis/</guid>
      <pubDate>Mon, 21 Nov 2022 20:33:44 GMT</pubDate>
      
      <description>&lt;p&gt;종종 들었던 Redis, 이번 레거시프로젝트 소스코드분석중 RedisTemplate을 만나면서 그 개념을 함께 정리해보고자한다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>종종 들었던 Redis, 이번 레거시프로젝트 소스코드분석중 RedisTemplate을 만나면서 그 개념을 함께 정리해보고자한다.</p><a id="more"></a><h1 id="In-Memory-DB란"><a href="#In-Memory-DB란" class="headerlink" title="In Memory DB란?"></a>In Memory DB란?</h1><blockquote><p>인메모리 데이터베이스(In-memory Database)는 데이터 스토리지의 메인 메모리에 설치되어 운영되는 방식의 데이터베이스 관리 시스템이다.<br>인메모리 데이터베이스는 디스크에 최적화된 데이터베이스보다 더 빠른데 그 까닭은 디스크 접근이 메모리 접근보다 느리기 때문이며, 이 데이터베이스는 내부 최적화 알고리즘이 더 단순하며 더 적은 CPU 명령을 실행한다. 메모리의 데이터에 접근하면 데이터를 조회할 때 검색 시간이 줄어들며 디스크보다 더 빠르고 더 예측 가능성 성능을 제공한다.<br>인메모리 데이터 스토리지의 잠재적인 기술적 문제는 RAM의 휘발성이다. 구체적으로 말해 전원이 소실될 경우나 고의적인 상황 등에서 휘발성 RAM 안에 저장된 데이터는 손실된다.비휘발성 RAM 기술의 도입으로 인메모리 데이터베이스는 전력 손실에도 완전한 속도로 데이터를 유지할 수 있게 되었다.<br>출처: <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">위키백과</a></p></blockquote><p><br><br><br></p><h2 id="인메모리DB-특징"><a href="#인메모리DB-특징" class="headerlink" title="인메모리DB 특징"></a>인메모리DB 특징</h2><p>인메모리디비의 가장 큰 특징은 2가지이다.</p><ol><li>인메모리 데이터구조: 디스크 아닌 메모리 기반. Redis의 가장 큰 특징.</li><li>캐시를 사용하여 속도가 빠름</li></ol><p><br><br><br></p><h2 id="인메모리DB-사용처"><a href="#인메모리DB-사용처" class="headerlink" title="인메모리DB 사용처"></a>인메모리DB 사용처</h2><p>크게 3가지 용도로 사용한다.</p><ol><li>데이터베이스</li><li>캐시</li><li>메세지 브로커</li></ol><p>결국 빠른 속도를 위해서 메모리에 올려서 사용하는 데이터 저장소이다.<br>인메모리DB의 종류에는 Redis, Memcached, Amazon ElastiCache 등이 있고 그 중 Redis의 인기가 압도적으로 높다. </p><p><br><br><br></p><h1 id="Redis란"><a href="#Redis란" class="headerlink" title="Redis란?"></a>Redis란?</h1><p>Redis는 REmote DIctionary Server의 약어로 Key와 Value를 가진 오픈소스 NoSQL 데이터베이스이다.<br>여기서 NoSQL이란 스키마없이 데이터를 표현한 데이터베이스로 <a href="https://sowon-dev.github.io/2022/02/26/220226NoSQL/">NoSQL이 뭐길래</a>포스팅을 참고하면된다.</p><p><br><br><br></p><h2 id="Redis-특징"><a href="#Redis-특징" class="headerlink" title="Redis 특징"></a>Redis 특징</h2><ol><li>다양한 데이터 구조: String, Set, Sorted Set, Hash, List 등 다양한 타입을 지원</li><li>스냅샷: 장애시 복구 가능</li><li>Master-Slave 구조로 여러 개의 복제본 만들기 용이</li><li>트랜잭션 지원</li><li>Pub(발행) / Sub(구독) 방식의 메시징을 지원</li></ol><p><br><br><br></p><h1 id="DB가-있는데-인메모리DB를-왜-쓸까"><a href="#DB가-있는데-인메모리DB를-왜-쓸까" class="headerlink" title="DB가 있는데 인메모리DB를 왜 쓸까?"></a>DB가 있는데 인메모리DB를 왜 쓸까?</h1><p>근원적인 궁금증을 해결해준 글을 발견해서 발췌해왔다.</p><blockquote><p>데이터 베이스가 있는데도 Redis라는 인메모리 데이터 구조 저장소를 사용하는 이유는 무엇일까요?<br>데이터 베이스는 데이터를 물리 디스크에 직접 쓰기 때문에 서버에 문제가 발생하여 다운되더라도 데이터가 손실되지 않습니다. 하지만 매번 디스크에 접근해야 하기 때문에 사용자가 많아질수록 부하가 많아져서 느려질 수 있는데요.<br>일반적으로 서비스 운영 초반이거나 규모가 작은, 사용자가 많지 않은 서비스의 경우에는 WEB - WAS - DB 의 구조로도 데이터 베이스에 무리가 가지 않습니다.<br>하지만 사용자가 늘어난다면 데이터 베이스가 과부하 될 수 있기 때문에 이때 캐시 서버를 도입하여 사용합니다.<br>그리고 이 캐시 서버로 이용할 수 있는 것이 바로 Redis 입니다.<br>캐시는 한번 읽어온 데이터를 임의의 공간에 저장하여 다음에 읽을 때는 빠르게 결괏값을 받을 수 있도록 도와주는 공간입니다.<br>같은 요청이 여러 번 들어오는 경우 매번 데이터 베이스를 거치는 것이 아니라 캐시 서버에서 첫 번째 요청 이후 저장된 결괏값을 바로 내려주기 때문에 DB의 부하를 줄이고 서비스의 속도도 느려지지 않는 장점이 있습니다.<br>출처: <a href="https://wildeveloperetrain.tistory.com/m/21">Jan92님 블로그 - Redis란? 레디스의 기본적인 개념</a></p></blockquote><p><br><br><br></p><h1 id="MSSQL이나-MYSQL도-인메모리테이블을-지원하는데-왜-굳이-레디스-Redis-를-사용할까"><a href="#MSSQL이나-MYSQL도-인메모리테이블을-지원하는데-왜-굳이-레디스-Redis-를-사용할까" class="headerlink" title="MSSQL이나 MYSQL도 인메모리테이블을 지원하는데 왜 굳이 레디스(Redis)를 사용할까?"></a>MSSQL이나 MYSQL도 인메모리테이블을 지원하는데 왜 굳이 레디스(Redis)를 사용할까?</h1><p>레디스에 대해 이야기를 나누다가 팀장님이 RDB에서도 인메모리를 지원하는데 왜 굳이 레디스를 사용하는 지 알아보는게 어떠냐고 제안해주셨다.<br>RDB에서도 메모리DB를 쓸수있다니! 전혀 몰랐던 사실이어서 공부해봤다.</p><table><thead><tr><th align="center">DB명</th><th align="left">인메모리DB 사용</th><th align="left">적용법</th></tr></thead><tbody><tr><td align="center">Oracle</td><td align="left">In Memory Option</td><td align="left"><a href="http://www.koreaoug.org/c12/935">Oracle Database In-Memory Option –I (설명과 설정방법)</a></td></tr><tr><td align="center">MySQL</td><td align="left">메모리테이블</td><td align="left"><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=oralol&logNo=222198862146">DB 튜닝 - MySQL Memory 테이블 사용</a></td></tr><tr><td align="center">MSSQL</td><td align="left">메모리테이블</td><td align="left"><a href="https://mozi.tistory.com/566">MSSQL 테이블을 인메모리(in-memory)로 사용하는 방법</a></td></tr></tbody></table><p><br><br><br></p><h2 id="왜-굳이-레디스를-사용할까"><a href="#왜-굳이-레디스를-사용할까" class="headerlink" title="왜 굳이 레디스를 사용할까?"></a>왜 굳이 레디스를 사용할까?</h2><p>먼저, 레디스는 사용자가 많아 자료가 많다. 커뮤니티가 큰 오픈소스를 사용해야 적용 및 대응이 쉽다.<br>두번째로 인메모리데이블은 제약사항이 많은 반면에 레디스는 다양한 데이터구조 사용가능, 스냅샷으로 복구시 활용가능한 점등이 확장성을 고려해봤을때도 여전히 좋다.</p><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://aws.amazon.com/ko/elasticache/what-is-redis/">https://aws.amazon.com/ko/elasticache/what-is-redis/</a></li><li><a href="https://wildeveloperetrain.tistory.com/m/21">https://wildeveloperetrain.tistory.com/m/21</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">위키백과 - 인메모리데이터베이스</a></li><li><a href="http://www.koreaoug.org/c12/935">http://www.koreaoug.org/c12/935</a></li><li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=oralol&amp;logNo=222198862146">https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=oralol&amp;logNo=222198862146</a></li><li><a href="https://mozi.tistory.com/566">https://mozi.tistory.com/566</a></li><li><a href="https://kdhyo98.tistory.com/89">https://kdhyo98.tistory.com/89</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Database/">Database</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/Redis/">Redis</category>
      
      
      <comments>https://sowon-dev.github.io/2022/11/21/221122Redis/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[JS]Web Storage vs 쿠키(Cookie) vs 세션(Session) vs 캐시(Cache)</title>
      <link>https://sowon-dev.github.io/2022/11/21/221121JS-webstorage/</link>
      <guid>https://sowon-dev.github.io/2022/11/21/221121JS-webstorage/</guid>
      <pubDate>Mon, 21 Nov 2022 04:27:19 GMT</pubDate>
      
      <description>&lt;p&gt;레거시프로젝트의 소스코드를 분석하다가 Web Storage를 만났다.&lt;br&gt;localStorage와 sessionStorage를 둘 다 사용하고 있었기에 둘 차이가 궁금해졌다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>레거시프로젝트의 소스코드를 분석하다가 Web Storage를 만났다.<br>localStorage와 sessionStorage를 둘 다 사용하고 있었기에 둘 차이가 궁금해졌다.</p><a id="more"></a><p>구글링할수도록 쿠키, 세션, 캐시까지 다양한 개념이 나오길래 이참에 다 정리해봤다.</p><h1 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h1><ul><li>클라이언트에 저장</li><li>Key-Value 형태</li><li>쿠키와 달리 서버에 전송안함</li><li>CSRF로부터 안전 why? Origin단위로 접근이 제한되기때문에.</li><li>쿠키(4GB)보다 큰 저장용량(5GB)지원</li><li>문자형(String) 데이터 타입만 지원</li><li>종류<ul><li>localStorage: 사용자가 데이터를 지우지 않는 이상, 브라우저나 OS를 종료해도 계속 브라우저에 남아있음 (영구성) 단, 동일한 브라우저를 사용할 때만 해당</li><li>sessionStorage: 브라우저 탭에도 종속되기 때문에, 윈도우나 브라우저 탭을 닫을 경우 제거</li></ul></li></ul><p><br><br><br></p><h2 id="Origin-오리진이란"><a href="#Origin-오리진이란" class="headerlink" title="Origin 오리진이란?"></a>Origin 오리진이란?</h2><p>오리진 = 프로토콜 + 도메인 + 포트</p><p><br><br><br></p><h1 id="비교"><a href="#비교" class="headerlink" title="비교"></a>비교</h1><table><thead><tr><th align="center"></th><th align="left">localStorage</th><th align="left">sessionStorage</th><th align="left">Cookie</th><th align="left">Session</th></tr></thead><tbody><tr><td align="center">저장위치</td><td align="left">클라이언트</td><td align="left">클라이언트</td><td align="left">클라이언트</td><td align="left">서버</td></tr><tr><td align="center">저장형식</td><td align="left">String</td><td align="left">String</td><td align="left">String</td><td align="left">Obejct</td></tr><tr><td align="center">전송</td><td align="left">서버전송x <br> -&gt; 서버 부담없음</td><td align="left">서버전송x <br> -&gt; 서버 부담없음</td><td align="left">매번 서버에 자동 전송 <br> -&gt; 크기가 크면 서버에 부담</td><td align="left">서버에서 클라이언트를 구분하기 위해 세션 ID를 부여 <br> -&gt; 사용자가 많아질수록 서버 메모리를 많이 차지</td></tr><tr><td align="center">유효기간 설정</td><td align="left">불가능</td><td align="left">불가능</td><td align="left">가능</td><td align="left">가능(기본 30분)</td></tr><tr><td align="center">데이터영구성</td><td align="left">브라우저 종료해도 유지 <br> 명시적 삭제 필요</td><td align="left">윈도우나 브라우저 탭을 닫을 경우 삭제됨</td><td align="left">쿠키 저장시 설정(설정 없을 시에는 브라우저 종료시 만료)</td><td align="left">브라우저 종료 시 만료기간에 상관없이 삭제됨</td></tr><tr><td align="center">생성단위</td><td align="left">Origin별로 생성<br>다른 오리진의 로컬 스토리지에는 접근 불가<br>서로 다른 브라우저 탭이라도 동일한 오리진이라면 동일한 로컬 스토리지를 사용함<br></td><td align="left">Origin별마다 탭/윈도우 단위로 생성-&gt;탭/윈도우를 닫을 시 데이터가 삭제됨</td><td align="left">브라우저에 여러개 생성가능</td><td align="left">브라우저당 하나의 세션SessionID이 생성</td></tr><tr><td align="center">주 사용처</td><td align="left">지속적으로 필요한 정보를 저장할때<br>e.g.자동 로그인 등</td><td align="left">잠시 동안 필요한 정보를 저장할 때<br>e.g.입력 폼 저장, 일회성 로그인 등</td><td align="left">로그인유지, 자동완성, 일주일간 다시 보지 않기, 최근 검색한 상품들을 광고에서 추천, 쇼핑몰 장바구니 기능</td><td align="left">로그인유지</td></tr></tbody></table><p><br><br><br></p><h1 id="캐시-Cache-는-또-뭘까"><a href="#캐시-Cache-는-또-뭘까" class="headerlink" title="캐시(Cache)는 또 뭘까?"></a>캐시(Cache)는 또 뭘까?</h1><p>쿠키와 세션을 이야기하다보면 자연스럽게 캐시가 나온다.<br>어떤 차이가 있을까?</p><ul><li>캐시: 웹 페이지 요소(e.g.img,css,js등 리소스파일)를 저장하기 위한 임시 저장소 for 빠른 웹페이지 랜더링</li><li>쿠키,세션: 정보 저장소 for 사용자인증</li></ul><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/API/Window/sessionStorage">https://developer.mozilla.org/ko/docs/Web/API/Window/sessionStorage</a></li><li><a href="https://it-eldorado.tistory.com/90">IT엘도라도 - 쿠키, 웹 스토리지(로컬 스토리지, 세션 스토리지)</a></li><li><a href="https://doqtqu.tistory.com/m/306">푸고배님 - 쿠키 vs 세션 vs 웹 스토리지(로컬 스토리지, 세션 스토리지)</a></li><li><a href="https://sowon-dev.github.io/2020/06/30/200701jspi/">https://sowon-dev.github.io/2020/06/30/200701jspi/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JavaScript/">JavaScript</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/11/21/221121JS-webstorage/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Cron표현식이 뭐길래</title>
      <link>https://sowon-dev.github.io/2022/11/16/221116cron/</link>
      <guid>https://sowon-dev.github.io/2022/11/16/221116cron/</guid>
      <pubDate>Wed, 16 Nov 2022 05:14:08 GMT</pubDate>
      
      <description>&lt;p&gt;신규로 맡은 프로젝트의 코드분석 중 크론표현식을 만났다.&lt;br&gt;크론표현식을 한 번 공부한 적이 있어서 당연히 술술 읽힐 줄 알았는데 웬걸… 기억이 나질않았다.&lt;br&gt;역시 안다고 생각하는 것과 아는 것은 다르다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>신규로 맡은 프로젝트의 코드분석 중 크론표현식을 만났다.<br>크론표현식을 한 번 공부한 적이 있어서 당연히 술술 읽힐 줄 알았는데 웬걸… 기억이 나질않았다.<br>역시 안다고 생각하는 것과 아는 것은 다르다.</p><a id="more"></a><p>이참에 포스팅을 통해 확실히 내 것으로 만들어야겠다.</p><h1 id="개념"><a href="#개념" class="headerlink" title="개념"></a>개념</h1><p>Cron 표현식은 스케줄러 시간을 세팅할 때 주로 사용되는 표현식으로 7개의 필드를 띄어쓰기로 구분한다.<br>연도는 생략가능하다!</p><p><br><br><br></p><h1 id="형태"><a href="#형태" class="headerlink" title="형태"></a>형태</h1><p>시간을 나타내는 표현식인만큼 필드를 외우기는 참 쉽다!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;초&gt; &lt;분&gt; &lt;시&gt; &lt;일&gt; &lt;월&gt; &lt;요일&gt; &lt;년&gt;</span><br></pre></td></tr></table></figure><p>각 필드마다 허용되는 값과 허용되는 특수문자가 다르다. 각 특수문자의 의미도 알아둬야한다!</p><table><thead><tr><th align="center">필드</th><th align="center">필수여부</th><th align="center">허용되는 값</th><th align="center">허용되는 특수문자</th></tr></thead><tbody><tr><td align="center">초</td><td align="center">Y</td><td align="center">0-59</td><td align="center">, - * /</td></tr><tr><td align="center">분</td><td align="center">Y</td><td align="center">0-59</td><td align="center">, - * /</td></tr><tr><td align="center">시간</td><td align="center">Y</td><td align="center">0-23</td><td align="center">, - * /</td></tr><tr><td align="center">일</td><td align="center">Y</td><td align="center">1-31</td><td align="center">, - * ? / L W C</td></tr><tr><td align="center">월</td><td align="center">Y</td><td align="center">0-11 or JAN-DEC</td><td align="center">, - * /</td></tr><tr><td align="center">요일</td><td align="center">Y</td><td align="center">1-7 or SUN-SAT or sun-sat</td><td align="center">, - * ? / L C #</td></tr><tr><td align="center">년</td><td align="center">N</td><td align="center">empty or 1970-2099</td><td align="center">, - * /</td></tr></tbody></table><p><br><br><br></p><h1 id="특수문자의-의미"><a href="#특수문자의-의미" class="headerlink" title="특수문자의 의미"></a>특수문자의 의미</h1><table><thead><tr><th align="center">특수문자</th><th align="center">의미</th></tr></thead><tbody><tr><td align="center"><code>*</code></td><td align="center">모든 값</td></tr><tr><td align="center">?</td><td align="center">특정한 값이 없음</td></tr><tr><td align="center">-</td><td align="center">범위 지정</td></tr><tr><td align="center">,</td><td align="center">여러 값을 지정</td></tr><tr><td align="center">/</td><td align="center">증가하는 값을 지정(초기값/증가값)</td></tr><tr><td align="center">L</td><td align="center">마지막 값 지</td></tr><tr><td align="center">W</td><td align="center">가장 가까운 평일</td></tr><tr><td align="center">#</td><td align="center">몇 번째 무슨 요일인지 지정</td></tr></tbody></table><p><br><br><br></p><h1 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 30 13 * * ?</span><br><span class="line">&#x2F;&#x2F; 매일 오후 1시 30분마다</span><br><span class="line"></span><br><span class="line">0 30 10 ? * MON-FRI</span><br><span class="line">&#x2F;&#x2F;평일 오전 10시 30분마다</span><br><span class="line"></span><br><span class="line">0 15 15 L * ?</span><br><span class="line">&#x2F;&#x2F; 매월 말일 3시 15분마다</span><br></pre></td></tr></table></figure><p>사실 가장 쉬운 방법은 <a href="http://www.cronmaker.com/;jsessionid=node01e568mpg1sqg9132x6b0diwtkc1083568.node0?0">cronmaker</a>사이트를 이용하면된다.</p><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm">https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm</a></li><li><a href="https://dev-bri.tistory.com/4">https://dev-bri.tistory.com/4</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Journal/">Journal</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/11/16/221116cron/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>asp.net 웹폼(Web Form)프로젝트를 끝내며 내가 배운 것</title>
      <link>https://sowon-dev.github.io/2022/11/10/221111projectreview8/</link>
      <guid>https://sowon-dev.github.io/2022/11/10/221111projectreview8/</guid>
      <pubDate>Thu, 10 Nov 2022 19:59:26 GMT</pubDate>
      
      <description>&lt;p&gt;이번 프로젝트는 나에게 효율이 나질않는 프로젝트였다.&lt;br&gt;MVC패턴이 아닌 웹폼프레임워크를 처음 사용하면서 효율이 제대로 나오지않아 많이 답답했다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번 프로젝트는 나에게 효율이 나질않는 프로젝트였다.<br>MVC패턴이 아닌 웹폼프레임워크를 처음 사용하면서 효율이 제대로 나오지않아 많이 답답했다.</p><a id="more"></a><p>이번 프로젝트에서는 Code-Behind Page Model을 사용했는데 <code>*.aspx.cs</code>로부터 클래스를 상속받는 <code>*.aspx</code>파일에 html과 js로 화면작업을 했다.<br>화면작업 위주로 했기에 백단을 많이 다루지 못해 개인적으로 아쉬운 프로젝트였다.</p><h1 id="keep"><a href="#keep" class="headerlink" title="keep"></a>keep</h1><p>현재 만족하고 있는 부분과 계속해서 이어갔으면 하는 부분</p><ol><li>레거시 코드를 분석하고 페이지테스트없이 코드를 이해하는 능력: 레거시 프로젝트를 고도화하는 작업이었기 때문에 레거시 코드를 정확히 읽어 기능을 이해하는 것이 작업의 핵심이였다. 프로젝트 특성상 기능을 테스트해볼수있는 페이지없이 오로지 코드만 보고 기능을 이해해야했기에 처음에는 버벅거렸으나 프로젝트 후반에는 술술 읽혀서 나조차 신기했다. 스스로 가장 많이 성장했다고 생각하는 부분이다.</li><li>프로시저 바로 이해하기: 이번 프로젝트는 전체가 프로시저로 구현되어있어 프로시저를 읽고 해석하는 부분이 많았고 덕분에 프로시저와 엄청나게 친숙해졌다.  </li></ol><p><br><br><br></p><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>개선이 필요하다고 생각되는 부분</p><ol><li>엑셀파일을 업로드하면 엑셀파일을 읽어서 DB에 등록하는 부분 코드 뜯어보기: 호출만 하고 넘어간 부분인데 스스로 구현할 수 있을정도로 깊게 봤으면 더 성장했겠다는 생각이 들었다.</li></ol><p><br><br><br></p><h1 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h1><p>Problem의 해결책이 될 수 있는 부분</p><ol><li>이번에는 백엔드를 거의 건들이지 않았는데 욕심내서 뜯어볼 수도 있었는데 호출만해서 사용한 점이 아쉽다.</li></ol>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Journal/">Journal</category>
      
      <category domain="https://sowon-dev.github.io/categories/Journal/%ED%9A%8C%EA%B3%A0%EB%A1%9D/">회고록</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/%ED%9A%8C%EA%B3%A0%EB%A1%9D/">회고록</category>
      
      
      <comments>https://sowon-dev.github.io/2022/11/10/221111projectreview8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[jQuery] checkbox와 select 다루기</title>
      <link>https://sowon-dev.github.io/2022/11/08/221109jQuery-input-type/</link>
      <guid>https://sowon-dev.github.io/2022/11/08/221109jQuery-input-type/</guid>
      <pubDate>Tue, 08 Nov 2022 23:04:34 GMT</pubDate>
      
      <description>&lt;p&gt;jQuery로 checkbox와 select 다루는 법을 전체적으로 정리해보자.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>jQuery로 checkbox와 select 다루는 법을 전체적으로 정리해보자.</p><a id="more"></a><h1 id="✍Checkbox"><a href="#✍Checkbox" class="headerlink" title="✍Checkbox"></a>✍Checkbox</h1><p><br><br></p><h2 id="1-체크하기"><a href="#1-체크하기" class="headerlink" title="1. 체크하기"></a>1. 체크하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ID로 지정하는 방법</span></span><br><span class="line">$(<span class="string">'#체크박스아이디'</span>).prop(<span class="string">'checked'</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// input 속성으로 지정하는 방법</span></span><br><span class="line">$(<span class="string">'input:checkbox[name="체크박스네임"]'</span>).prop(<span class="string">'checked'</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="2-체크여부-확인"><a href="#2-체크여부-확인" class="headerlink" title="2. 체크여부 확인"></a>2. 체크여부 확인</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#체크박스아이디'</span>).is(<span class="string">':checked'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반환값: true, false</span></span><br></pre></td></tr></table></figure><p>참고로 <code>$(&#39;#체크박스아이디&#39;).val()</code>을 하면 반환값이 on이나 undifined가 뜬다.</p><p><br><br></p><h2 id="3-한번에-전체-체크하기"><a href="#3-한번에-전체-체크하기" class="headerlink" title="3. 한번에 전체 체크하기"></a>3. 한번에 전체 체크하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#allCheck'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> isChecked = $(<span class="string">'#allCheck'</span>).is(<span class="string">':checked'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isChecked)</span><br><span class="line">$(<span class="string">'input:checkbox'</span>).prop(<span class="string">'checked'</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br><br></p><h1 id="✍-Select"><a href="#✍-Select" class="headerlink" title="✍ Select"></a>✍ Select</h1><p><br><br></p><h2 id="1-값-읽기-가져오기"><a href="#1-값-읽기-가져오기" class="headerlink" title="1. 값 읽기(가져오기)"></a>1. 값 읽기(가져오기)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ID로 접근하는 방법</span></span><br><span class="line">$(<span class="string">"#셀렉트박스아이디 option:selected"</span>).val();</span><br><span class="line"></span><br><span class="line"><span class="comment">// input 속성으로 접근하는 방법</span></span><br><span class="line">$(<span class="string">"select[name=셀렉트박스네임]"</span>).val();</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="2-옵션-추가하기"><a href="#2-옵션-추가하기" class="headerlink" title="2. 옵션 추가하기"></a>2. 옵션 추가하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 옵션추가</span></span><br><span class="line">$(<span class="string">"#셀렉트박스아이디"</span>).append(<span class="string">"&lt;option value='1번'&gt;1번 테스트&lt;/option&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 옵션을 맨 앞에 추가</span></span><br><span class="line">$(<span class="string">"#셀렉트박스ID"</span>).prepend(<span class="string">"&lt;option value='맨앞'&gt;맨앞&lt;/option&gt;"</span>);</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="3-옵션-삭제하기"><a href="#3-옵션-삭제하기" class="headerlink" title="3. 옵션 삭제하기"></a>3. 옵션 삭제하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 옵션 전체 삭제</span></span><br><span class="line">$(<span class="string">"#셀렉트박스아이디 option"</span>).remove();</span><br><span class="line">$(<span class="string">"select[name=셀렉트박스네임] option"</span>).remove();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 특정 옵션 벨류 값으로 삭제</span></span><br><span class="line">$(<span class="string">"#셀렉트박스아이디 option[value='맨앞']"</span>).remove();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 특정 옵션 인덱스 값으로 삭제</span></span><br><span class="line">$(<span class="string">"#셀렉트박스아이디 option:eq(0)"</span>).remove();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫번째 옵션 삭제</span></span><br><span class="line">$(<span class="string">"#셀렉트박스아이디 option:first"</span>).remove();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 마지막 옵션 삭제</span></span><br><span class="line">$(<span class="string">"#셀렉트박스아이디 option:last"</span>).remove();</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="4-선택하기"><a href="#4-선택하기" class="headerlink" title="4. 선택하기"></a>4. 선택하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 옵션 전체 삭제</span></span><br><span class="line">$(<span class="string">"#셀렉트ID option:eq(1)"</span>).attr(<span class="string">"selected"</span>, <span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/jQuery/">jQuery</category>
      
      
      <comments>https://sowon-dev.github.io/2022/11/08/221109jQuery-input-type/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[JSTL] java.util.Date 현재날짜의 시간을 0으로 설정하기</title>
      <link>https://sowon-dev.github.io/2022/11/02/221103JSP-utilDatefmt/</link>
      <guid>https://sowon-dev.github.io/2022/11/02/221103JSP-utilDatefmt/</guid>
      <pubDate>Wed, 02 Nov 2022 16:15:38 GMT</pubDate>
      
      <description>&lt;p&gt;JSTL로 현재날짜와 DB에서 가져오는 날짜 차이를 계산했었다.&lt;br&gt;잘 되는 줄 알았던 코드가 특정 시간을 기점으로 버그가 발생한다는 것을 알게되었다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>JSTL로 현재날짜와 DB에서 가져오는 날짜 차이를 계산했었다.<br>잘 되는 줄 알았던 코드가 특정 시간을 기점으로 버그가 발생한다는 것을 알게되었다.</p><a id="more"></a><p><br><br><br></p><h1 id="기존코드와-문제점"><a href="#기존코드와-문제점" class="headerlink" title="기존코드와 문제점"></a>기존코드와 문제점</h1><p>구글링하면 가장 많이 사용하는 방법으로 <a href="https://sowon-dev.github.io/2022/08/18/220818JSTL-date/">포스팅 - 날짜 차이 계산하기</a>을 작성했다.<br>날짜차이 계산은 모든 날짜를 시간으로 바꾼 뒤 뺄셈을 통해 날짜가 얼마나 남았는지 계산할 수 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"now"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.util.Date"</span> /&gt;</span><br><span class="line">&lt;fmt:parseNumber <span class="keyword">var</span>=<span class="string">"nowfmtTime"</span> value=<span class="string">"$&#123;now.time / (1000*60*60*24)&#125;"</span> integerOnly=<span class="string">"true"</span> scope=<span class="string">"request"</span>/&gt;</span><br><span class="line">&lt;fmt:parseNumber <span class="keyword">var</span>=<span class="string">"dbDtParse"</span> value=<span class="string">"$&#123;list.dbDt.time / (1000*60*60*24)&#125;"</span> integerOnly=<span class="string">"true"</span> scope=<span class="string">"request"</span>/&gt;</span><br><span class="line"></span><br><span class="line">$&#123;nowfmtTime &#125;</span><br></pre></td></tr></table></figure><p>코드상의 문제는 전혀없으나 요구사항이 하루전에는 예약할 수 없는 예약프로그램을 구현하는 것이라서 수정이 필요했다.<br>현재시간을 time로 변경하는데 HH:mm:ss가 00:00:00이 아니라서 위 방식으로 시간계산시 미세하게 차이가 발생했다.<br>이를 해결하기 위해 현재날짜의 시간을 0으로 설정해야했다.</p><p><br><br><br></p><h1 id="해결코드"><a href="#해결코드" class="headerlink" title="해결코드"></a>해결코드</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"now"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.util.Date"</span> /&gt;</span><br><span class="line">&lt;fmt:formatDate <span class="keyword">var</span>=<span class="string">"today"</span> value=<span class="string">"$&#123;now&#125;"</span> pattern=<span class="string">"yyyyMMdd000000"</span> /&gt;</span><br><span class="line">&lt;fmt:parseDate <span class="keyword">var</span>=<span class="string">"nowfmt"</span> value=<span class="string">"$&#123;today&#125;"</span> pattern=<span class="string">"yyyyMMddHHmmss"</span>/&gt;</span><br><span class="line">&lt;fmt:parseNumber <span class="keyword">var</span>=<span class="string">"nowfmtTime"</span> value=<span class="string">"$&#123;nowfmt.time / (1000*60*60*24)&#125;"</span> integerOnly=<span class="string">"true"</span> scope=<span class="string">"request"</span>/&gt;</span><br><span class="line"></span><br><span class="line">$&#123;nowfmtTime &#125;</span><br></pre></td></tr></table></figure><p><code>fmt:formatDate</code>의 pattern속성으로 시간을 0으로 설정한다.<br>그리고 <code>fmt:parseDate</code>로 Date 타입으로 파싱해준 뒤 바로 날짜를 이용할 수 있고 나처럼 날짜계산을 위해 다시 <code>fmt:parseNumber</code> 숫자타입으로 변경해서 이용할수도 있다.</p><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://sowon-dev.github.io/2020/08/11/200812jspi2/">JSTL과 EL : fmt 라이브러리(formatDate, formatNumber)</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JSP/">JSP</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/JSTL/">JSTL</category>
      
      
      <comments>https://sowon-dev.github.io/2022/11/02/221103JSP-utilDatefmt/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[SQLD] 슈퍼타입과 서브타입</title>
      <link>https://sowon-dev.github.io/2022/10/31/221101SQLD-super-sub/</link>
      <guid>https://sowon-dev.github.io/2022/10/31/221101SQLD-super-sub/</guid>
      <pubDate>Mon, 31 Oct 2022 21:31:02 GMT</pubDate>
      
      <description>&lt;p&gt;슈퍼/서브타입 데이터 모델은 Extended ER모델이라고도 불린다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>슈퍼/서브타입 데이터 모델은 Extended ER모델이라고도 불린다.</p><a id="more"></a><ul><li>슈퍼타입: 공통의 부분</li><li>서브타입: 공통으로부터 상속받아 서</li></ul><p>if 10만건도 되지 않는 데이터 or 시스템을 운영하는 도중에도 데이터가 증가하지 않는다, 트랜잭션의 성격을 고려하지않고 전체를 하나의 테이블로 묶는 것도 괜찮은 방법이다.<br>하지만 데이터 양이 이미 많고 지속적으로 증가한다면 슈퍼/서브타입 물리적 데이터 모델로 변환하는 세 가지 유형을 고려해야한다.</p><p><br><br><br></p><h1 id="성능을-고려한-슈퍼-서브타입-데이터-모델-변환"><a href="#성능을-고려한-슈퍼-서브타입-데이터-모델-변환" class="headerlink" title="성능을 고려한 슈퍼/서브타입 데이터 모델 변환"></a>성능을 고려한 슈퍼/서브타입 데이터 모델 변환</h1><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FdIB9Iq%2FbtqCbgT9pcy%2FxrapasEiGw1KvgUTjG4k31%2Fimg.jpg" alt="https://hec-ker.tistory.com/68"></p><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FFLEnX%2FbtqCbhrWGzj%2FJk1PxKYOQNEXq8zkDbqGz0%2Fimg.jpg" alt="https://hec-ker.tistory.com/68"></p><table><thead><tr><th align="center">논리모델</th><th align="center">One to One Type(1:1 타입)</th><th align="center">Plus Type(슈퍼+서브 타입)</th><th align="center">Single Type(All in One 타입)</th></tr></thead><tbody><tr><td align="center">정의</td><td align="center">if 슈퍼타입과 서브타입 각각 트랜잭션이 발생, 개별 테이블로 구성(1:1 관계)</td><td align="center">if 슈퍼타입과 서브타입 함께 트랜잭션이 발생, 슈퍼타입의 PK와 각 서브타입의 속성을 묶어 N개의 테이블을 구성</td><td align="center">if 슈퍼타입과 서브타입 정확히 지정x상황, 하나의 테이블로 통합</td></tr><tr><td align="center">예시</td><td align="center">고객엔티티 하위에 개인고객, 법인고객으로 구분</td><td align="center">개인고객엔티티, 법인고객엔티티</td><td align="center">고객엔티티</td></tr><tr><td align="center">물리모델 결정기준</td><td align="center">개별로 발생되는 경우가 많은 서비스는 Identity로</td><td align="center">슈퍼타입+서브타입에 대해 발생되는 서비스는 RollDown 으로!</td><td align="center">전체를 하나로 묶어 트랜잭션이 발생할 때는 RollUp 으로!</td></tr></tbody></table><p><br><br><br></p><h1 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h1><ul><li><a href="https://hec-ker.tistory.com/68">마띠의블로그 - 데이터베이스 구조와 성능</a></li><li><a href="https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=54034">데이터온에어 - ‘6개의 열쇠’로 데이터 모델링의 고수가 되자</a></li><li><a href="https://developer-ping9.tistory.com/293">공부하는 개발자 핑구 - 슈퍼-서브타입 모델의 물리모델 결정기준</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Database/">Database</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/SQLD/">SQLD</category>
      
      
      <comments>https://sowon-dev.github.io/2022/10/31/221101SQLD-super-sub/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[SQLD] 테이블 분할</title>
      <link>https://sowon-dev.github.io/2022/10/29/221029SQLD-tablepartition/</link>
      <guid>https://sowon-dev.github.io/2022/10/29/221029SQLD-tablepartition/</guid>
      <pubDate>Sat, 29 Oct 2022 05:37:20 GMT</pubDate>
      
      <description>&lt;p&gt;SQL을 더 잘 다루고싶어서 공부하다가 하는 김에 결과가 남는 자격증을 도전하게되었다.&lt;br&gt;테이블 반정규화 과정에는 3가지가 있다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>SQL을 더 잘 다루고싶어서 공부하다가 하는 김에 결과가 남는 자격증을 도전하게되었다.<br>테이블 반정규화 과정에는 3가지가 있다.</p><a id="more"></a><h1 id="🏷️-테이블-반정규화"><a href="#🏷️-테이블-반정규화" class="headerlink" title="🏷️ 테이블 반정규화"></a>🏷️ 테이블 반정규화</h1><ol><li>테이블 병합: 1:1관계, 1:M관계, 슈퍼/서브타입</li><li>테이블 분할: 수직분할, 수평분할</li><li>테이블 추가: 중복, 통계, 이력</li></ol><p>이 중 테이블 분할에 대해 궁금해져 자세히 알아보았다.<br>테이블은 합치는 것보다 나누는 것이 더 어렵다. 사실 기존 테이블을 바꾼다는 것 자체가 큰 위험이 따른다.</p><p><br><br></p><h2 id="이렇게-위험한-테이블-반정규화를-왜-하는걸까"><a href="#이렇게-위험한-테이블-반정규화를-왜-하는걸까" class="headerlink" title="이렇게 위험한 테이블 반정규화를 왜 하는걸까?"></a>이렇게 위험한 테이블 반정규화를 왜 하는걸까?</h2><p>반정규화는 시스템 성능향상과 개바로가 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 기법이다. 즉, 장기적으로 봤을 때 기존 시스템보다 개선효과가 클때 반정규화를 한다.</p><ul><li>테이블 컬럼 수 많을수록  -&gt; I/O(Input/Output) 부하 생김</li><li>테이블 Row 수 많을수록 -&gt; Index 부하 생김</li></ul><p>따라서, 컬럼 또는 로우 기준으로 수직 또는 수평으로 테이블 분리를 통한 성능 개선을 검토한다.<br>그럼 이제 수직분할과 수평분할을 알아보자.</p><p><br><br><br></p><h1 id="🏷️-수직분할"><a href="#🏷️-수직분할" class="headerlink" title="🏷️ 수직분할"></a>🏷️ 수직분할</h1><ol><li>정의: 컬럼 기준으로 테이블 분리</li><li>분리이유<ul><li>만약 한 테이블에 너무 많은 컬럼이 존재한다면 디스크의 여러 블록에 데이터가 저장되어 디스크I/O성능 저하가 일어난다. </li></ul></li><li>왜 디스크의 여러 블록에 데이터가 저장될까? <ul><li>로우체이닝과 로우 마이그레이션이 많아지기때문! 로우체이닝과 로우마이그레이션이 많아지면 디스크I/O 성능저하가 나타난다.</li><li>Row Chaining: 길이가 너무 길어 하나의 블록에 저장되지 못하고 다수의 블록에 나눠 저장</li><li>Row Migration: 수정된 데이터를 해당 데이터 블록에 저장하지 못하고 다른 블록 빈 공간에 저장</li></ul></li><li>분리기준<ul><li>조회 조건에 맞게 이용되는 컬럼들을 그룹화하여 분리</li></ul></li></ol><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbK6vM6%2FbtqxJaKhzIM%2FNLAp7u63ZC87MIiDXXOfIK%2Fimg.png" alt="출처: https://umbum.dev/969"></p><p><br><br><br></p><h1 id="🏷️-수평분할"><a href="#🏷️-수평분할" class="headerlink" title="🏷️ 수평분할"></a>🏷️ 수평분할</h1><ol><li>정의: Row 기준으로 테이블 분리</li><li>분리이유<ul><li>대량의 데이터가 하나의 테이블에 있으면 인덱스 정보 생성시 부하가 터진다. </li><li>집중 발생되는 트랙잰션 해소를 통한 성능 향상</li></ul></li><li>왜 인덱시 정보 생성시 부하가 커질까?<ul><li>인덱스 깊이(Depth)가 깊어지면 찾아가는데 해당 depth까지 시간이 오래 걸림</li><li>인덱스 크기가 커질수록 더 많은 성능 저하</li></ul></li><li>분리기준<ul><li>논리적으로 같은 테이블이지만 물리적으로 나누는 파티션 방법 이용</li></ul></li></ol><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F0OIvd%2FbtqxKq6sYRh%2F2lKlThTW3Yr7kELKJjubP0%2Fimg.png" alt="출처: https://umbum.dev/969"> </p><p>수평분할시 분리기준으로 파티션 방법이 있다. 파티션 방법이 구체적으로 뭘까? </p><p><br><br><br></p><h2 id="파티셔닝-종류"><a href="#파티셔닝-종류" class="headerlink" title="파티셔닝 종류"></a>파티셔닝 종류</h2><p><img src="https://docs.oracle.com/cd/B10500_01/server.920/a96524/cncpt158.gif" alt="출처: docs.oracle.com"></p><table><thead><tr><th align="center">파티셔닝명</th><th align="center">분리기준</th><th align="center">예시</th></tr></thead><tbody><tr><td align="center">List</td><td align="center">사용자가 지정한 값으로 분리(불연속적, 보통 핵심적인 코드값)</td><td align="center">판매데이터를 지역별로</td></tr><tr><td align="center">Range</td><td align="center">주로 날짜 또는 숫자값 기준으로 분리</td><td align="center">판매데이터를 분기별로</td></tr><tr><td align="center">Hash</td><td align="center">파티션 키 값에 해시 함수를 적용하여 지정된 Hash조건에 따라 분리</td><td align="center">고객번호, 주문일련번호 등</td></tr><tr><td align="center">Composite</td><td align="center">Range나 List 파티션 내 다른 서브파티션</td><td align="center">Range + List 또는 List + Hash</td></tr></tbody></table><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=51990#:~:text=%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98%20%EC%88%98%EC%A7%81%EB%B6%84%ED%95%A0%EC%9D%80,%EC%84%B1%EB%8A%A5%20%EA%B0%9C%EC%84%A0%EC%9D%84%20%EC%9C%84%ED%95%9C%20%EA%B2%83%EC%9D%B4%EB%8B%A4.">데이타온에어 전문가칼럼 - 테이블의 수직분할과 수평분할에 대한 이해</a></li><li><a href="https://umbum.dev/969">엄범 기술블로그 - 분산 DB, 파티셔닝 (partitioning ), 샤딩 (sharding)</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/Database/">Database</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/SQLD/">SQLD</category>
      
      
      <comments>https://sowon-dev.github.io/2022/10/29/221029SQLD-tablepartition/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[jQuery] attr과 prop차이</title>
      <link>https://sowon-dev.github.io/2022/10/27/221028jQuery-attr-vs-prop/</link>
      <guid>https://sowon-dev.github.io/2022/10/27/221028jQuery-attr-vs-prop/</guid>
      <pubDate>Thu, 27 Oct 2022 19:42:41 GMT</pubDate>
      
      <description>&lt;p&gt;제이쿼리를 사용하면서 attr와 prop는 아주 유사한 기능인데 어떠한 차이점이 있고 어떤 상황일때 어떤 걸 쓰는 게 더 좋은지 궁금해서 찾아봤다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>제이쿼리를 사용하면서 attr와 prop는 아주 유사한 기능인데 어떠한 차이점이 있고 어떤 상황일때 어떤 걸 쓰는 게 더 좋은지 궁금해서 찾아봤다.</p><a id="more"></a><p>역시 제일 좋은 건 jQuery 공식문서이다.<br>jQuery 1.6.0 버전에서부터 jQuery.attr()과 jQuery.prop()가 나눠졌다.</p><table><thead><tr><th align="center"></th><th align="center">jQuery.attr()</th><th align="center">jQuery.prop()</th></tr></thead><tbody><tr><td align="center">정의</td><td align="center">changes attributes for that HTML tag.</td><td align="center">changes properties for that HTML tag as per the DOM tree</td></tr><tr><td align="center">취급</td><td align="center">HTML 속성 (Attribute) 취급</td><td align="center">javascript 프로퍼티 (Property) 취급</td></tr><tr><td align="center">반환값</td><td align="center">returns the default value (Original state)</td><td align="center">returns the current value (Current state)</td></tr></tbody></table><p>많은 상황에서 둘은 같은 값을 반환하지만 attr()는 원래 값을 prop()는 현재 값을 반환한다.<br>예를 들어보자.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"checkbox"</span> id=<span class="string">"test1"</span> checked=<span class="string">"checked"</span>&gt; 테스트<span class="number">1</span></span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> id=<span class="string">"test2"</span>&gt; 테스트<span class="number">2</span></span><br></pre></td></tr></table></figure><p>위 두가지 체크박스의 차이는 checked가 기본값인지 아닌지이다.<br>이를 콘솔에 찍어보면 차이를 발견할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#test1&quot;).attr(&quot;checked&quot;)</span><br><span class="line">$(&quot;#test2&quot;).attr(&quot;checked&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;결과값</span><br><span class="line">checked</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#test1&quot;).prop(&quot;checked&quot;)</span><br><span class="line">$(&quot;#test2&quot;).prop(&quot;checked&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;결과값</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>attr()은 최초 element 랜더링시 defalut value를 반환하지만 prop()는 현재상태를 반환한다.</p><p><br><br><br></p><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><ul><li><code>.attr()</code> : element가 가지는 속성 조회 권장<ul><li>style, src, rowspan</li></ul></li><li><code>.prop()</code>: element가 가지는 실제적인 상태 제어 사용 권장<ul><li>form요소의 disabled, selected, checked 속성값 확인 혹은 변경</li></ul></li></ul><p><br><br><br></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul><li><a href="https://api.jquery.com/attr/">https://api.jquery.com/attr/</a></li><li><a href="https://api.jquery.com/prop/">https://api.jquery.com/prop/</a></li><li><a href="http://net-informations.com/jq/iq/prop.htm">http://net-informations.com/jq/iq/prop.htm</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JavaScript/">JavaScript</category>
      
      
      <category domain="https://sowon-dev.github.io/tags/jQuery/">jQuery</category>
      
      
      <comments>https://sowon-dev.github.io/2022/10/27/221028jQuery-attr-vs-prop/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[JS] 배열Array와 객체Object 내 포함 여부</title>
      <link>https://sowon-dev.github.io/2022/10/25/221026JS-some/</link>
      <guid>https://sowon-dev.github.io/2022/10/25/221026JS-some/</guid>
      <pubDate>Tue, 25 Oct 2022 20:20:15 GMT</pubDate>
      
      <description>&lt;p&gt;자바스크립트에서 &lt;code&gt;배열[]&lt;/code&gt; 안의 &lt;code&gt;객체{}&lt;/code&gt;가 있는 경우가 많은데 여기서 내가 원하는 값이 포함되어있는지 확인할 수 있는 좋은 메서드가 있는데 바로 some()이다.&lt;br&gt;some()메서드를 알아볼땐 함께 알아봐야할 메서드가 있다. 짝궁인 every()메서드이다. 또한 개인적으로 includes()와 비슷해서 함께 알아보았다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>자바스크립트에서 <code>배열[]</code> 안의 <code>객체{}</code>가 있는 경우가 많은데 여기서 내가 원하는 값이 포함되어있는지 확인할 수 있는 좋은 메서드가 있는데 바로 some()이다.<br>some()메서드를 알아볼땐 함께 알아봐야할 메서드가 있다. 짝궁인 every()메서드이다. 또한 개인적으로 includes()와 비슷해서 함께 알아보았다.</p><a id="more"></a><h1 id="📌-Some"><a href="#📌-Some" class="headerlink" title="📌 Some"></a>📌 Some</h1><p>특정 조건을 만족하는지 배열 내부를 차례대로 검사한다.<br>조건에 <code>내부 원소 한 개라도</code> 만족하면 true, 아니면 false를 리턴한다.<br>차례대로 검사하던 중 조건을 만족하는 내부 값이 발견되면 즉시 검사가 중단되고 return값이 나온다. -&gt; 성능에 GOOD<br>es5이상 사용가능하다.</p><p><br><br></p><h2 id="배열-내-객체-예시"><a href="#배열-내-객체-예시" class="headerlink" title="배열 내 객체 예시"></a>배열 내 객체 예시</h2><p>예약프로그램을 예시로 들어보자. 아래처럼 휴일 객체가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const holiday &#x3D; [</span><br><span class="line">  &#123;RESTDE_DATE: &#39;2022-10-03&#39;, RESTDE_NM: &#39;개천절&#39;&#125;</span><br><span class="line">  , &#123;RESTDE_DATE: &#39;2022-10-28&#39;, RESTDE_NM: &#39;정기휴관&#39;&#125;</span><br><span class="line">  , &#123;RESTDE_DATE: &#39;2022-10-30&#39;, RESTDE_NM: &#39;임시휴관&#39;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>holiday 객체안에 <code>2022-10-28</code> 있는지 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">holiday.some(date &#x3D;&gt; date.RESTDE_DATE &#x3D;&#x3D; &#39;2022-10-28&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 결과값</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>moment.js를 이용해서 오늘이 휴일객체 안에 있는지 확인해볼 수도 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">holiday.some(date &#x3D;&gt; date.RESTDE_DATE &#x3D;&#x3D; moment().format(&#39;YYYY-MM-DD&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 결과값</span><br><span class="line">true or false</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="📌-Every"><a href="#📌-Every" class="headerlink" title="📌 Every"></a>📌 Every</h1><p>some과 비교되는 메서드로 every가 있다.<br>특정 조건을 만족하는지 배열 내부를 차례대로 검사한다.<br>조건에 <code>내부 원소 모두</code> 만족하면 true, 아니면 false를 리턴한다.<br>차례대로 검사하던 중 조건을 만족하지 않는 내부 값이 발견되면 즉시 검사가 중단되고 return값이 나온다. -&gt; 성능에 GOOD<br>es5이상 사용가능하다.</p><p><br><br></p><h2 id="배열-내-객체-예시-1"><a href="#배열-내-객체-예시-1" class="headerlink" title="배열 내 객체 예시"></a>배열 내 객체 예시</h2><p>예약프로그램을 예시로 들어보자. 아래처럼 휴일 객체가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const holiday &#x3D; [</span><br><span class="line">  &#123;RESTDE_DATE: &#39;2022-10-03&#39;, RESTDE_NM: &#39;개천절&#39;&#125;</span><br><span class="line">  , &#123;RESTDE_DATE: &#39;2022-10-28&#39;, RESTDE_NM: &#39;정기휴관&#39;&#125;</span><br><span class="line">  , &#123;RESTDE_DATE: &#39;2022-10-30&#39;, RESTDE_NM: &#39;임시휴관&#39;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>holiday 객체가 모두 <code>2022-10-31</code> 이전 일자인지 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">holiday.some(date &#x3D;&gt; date.RESTDE_DATE &lt; &#39;2022-10-31&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 결과값</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>moment.js를 이용해서 오늘보다 이전날짜만 있는지도 확인가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">holiday.some(date &#x3D;&gt; date.RESTDE_DATE &lt; moment().format(&#39;YYYY-MM-DD&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 결과값</span><br><span class="line">true or false</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="📌-includes"><a href="#📌-includes" class="headerlink" title="📌 includes"></a>📌 includes</h1><p>배열이 특정 요소를 포함하고 있는 지 검사한다.<br>있으면 true, 없으면 false를 리턴한다.<br>대소문자를 구별하고 <code>배열[]</code> 에서만 사용할 수 있다.</p><p><br><br></p><h2 id="배열-예시"><a href="#배열-예시" class="headerlink" title="배열 예시"></a>배열 예시</h2><p>예약프로그램을 예시로 들어보자. 아래처럼 휴일 객체가 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const holiday &#x3D; [&#39;2022-10-03&#39;, &#39;2022-10-28&#39;, &#39;2022-10-30&#39;];</span><br></pre></td></tr></table></figure><p>holiday배열에 <code>2022-10-28</code>이 있는지 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">holiday.includes(&#39;2022-10-28&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 결과값</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="📌-참고"><a href="#📌-참고" class="headerlink" title="📌 참고"></a>📌 참고</h1><p> -<a href="https://stackoverflow.com/questions/64946404/when-use-js-includes-vs-some">스택오버플로우 질문글 when use JS .includes() vs .some() </a></p>]]></content:encoded>
      
      
      <category domain="https://sowon-dev.github.io/categories/JavaScript/">JavaScript</category>
      
      
      
      <comments>https://sowon-dev.github.io/2022/10/25/221026JS-some/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
